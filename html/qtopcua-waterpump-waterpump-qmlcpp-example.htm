<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Waterpump Example | Qt OPC UA</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtopcua-waterpump-waterpump-qmlcpp-example.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="http://doc.qt.io/QtForAutomation/index.html" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtopcua-index.htm" translate="no">Qt OPC UA</a></li>
                            <li><a href="./qtopcua-examples.htm" translate="no">Qt OPC UA Examples</a></li>
                            <li><a>Waterpump Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Waterpump Example</h1>
<span class="subtitle"></span>
<!-- $$$waterpump/waterpump-qmlcpp-brief -->
<p>Interacting with an OPC UA server to build a QML-based HMI for a simple machine.</p>
<!-- @@@waterpump/waterpump-qmlcpp -->
<!-- $$$waterpump/waterpump-qmlcpp-description -->
<div class="descr"> <a name="details"></a>
<p><i>Waterpump</i> shows how to use Qt OPC UA to interact with an OPC UA server to build a QML-based HMI for a simple machine.</p>
<a name="building-the-server"></a>
<h4 id="building-the-server">Building the Server<a class="plink" href="#building-the-server" title="Direct link to this headline"></a></h4>
<p>Before you can use the waterpump examples, you need to build the simulation server. The simulator server project resides next to the waterpump examples. You can open and build it in QtCreator or from the terminal as usual.</p>
<a name="the-simulation"></a>
<h4 id="the-simulation">The Simulation<a class="plink" href="#the-simulation" title="Direct link to this headline"></a></h4>
<p>The OPC UA server included in this example runs a simulation of a machine containing two tanks, a water pump, and a valve. Water can be pumped from the first tank into the second tank and then be flushed from the second tank by opening the valve. Both operations have a user-configurable setpoint which controls how much water is pumped to or flushed from the second tank.</p>
<p>The following nodes exist on the server:</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th><a href="./qml-qtopcua-nodeid.htm" translate="no">NodeId</a></th><th>Function</th></tr></thead>
<tbody><tr class="odd" valign="top"><td>ns=2;s=Machine</td><td>The folder containing the method and variable nodes for the machine</td></tr>
<tr class="even" valign="top"><td>ns=2;s=Machine.State</td><td>The state of the machine</td></tr>
<tr class="odd" valign="top"><td>ns=2;s=Machine.Tank1.PercentFilled</td><td>The current fill status of the first tank</td></tr>
<tr class="even" valign="top"><td>ns=2;s=Machine.Tank2.PercentFilled</td><td>The current fill status of the second tank</td></tr>
<tr class="odd" valign="top"><td>ns=2;s=Machine.Tank2.TargetPercent</td><td>The setpoint for pumping and flushing</td></tr>
<tr class="even" valign="top"><td>ns=2;s=Machine.Tank2.ValveState</td><td>The state of the valve of the second tank</td></tr>
<tr class="odd" valign="top"><td>ns=2;s=Machine.Designation</td><td>A human readable designation of the machine for display purposes</td></tr>
<tr class="even" valign="top"><td>ns=2;s=Machine.Start</td><td>Call this method to start the pump</td></tr>
<tr class="odd" valign="top"><td>ns=2;s=Machine.Stop</td><td>Call this method to stop the pump</td></tr>
<tr class="even" valign="top"><td>ns=2;s=Machine.FlushTank2</td><td>Call this method to flush tank 2</td></tr>
</tbody></table></div>
<p>All methods return <a href="./qopcua.htm#UaStatusCode-enum" translate="no">Good</a> in case of success and <a href="./qopcua.htm#UaStatusCode-enum" translate="no">BadUserAccessDenied</a> if the operation is illegal (for example, trying to start the pump if the first tank is empty).</p>
<a name="client-features"></a>
<h4 id="client-features">Client Features<a class="plink" href="#client-features" title="Direct link to this headline"></a></h4>
<p>This example uses read, write, method calls, and data change subscriptions and shows how to set up handlers for the asynchronous operations offered by <a href="./qopcuaclient.htm#qopcuaclient" translate="no">QOpcUaClient</a> and <a href="./qopcuanode.htm" translate="no">QOpcUaNode</a>.</p>
<a name="implementation"></a>
<h4 id="implementation">Implementation<a class="plink" href="#implementation" title="Direct link to this headline"></a></h4>
<p>A backend class is used to handle the communication with the OPC UA server and expose the content of this server by means of properties and <code translate="no">Q_INVOKABLE</code> methods wrapping the OPC UA method calls.</p>
<a name="member-variables"></a>
<h5 id="member-variables">Member Variables<a class="plink" href="#member-variables" title="Direct link to this headline"></a></h5>
<p>A pointer to <a href="./qopcuaclient.htm#qopcuaclient" translate="no">QOpcUaClient</a> is required for connection management. An additional pointer to a <a href="./qopcuanode.htm" translate="no">QOpcUaNode</a> object is needed for each OPC UA node the HMI interacts with. For the values of these nodes, member variables containing the last value reported by the server are added.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    ...
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuaclient.htm" translate="no">QOpcUaClient</a></span><span class="operator">&gt;</span> m_client;
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_machineStateNode;
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_percentFilledTank1Node;
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_percentFilledTank2Node;
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_tank2TargetPercentNode;
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_tank2ValveStateNode;
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_machineNode;
    <span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">&gt;</span> m_machineDesignationNode;
    <span class="type">double</span> m_percentFilledTank1;
    <span class="type">double</span> m_percentFilledTank2;
    <span class="type">double</span> m_tank2TargetPercent;
    bool m_tank2ValveState;
    MachineState m_machineState;
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> m_machineDesignation;
    ...</pre></div>
<p>For each value used in the HMI, a getter, a changed signal, and a property are added to enable property bindings in QML</p>
<div class="pre"><pre class="cpp" translate="no">    ...
    Q_PROPERTY(<span class="type">double</span> percentFilledTank1 READ percentFilledTank1 NOTIFY percentFilledTank1Changed)
    Q_PROPERTY(<span class="type">double</span> percentFilledTank2 READ percentFilledTank2 NOTIFY percentFilledTank2Changed)
    Q_PROPERTY(<span class="type">double</span> tank2TargetPercent READ tank2TargetPercent NOTIFY tank2TargetPercentChanged)
    Q_PROPERTY(OpcUaMachineBackend<span class="operator">::</span>MachineState machineState READ machineState NOTIFY machineStateChanged)
    Q_PROPERTY(bool tank2ValveState READ tank2ValveState NOTIFY tank2ValveStateChanged)
    Q_PROPERTY(bool connected READ connected NOTIFY connectedChanged)
    Q_PROPERTY(<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> machineDesignation READ machineDesignation NOTIFY machineDesignationChanged)
    Q_PROPERTY(<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> message READ message NOTIFY messageChanged)
    ...</pre></div>
<a name="asynchronous-handlers"></a>
<h5 id="asynchronous-handlers">Asynchronous Handlers<a class="plink" href="#asynchronous-handlers" title="Direct link to this headline"></a></h5>
<p>The asynchronous API of Qt OPC UA requires signal handlers for all operations.</p>
<p>Data change subscriptions report their updates using <a href="./qopcuanode.htm#attributeUpdated" translate="no">QOpcUaNode::attributeUpdated</a>. A handler connected to this signal gets the new value as <a href="./qvariant.htm" translate="no">QVariant</a> and can write that value to a variable or emit a signal with the new value, for example.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>percentFilledTank1Updated(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute attr<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> <span class="operator">&amp;</span>value)
{
    Q_UNUSED(attr);
    m_percentFilledTank1 <span class="operator">=</span> value<span class="operator">.</span>toDouble();
    <span class="keyword">emit</span> percentFilledTank1Changed(m_percentFilledTank1);
}</pre></div>
<p>A read operation emits the <a href="./qopcuanode.htm#attributeRead" translate="no">QOpcUaNode::attributeRead</a> signal on completion. The client has to check the status code and then get the result from the node.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>machineDesignationRead(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttributes attr)
{
    <span class="keyword">if</span> (attr <span class="operator">&amp;</span> <span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value) { <span class="comment">// Make sure the value attribute has been read</span>
        <span class="keyword">if</span> (m_machineDesignationNode<span class="operator">-</span><span class="operator">&gt;</span>attributeError(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value) <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>UaStatusCode<span class="operator">::</span>Good) { <span class="comment">// Make sure there was no error</span>
            m_machineDesignation <span class="operator">=</span> m_machineDesignationNode<span class="operator">-</span><span class="operator">&gt;</span>attribute(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value)<span class="operator">.</span>toString(); <span class="comment">// Get the attribute from the cache</span>
            <span class="keyword">emit</span> machineDesignationChanged(m_machineDesignation);
        }
    }
}</pre></div>
<a name="interaction-with-the-server"></a>
<h5 id="interaction-with-the-server">Interaction with the Server<a class="plink" href="#interaction-with-the-server" title="Direct link to this headline"></a></h5>
<p>In the constructor, a <a href="./qopcuaprovider.htm" translate="no">QOpcUaProvider</a> is created and the available backends are saved to provide a model for the backend selection dropdown menu.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    ...
    <span class="type"><a href="./qopcuaprovider.htm" translate="no">QOpcUaProvider</a></span> provider;
    setBackends(provider<span class="operator">.</span>availableBackends());
    ...</pre></div>
<p>Before attempting a connection, a <a href="./qopcuaclient.htm#qopcuaclient" translate="no">QOpcUaClient</a> with the selected backend is created. Its <a href="./qopcuaclient.htm#endpointsRequestFinished" translate="no">QOpcUaClient::endpointsRequestFinished</a> signal is connected to the backend's <code translate="no">requestEndpointsFinished</code> slot. The <a href="./qopcuaclient.htm#state-prop" translate="no">QOpcUaClient::stateChanged</a> signal must be connected to the backend's <code translate="no">clientStateHandler</code> slot.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>connectToEndpoint(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>url<span class="operator">,</span> <span class="type"><a href="./qtglobal.htm#qint32-typedef" translate="no">qint32</a></span> index)
{
    <span class="keyword">if</span> (m_connected)
        <span class="keyword">return</span>;

    <span class="type"><a href="./qopcuaprovider.htm" translate="no">QOpcUaProvider</a></span> provider;

    <span class="keyword">if</span> (index <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> index <span class="operator">&gt;</span><span class="operator">=</span> m_backends<span class="operator">.</span>size())
        <span class="keyword">return</span>; <span class="comment">// Invalid index</span>

    <span class="keyword">if</span> (<span class="operator">!</span>m_client <span class="operator">|</span><span class="operator">|</span> (m_client <span class="operator">&amp;</span><span class="operator">&amp;</span> m_client<span class="operator">-</span><span class="operator">&gt;</span>backend() <span class="operator">!</span><span class="operator">=</span> m_backends<span class="operator">.</span>at(index))) {
        m_client<span class="operator">.</span>reset(provider<span class="operator">.</span>createClient(m_backends<span class="operator">.</span>at(index)));
        <span class="keyword">if</span> (m_client) {
            <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_client<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuaclient.htm" translate="no">QOpcUaClient</a></span><span class="operator">::</span>endpointsRequestFinished<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>requestEndpointsFinished);
            <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_client<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuaclient.htm" translate="no">QOpcUaClient</a></span><span class="operator">::</span>stateChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>clientStateHandler);
        }
    }

    <span class="keyword">if</span> (<span class="operator">!</span>m_client) {
        <a href="./qtglobal.htm#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Could not create client"</span>;
        m_successfullyCreated <span class="operator">=</span> <span class="keyword">false</span>;
        <span class="keyword">return</span>;
    }

    m_successfullyCreated <span class="operator">=</span> <span class="keyword">true</span>;
    m_client<span class="operator">-</span><span class="operator">&gt;</span>requestEndpoints(url);
}</pre></div>
<p>The <code translate="no">OpcUaMachineBackend::requestEndpointsFinished</code> slot receives the list of available endpoints on the server and starts a connection to the first entry in the list. If there are no available endpoints, the connection establishment is aborted.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>requestEndpointsFinished(<span class="keyword">const</span> <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qopcuaendpointdescription.htm" translate="no">QOpcUaEndpointDescription</a></span><span class="operator">&gt;</span> <span class="operator">&amp;</span>endpoints)
{
    <span class="keyword">if</span> (endpoints<span class="operator">.</span>isEmpty()) {
       <a href="./qtglobal.htm#qWarning" translate="no">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"The server did not return any endpoints"</span>;
       clientStateHandler(<span class="type"><a href="./qopcuaclient.htm" translate="no">QOpcUaClient</a></span><span class="operator">::</span>ClientState<span class="operator">::</span>Disconnected);
       <span class="keyword">return</span>;
    }
    m_client<span class="operator">-</span><span class="operator">&gt;</span>connectToEndpoint(endpoints<span class="operator">.</span>at(<span class="number">0</span>));
}</pre></div>
<p><code translate="no">clientStateHandler</code> acts on <a href="./qopcuaclient.htm#qopcuaclient" translate="no">QOpcUaClient</a> being connected or disconnected. In case of a successful connection, the node member variables created before are filled with node objects.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    ...
    <span class="keyword">if</span> (state <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="./qopcuaclient.htm" translate="no">QOpcUaClient</a></span><span class="operator">::</span>ClientState<span class="operator">::</span>Connected) {
        setMessage(<span class="string">"Connected"</span>);
        <span class="comment">// Create node objects for reading, writing and subscriptions</span>
        m_machineNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">"ns=2;s=Machine"</span>));
        m_machineStateNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">"ns=2;s=Machine.State"</span>));
        m_percentFilledTank1Node<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">"ns=2;s=Machine.Tank1.PercentFilled"</span>));
        m_percentFilledTank2Node<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">"ns=2;s=Machine.Tank2.PercentFilled"</span>));
        m_tank2TargetPercentNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">"ns=2;s=Machine.Tank2.TargetPercent"</span>));
        m_tank2ValveStateNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">"ns=2;s=Machine.Tank2.ValveState"</span>));
        m_machineDesignationNode<span class="operator">.</span>reset(m_client<span class="operator">-</span><span class="operator">&gt;</span>node(<span class="string">"ns=2;s=Machine.Designation"</span>));
    ...</pre></div>
<p>After all node objects have been created, the data change handlers are connected to the node objects and monitoring is enabled.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    ...
        <span class="comment">// Connect signal handlers for subscribed values</span>
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_machineStateNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>machineStateUpdated);
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_percentFilledTank1Node<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>percentFilledTank1Updated);
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_percentFilledTank2Node<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>percentFilledTank2Updated);
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_tank2TargetPercentNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>tank2TargetPercentUpdated);
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_tank2ValveStateNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">::</span>dataChangeOccurred<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>tank2ValveStateUpdated);

        <span class="comment">// Subscribe to data changes</span>
        m_machineStateNode<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="./qopcuamonitoringparameters.htm" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
        m_percentFilledTank1Node<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="./qopcuamonitoringparameters.htm" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
        m_percentFilledTank2Node<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="./qopcuamonitoringparameters.htm" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
        m_tank2TargetPercentNode<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="./qopcuamonitoringparameters.htm" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
        m_tank2ValveStateNode<span class="operator">-</span><span class="operator">&gt;</span>enableMonitoring(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> <span class="type"><a href="./qopcuamonitoringparameters.htm" translate="no">QOpcUaMonitoringParameters</a></span>(<span class="number">100</span>));
    ...</pre></div>
<p>The machine designation is not supposed to change and will be read once at startup.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    ...
        <span class="comment">// Connect the handler for async reading</span>
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(m_machineDesignationNode<span class="operator">.</span>data()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qopcuanode.htm" translate="no">QOpcUaNode</a></span><span class="operator">::</span>attributeRead<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>OpcUaMachineBackend<span class="operator">::</span>machineDesignationRead);
        <span class="comment">// Request the value attribute of the machine designation node</span>
        m_machineDesignationNode<span class="operator">-</span><span class="operator">&gt;</span>readAttributes(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value);
    ...</pre></div>
<p>A setter for the setpoint is added to the backend.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>machineWriteTank2TargetPercent(<span class="type">double</span> value)
{
    <span class="keyword">if</span> (m_tank2TargetPercentNode)
        m_tank2TargetPercentNode<span class="operator">-</span><span class="operator">&gt;</span>writeAttribute(<span class="type"><a href="./qopcua.htm" translate="no">QOpcUa</a></span><span class="operator">::</span>NodeAttribute<span class="operator">::</span>Value<span class="operator">,</span> value);
}</pre></div>
<p>For the methods, wrappers which call the OPC UA server method are created.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> OpcUaMachineBackend<span class="operator">::</span>startPump()
{
    m_machineNode<span class="operator">-</span><span class="operator">&gt;</span>callMethod(<span class="string">"ns=2;s=Machine.Start"</span>);
}</pre></div>
<a name="the-hmi"></a>
<h5 id="the-hmi">The HMI<a class="plink" href="#the-hmi" title="Direct link to this headline"></a></h5>
<p>A backend instance is created and handed to the QML part as a context property named <code translate="no">uaBackend</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    ...
    OpcUaMachineBackend backend;

    <span class="type"><a href="./qqmlapplicationengine.htm" translate="no">QQmlApplicationEngine</a></span> engine;
    engine<span class="operator">.</span>rootContext()<span class="operator">-</span><span class="operator">&gt;</span>setContextProperty(<span class="string">"uaBackend"</span><span class="operator">,</span> <span class="operator">&amp;</span>backend);
    ...</pre></div>
<p>The properties, signals and <code translate="no">Q_INVOKABLE</code> methods of uaBackend can now be accessed by the QML code. For example, the button to flush the second tank is enabled only if the backend is connected to the server, the machine is idle and the tank level is above the setpoint. On click, the <code translate="no">flushTank2()</code> method is called on the server.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">        <span class="type">Button</span> {
            <span class="name">id</span>: <span class="name">flushButton</span>
            <span class="name">text</span>: <span class="string">"Flush"</span>
            <span class="name">enabled</span>: <span class="name">uaBackend</span>.<span class="name">connected</span> <span class="operator">&amp;&amp;</span> <span class="name">uaBackend</span>.<span class="name">machineState</span> <span class="operator">===</span> <span class="name">OpcUaMachineBackend</span>.<span class="name">MachineState</span>.<span class="name">Idle</span> <span class="operator">&amp;&amp;</span> <span class="name">uaBackend</span>.<span class="name">percentFilledTank2</span> <span class="operator">&gt;</span> <span class="name">uaBackend</span>.<span class="name">tank2TargetPercent</span>
            <span class="name">onClicked</span>: {
                <span class="name">uaBackend</span>.<span class="name">flushTank2</span>()
            }
        }</pre></div>
<p>Signals from the backend can also be used directly in the QML code.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qml-qtqml-connections.htm" translate="no">Connections</a></span> {
        <span class="name">target</span>: <span class="name">uaBackend</span>
        <span class="name">onPercentFilledTank2Changed</span>: {
            <span class="keyword">if</span> (<span class="name">uaBackend</span>.<span class="name">machineState</span> <span class="operator">===</span> <span class="name">OpcUaMachineBackend</span>.<span class="name">MachineState</span>.<span class="name">Pumping</span>)
                <span class="name">rotation</span> <span class="operator">+=</span> <span class="number">15</span>
        }
    }</pre></div>
<a name="usage"></a>
<h4 id="usage">Usage<a class="plink" href="#usage" title="Direct link to this headline"></a></h4>
<p>The server is started automatically by the HMI application. After connecting to the server by clicking the <b translate="no">Connect</b> button, drag the slider to set a setpoint, then click <b translate="no">Start</b> to start pumping water from the first tank to the second tank. After setting a setpoint lower than the current value of the second tank, a click on <b translate="no">Flush</b> opens the valve.</p>
<p>If there is no water left, click <b translate="no">Reset simulation</b> to refill the first tank.</p>
<p class="centerAlign"><img alt="" src="./images/tankexample.jpg"></p><p>Files:</p>
<ul>
<li><a href="./qtopcua-waterpump-waterpump-qmlcpp-main-cpp.htm" translate="no">waterpump/waterpump-qmlcpp/main.cpp</a></li>
<li><a href="./qtopcua-waterpump-waterpump-qmlcpp-opcuamachinebackend-cpp.htm" translate="no">waterpump/waterpump-qmlcpp/opcuamachinebackend.cpp</a></li>
<li><a href="./qtopcua-waterpump-waterpump-qmlcpp-qml-qrc.htm" translate="no">waterpump/waterpump-qmlcpp/qml.qrc</a></li>
<li><a href="./qtopcua-waterpump-waterpump-qmlcpp-waterpump-qmlcpp-pro.htm" translate="no">waterpump/waterpump-qmlcpp/waterpump-qmlcpp.pro</a></li>
</ul>
</div>
<!-- @@@waterpump/waterpump-qmlcpp -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>