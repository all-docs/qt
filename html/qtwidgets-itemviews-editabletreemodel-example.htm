<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Editable Tree Model Example | Qt Widgets</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtwidgets-itemviews-editabletreemodel-example.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtwidgets-index.htm" translate="no">Qt Widgets</a></li>
                            <li><a href="./examples-itemviews.htm" translate="no">Item Views Examples</a></li>
                            <li><a>Editable Tree Model Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Editable Tree Model Example</h1>
<span class="subtitle"></span>
<!-- $$$itemviews/editabletreemodel-brief -->
<p>This example shows how to implement a simple item-based tree model that can be used with other classes the model/view framework.</p>
<!-- @@@itemviews/editabletreemodel -->
<!-- $$$itemviews/editabletreemodel-description -->
<div class="descr"> <a name="details"></a>
<p class="centerAlign"><img alt="" src="./images/itemviews-editabletreemodel.png"></p><p>The model supports editable items, custom headers, and the ability to insert and remove rows and columns. With these features, it is also possible to insert new child items, and this is shown in the supporting example code.</p>
<a name="overview"></a>
<h4 id="overview">Overview<a class="plink" href="#overview" title="Direct link to this headline"></a></h4>
<p>As described in the <a href="./model-view-programming.htm#model-subclassing-reference" translate="no">Model Subclassing Reference</a>, models must provide implementations for the standard set of model functions: <a href="./qabstractitemmodel.htm#flags" translate="no">flags()</a>, <a href="./qabstractitemmodel.htm#data" translate="no">data()</a>, <a href="./qabstractitemmodel.htm#headerData" translate="no">headerData()</a>, <a href="./qabstractitemmodel.htm#columnCount" translate="no">columnCount()</a>, and <a href="./qabstractitemmodel.htm#rowCount" translate="no">rowCount()</a>. In addition, hierarchical models, such as this one, need to provide implementations of <a href="./qabstractitemmodel.htm#index" translate="no">index()</a> and <a href="./qabstractitemmodel.htm#parent" translate="no">parent()</a>.</p>
<p>An editable model needs to provide implementations of <a href="./qabstractitemmodel.htm#setData" translate="no">setData()</a> and <a href="./qabstractitemmodel.htm#setHeaderData" translate="no">setHeaderData()</a>, and must return a suitable combination of flags from its <a href="./qabstractitemmodel.htm#flags" translate="no">flags()</a> function.</p>
<p>Since this example allows the dimensions of the model to be changed, we must also implement <a href="./qabstractitemmodel.htm#insertRows" translate="no">insertRows()</a>, <a href="./qabstractitemmodel.htm#insertColumns" translate="no">insertColumns()</a>, <a href="./qabstractitemmodel.htm#removeRows" translate="no">removeRows()</a>, and <a href="./qabstractitemmodel.htm#removeColumns" translate="no">removeColumns()</a>.</p>
<a name="design"></a>
<h4 id="design">Design<a class="plink" href="#design" title="Direct link to this headline"></a></h4>
<p>As with the <a href="./qtwidgets-itemviews-simpletreemodel-example.htm" translate="no">Simple Tree Model</a> example, the model simply acts as a wrapper around a collection of instances of a <code translate="no">TreeItem</code> class. Each <code translate="no">TreeItem</code> is designed to hold data for a row of items in a tree view, so it contains a list of values corresponding to the data shown in each column.</p>
<p>Since <a href="./qtreeview.htm" translate="no">QTreeView</a> provides a row-oriented view onto a model, it is natural to choose a row-oriented design for data structures that will supply data via a model to this kind of view. Although this makes the tree model less flexible, and possibly less useful for use with more sophisticated views, it makes it less complex to design and easier to implement.</p>
<a name="relations-between-internal-items"></a><div class="table"><table class="generic">
<tbody><tr class="odd" valign="top"><td><img alt="" src="./images/itemviews-editabletreemodel-items.png"></td><td><b>Relations between internal items</b><p>When designing a data structure for use with a custom model, it is useful to expose each item's parent via a function like <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-parent" translate="no">TreeItem::parent()</a> because it will make writing the model's own <a href="./qabstractitemmodel.htm#parent" translate="no">parent()</a> function easier. Similarly, a function like <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-child" translate="no">TreeItem::child()</a> is helpful when implementing the model's <a href="./qabstractitemmodel.htm#index" translate="no">index()</a> function. As a result, each <code translate="no">TreeItem</code> maintains information about its parent and children, making it possible for us to traverse the tree structure.</p>
<p>The diagram shows how <code translate="no">TreeItem</code> instances are connected via their <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-parent" translate="no">parent()</a> and <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-child" translate="no">child()</a> functions.</p>
<p>In the example shown, two top-level items, <b>A</b> and <b>B</b>, can be obtained from the root item by calling its child() function, and each of these items return the root node from their parent() functions, though this is only shown for item <b>A</b>.</p>
</td></tr>
</tbody></table></div>
<p>Each <code translate="no">TreeItem</code> stores data for each column in the row it represents in its <code translate="no">itemData</code> private member (a list of <a href="./qvariant.htm" translate="no">QVariant</a> objects). Since there is a one-to-one mapping between each column in the view and each entry in the list, we provide a simple <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-data" translate="no">data()</a> function to read entries in the <code translate="no">itemData</code> list and a <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-setdata" translate="no">setData()</a> function to allow them to be modified. As with other functions in the item, this simplifies the implemention of the model's <a href="./qabstractitemmodel.htm#data" translate="no">data()</a> and <a href="./qabstractitemmodel.htm#setData" translate="no">setData()</a> functions.</p>
<p>We place an item at the root of the tree of items. This root item corresponds to the null model index, <a href="./qmodelindex.htm#QModelIndex" translate="no">QModelIndex()</a>, that is used to represent the parent of a top-level item when handling model indexes. Although the root item does not have a visible representation in any of the standard views, we use its internal list of <a href="./qvariant.htm" translate="no">QVariant</a> objects to store a list of strings that will be passed to views for use as horizontal header titles.</p>
<div class="table"><table class="generic">
<tbody><tr class="odd" valign="top"><td><img alt="" src="./images/itemviews-editabletreemodel-model.png"></td><td><b>Accessing data via the model</b><p>In the case shown in the diagram, the piece of information represented by <b>a</b> can be obtained using the standard model/view API:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> a <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>())<span class="operator">.</span>data();</pre></div>
<p>Since each items holds pieces of data for each column in a given row, there can be many model indexes that map to the same <code translate="no">TreeItem</code> object. For example, the information represented by <b>b</b> can be obtained using the following code:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> b <span class="operator">=</span> model<span class="operator">-</span><span class="operator">&gt;</span>index(<span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>())<span class="operator">.</span>data();</pre></div>
<p>The same underlying <code translate="no">TreeItem</code> would be accessed to obtain information for the other model indexes in the same row as <b>b</b>.</p>
</td></tr>
</tbody></table></div>
<p>In the model class, <code translate="no">TreeModel</code>, we relate <code translate="no">TreeItem</code> objects to model indexes by passing a pointer for each item when we create its corresponding model index with <a href="./qabstractitemmodel.htm#createIndex" translate="no">QAbstractItemModel::createIndex</a>() in our <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-index" translate="no">index()</a> and <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-parent" translate="no">parent()</a> implementations. We can retrieve pointers stored in this way by calling the <a href="./qmodelindex.htm#internalPointer" translate="no">internalPointer()</a> function on the relevant model index - we create our own <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-getitem" translate="no">getItem()</a> function to do the work for us, and call it from our <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-data" translate="no">data()</a> and <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-parent" translate="no">parent()</a> implementations.</p>
<p>Storing pointers to items is convenient when we control how they are created and destroyed since we can assume that an address obtained from <a href="./qmodelindex.htm#internalPointer" translate="no">internalPointer()</a> is a valid pointer. However, some models need to handle items that are obtained from other components in a system, and in many cases it is not possible to fully control how items are created or destroyed. In such situations, a pure pointer-based approach needs to be supplemented by safeguards to ensure that the model does not attempt to access items that have been deleted.</p>
<div class="table"><table class="generic">
<tbody><tr class="odd" valign="top"><td><b>Storing information in the underlying data structure</b><p>Several pieces of data are stored as <a href="./qvariant.htm" translate="no">QVariant</a> objects in the <code translate="no">itemData</code> member of each <code translate="no">TreeItem</code> instance.</p>
<p>The diagram shows how pieces of information, represented by the labels <b>a</b>, <b>b</b> and <b>c</b> in the previous two diagrams, are stored in items <b>A</b>, <b>B</b> and <b>C</b> in the underlying data structure. Note that pieces of information from the same row in the model are all obtained from the same item. Each element in a list corresponds to a piece of information exposed by each column in a given row in the model.</p>
</td><td><img alt="" src="./images/itemviews-editabletreemodel-values.png"></td></tr>
</tbody></table></div>
<p>Since the <code translate="no">TreeModel</code> implementation has been designed for use with <a href="./qtreeview.htm" translate="no">QTreeView</a>, we have added a restriction on the way it uses <code translate="no">TreeItem</code> instances: each item must expose the same number of columns of data. This makes viewing the model consistent, allowing us to use the root item to determine the number of columns for any given row, and only adds the requirement that we create items containing enough data for the total number of columns. As a result, inserting and removing columns are time-consuming operations because we need to traverse the entire tree to modify every item.</p>
<p>An alternative approach would be to design the <code translate="no">TreeModel</code> class so that it truncates or expands the list of data in individual <code translate="no">TreeItem</code> instances as items of data are modified. However, this "lazy" resizing approach would only allow us to insert and remove columns at the end of each row and would not allow columns to be inserted or removed at arbitrary positions in each row.</p>
<a name="relating-items-using-model-indexes"></a><div class="table"><table class="generic">
<tbody><tr class="odd" valign="top"><td><img alt="" src="./images/itemviews-editabletreemodel-indexes.png"></td><td><b>Relating items using model indexes</b><p>As with the <a href="./qtwidgets-itemviews-simpletreemodel-example.htm" translate="no">Simple Tree Model</a> example, the <code translate="no">TreeModel</code> needs to be able to take a model index, find the corresponding <code translate="no">TreeItem</code>, and return model indexes that correspond to its parents and children.</p>
<p>In the diagram, we show how the model's <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-parent" translate="no">parent()</a> implementation obtains the model index corresponding to the parent of an item supplied by the caller, using the items shown in a <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#relations-between-internal-items" translate="no">previous diagram</a>.</p>
<p>A pointer to item <b>C</b> is obtained from the corresponding model index using the <a href="./qmodelindex.htm#internalPointer" translate="no">QModelIndex::internalPointer</a>() function. The pointer was stored internally in the index when it was created. Since the child contains a pointer to its parent, we use its <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-parent" translate="no">parent()</a> function to obtain a pointer to item <b>B</b>. The parent model index is created using the <a href="./qabstractitemmodel.htm#createIndex" translate="no">QAbstractItemModel::createIndex</a>() function, passing the pointer to item <b>B</b> as the internal pointer.</p>
</td></tr>
</tbody></table></div>
<a name="treeitem-class-definition"></a>
<h4 id="treeitem-class-definition">TreeItem Class Definition<a class="plink" href="#treeitem-class-definition" title="Direct link to this headline"></a></h4>
<p>The <code translate="no">TreeItem</code> class provides simple items that contain several pieces of data, including information about their parent and child items:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> TreeItem
{
<span class="keyword">public</span>:
    <span class="keyword">explicit</span> TreeItem(<span class="keyword">const</span> <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span><span class="operator">&gt;</span> <span class="operator">&amp;</span>data<span class="operator">,</span> TreeItem <span class="operator">*</span>parent <span class="operator">=</span> nullptr);
    <span class="operator">~</span>TreeItem();

    TreeItem <span class="operator">*</span>child(<span class="type">int</span> number);
    <span class="type">int</span> childCount() <span class="keyword">const</span>;
    <span class="type">int</span> columnCount() <span class="keyword">const</span>;
    <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> data(<span class="type">int</span> column) <span class="keyword">const</span>;
    bool insertChildren(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> count<span class="operator">,</span> <span class="type">int</span> columns);
    bool insertColumns(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> columns);
    TreeItem <span class="operator">*</span>parent();
    bool removeChildren(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> count);
    bool removeColumns(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> columns);
    <span class="type">int</span> childNumber() <span class="keyword">const</span>;
    bool setData(<span class="type">int</span> column<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> <span class="operator">&amp;</span>value);

<span class="keyword">private</span>:
    <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span>TreeItem<span class="operator">*</span><span class="operator">&gt;</span> childItems;
    <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span><span class="operator">&gt;</span> itemData;
    TreeItem <span class="operator">*</span>parentItem;
};</pre></div>
<p>We have designed the API to be similar to that provided by <a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a> by giving each item functions to return the number of columns of information, read and write data, and insert and remove columns. However, we make the relationship between items explicit by providing functions to deal with "children" rather than "rows".</p>
<p>Each item contains a list of pointers to child items, a pointer to its parent item, and a list of <a href="./qvariant.htm" translate="no">QVariant</a> objects that correspond to information held in columns in a given row in the model.</p>
<a name="treeitem-class-implementation"></a>
<h4 id="treeitem-class-implementation">TreeItem Class Implementation<a class="plink" href="#treeitem-class-implementation" title="Direct link to this headline"></a></h4>
<p>Each <code translate="no">TreeItem</code> is constructed with a list of data and an optional parent item:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TreeItem<span class="operator">::</span>TreeItem(<span class="keyword">const</span> <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span><span class="operator">&gt;</span> <span class="operator">&amp;</span>data<span class="operator">,</span> TreeItem <span class="operator">*</span>parent)
    : itemData(data)<span class="operator">,</span>
      parentItem(parent)
{}</pre></div>
<p>Initially, each item has no children. These are added to the item's internal <code translate="no">childItems</code> member using the <code translate="no">insertChildren()</code> function described later.</p>
<p>The destructor ensures that each child added to the item is deleted when the item itself is deleted:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TreeItem<span class="operator">::</span><span class="operator">~</span>TreeItem()
{
    <a href="./qtalgorithms.htm#qDeleteAll" translate="no">qDeleteAll</a>(childItems);
}</pre></div>
<a name="treeitem-parent"></a><p>Since each item stores a pointer to its parent, the <code translate="no">parent()</code> function is trivial:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TreeItem <span class="operator">*</span>TreeItem<span class="operator">::</span>parent()
{
    <span class="keyword">return</span> parentItem;
}</pre></div>
<a name="treeitem-child"></a><p>Three functions provide information about the children of an item. <code translate="no">child()</code> returns a specific child from the internal list of children:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TreeItem <span class="operator">*</span>TreeItem<span class="operator">::</span>child(<span class="type">int</span> number)
{
    <span class="keyword">if</span> (number <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> number <span class="operator">&gt;</span><span class="operator">=</span> childItems<span class="operator">.</span>size())
        <span class="keyword">return</span> nullptr;
    <span class="keyword">return</span> childItems<span class="operator">.</span>at(number);
}</pre></div>
<p>The <code translate="no">childCount()</code> function returns the total number of children:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> TreeItem<span class="operator">::</span>childCount() <span class="keyword">const</span>
{
    <span class="keyword">return</span> childItems<span class="operator">.</span>count();
}</pre></div>
<p>The <code translate="no">childNumber()</code> function is used to determine the index of the child in its parent's list of children. It accesses the parent's <code translate="no">childItems</code> member directly to obtain this information:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> TreeItem<span class="operator">::</span>childNumber() <span class="keyword">const</span>
{
    <span class="keyword">if</span> (parentItem)
        <span class="keyword">return</span> parentItem<span class="operator">-</span><span class="operator">&gt;</span>childItems<span class="operator">.</span>indexOf(<span class="keyword">const_cast</span><span class="operator">&lt;</span>TreeItem<span class="operator">*</span><span class="operator">&gt;</span>(<span class="keyword">this</span>));
    <span class="keyword">return</span> <span class="number">0</span>;
}</pre></div>
<p>The root item has no parent item; for this item, we return zero to be consistent with the other items.</p>
<p>The <code translate="no">columnCount()</code> function simply returns the number of elements in the internal <code translate="no">itemData</code> list of <a href="./qvariant.htm" translate="no">QVariant</a> objects:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> TreeItem<span class="operator">::</span>columnCount() <span class="keyword">const</span>
{
    <span class="keyword">return</span> itemData<span class="operator">.</span>count();
}</pre></div>
<a name="treeitem-data"></a><p>Data is retrieved using the <code translate="no">data()</code> function, which accesses the appropriate element in the <code translate="no">itemData</code> list:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> TreeItem<span class="operator">::</span>data(<span class="type">int</span> column) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (column <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> column <span class="operator">&gt;</span><span class="operator">=</span> itemData<span class="operator">.</span>size())
        <span class="keyword">return</span> <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span>();
    <span class="keyword">return</span> itemData<span class="operator">.</span>at(column);
}</pre></div>
<a name="treeitem-setdata"></a><p>Data is set using the <code translate="no">setData()</code> function, which only stores values in the <code translate="no">itemData</code> list for valid list indexes, corresponding to column values in the model:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">bool TreeItem<span class="operator">::</span>setData(<span class="type">int</span> column<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> <span class="operator">&amp;</span>value)
{
    <span class="keyword">if</span> (column <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> column <span class="operator">&gt;</span><span class="operator">=</span> itemData<span class="operator">.</span>size())
        <span class="keyword">return</span> <span class="keyword">false</span>;

    itemData<span class="operator">[</span>column<span class="operator">]</span> <span class="operator">=</span> value;
    <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre></div>
<p>To make implementation of the model easier, we return true to indicate that the data was set successfully.</p>
<p>Editable models often need to be resizable, enabling rows and columns to be inserted and removed. The insertion of rows beneath a given model index in the model leads to the insertion of new child items in the corresponding item, handled by the <code translate="no">insertChildren()</code> function:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">bool TreeItem<span class="operator">::</span>insertChildren(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> count<span class="operator">,</span> <span class="type">int</span> columns)
{
    <span class="keyword">if</span> (position <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> position <span class="operator">&gt;</span> childItems<span class="operator">.</span>size())
        <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="keyword">for</span> (<span class="type">int</span> row <span class="operator">=</span> <span class="number">0</span>; row <span class="operator">&lt;</span> count; <span class="operator">+</span><span class="operator">+</span>row) {
        <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span><span class="operator">&gt;</span> data(columns);
        TreeItem <span class="operator">*</span>item <span class="operator">=</span> <span class="keyword">new</span> TreeItem(data<span class="operator">,</span> <span class="keyword">this</span>);
        childItems<span class="operator">.</span>insert(position<span class="operator">,</span> item);
    }

    <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre></div>
<p>This ensures that new items are created with the required number of columns and inserted at a valid position in the internal <code translate="no">childItems</code> list. Items are removed with the <code translate="no">removeChildren()</code> function:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">bool TreeItem<span class="operator">::</span>removeChildren(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> count)
{
    <span class="keyword">if</span> (position <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> position <span class="operator">+</span> count <span class="operator">&gt;</span> childItems<span class="operator">.</span>size())
        <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="keyword">for</span> (<span class="type">int</span> row <span class="operator">=</span> <span class="number">0</span>; row <span class="operator">&lt;</span> count; <span class="operator">+</span><span class="operator">+</span>row)
        <span class="keyword">delete</span> childItems<span class="operator">.</span>takeAt(position);

    <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre></div>
<p>As discussed above, the functions for inserting and removing columns are used differently to those for inserting and removing child items because they are expected to be called on every item in the tree. We do this by recursively calling this function on each child of the item:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">bool TreeItem<span class="operator">::</span>insertColumns(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> columns)
{
    <span class="keyword">if</span> (position <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">|</span><span class="operator">|</span> position <span class="operator">&gt;</span> itemData<span class="operator">.</span>size())
        <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="keyword">for</span> (<span class="type">int</span> column <span class="operator">=</span> <span class="number">0</span>; column <span class="operator">&lt;</span> columns; <span class="operator">+</span><span class="operator">+</span>column)
        itemData<span class="operator">.</span>insert(position<span class="operator">,</span> <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span>());

    <span class="keyword">for</span> (TreeItem <span class="operator">*</span>child : qAsConst(childItems))
        child<span class="operator">-</span><span class="operator">&gt;</span>insertColumns(position<span class="operator">,</span> columns);

    <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre></div>
<a name="treemodel-class-definition"></a>
<h4 id="treemodel-class-definition">TreeModel Class Definition<a class="plink" href="#treemodel-class-definition" title="Direct link to this headline"></a></h4>
<p>The <code translate="no">TreeModel</code> class provides an implementation of the <a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a> class, exposing the necessary interface for a model that can be edited and resized.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> TreeModel : <span class="keyword">public</span> <span class="type"><a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a></span>
{
    Q_OBJECT

<span class="keyword">public</span>:
    TreeModel(<span class="keyword">const</span> <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> <span class="operator">&amp;</span>headers<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>data<span class="operator">,</span>
              <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);
    <span class="operator">~</span>TreeModel();</pre></div>
<p>The constructor and destructor are specific to this model.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> data(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span> <span class="type">int</span> role) <span class="keyword">const</span> override;
    <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> headerData(<span class="type">int</span> section<span class="operator">,</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>Orientation orientation<span class="operator">,</span>
                        <span class="type">int</span> role <span class="operator">=</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>DisplayRole) <span class="keyword">const</span> override;

    <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> index(<span class="type">int</span> row<span class="operator">,</span> <span class="type">int</span> column<span class="operator">,</span>
                      <span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>()) <span class="keyword">const</span> override;
    <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> parent(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span> override;

    <span class="type">int</span> rowCount(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>()) <span class="keyword">const</span> override;
    <span class="type">int</span> columnCount(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>()) <span class="keyword">const</span> override;</pre></div>
<p>Read-only tree models only need to provide the above functions. The following public functions provide support for editing and resizing:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>ItemFlags flags(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span> override;
    bool setData(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> <span class="operator">&amp;</span>value<span class="operator">,</span>
                 <span class="type">int</span> role <span class="operator">=</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>EditRole) override;
    bool setHeaderData(<span class="type">int</span> section<span class="operator">,</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>Orientation orientation<span class="operator">,</span>
                       <span class="keyword">const</span> <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> <span class="operator">&amp;</span>value<span class="operator">,</span> <span class="type">int</span> role <span class="operator">=</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>EditRole) override;

    bool insertColumns(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> columns<span class="operator">,</span>
                       <span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>()) override;
    bool removeColumns(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> columns<span class="operator">,</span>
                       <span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>()) override;
    bool insertRows(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> rows<span class="operator">,</span>
                    <span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>()) override;
    bool removeRows(<span class="type">int</span> position<span class="operator">,</span> <span class="type">int</span> rows<span class="operator">,</span>
                    <span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent <span class="operator">=</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>()) override;

<span class="keyword">private</span>:
    <span class="type">void</span> setupModelData(<span class="keyword">const</span> <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> <span class="operator">&amp;</span>lines<span class="operator">,</span> TreeItem <span class="operator">*</span>parent);
    TreeItem <span class="operator">*</span>getItem(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>;

    TreeItem <span class="operator">*</span>rootItem;
};</pre></div>
<p>To simplify this example, the data exposed by the model is organized into a data structure by the model's <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-setupmodeldata" translate="no">setupModelData()</a> function. Many real world models will not process the raw data at all, but simply work with an existing data structure or library API.</p>
<a name="treemodel-class-implementation"></a>
<h4 id="treemodel-class-implementation">TreeModel Class Implementation<a class="plink" href="#treemodel-class-implementation" title="Direct link to this headline"></a></h4>
<p>The constructor creates a root item and initializes it with the header data supplied:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TreeModel<span class="operator">::</span>TreeModel(<span class="keyword">const</span> <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> <span class="operator">&amp;</span>headers<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>data<span class="operator">,</span> <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>parent)
    : <span class="type"><a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a></span>(parent)
{
    <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span><span class="operator">&gt;</span> rootData;
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>header : headers)
        rootData <span class="operator">&lt;</span><span class="operator">&lt;</span> header;

    rootItem <span class="operator">=</span> <span class="keyword">new</span> TreeItem(rootData);
    setupModelData(data<span class="operator">.</span>split(<span class="char">'\n'</span>)<span class="operator">,</span> rootItem);
}</pre></div>
<p>We call the internal <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-setupmodeldata" translate="no">setupModelData()</a> function to convert the textual data supplied to a data structure we can use with the model. Other models may be initialized with a ready-made data structure, or use an API from a library that maintains its own data.</p>
<p>The destructor only has to delete the root item, which will cause all child items to be recursively deleted.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TreeModel<span class="operator">::</span><span class="operator">~</span>TreeModel()
{
    <span class="keyword">delete</span> rootItem;
}</pre></div>
<a name="treemodel-getitem"></a><p>Since the model's interface to the other model/view components is based on model indexes, and since the internal data structure is item-based, many of the functions implemented by the model need to be able to convert any given model index to its corresponding item. For convenience and consistency, we have defined a <code translate="no">getItem()</code> function to perform this repetitive task:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TreeItem <span class="operator">*</span>TreeModel<span class="operator">::</span>getItem(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (index<span class="operator">.</span>isValid()) {
        TreeItem <span class="operator">*</span>item <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span>TreeItem<span class="operator">*</span><span class="operator">&gt;</span>(index<span class="operator">.</span>internalPointer());
        <span class="keyword">if</span> (item)
            <span class="keyword">return</span> item;
    }
    <span class="keyword">return</span> rootItem;
}</pre></div>
<p>Each model index passed to this function should correspond to a valid item in memory. If the index is invalid, or its internal pointer does not refer to a valid item, the root item is returned instead.</p>
<p>The model's <code translate="no">rowCount()</code> implementation is simple: it first uses the <code translate="no">getItem()</code> function to obtain the relevant item; then it returns the number of children it contains:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> TreeModel<span class="operator">::</span>rowCount(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (parent<span class="operator">.</span>isValid() <span class="operator">&amp;</span><span class="operator">&amp;</span> parent<span class="operator">.</span>column() <span class="operator">&gt;</span> <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">0</span>;

    <span class="keyword">const</span> TreeItem <span class="operator">*</span>parentItem <span class="operator">=</span> getItem(parent);

    <span class="keyword">return</span> parentItem <span class="operator">?</span> parentItem<span class="operator">-</span><span class="operator">&gt;</span>childCount() : <span class="number">0</span>;
}</pre></div>
<p>By contrast, the <code translate="no">columnCount()</code> implementation does not need to look for a particular item because all items are defined to have the same number of columns associated with them.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> TreeModel<span class="operator">::</span>columnCount(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent) <span class="keyword">const</span>
{
    Q_UNUSED(parent);
    <span class="keyword">return</span> rootItem<span class="operator">-</span><span class="operator">&gt;</span>columnCount();
}</pre></div>
<p>As a result, the number of columns can be obtained directly from the root item.</p>
<p>To enable items to be edited and selected, the <code translate="no">flags()</code> function needs to be implemented so that it returns a combination of flags that includes the <a href="./qt.htm#ItemFlag-enum" translate="no">Qt::ItemIsEditable</a> and <a href="./qt.htm#ItemFlag-enum" translate="no">Qt::ItemIsSelectable</a> flags as well as <a href="./qt.htm#ItemFlag-enum" translate="no">Qt::ItemIsEnabled</a>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>ItemFlags TreeModel<span class="operator">::</span>flags(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (<span class="operator">!</span>index<span class="operator">.</span>isValid())
        <span class="keyword">return</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>NoItemFlags;

    <span class="keyword">return</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>ItemIsEditable <span class="operator">|</span> <span class="type"><a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a></span><span class="operator">::</span>flags(index);
}</pre></div>
<a name="treemodel-index"></a><p>The model needs to be able to generate model indexes to allow other components to request data and information about its structure. This task is performed by the <code translate="no">index()</code> function, which is used to obtain model indexes corresponding to children of a given parent item:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> TreeModel<span class="operator">::</span>index(<span class="type">int</span> row<span class="operator">,</span> <span class="type">int</span> column<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>parent) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (parent<span class="operator">.</span>isValid() <span class="operator">&amp;</span><span class="operator">&amp;</span> parent<span class="operator">.</span>column() <span class="operator">!</span><span class="operator">=</span> <span class="number">0</span>)
        <span class="keyword">return</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>();</pre></div>
<p>In this model, we only return model indexes for child items if the parent index is invalid (corresponding to the root item) or if it has a zero column number.</p>
<p>We use the custom <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-getitem" translate="no">getItem()</a> function to obtain a <code translate="no">TreeItem</code> instance that corresponds to the model index supplied, and request its child item that corresponds to the specified row.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    TreeItem <span class="operator">*</span>parentItem <span class="operator">=</span> getItem(parent);
    <span class="keyword">if</span> (<span class="operator">!</span>parentItem)
        <span class="keyword">return</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>();

    TreeItem <span class="operator">*</span>childItem <span class="operator">=</span> parentItem<span class="operator">-</span><span class="operator">&gt;</span>child(row);
    <span class="keyword">if</span> (childItem)
        <span class="keyword">return</span> createIndex(row<span class="operator">,</span> column<span class="operator">,</span> childItem);
    <span class="keyword">return</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>();
}</pre></div>
<p>Since each item contains information for an entire row of data, we create a model index to uniquely identify it by calling <a href="./qabstractitemmodel.htm#createIndex" translate="no">createIndex()</a> it with the row and column numbers and a pointer to the item. In the <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-data" translate="no">data()</a> function, we will use the item pointer and column number to access the data associated with the model index; in this model, the row number is not needed to identify data.</p>
<a name="treemodel-parent"></a><p>The <code translate="no">parent()</code> function supplies model indexes for parents of items by finding the corresponding item for a given model index, using its <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treeitem-parent" translate="no">parent()</a> function to obtain its parent item, then creating a model index to represent the parent. (See <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#relating-items-using-model-indexes" translate="no">the above diagram</a>).</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> TreeModel<span class="operator">::</span>parent(<span class="keyword">const</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span> <span class="operator">&amp;</span>index) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (<span class="operator">!</span>index<span class="operator">.</span>isValid())
        <span class="keyword">return</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>();

    TreeItem <span class="operator">*</span>childItem <span class="operator">=</span> getItem(index);
    TreeItem <span class="operator">*</span>parentItem <span class="operator">=</span> childItem <span class="operator">?</span> childItem<span class="operator">-</span><span class="operator">&gt;</span>parent() : nullptr;

    <span class="keyword">if</span> (parentItem <span class="operator">=</span><span class="operator">=</span> rootItem <span class="operator">|</span><span class="operator">|</span> <span class="operator">!</span>parentItem)
        <span class="keyword">return</span> <span class="type"><a href="./qmodelindex.htm" translate="no">QModelIndex</a></span>();

    <span class="keyword">return</span> createIndex(parentItem<span class="operator">-</span><span class="operator">&gt;</span>childNumber()<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> parentItem);
}</pre></div>
<p>Items without parents, including the root item, are handled by returning a null model index. Otherwise, a model index is created and returned as in the <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-index" translate="no">index()</a> function, with a suitable row number, but with a zero column number to be consistent with the scheme used in the <a href="./qtwidgets-itemviews-editabletreemodel-example.htm#treemodel-index" translate="no">index()</a> implementation.</p>
<a name="treemodel-data"></a><a name="treemodel-setupmodeldata"></a><p><a href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/itemviews/editabletreemodel?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@itemviews/editabletreemodel -->
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>