<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QFutureWatcher | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qfuturewatcher.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QFutureWatcher</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QFutureWatcher Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QFutureWatcher</span>
<!-- $$$QFutureWatcher-brief -->
<p>The QFutureWatcher class allows monitoring a <a href="./qfuture.htm" translate="no">QFuture</a> using signals and slots. <a href="#details">More...</a></p>
<!-- @@@QFutureWatcher -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QFutureWatcher&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.4</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qobject.htm" translate="no">QObject</a></td></tr></tbody></table></div><p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="./qfuturewatcher-members.htm">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#QFutureWatcher" translate="no">QFutureWatcher</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#dtor.QFutureWatcher" translate="no">~QFutureWatcher</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#future" translate="no">future</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#isCanceled" translate="no">isCanceled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#isFinished" translate="no">isFinished</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#isPaused" translate="no">isPaused</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#isRunning" translate="no">isRunning</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#isStarted" translate="no">isStarted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#progressMaximum" translate="no">progressMaximum</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#progressMinimum" translate="no">progressMinimum</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#progressText" translate="no">progressText</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#progressValue" translate="no">progressValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#result" translate="no">result</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#resultAt" translate="no">resultAt</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#setFuture" translate="no">setFuture</a></b>(const QFuture&lt;T&gt; &amp;<i>future</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#setPendingResultsLimit" translate="no">setPendingResultsLimit</a></b>(int <i>limit</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#waitForFinished" translate="no">waitForFinished</a></b>()</td></tr>
</tbody></table></div>
<a name="public-slots"></a>
<h2 id="public-slots">Public Slots<a class="plink" href="#public-slots" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#cancel" translate="no">cancel</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#pause" translate="no">pause</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#resume" translate="no">resume</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a></b>(bool <i>paused</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#togglePaused" translate="no">togglePaused</a></b>()</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#canceled" translate="no">canceled</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#finished" translate="no">finished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#paused" translate="no">paused</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#progressRangeChanged" translate="no">progressRangeChanged</a></b>(int <i>minimum</i>, int <i>maximum</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#progressTextChanged" translate="no">progressTextChanged</a></b>(const QString &amp;<i>progressText</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#progressValueChanged" translate="no">progressValueChanged</a></b>(int <i>progressValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#resultReadyAt" translate="no">resultReadyAt</a></b>(int <i>index</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#resultsReadyAt" translate="no">resultsReadyAt</a></b>(int <i>beginIndex</i>, int <i>endIndex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#resumed" translate="no">resumed</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuturewatcher.htm#started" translate="no">started</a></b>()</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QFutureWatcher-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QFutureWatcher provides information and notifications about a <a href="./qfuture.htm" translate="no">QFuture</a>. Use the <a href="./qfuturewatcher.htm#setFuture" translate="no">setFuture</a>() function to start watching a particular <a href="./qfuture.htm" translate="no">QFuture</a>. The <a href="./qfuturewatcher.htm#future" translate="no">future</a>() function returns the future set with <a href="./qfuturewatcher.htm#setFuture" translate="no">setFuture</a>().</p>
<p>For convenience, several of <a href="./qfuture.htm" translate="no">QFuture</a>'s functions are also available in QFutureWatcher: <a href="./qfuturewatcher.htm#progressValue" translate="no">progressValue</a>(), <a href="./qfuturewatcher.htm#progressMinimum" translate="no">progressMinimum</a>(), <a href="./qfuturewatcher.htm#progressMaximum" translate="no">progressMaximum</a>(), <a href="./qfuturewatcher.htm#progressText" translate="no">progressText</a>(), <a href="./qfuturewatcher.htm#isStarted" translate="no">isStarted</a>(), <a href="./qfuturewatcher.htm#isFinished" translate="no">isFinished</a>(), <a href="./qfuturewatcher.htm#isRunning" translate="no">isRunning</a>(), <a href="./qfuturewatcher.htm#isCanceled" translate="no">isCanceled</a>(), <a href="./qfuturewatcher.htm#isPaused" translate="no">isPaused</a>(), <a href="./qfuturewatcher.htm#waitForFinished" translate="no">waitForFinished</a>(), <a href="./qfuturewatcher.htm#result" translate="no">result</a>(), and <a href="./qfuturewatcher.htm#resultAt" translate="no">resultAt</a>(). The <a href="./qfuturewatcher.htm#cancel" translate="no">cancel</a>(), <a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>(), <a href="./qfuturewatcher.htm#pause" translate="no">pause</a>(), <a href="./qfuturewatcher.htm#resume" translate="no">resume</a>(), and <a href="./qfuturewatcher.htm#togglePaused" translate="no">togglePaused</a>() functions are slots in QFutureWatcher.</p>
<p>Status changes are reported via the <a href="./qfuturewatcher.htm#started" translate="no">started</a>(), <a href="./qfuturewatcher.htm#finished" translate="no">finished</a>(), <a href="./qfuturewatcher.htm#canceled" translate="no">canceled</a>(), <a href="./qfuturewatcher.htm#paused" translate="no">paused</a>(), <a href="./qfuturewatcher.htm#resumed" translate="no">resumed</a>(), <a href="./qfuturewatcher.htm#resultReadyAt" translate="no">resultReadyAt</a>(), and <a href="./qfuturewatcher.htm#resultsReadyAt" translate="no">resultsReadyAt</a>() signals. Progress information is provided from the <a href="./qfuturewatcher.htm#progressRangeChanged" translate="no">progressRangeChanged</a>(), void <a href="./qfuturewatcher.htm#progressValueChanged" translate="no">progressValueChanged</a>(), and <a href="./qfuturewatcher.htm#progressTextChanged" translate="no">progressTextChanged</a>() signals.</p>
<p>Throttling control is provided by the <a href="./qfuturewatcher.htm#setPendingResultsLimit" translate="no">setPendingResultsLimit</a>() function. When the number of pending <a href="./qfuturewatcher.htm#resultReadyAt" translate="no">resultReadyAt</a>() or <a href="./qfuturewatcher.htm#resultsReadyAt" translate="no">resultsReadyAt</a>() signals exceeds the limit, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the limit.</p>
<p>Example: Starting a computation and getting a slot callback when it's finished:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Instantiate the objects and connect to the finished signal.</span>
MyClass myObject;
<span class="type"><a href="./qfuturewatcher.htm#QFutureWatcher" translate="no">QFutureWatcher</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> watcher;
connect(<span class="operator">&amp;</span>watcher<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qfuturewatcher.htm#QFutureWatcher" translate="no">QFutureWatcher</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>finished<span class="operator">,</span> <span class="operator">&amp;</span>myObject<span class="operator">,</span> <span class="operator">&amp;</span>MyClass<span class="operator">::</span>handleFinished);

<span class="comment">// Start the computation.</span>
<span class="type"><a href="./qfuture.htm" translate="no">QFuture</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> future <span class="operator">=</span> <span class="type">QtConcurrent</span><span class="operator">::</span>run(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
watcher<span class="operator">.</span>setFuture(future);</pre></div>
<p>Be aware that not all running asynchronous computations can be canceled or paused. For example, the future returned by <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() cannot be canceled; but the future returned by <a href="./qtconcurrent.htm#mappedReduced" translate="no">QtConcurrent::mappedReduced</a>() can.</p>
<p>QFutureWatcher&lt;void&gt; is specialized to not contain any of the result fetching functions. Any <a href="./qfuture.htm" translate="no">QFuture</a>&lt;T&gt; can be watched by a QFutureWatcher&lt;void&gt; as well. This is useful if only status or progress information is needed; not the actual result data.</p>
</div>
<p><b>See also </b><a href="./qfuture.htm" translate="no">QFuture</a> and <a href="./qtconcurrent-index.htm" translate="no">Qt Concurrent</a>.</p>
<!-- @@@QFutureWatcher -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QFutureWatcher[overload1]$$$QFutureWatcherQObject* -->
<h3 class="fn" id="QFutureWatcher" translate="no"><a name="QFutureWatcher"></a>QFutureWatcher::<span class="name">QFutureWatcher</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QFutureWatcher" title="Direct link to this headline"></a></h3>
<p>Constructs a new QFutureWatcher with the given <i translate="no">parent</i>. Until a future is set with <a href="./qfuturewatcher.htm#setFuture" translate="no">setFuture</a>(), the functions <a href="./qfuturewatcher.htm#isStarted" translate="no">isStarted</a>(), <a href="./qfuturewatcher.htm#isCanceled" translate="no">isCanceled</a>(), and <a href="./qfuturewatcher.htm#isFinished" translate="no">isFinished</a>() return <code translate="no">true</code>.</p>
<!-- @@@QFutureWatcher -->
<!-- $$$cancel[overload1]$$$cancel -->
<h3 class="fn" id="cancel" translate="no"><a name="cancel"></a><code translate="no">[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">cancel</span>()<a class="plink" href="#cancel" title="Direct link to this headline"></a></h3>
<p>Cancels the asynchronous computation represented by the <a href="./qfuturewatcher.htm#future" translate="no">future</a>(). Note that the cancellation is asynchronous. Use <a href="./qfuturewatcher.htm#waitForFinished" translate="no">waitForFinished</a>() after calling cancel() when you need synchronous cancellation.</p>
<p>Currently available results may still be accessed on a canceled <a href="./qfuture.htm" translate="no">QFuture</a>, but new results will <i>not</i> become available after calling this function. Also, this <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> will not deliver progress and result ready signals once canceled. This includes the <a href="./qfuturewatcher.htm#progressValueChanged" translate="no">progressValueChanged</a>(), <a href="./qfuturewatcher.htm#progressRangeChanged" translate="no">progressRangeChanged</a>(), <a href="./qfuturewatcher.htm#progressTextChanged" translate="no">progressTextChanged</a>(), <a href="./qfuturewatcher.htm#resultReadyAt" translate="no">resultReadyAt</a>(), and <a href="./qfuturewatcher.htm#resultsReadyAt" translate="no">resultsReadyAt</a>() signals.</p>
<p>Be aware that not all running asynchronous computations can be canceled. For example, the <a href="./qfuture.htm" translate="no">QFuture</a> returned by <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() cannot be canceled; but the <a href="./qfuture.htm" translate="no">QFuture</a> returned by <a href="./qtconcurrent.htm#mappedReduced" translate="no">QtConcurrent::mappedReduced</a>() can.</p>
<!-- @@@cancel -->
<!-- $$$canceled[overload1]$$$canceled -->
<h3 class="fn" id="canceled" translate="no"><a name="canceled"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">canceled</span>()<a class="plink" href="#canceled" title="Direct link to this headline"></a></h3>
<p>This signal is emitted if the watched future is canceled.</p>
<!-- @@@canceled -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn" id="finished" translate="no"><a name="finished"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">finished</span>()<a class="plink" href="#finished" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the watched future finishes.</p>
<!-- @@@finished -->
<!-- $$$pause[overload1]$$$pause -->
<h3 class="fn" id="pause" translate="no"><a name="pause"></a><code translate="no">[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">pause</span>()<a class="plink" href="#pause" title="Direct link to this headline"></a></h3>
<p>Pauses the asynchronous computation represented by the <a href="./qfuturewatcher.htm#future" translate="no">future</a>(). This is a convenience method that simply calls <a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>(true).</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#resume" translate="no">resume</a>().</p>
<!-- @@@pause -->
<!-- $$$paused[overload1]$$$paused -->
<h3 class="fn" id="paused" translate="no"><a name="paused"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">paused</span>()<a class="plink" href="#paused" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the watched future is paused.</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>().</p>
<!-- @@@paused -->
<!-- $$$progressRangeChanged[overload1]$$$progressRangeChangedintint -->
<h3 class="fn" id="progressRangeChanged" translate="no"><a name="progressRangeChanged"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressRangeChanged</span>(<span class="type">int</span> <i>minimum</i>, <span class="type">int</span> <i>maximum</i>)<a class="plink" href="#progressRangeChanged" title="Direct link to this headline"></a></h3>
<p>The progress range for the watched future has changed to <i translate="no">minimum</i> and <i translate="no">maximum</i></p>
<!-- @@@progressRangeChanged -->
<!-- $$$progressTextChanged[overload1]$$$progressTextChangedconstQString& -->
<h3 class="fn" id="progressTextChanged" translate="no"><a name="progressTextChanged"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressTextChanged</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>progressText</i>)<a class="plink" href="#progressTextChanged" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the watched future reports textual progress information, <i translate="no">progressText</i>.</p>
<!-- @@@progressTextChanged -->
<!-- $$$progressValueChanged[overload1]$$$progressValueChangedint -->
<h3 class="fn" id="progressValueChanged" translate="no"><a name="progressValueChanged"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">progressValueChanged</span>(<span class="type">int</span> <i>progressValue</i>)<a class="plink" href="#progressValueChanged" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the watched future reports progress, <i translate="no">progressValue</i> gives the current progress. In order to avoid overloading the GUI event loop, <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> limits the progress signal emission rate. This means that listeners connected to this slot might not get all progress reports the future makes. The last progress update (where <i translate="no">progressValue</i> equals the maximum value) will always be delivered.</p>
<!-- @@@progressValueChanged -->
<!-- $$$resultReadyAt[overload1]$$$resultReadyAtint -->
<h3 class="fn" id="resultReadyAt" translate="no"><a name="resultReadyAt"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resultReadyAt</span>(<span class="type">int</span> <i>index</i>)<a class="plink" href="#resultReadyAt" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the watched future reports a ready result at <i translate="no">index</i>. If the future reports multiple results, the index will indicate which one it is. Results can be reported out-of-order. To get the result, call <a href="./qfuturewatcher.htm#resultAt" translate="no">resultAt</a>(index);</p>
<!-- @@@resultReadyAt -->
<!-- $$$resultsReadyAt[overload1]$$$resultsReadyAtintint -->
<h3 class="fn" id="resultsReadyAt" translate="no"><a name="resultsReadyAt"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resultsReadyAt</span>(<span class="type">int</span> <i>beginIndex</i>, <span class="type">int</span> <i>endIndex</i>)<a class="plink" href="#resultsReadyAt" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the watched future reports ready results. The results are indexed from <i translate="no">beginIndex</i> to <i translate="no">endIndex</i>.</p>
<!-- @@@resultsReadyAt -->
<!-- $$$resume[overload1]$$$resume -->
<h3 class="fn" id="resume" translate="no"><a name="resume"></a><code translate="no">[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">resume</span>()<a class="plink" href="#resume" title="Direct link to this headline"></a></h3>
<p>Resumes the asynchronous computation represented by the <a href="./qfuturewatcher.htm#future" translate="no">future</a>(). This is a convenience method that simply calls <a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>(false).</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#pause" translate="no">pause</a>().</p>
<!-- @@@resume -->
<!-- $$$resumed[overload1]$$$resumed -->
<h3 class="fn" id="resumed" translate="no"><a name="resumed"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">resumed</span>()<a class="plink" href="#resumed" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the watched future is resumed.</p>
<!-- @@@resumed -->
<!-- $$$setPaused[overload1]$$$setPausedbool -->
<h3 class="fn" id="setPaused" translate="no"><a name="setPaused"></a><code translate="no">[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">setPaused</span>(<span class="type">bool</span> <i>paused</i>)<a class="plink" href="#setPaused" title="Direct link to this headline"></a></h3>
<p>If <i translate="no">paused</i> is true, this function pauses the asynchronous computation represented by the <a href="./qfuturewatcher.htm#future" translate="no">future</a>(). If the computation is already paused, this function does nothing. This <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> will stop delivering progress and result ready signals while the future is paused. Signal delivery will continue once the computation is resumed.</p>
<p>If <i translate="no">paused</i> is false, this function resumes the asynchronous computation. If the computation was not previously paused, this function does nothing.</p>
<p>Be aware that not all computations can be paused. For example, the <a href="./qfuture.htm" translate="no">QFuture</a> returned by <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() cannot be paused; but the <a href="./qfuture.htm" translate="no">QFuture</a> returned by <a href="./qtconcurrent.htm#mappedReduced" translate="no">QtConcurrent::mappedReduced</a>() can.</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#paused" translate="no">paused</a>(), <a href="./qfuturewatcher.htm#pause" translate="no">pause</a>(), <a href="./qfuturewatcher.htm#resume" translate="no">resume</a>(), and <a href="./qfuturewatcher.htm#togglePaused" translate="no">togglePaused</a>().</p>
<!-- @@@setPaused -->
<!-- $$$started[overload1]$$$started -->
<h3 class="fn" id="started" translate="no"><a name="started"></a><code translate="no">[signal] </code><span class="type">void</span> QFutureWatcher::<span class="name">started</span>()<a class="plink" href="#started" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when this <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> starts watching the future set with <a href="./qfuturewatcher.htm#setFuture" translate="no">setFuture</a>().</p>
<!-- @@@started -->
<!-- $$$togglePaused[overload1]$$$togglePaused -->
<h3 class="fn" id="togglePaused" translate="no"><a name="togglePaused"></a><code translate="no">[slot] </code><span class="type">void</span> QFutureWatcher::<span class="name">togglePaused</span>()<a class="plink" href="#togglePaused" title="Direct link to this headline"></a></h3>
<p>Toggles the paused state of the asynchronous computation. In other words, if the computation is currently paused, calling this function resumes it; if the computation is running, it becomes paused. This is a convenience method for calling <a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>(!<a href="./qfuturewatcher.htm#isPaused" translate="no">isPaused</a>()).</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>(), <a href="./qfuturewatcher.htm#pause" translate="no">pause</a>(), and <a href="./qfuturewatcher.htm#resume" translate="no">resume</a>().</p>
<!-- @@@togglePaused -->
<!-- $$$~QFutureWatcher[overload1]$$$~QFutureWatcher -->
<h3 class="fn" id="dtor.QFutureWatcher" translate="no"><a name="dtor.QFutureWatcher"></a><code translate="no">[virtual] </code>QFutureWatcher::<span class="name">~QFutureWatcher</span>()<a class="plink" href="#dtor.QFutureWatcher" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a>.</p>
<!-- @@@~QFutureWatcher -->
<!-- $$$future[overload1]$$$future -->
<h3 class="fn" id="future" translate="no"><a name="future"></a><span class="type"><a href="./qfuture.htm" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; QFutureWatcher::<span class="name">future</span>() const<a class="plink" href="#future" title="Direct link to this headline"></a></h3>
<p>Returns the watched future.</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#setFuture" translate="no">setFuture</a>().</p>
<!-- @@@future -->
<!-- $$$isCanceled[overload1]$$$isCanceled -->
<h3 class="fn" id="isCanceled" translate="no"><a name="isCanceled"></a><span class="type">bool</span> QFutureWatcher::<span class="name">isCanceled</span>() const<a class="plink" href="#isCanceled" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation has been canceled with the <a href="./qfuturewatcher.htm#cancel" translate="no">cancel</a>() function, or if no future has been set; otherwise returns <code translate="no">false</code>.</p>
<p>Be aware that the computation may still be running even though this function returns <code translate="no">true</code>. See <a href="./qfuturewatcher.htm#cancel" translate="no">cancel</a>() for more details.</p>
<!-- @@@isCanceled -->
<!-- $$$isFinished[overload1]$$$isFinished -->
<h3 class="fn" id="isFinished" translate="no"><a name="isFinished"></a><span class="type">bool</span> QFutureWatcher::<span class="name">isFinished</span>() const<a class="plink" href="#isFinished" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by the <a href="./qfuturewatcher.htm#future" translate="no">future</a>() has finished, or if no future has been set; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isFinished -->
<!-- $$$isPaused[overload1]$$$isPaused -->
<h3 class="fn" id="isPaused" translate="no"><a name="isPaused"></a><span class="type">bool</span> QFutureWatcher::<span class="name">isPaused</span>() const<a class="plink" href="#isPaused" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation has been paused with the <a href="./qfuturewatcher.htm#pause" translate="no">pause</a>() function; otherwise returns <code translate="no">false</code>.</p>
<p>Be aware that the computation may still be running even though this function returns <code translate="no">true</code>. See <a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>() for more details.</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#setPaused" translate="no">setPaused</a>() and <a href="./qfuturewatcher.htm#togglePaused" translate="no">togglePaused</a>().</p>
<!-- @@@isPaused -->
<!-- $$$isRunning[overload1]$$$isRunning -->
<h3 class="fn" id="isRunning" translate="no"><a name="isRunning"></a><span class="type">bool</span> QFutureWatcher::<span class="name">isRunning</span>() const<a class="plink" href="#isRunning" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by the <a href="./qfuturewatcher.htm#future" translate="no">future</a>() is currently running; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isRunning -->
<!-- $$$isStarted[overload1]$$$isStarted -->
<h3 class="fn" id="isStarted" translate="no"><a name="isStarted"></a><span class="type">bool</span> QFutureWatcher::<span class="name">isStarted</span>() const<a class="plink" href="#isStarted" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by the <a href="./qfuturewatcher.htm#future" translate="no">future</a>() has been started, or if no future has been set; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isStarted -->
<!-- $$$progressMaximum[overload1]$$$progressMaximum -->
<h3 class="fn" id="progressMaximum" translate="no"><a name="progressMaximum"></a><span class="type">int</span> QFutureWatcher::<span class="name">progressMaximum</span>() const<a class="plink" href="#progressMaximum" title="Direct link to this headline"></a></h3>
<p>Returns the maximum <a href="./qfuturewatcher.htm#progressValue" translate="no">progressValue</a>().</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#progressValue" translate="no">progressValue</a>() and <a href="./qfuturewatcher.htm#progressMinimum" translate="no">progressMinimum</a>().</p>
<!-- @@@progressMaximum -->
<!-- $$$progressMinimum[overload1]$$$progressMinimum -->
<h3 class="fn" id="progressMinimum" translate="no"><a name="progressMinimum"></a><span class="type">int</span> QFutureWatcher::<span class="name">progressMinimum</span>() const<a class="plink" href="#progressMinimum" title="Direct link to this headline"></a></h3>
<p>Returns the minimum <a href="./qfuturewatcher.htm#progressValue" translate="no">progressValue</a>().</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#progressValue" translate="no">progressValue</a>() and <a href="./qfuturewatcher.htm#progressMaximum" translate="no">progressMaximum</a>().</p>
<!-- @@@progressMinimum -->
<!-- $$$progressText[overload1]$$$progressText -->
<h3 class="fn" id="progressText" translate="no"><a name="progressText"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QFutureWatcher::<span class="name">progressText</span>() const<a class="plink" href="#progressText" title="Direct link to this headline"></a></h3>
<p>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</p>
<p>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</p>
<!-- @@@progressText -->
<!-- $$$progressValue[overload1]$$$progressValue -->
<h3 class="fn" id="progressValue" translate="no"><a name="progressValue"></a><span class="type">int</span> QFutureWatcher::<span class="name">progressValue</span>() const<a class="plink" href="#progressValue" title="Direct link to this headline"></a></h3>
<p>Returns the current progress value, which is between the <a href="./qfuturewatcher.htm#progressMinimum" translate="no">progressMinimum</a>() and <a href="./qfuturewatcher.htm#progressMaximum" translate="no">progressMaximum</a>().</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#progressMinimum" translate="no">progressMinimum</a>() and <a href="./qfuturewatcher.htm#progressMaximum" translate="no">progressMaximum</a>().</p>
<!-- @@@progressValue -->
<!-- $$$result[overload1]$$$result -->
<h3 class="fn" id="result" translate="no"><a name="result"></a><span class="type">T</span> QFutureWatcher::<span class="name">result</span>() const<a class="plink" href="#result" title="Direct link to this headline"></a></h3>
<p>Returns the first result in the <a href="./qfuturewatcher.htm#future" translate="no">future</a>(). If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <a href="./qfuturewatcher.htm#resultAt" translate="no">resultAt</a>(0).</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#resultAt" translate="no">resultAt</a>().</p>
<!-- @@@result -->
<!-- $$$resultAt[overload1]$$$resultAtint -->
<h3 class="fn" id="resultAt" translate="no"><a name="resultAt"></a><span class="type">T</span> QFutureWatcher::<span class="name">resultAt</span>(<span class="type">int</span> <i>index</i>) const<a class="plink" href="#resultAt" title="Direct link to this headline"></a></h3>
<p>Returns the result at <i translate="no">index</i> in the <a href="./qfuturewatcher.htm#future" translate="no">future</a>(). If the result is not immediately available, this function will block and wait for the result to become available.</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#result" translate="no">result</a>().</p>
<!-- @@@resultAt -->
<!-- $$$setFuture[overload1]$$$setFutureconstQFuture<T>& -->
<h3 class="fn" id="setFuture" translate="no"><a name="setFuture"></a><span class="type">void</span> QFutureWatcher::<span class="name">setFuture</span>(const <span class="type"><a href="./qfuture.htm" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>future</i>)<a class="plink" href="#setFuture" title="Direct link to this headline"></a></h3>
<p>Starts watching the given <i translate="no">future</i>.</p>
<p>If <i translate="no">future</i> has already started, the watcher will initially emit signals that bring their listeners up to date about the future's state. The following signals will, if applicable, be emitted in the given order: <a href="./qfuturewatcher.htm#started" translate="no">started</a>(), <a href="./qfuturewatcher.htm#progressRangeChanged" translate="no">progressRangeChanged</a>(), <a href="./qfuturewatcher.htm#progressValueChanged" translate="no">progressValueChanged</a>(), <a href="./qfuturewatcher.htm#progressTextChanged" translate="no">progressTextChanged</a>(), <a href="./qfuturewatcher.htm#resultsReadyAt" translate="no">resultsReadyAt</a>(), <a href="./qfuturewatcher.htm#resultReadyAt" translate="no">resultReadyAt</a>(), <a href="./qfuturewatcher.htm#paused" translate="no">paused</a>(), <a href="./qfuturewatcher.htm#canceled" translate="no">canceled</a>(), and <a href="./qfuturewatcher.htm#finished" translate="no">finished</a>(). Of these, <a href="./qfuturewatcher.htm#resultsReadyAt" translate="no">resultsReadyAt</a>() and <a href="./qfuturewatcher.htm#resultReadyAt" translate="no">resultReadyAt</a>() may be emitted several times to cover all available results. <a href="./qfuturewatcher.htm#progressValueChanged" translate="no">progressValueChanged</a>() and <a href="./qfuturewatcher.htm#progressTextChanged" translate="no">progressTextChanged</a>() will only be emitted once for the latest available progress value and text.</p>
<p>To avoid a race condition, it is important to call this function <i>after</i> doing the connections.</p>
<p><b>See also </b><a href="./qfuturewatcher.htm#future" translate="no">future</a>().</p>
<!-- @@@setFuture -->
<!-- $$$setPendingResultsLimit[overload1]$$$setPendingResultsLimitint -->
<h3 class="fn" id="setPendingResultsLimit" translate="no"><a name="setPendingResultsLimit"></a><span class="type">void</span> QFutureWatcher::<span class="name">setPendingResultsLimit</span>(<span class="type">int</span> <i>limit</i>)<a class="plink" href="#setPendingResultsLimit" title="Direct link to this headline"></a></h3>
<p>The setPendingResultsLimit() provides throttling control. When the number of pending <a href="./qfuturewatcher.htm#resultReadyAt" translate="no">resultReadyAt</a>() or <a href="./qfuturewatcher.htm#resultsReadyAt" translate="no">resultsReadyAt</a>() signals exceeds the <i translate="no">limit</i>, the computation represented by the future will be throttled automatically. The computation will resume once the number of pending signals drops below the <i translate="no">limit</i>.</p>
<!-- @@@setPendingResultsLimit -->
<!-- $$$waitForFinished[overload1]$$$waitForFinished -->
<h3 class="fn" id="waitForFinished" translate="no"><a name="waitForFinished"></a><span class="type">void</span> QFutureWatcher::<span class="name">waitForFinished</span>()<a class="plink" href="#waitForFinished" title="Direct link to this headline"></a></h3>
<p>Waits for the asynchronous computation to finish (including <a href="./qfuturewatcher.htm#cancel" translate="no">cancel</a>()ed computations).</p>
<!-- @@@waitForFinished -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>