<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Multithreading Technologies in Qt</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/threads-technologies.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a>Multithreading Technologies in Qt</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    
<link href="threads.html" rel="prev">
<link href="threads-synchronizing.html" rel="next">
<p class="naviNextPrevious headerNavi">
<a class="" href="./threads.htm">Thread Support in Qt</a>
<a class="" href="./threads-synchronizing.htm">Synchronizing Threads</a>
</p><p></p>

<div class="context">
<h1 class="title">Multithreading Technologies in Qt</h1>
<span class="subtitle"></span>
<!-- $$$threads-technologies.html-description -->
<div class="descr"> <a name="details"></a>
<p>Qt offers many classes and functions for working with threads. Below are four different approaches that Qt programmers can use to implement multithreaded applications.</p>
<a name="qthread-low-level-api-with-optional-event-loops"></a>
<h2 id="qthread-low-level-api-with-optional-event-loops">QThread: Low-Level API with Optional Event Loops<a class="plink" href="#qthread-low-level-api-with-optional-event-loops" title="Direct link to this headline"></a></h2>
<p><a href="./qthread.htm" translate="no">QThread</a> is the foundation of all thread control in Qt. Each <a href="./qthread.htm" translate="no">QThread</a> instance represents and controls one thread.</p>
<p><a href="./qthread.htm" translate="no">QThread</a> can either be instantiated directly or subclassed. Instantiating a <a href="./qthread.htm" translate="no">QThread</a> provides a parallel event loop, allowing <a href="./qobject.htm" translate="no">QObject</a> slots to be invoked in a secondary thread. Subclassing a <a href="./qthread.htm" translate="no">QThread</a> allows the application to initialize the new thread before starting its event loop, or to run parallel code without an event loop.</p>
<p>See the <a href="./qthread.htm" translate="no">QThread class reference</a> and the <a href="./examples-threadandconcurrent.htm" translate="no">threading examples</a> for demonstrations on how to use <a href="./qthread.htm" translate="no">QThread</a>.</p>
<a name="qthreadpool-and-qrunnable-reusing-threads"></a>
<h2 id="qthreadpool-and-qrunnable-reusing-threads">QThreadPool and QRunnable: Reusing Threads<a class="plink" href="#qthreadpool-and-qrunnable-reusing-threads" title="Direct link to this headline"></a></h2>
<p>Creating and destroying threads frequently can be expensive. To reduce this overhead, existing threads can be reused for new tasks. <a href="./qthreadpool.htm" translate="no">QThreadPool</a> is a collection of reuseable QThreads.</p>
<p>To run code in one of a <a href="./qthreadpool.htm" translate="no">QThreadPool</a>'s threads, reimplement <a href="./qrunnable.htm#run" translate="no">QRunnable::run</a>() and instantiate the subclassed <a href="./qrunnable.htm" translate="no">QRunnable</a>. Use <a href="./qthreadpool.htm#start" translate="no">QThreadPool::start</a>() to put the <a href="./qrunnable.htm" translate="no">QRunnable</a> in the <a href="./qthreadpool.htm" translate="no">QThreadPool</a>'s run queue. When a thread becomes available, the code within <a href="./qrunnable.htm#run" translate="no">QRunnable::run</a>() will execute in that thread.</p>
<p>Each Qt application has a global thread pool, which is accessible through <a href="./qthreadpool.htm#globalInstance" translate="no">QThreadPool::globalInstance</a>(). This global thread pool automatically maintains an optimal number of threads based on the number of cores in the CPU. However, a separate <a href="./qthreadpool.htm" translate="no">QThreadPool</a> can be created and managed explicitly.</p>
<a name="qt-concurrent-using-a-high-level-api"></a>
<h2 id="qt-concurrent-using-a-high-level-api">Qt Concurrent: Using a High-level API<a class="plink" href="#qt-concurrent-using-a-high-level-api" title="Direct link to this headline"></a></h2>
<p>The <a href="./qtconcurrent-index.htm" translate="no">Qt Concurrent</a> module provides high-level functions that deal with some common parallel computation patterns: map, filter, and reduce. Unlike using <a href="./qthread.htm" translate="no">QThread</a> and <a href="./qrunnable.htm" translate="no">QRunnable</a>, these functions never require the use of <a href="./threads-synchronizing.htm#low-level-synchronization-primitives" translate="no">low-level threading primitives</a> such as mutexes or semaphores. Instead, they return a <a href="./qfuture.htm" translate="no">QFuture</a> object which can be used to retrieve the functions' results when they are ready. <a href="./qfuture.htm" translate="no">QFuture</a> can also be used to query computation progress and to pause/resume/cancel the computation. For convenience, <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> enables interactions with <a href="./qfuture.htm" translate="no">QFuture</a>s via signals and slots.</p>
<p><a href="./qtconcurrent-index.htm" translate="no">Qt Concurrent</a>'s map, filter and reduce algorithms automatically distribute computation across all available processor cores, so applications written today will continue to scale when deployed later on a system with more cores.</p>
<p>This module also provides the <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() function, which can run any function in another thread. However, <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() only supports a subset of features available to the map, filter and reduce functions. The <a href="./qfuture.htm" translate="no">QFuture</a> can be used to retrieve the function's return value and to check if the thread is running. However, a call to <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() uses one thread only, cannot be paused/resumed/canceled, and cannot be queried for progress.</p>
<p>See the <a href="./qtconcurrent-index.htm" translate="no">Qt Concurrent</a> module documentation for details on the individual functions.</p>
<a name="workerscript-threading-in-qml"></a>
<h2 id="workerscript-threading-in-qml">WorkerScript: Threading in QML<a class="plink" href="#workerscript-threading-in-qml" title="Direct link to this headline"></a></h2>
<p>The <a href="./qml-qtqml-workerscript-workerscript.htm" translate="no">WorkerScript</a> QML type lets JavaScript code run in parallel with the GUI thread.</p>
<p>Each <a href="./qml-qtqml-workerscript-workerscript.htm" translate="no">WorkerScript</a> instance can have one <code translate="no">.js</code> script attached to it. When <a href="./qml-qtqml-workerscript-workerscript.htm#sendMessage-method" translate="no">WorkerScript.sendMessage</a>() is called, the script will run in a separate thread (and a separate <a href="./qqmlcontext.htm" translate="no">QML context</a>). When the script finishes running, it can send a reply back to the GUI thread which will invoke the <a href="./qml-qtqml-workerscript-workerscript.htm#message-signal" translate="no">WorkerScript.onMessage</a>() signal handler.</p>
<p>Using a <a href="./qml-qtqml-workerscript-workerscript.htm" translate="no">WorkerScript</a> is similar to using a worker <a href="./qobject.htm" translate="no">QObject</a> that has been moved to another thread. Data is transferred between threads via signals.</p>
<p>See the <a href="./qml-qtqml-workerscript-workerscript.htm" translate="no">WorkerScript</a> documentation for details on how to implement the script, and for a list of data types that can be passed between threads.</p>
<a name="choosing-an-appropriate-approach"></a>
<h2 id="choosing-an-appropriate-approach">Choosing an Appropriate Approach<a class="plink" href="#choosing-an-appropriate-approach" title="Direct link to this headline"></a></h2>
<p>As demonstrated above, Qt provides different solutions for developing threaded applications. The right solution for a given application depends on the purpose of the new thread and the thread's lifetime. Below is a comparison of Qt's threading technologies, followed by recommended solutions for some example use cases.</p>
<a name="comparison-of-solutions"></a>
<h3 id="comparison-of-solutions">Comparison of Solutions<a class="plink" href="#comparison-of-solutions" title="Direct link to this headline"></a></h3>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Feature</th><th><a href="./qthread.htm" translate="no">QThread</a></th><th><a href="./qrunnable.htm" translate="no">QRunnable</a> and <a href="./qthreadpool.htm" translate="no">QThreadPool</a></th><th><a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>()</th><th>Qt Concurrent (Map, Filter, Reduce)</th><th><a href="./qml-qtqml-workerscript-workerscript.htm" translate="no">WorkerScript</a></th></tr></thead>
<tbody><tr class="odd" valign="top"><td>Language</td><td>C++</td><td>C++</td><td>C++</td><td>C++</td><td>QML</td></tr>
<tr class="even" valign="top"><td>Thread priority can be specified</td><td>Yes</td><td>Yes</td><td></td><td></td><td></td></tr>
<tr class="odd" valign="top"><td>Thread can run an event loop</td><td>Yes</td><td></td><td></td><td></td><td></td></tr>
<tr class="even" valign="top"><td>Thread can receive data updates through signals</td><td>Yes (received by a worker <a href="./qobject.htm" translate="no">QObject</a>)</td><td></td><td></td><td></td><td>Yes (received by <a href="./qml-qtqml-workerscript-workerscript.htm" translate="no">WorkerScript</a>)</td></tr>
<tr class="odd" valign="top"><td>Thread can be controlled using signals</td><td>Yes (received by <a href="./qthread.htm" translate="no">QThread</a>)</td><td></td><td></td><td>Yes (received by <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a>)</td><td></td></tr>
<tr class="even" valign="top"><td>Thread can be monitored through a <a href="./qfuture.htm" translate="no">QFuture</a></td><td></td><td></td><td>Partially</td><td>Yes</td><td></td></tr>
<tr class="odd" valign="top"><td>Built-in ability to pause/resume/cancel</td><td></td><td></td><td></td><td>Yes</td><td></td></tr>
</tbody></table></div>
<a name="example-use-cases"></a>
<h3 id="example-use-cases">Example Use Cases<a class="plink" href="#example-use-cases" title="Direct link to this headline"></a></h3>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Lifetime of thread</th><th>Operation</th><th>Solution</th></tr></thead>
<tbody><tr class="odd" valign="top"><td>One call</td><td>Run a new linear function within another thread, optionally with progress updates during the run.</td><td>Qt provides different solutions:<ul>
<li>Place the function in a reimplementation of <a href="./qthread.htm#run" translate="no">QThread::run</a>() and start the <a href="./qthread.htm" translate="no">QThread</a>. Emit signals to update progress. OR</li>
<li>Place the function in a reimplementation of <a href="./qrunnable.htm#run" translate="no">QRunnable::run</a>() and add the <a href="./qrunnable.htm" translate="no">QRunnable</a> to a <a href="./qthreadpool.htm" translate="no">QThreadPool</a>. Write to a <a href="./threads-synchronizing.htm" translate="no">thread-safe variable</a> to update progress. OR</li>
<li>Run the function using <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>(). Write to a <a href="./threads-synchronizing.htm" translate="no">thread-safe variable</a> to update progress.</li>
</ul>
</td></tr>
<tr class="even" valign="top"><td>One call</td><td>Run an existing function within another thread and get its return value.</td><td>Run the function using <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>(). Have a <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> emit the <a href="./qfuturewatcher.htm#finished" translate="no">finished()</a> signal when the function has returned, and call <a href="./qfuturewatcher.htm#result" translate="no">QFutureWatcher::result</a>() to get the function's return value.</td></tr>
<tr class="odd" valign="top"><td>One call</td><td>Perform an operation on all items of a container, using all available cores. For example, producing thumbnails from a list of images.</td><td>Use Qt Concurrent's <a href="./qtconcurrent.htm#filter" translate="no">QtConcurrent::filter</a>() function to select container elements, and the <a href="./qtconcurrent.htm#map" translate="no">QtConcurrent::map</a>() function to apply an operation to each element. To fold the output into a single result, use <a href="./qtconcurrent.htm#filteredReduced" translate="no">QtConcurrent::filteredReduced</a>() and <a href="./qtconcurrent.htm#mappedReduced" translate="no">QtConcurrent::mappedReduced</a>() instead.</td></tr>
<tr class="even" valign="top"><td>One call/Permanent</td><td>Perfrom a long computation in a pure QML application, and update the GUI when the results are ready.</td><td>Place the computation code in a <code translate="no">.js</code> script and attach it to a <a href="./qml-qtqml-workerscript-workerscript.htm" translate="no">WorkerScript</a> instance. Call <a href="./qml-qtqml-workerscript-workerscript.htm#sendMessage-method" translate="no">WorkerScript.sendMessage</a>() to start the computation in a new thread. Let the script call sendMessage() too, to pass the result back to the GUI thread. Handle the result in <code translate="no">onMessage</code> and update the GUI there.</td></tr>
<tr class="odd" valign="top"><td>Permanent</td><td>Have an object living in another thread that can perform different tasks upon request and/or can receive new data to work with.</td><td>Subclass a <a href="./qobject.htm" translate="no">QObject</a> to create a worker. Instantiate this worker object and a <a href="./qthread.htm" translate="no">QThread</a>. Move the worker to the new thread. Send commands or data to the worker object over queued signal-slot connections.</td></tr>
<tr class="even" valign="top"><td>Permanent</td><td>Repeatedly perform an expensive operation in another thread, where the thread does not need to receive any signals or events.</td><td>Write the infinite loop directly within a reimplementation of <a href="./qthread.htm#run" translate="no">QThread::run</a>(). Start the thread without an event loop. Let the thread emit signals to send data back to the GUI thread.</td></tr>
</tbody></table></div>
</div>
<!-- @@@threads-technologies.html -->
<p class="naviNextPrevious footerNavi">
<a class="prevPage" href="./threads.htm">Thread Support in Qt</a>
<a class="nextPage" href="./threads-synchronizing.htm">Synchronizing Threads</a>
</p>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>