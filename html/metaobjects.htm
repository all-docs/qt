<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>The Meta-Object System | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/metaobjects.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a>The Meta-Object System</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">The Meta-Object System</h1>
<span class="subtitle"></span>
<!-- $$$metaobjects.html-description -->
<div class="descr"> <a name="details"></a>
<p>Qt's meta-object system provides the signals and slots mechanism for inter-object communication, run-time type information, and the dynamic property system.</p>
<p>The meta-object system is based on three things:</p>
<ol class="1" type="1"><li>The <a href="./qobject.htm" translate="no">QObject</a> class provides a base class for objects that can take advantage of the meta-object system.</li>
<li>The <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> macro inside the private section of the class declaration is used to enable meta-object features, such as dynamic properties, signals, and slots.</li>
<li>The <a href="./moc.htm" translate="no">Meta-Object Compiler</a> (<code translate="no">moc</code>) supplies each <a href="./qobject.htm" translate="no">QObject</a> subclass with the necessary code to implement meta-object features.</li>
</ol>
<p>The <code translate="no">moc</code> tool reads a C++ source file. If it finds one or more class declarations that contain the <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> macro, it produces another C++ source file which contains the meta-object code for each of those classes. This generated source file is either <code translate="no">#include</code>'d into the class's source file or, more usually, compiled and linked with the class's implementation.</p>
<p>In addition to providing the <a href="./signalsandslots.htm" translate="no">signals and slots</a> mechanism for communication between objects (the main reason for introducing the system), the meta-object code provides the following additional features:</p>
<ul>
<li><a href="./qobject.htm#metaObject" translate="no">QObject::metaObject</a>() returns the associated <a href="./qmetaobject.htm" translate="no">meta-object</a> for the class.</li>
<li><a href="./qmetaobject.htm#className" translate="no">QMetaObject::className</a>() returns the class name as a string at run-time, without requiring native run-time type information (RTTI) support through the C++ compiler.</li>
<li><a href="./qobject.htm#inherits" translate="no">QObject::inherits</a>() function returns whether an object is an instance of a class that inherits a specified class within the <a href="./qobject.htm" translate="no">QObject</a> inheritance tree.</li>
<li><a href="./qobject.htm#tr" translate="no">QObject::tr</a>() and QObject::trUtf8() translate strings for <a href="./internationalization.htm" translate="no">internationalization</a>.</li>
<li><a href="./qobject.htm#setProperty" translate="no">QObject::setProperty</a>() and <a href="./qobject.htm#property" translate="no">QObject::property</a>() dynamically set and get properties by name.</li>
<li><a href="./qmetaobject.htm#newInstance" translate="no">QMetaObject::newInstance</a>() constructs a new instance of the class.</li>
</ul>
<a name="qobjectcast"></a><p>It is also possible to perform dynamic casts using <a href="./qobject.htm#qobject_cast" translate="no">qobject_cast</a>() on <a href="./qobject.htm" translate="no">QObject</a> classes. The <a href="./qobject.htm#qobject_cast" translate="no">qobject_cast</a>() function behaves similarly to the standard C++ <code translate="no">dynamic_cast()</code>, with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries. It attempts to cast its argument to the pointer type specified in angle-brackets, returning a non-zero pointer if the object is of the correct type (determined at run-time), or <code translate="no">nullptr</code> if the object's type is incompatible.</p>
<p>For example, let's assume <code translate="no">MyWidget</code> inherits from <a href="./qwidget.htm" translate="no">QWidget</a> and is declared with the <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> macro:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>obj <span class="operator">=</span> <span class="keyword">new</span> MyWidget;</pre></div>
<p>The <code translate="no">obj</code> variable, of type <code translate="no">QObject *</code>, actually refers to a <code translate="no">MyWidget</code> object, so we can cast it appropriately:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>widget <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj);</pre></div>
<p>The cast from <a href="./qobject.htm" translate="no">QObject</a> to <a href="./qwidget.htm" translate="no">QWidget</a> is successful, because the object is actually a <code translate="no">MyWidget</code>, which is a subclass of <a href="./qwidget.htm" translate="no">QWidget</a>. Since we know that <code translate="no">obj</code> is a <code translate="no">MyWidget</code>, we can also cast it to <code translate="no">MyWidget *</code>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    MyWidget <span class="operator">*</span>myWidget <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>MyWidget <span class="operator">*</span><span class="operator">&gt;</span>(obj);</pre></div>
<p>The cast to <code translate="no">MyWidget</code> is successful because <a href="./qobject.htm#qobject_cast" translate="no">qobject_cast</a>() makes no distinction between built-in Qt types and custom types.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qlabel.htm" translate="no">QLabel</a></span> <span class="operator">*</span>label <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qlabel.htm" translate="no">QLabel</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj);
    <span class="comment">// label is 0</span></pre></div>
<p>The cast to <a href="./qlabel.htm" translate="no">QLabel</a>, on the other hand, fails. The pointer is then set to 0. This makes it possible to handle objects of different types differently at run-time, based on the type:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="keyword">if</span> (<span class="type"><a href="./qlabel.htm" translate="no">QLabel</a></span> <span class="operator">*</span>label <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qlabel.htm" translate="no">QLabel</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj)) {
        label<span class="operator">-</span><span class="operator">&gt;</span>setText(tr(<span class="string">"Ping"</span>));
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type"><a href="./qpushbutton.htm" translate="no">QPushButton</a></span> <span class="operator">*</span>button <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qpushbutton.htm" translate="no">QPushButton</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(obj)) {
        button<span class="operator">-</span><span class="operator">&gt;</span>setText(tr(<span class="string">"Pong!"</span>));
    }</pre></div>
<p>While it is possible to use <a href="./qobject.htm" translate="no">QObject</a> as a base class without the <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> macro and without meta-object code, neither signals and slots nor the other features described here will be available if the <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> macro is not used. From the meta-object system's point of view, a <a href="./qobject.htm" translate="no">QObject</a> subclass without meta code is equivalent to its closest ancestor with meta-object code. This means for example, that <a href="./qmetaobject.htm#className" translate="no">QMetaObject::className</a>() will not return the actual name of your class, but the class name of this ancestor.</p>
<p>Therefore, we strongly recommend that all subclasses of <a href="./qobject.htm" translate="no">QObject</a> use the <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> macro regardless of whether or not they actually use signals, slots, and properties.</p>
</div>
<p><b>See also </b><a href="./qmetaobject.htm" translate="no">QMetaObject</a>, <a href="./properties.htm" translate="no">Qt's Property System</a>, and <a href="./signalsandslots.htm" translate="no">Signals and Slots</a>.</p>
<!-- @@@metaobjects.html -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>