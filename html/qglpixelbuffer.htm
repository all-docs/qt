<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QGLPixelBuffer | Qt OpenGL</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtopengl-index.htm" translate="no">Qt OpenGL</a></li>
                            <li><a href="./qtopengl-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QGLPixelBuffer</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QGLPixelBuffer Class</h1>
<!-- $$$QGLPixelBuffer-brief -->
<p>The QGLPixelBuffer class encapsulates an OpenGL pbuffer. <a href="#details">More...</a></p>
<!-- @@@QGLPixelBuffer -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QGLPixelBuffer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += opengl</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.1</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qpaintdevice.htm" translate="no">QPaintDevice</a></td></tr></tbody></table></div><p><b>This class is obsolete.</b> It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>This class was introduced in Qt 4.1.</p>
<ul>
<li><a href="./qglpixelbuffer-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#QGLPixelBuffer-1" translate="no">QGLPixelBuffer</a></b>(int <i>width</i>, int <i>height</i>, const QGLFormat &amp;<i>format</i> = QGLFormat::defaultFormat(), QGLWidget *<i>shareWidget</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#QGLPixelBuffer" translate="no">QGLPixelBuffer</a></b>(const QSize &amp;<i>size</i>, const QGLFormat &amp;<i>format</i> = QGLFormat::defaultFormat(), QGLWidget *<i>shareWidget</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#dtor.QGLPixelBuffer" translate="no">~QGLPixelBuffer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#bindTexture" translate="no">bindTexture</a></b>(const QImage &amp;<i>image</i>, GLenum <i>target</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#bindTexture-1" translate="no">bindTexture</a></b>(const QPixmap &amp;<i>pixmap</i>, GLenum <i>target</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#bindTexture-2" translate="no">bindTexture</a></b>(const QString &amp;<i>fileName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#bindToDynamicTexture" translate="no">bindToDynamicTexture</a></b>(GLuint <i>texture_id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLContext *</td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#context" translate="no">context</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#deleteTexture" translate="no">deleteTexture</a></b>(GLuint <i>texture_id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#doneCurrent" translate="no">doneCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#drawTexture" translate="no">drawTexture</a></b>(const QRectF &amp;<i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#drawTexture-1" translate="no">drawTexture</a></b>(const QPointF &amp;<i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFormat </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#generateDynamicTexture" translate="no">generateDynamicTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::HANDLE </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#handle" translate="no">handle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#makeCurrent" translate="no">makeCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#releaseFromDynamicTexture" translate="no">releaseFromDynamicTexture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#toImage" translate="no">toImage</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#updateDynamicTexture" translate="no">updateDynamicTexture</a></b>(GLuint <i>texture_id</i>) const</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual QPaintEngine *</td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#paintEngine" translate="no">paintEngine</a></b>() const override</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#hasOpenGLPbuffers" translate="no">hasOpenGLPbuffers</a></b>()</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="./qglpixelbuffer.htm#metric" translate="no">metric</a></b>(QPaintDevice::PaintDeviceMetric <i>metric</i>) const override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QGLPixelBuffer-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>Rendering into a pbuffer is normally done using full hardware acceleration. This can be significantly faster than rendering into a <a href="./qpixmap.htm" translate="no">QPixmap</a>.</p>
<p>There are three approaches to using this class:</p>
<ol class="1" type="1"><li><b>We can draw into the pbuffer and convert it to a <a href="./qimage.htm" translate="no">QImage</a> using <a href="./qglpixelbuffer.htm#toImage" translate="no">toImage</a>().</b> This is normally much faster than calling <a href="./qglwidget.htm#renderPixmap" translate="no">QGLWidget::renderPixmap</a>().</li>
<li><b>We can draw into the pbuffer and copy the contents into an OpenGL texture using <a href="./qglpixelbuffer.htm#updateDynamicTexture" translate="no">updateDynamicTexture</a>().</b> This allows us to create dynamic textures and works on all systems with pbuffer support.</li>
<li><b>On systems that support it, we can bind the pbuffer to an OpenGL texture.</b> The texture is then updated automatically when the pbuffer contents change, eliminating the need for additional copy operations. This is supported only on Windows and macOS systems that provide the <code translate="no">render_texture</code> extension. Note that under Windows, a multi-sampled pbuffer can't be used in conjunction with the <code translate="no">render_texture</code> extension. If a multi-sampled pbuffer is requested under Windows, the <code translate="no">render_texture</code> extension is turned off for that pbuffer.</li>
</ol>
<div class="admonition note">
<p><b>Note: </b>This class has been deprecated, use <a href="./qopenglframebufferobject.htm" translate="no">QOpenGLFramebufferObject</a> for offscreen rendering.</p>
</div>
<a name="threading"></a>
<h3 id="threading">Threading<a class="plink" href="#threading" title="Direct link to this headline"></a></h3>
<p>As of Qt 4.8, it's possible to render into a QGLPixelBuffer using a <a href="./qpainter.htm" translate="no">QPainter</a> in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.</p>
<p>Pbuffers are provided by the OpenGL <code translate="no">pbuffer</code> extension; call hasOpenGLPbuffer() to find out if the system provides pbuffers.</p>
</div>
<!-- @@@QGLPixelBuffer -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QGLPixelBuffer$$$QGLPixelBufferintintconstQGLFormat&QGLWidget* -->
<h3 class="fn" id="QGLPixelBuffer-1" translate="no"><a name="QGLPixelBuffer-1"></a>QGLPixelBuffer::<span class="name">QGLPixelBuffer</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, const <span class="type"><a href="./qglformat.htm" translate="no">QGLFormat</a></span> &amp;<i>format</i> = QGLFormat::defaultFormat(), <span class="type"><a href="./qglwidget.htm" translate="no">QGLWidget</a></span> *<i>shareWidget</i> = nullptr)<a class="plink" href="#QGLPixelBuffer-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Constructs an OpenGL pbuffer with the <i translate="no">width</i> and <i translate="no">height</i>. If no <i translate="no">format</i> is specified, the <a href="./qglformat.htm#defaultFormat" translate="no">default format</a> is used. If the <i translate="no">shareWidget</i> parameter points to a valid QGLWidget, the pbuffer will share its context with <i translate="no">shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <code translate="no">size</code> must be powers of two (e.g., 512 x 128).</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#size" translate="no">size</a>() and <a href="./qglpixelbuffer.htm#format" translate="no">format</a>().</p>
<!-- @@@QGLPixelBuffer -->
<!-- $$$QGLPixelBuffer[overload1]$$$QGLPixelBufferconstQSize&constQGLFormat&QGLWidget* -->
<h3 class="fn" id="QGLPixelBuffer" translate="no"><a name="QGLPixelBuffer"></a>QGLPixelBuffer::<span class="name">QGLPixelBuffer</span>(const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>, const <span class="type"><a href="./qglformat.htm" translate="no">QGLFormat</a></span> &amp;<i>format</i> = QGLFormat::defaultFormat(), <span class="type"><a href="./qglwidget.htm" translate="no">QGLWidget</a></span> *<i>shareWidget</i> = nullptr)<a class="plink" href="#QGLPixelBuffer" title="Direct link to this headline"></a></h3>
<p>Constructs an OpenGL pbuffer of the given <i translate="no">size</i>. If no <i translate="no">format</i> is specified, the <a href="./qglformat.htm#defaultFormat" translate="no">default format</a> is used. If the <i translate="no">shareWidget</i> parameter points to a valid QGLWidget, the pbuffer will share its context with <i translate="no">shareWidget</i>.</p>
<p>If you intend to bind this pbuffer as a dynamic texture, the width and height components of <code translate="no">size</code> must be powers of two (e.g., 512 x 128).</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#size" translate="no">size</a>() and <a href="./qglpixelbuffer.htm#format" translate="no">format</a>().</p>
<!-- @@@QGLPixelBuffer -->
<!-- $$$~QGLPixelBuffer[overload1]$$$~QGLPixelBuffer -->
<h3 class="fn" id="dtor.QGLPixelBuffer" translate="no"><a name="dtor.QGLPixelBuffer"></a><code translate="no">[virtual] </code>QGLPixelBuffer::<span class="name">~QGLPixelBuffer</span>()<a class="plink" href="#dtor.QGLPixelBuffer" title="Direct link to this headline"></a></h3>
<p>Destroys the pbuffer and frees any allocated resources.</p>
<!-- @@@~QGLPixelBuffer -->
<!-- $$$bindTexture[overload1]$$$bindTextureconstQImage&GLenum -->
<h3 class="fn" id="bindTexture" translate="no"><a name="bindTexture"></a><span class="type">GLuint</span> QGLPixelBuffer::<span class="name">bindTexture</span>(const <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D)<a class="plink" href="#bindTexture" title="Direct link to this headline"></a></h3>
<p>Generates and binds a 2D GL texture to the current context, based on <i translate="no">image</i>. The generated texture id is returned and can be used in later glBindTexture() calls.</p>
<p>The <i translate="no">target</i> parameter specifies the texture target.</p>
<p>Equivalent to calling <a href="./qglcontext.htm#bindTexture" translate="no">QGLContext::bindTexture</a>().</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#deleteTexture" translate="no">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQPixmap&GLenum -->
<h3 class="fn" id="bindTexture-1" translate="no"><a name="bindTexture-1"></a><span class="type">GLuint</span> QGLPixelBuffer::<span class="name">bindTexture</span>(const <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> &amp;<i>pixmap</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D)<a class="plink" href="#bindTexture-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture based on <i translate="no">pixmap</i>.</p>
<p>Equivalent to calling <a href="./qglcontext.htm#bindTexture" translate="no">QGLContext::bindTexture</a>().</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#deleteTexture" translate="no">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQString& -->
<h3 class="fn" id="bindTexture-2" translate="no"><a name="bindTexture-2"></a><span class="type">GLuint</span> QGLPixelBuffer::<span class="name">bindTexture</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>fileName</i>)<a class="plink" href="#bindTexture-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Reads the DirectDrawSurface (DDS) compressed file <i translate="no">fileName</i> and generates a 2D GL texture from it.</p>
<p>Equivalent to calling <a href="./qglcontext.htm#bindTexture" translate="no">QGLContext::bindTexture</a>().</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#deleteTexture" translate="no">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindToDynamicTexture[overload1]$$$bindToDynamicTextureGLuint -->
<h3 class="fn" id="bindToDynamicTexture" translate="no"><a name="bindToDynamicTexture"></a><span class="type">bool</span> QGLPixelBuffer::<span class="name">bindToDynamicTexture</span>(<span class="type">GLuint</span> <i>texture_id</i>)<a class="plink" href="#bindToDynamicTexture" title="Direct link to this headline"></a></h3>
<p>Binds the texture specified by <i translate="no">texture_id</i> to this pbuffer. Returns <code translate="no">true</code> on success; otherwise returns <code translate="no">false</code>.</p>
<p>The texture must be of the same size and format as the pbuffer.</p>
<p>To unbind the texture, call <a href="./qglpixelbuffer.htm#releaseFromDynamicTexture" translate="no">releaseFromDynamicTexture</a>(). While the texture is bound, it is updated automatically when the pbuffer contents change, eliminating the need for additional copy operations.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qglpixelbuffer.htm#QGLPixelBuffer" translate="no">QGLPixelBuffer</a></span> pbuffer(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
pbuffer<span class="operator">.</span>makeCurrent();
GLuint dynamicTexture <span class="operator">=</span> pbuffer<span class="operator">.</span>generateDynamicTexture();
pbuffer<span class="operator">.</span>bindToDynamicTexture(dynamicTexture);
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
pbuffer<span class="operator">.</span>releaseFromDynamicTexture();</pre></div>
<div class="admonition warning">
<p><b>Warning: </b>This function uses the <code translate="no">render_texture</code> extension, which is currently not supported under X11. An alternative that works on all systems (including X11) is to manually copy the pbuffer contents to a texture using <a href="./qglpixelbuffer.htm#updateDynamicTexture" translate="no">updateDynamicTexture</a>().</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>For the bindToDynamicTexture() call to succeed on the macOS, the pbuffer needs a shared context, i.e. the <a class="obsolete" href="./qglpixelbuffer.htm" translate="no">QGLPixelBuffer</a> must be created with a share widget.</p>
</div>
<p><b>See also </b><a href="./qglpixelbuffer.htm#generateDynamicTexture" translate="no">generateDynamicTexture</a>() and <a href="./qglpixelbuffer.htm#releaseFromDynamicTexture" translate="no">releaseFromDynamicTexture</a>().</p>
<!-- @@@bindToDynamicTexture -->
<!-- $$$context[overload1]$$$context -->
<h3 class="fn" id="context" translate="no"><a name="context"></a><span class="type"><a href="./qglcontext.htm" translate="no">QGLContext</a></span> *QGLPixelBuffer::<span class="name">context</span>() const<a class="plink" href="#context" title="Direct link to this headline"></a></h3>
<p>Returns the context of this pixelbuffer.</p>
<!-- @@@context -->
<!-- $$$deleteTexture[overload1]$$$deleteTextureGLuint -->
<h3 class="fn" id="deleteTexture" translate="no"><a name="deleteTexture"></a><span class="type">void</span> QGLPixelBuffer::<span class="name">deleteTexture</span>(<span class="type">GLuint</span> <i>texture_id</i>)<a class="plink" href="#deleteTexture" title="Direct link to this headline"></a></h3>
<p>Removes the texture identified by <i translate="no">texture_id</i> from the texture cache.</p>
<p>Equivalent to calling <a href="./qglcontext.htm#deleteTexture" translate="no">QGLContext::deleteTexture</a>().</p>
<!-- @@@deleteTexture -->
<!-- $$$doneCurrent[overload1]$$$doneCurrent -->
<h3 class="fn" id="doneCurrent" translate="no"><a name="doneCurrent"></a><span class="type">bool</span> QGLPixelBuffer::<span class="name">doneCurrent</span>()<a class="plink" href="#doneCurrent" title="Direct link to this headline"></a></h3>
<p>Makes no context the current OpenGL context. Returns <code translate="no">true</code> on success; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@doneCurrent -->
<!-- $$$drawTexture[overload1]$$$drawTextureconstQRectF&GLuintGLenum -->
<h3 class="fn" id="drawTexture" translate="no"><a name="drawTexture"></a><span class="type">void</span> QGLPixelBuffer::<span class="name">drawTexture</span>(const <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> &amp;<i>target</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)<a class="plink" href="#drawTexture" title="Direct link to this headline"></a></h3>
<p>Draws the given texture, <i translate="no">textureId</i>, to the given target rectangle, <i translate="no">target</i>, in OpenGL model space. The <i translate="no">textureTarget</i> should be a 2D texture target.</p>
<p>Equivalent to the corresponding <a href="./qglcontext.htm#drawTexture" translate="no">QGLContext::drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$drawTexture$$$drawTextureconstQPointF&GLuintGLenum -->
<h3 class="fn" id="drawTexture-1" translate="no"><a name="drawTexture-1"></a><span class="type">void</span> QGLPixelBuffer::<span class="name">drawTexture</span>(const <span class="type"><a href="./qpointf.htm" translate="no">QPointF</a></span> &amp;<i>point</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)<a class="plink" href="#drawTexture-1" title="Direct link to this headline"></a></h3>
<p>Draws the given texture, <i translate="no">textureId</i>, at the given <i translate="no">point</i> in OpenGL model space. The textureTarget parameter should be a 2D texture target.</p>
<p>Equivalent to the corresponding <a href="./qglcontext.htm#drawTexture" translate="no">QGLContext::drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format" translate="no"><a name="format"></a><span class="type"><a href="./qglformat.htm" translate="no">QGLFormat</a></span> QGLPixelBuffer::<span class="name">format</span>() const<a class="plink" href="#format" title="Direct link to this headline"></a></h3>
<p>Returns the format of the pbuffer. The format may be different from the one that was requested.</p>
<!-- @@@format -->
<!-- $$$generateDynamicTexture[overload1]$$$generateDynamicTexture -->
<h3 class="fn" id="generateDynamicTexture" translate="no"><a name="generateDynamicTexture"></a><span class="type">GLuint</span> QGLPixelBuffer::<span class="name">generateDynamicTexture</span>() const<a class="plink" href="#generateDynamicTexture" title="Direct link to this headline"></a></h3>
<p>Generates and binds a 2D GL texture that is the same size as the pbuffer, and returns the texture's ID. This can be used in conjunction with <a href="./qglpixelbuffer.htm#bindToDynamicTexture" translate="no">bindToDynamicTexture</a>() and <a href="./qglpixelbuffer.htm#updateDynamicTexture" translate="no">updateDynamicTexture</a>().</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#size" translate="no">size</a>().</p>
<!-- @@@generateDynamicTexture -->
<!-- $$$handle[overload1]$$$handle -->
<h3 class="fn" id="handle" translate="no"><a name="handle"></a><span class="type"><a href="./qt.htm#HANDLE-typedef" translate="no">Qt::HANDLE</a></span> QGLPixelBuffer::<span class="name">handle</span>() const<a class="plink" href="#handle" title="Direct link to this headline"></a></h3>
<p>Returns the native pbuffer handle.</p>
<!-- @@@handle -->
<!-- $$$hasOpenGLPbuffers[overload1]$$$hasOpenGLPbuffers -->
<h3 class="fn" id="hasOpenGLPbuffers" translate="no"><a name="hasOpenGLPbuffers"></a><code translate="no">[static] </code><span class="type">bool</span> QGLPixelBuffer::<span class="name">hasOpenGLPbuffers</span>()<a class="plink" href="#hasOpenGLPbuffers" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the OpenGL <code translate="no">pbuffer</code> extension is present on this system; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@hasOpenGLPbuffers -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QGLPixelBuffer::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this pbuffer is valid; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isValid -->
<!-- $$$makeCurrent[overload1]$$$makeCurrent -->
<h3 class="fn" id="makeCurrent" translate="no"><a name="makeCurrent"></a><span class="type">bool</span> QGLPixelBuffer::<span class="name">makeCurrent</span>()<a class="plink" href="#makeCurrent" title="Direct link to this headline"></a></h3>
<p>Makes this pbuffer the current OpenGL rendering context. Returns true on success; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qglcontext.htm#makeCurrent" translate="no">QGLContext::makeCurrent</a>() and <a href="./qglpixelbuffer.htm#doneCurrent" translate="no">doneCurrent</a>().</p>
<!-- @@@makeCurrent -->
<!-- $$$metric[overload1]$$$metricQPaintDevice::PaintDeviceMetric -->
<h3 class="fn" id="metric" translate="no"><a name="metric"></a><code translate="no">[override virtual protected] </code><span class="type">int</span> QGLPixelBuffer::<span class="name">metric</span>(<span class="type"><a href="./qpaintdevice.htm#PaintDeviceMetric-enum" translate="no">QPaintDevice::PaintDeviceMetric</a></span> <i>metric</i>) const<a class="plink" href="#metric" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qpaintdevice.htm#metric" translate="no">QPaintDevice::metric</a>(QPaintDevice::PaintDeviceMetric metric) const.</p>
<!-- @@@metric -->
<!-- $$$paintEngine[overload1]$$$paintEngine -->
<h3 class="fn" id="paintEngine" translate="no"><a name="paintEngine"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qpaintengine.htm" translate="no">QPaintEngine</a></span> *QGLPixelBuffer::<span class="name">paintEngine</span>() const<a class="plink" href="#paintEngine" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qpaintdevice.htm#paintEngine" translate="no">QPaintDevice::paintEngine</a>() const.</p>
<!-- @@@paintEngine -->
<!-- $$$releaseFromDynamicTexture[overload1]$$$releaseFromDynamicTexture -->
<h3 class="fn" id="releaseFromDynamicTexture" translate="no"><a name="releaseFromDynamicTexture"></a><span class="type">void</span> QGLPixelBuffer::<span class="name">releaseFromDynamicTexture</span>()<a class="plink" href="#releaseFromDynamicTexture" title="Direct link to this headline"></a></h3>
<p>Releases the pbuffer from any previously bound texture.</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#bindToDynamicTexture" translate="no">bindToDynamicTexture</a>().</p>
<!-- @@@releaseFromDynamicTexture -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> QGLPixelBuffer::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the size of the pbuffer.</p>
<!-- @@@size -->
<!-- $$$toImage[overload1]$$$toImage -->
<h3 class="fn" id="toImage" translate="no"><a name="toImage"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QGLPixelBuffer::<span class="name">toImage</span>() const<a class="plink" href="#toImage" title="Direct link to this headline"></a></h3>
<p>Returns the contents of the pbuffer as a <a href="./qimage.htm" translate="no">QImage</a>.</p>
<!-- @@@toImage -->
<!-- $$$updateDynamicTexture[overload1]$$$updateDynamicTextureGLuint -->
<h3 class="fn" id="updateDynamicTexture" translate="no"><a name="updateDynamicTexture"></a><span class="type">void</span> QGLPixelBuffer::<span class="name">updateDynamicTexture</span>(<span class="type">GLuint</span> <i>texture_id</i>) const<a class="plink" href="#updateDynamicTexture" title="Direct link to this headline"></a></h3>
<p>Copies the pbuffer contents into the texture specified with <i translate="no">texture_id</i>.</p>
<p>The texture must be of the same size and format as the pbuffer.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qglpixelbuffer.htm#QGLPixelBuffer" translate="no">QGLPixelBuffer</a></span> pbuffer(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
pbuffer<span class="operator">.</span>makeCurrent();
GLuint dynamicTexture <span class="operator">=</span> pbuffer<span class="operator">.</span>generateDynamicTexture();
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
pbuffer<span class="operator">.</span>updateDynamicTexture(dynamicTexture);</pre></div>
<p>An alternative on Windows and macOS systems that support the <code translate="no">render_texture</code> extension is to use <a href="./qglpixelbuffer.htm#bindToDynamicTexture" translate="no">bindToDynamicTexture</a>() to get dynamic updates of the texture.</p>
<p><b>See also </b><a href="./qglpixelbuffer.htm#generateDynamicTexture" translate="no">generateDynamicTexture</a>() and <a href="./qglpixelbuffer.htm#bindToDynamicTexture" translate="no">bindToDynamicTexture</a>().</p>
<!-- @@@updateDynamicTexture -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>