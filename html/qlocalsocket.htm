<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QLocalSocket | Qt Network</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qlocalsocket.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtnetwork-index.htm" translate="no">Qt Network</a></li>
                            <li><a href="./qtnetwork-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QLocalSocket</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QLocalSocket Class</h1>
<!-- $$$QLocalSocket-brief -->
<p>The QLocalSocket class provides a local socket. <a href="#details">More...</a></p>
<!-- @@@QLocalSocket -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QLocalSocket&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.4</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qiodevice.htm" translate="no">QIODevice</a></td></tr></tbody></table></div><p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="./qlocalsocket-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qlocalsocket-obsolete.htm">Obsolete members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#LocalSocketError-enum" translate="no">LocalSocketError</a></b> { ConnectionRefusedError, PeerClosedError, ServerNotFoundError, SocketAccessError, SocketResourceError, â€¦, UnknownSocketError }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">LocalSocketState</a></b> { UnconnectedState, ConnectingState, ConnectedState, ClosingState }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#QLocalSocket" translate="no">QLocalSocket</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#dtor.QLocalSocket" translate="no">~QLocalSocket</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#abort" translate="no">abort</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a></b>(QIODevice::OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#connectToServer-1" translate="no">connectToServer</a></b>(const QString &amp;<i>name</i>, QIODevice::OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#disconnectFromServer" translate="no">disconnectFromServer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QLocalSocket::LocalSocketError </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#error" translate="no">error</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#flush" translate="no">flush</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#fullServerName" translate="no">fullServerName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#readBufferSize" translate="no">readBufferSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#serverName" translate="no">serverName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#setReadBufferSize" translate="no">setReadBufferSize</a></b>(qint64 <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#setServerName" translate="no">setServerName</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#setSocketDescriptor" translate="no">setSocketDescriptor</a></b>(qintptr <i>socketDescriptor</i>, QLocalSocket::LocalSocketState <i>socketState</i> = ConnectedState, QIODevice::OpenMode <i>openMode</i> = ReadWrite)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qintptr </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#socketDescriptor" translate="no">socketDescriptor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QLocalSocket::LocalSocketState </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#state" translate="no">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#waitForConnected" translate="no">waitForConnected</a></b>(int <i>msecs</i> = 30000)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#waitForDisconnected" translate="no">waitForDisconnected</a></b>(int <i>msecs</i> = 30000)</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#bytesAvailable" translate="no">bytesAvailable</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#bytesToWrite" translate="no">bytesToWrite</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#canReadLine" translate="no">canReadLine</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#close" translate="no">close</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#isSequential" translate="no">isSequential</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#open" translate="no">open</a></b>(QIODevice::OpenMode <i>openMode</i> = ReadWrite) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a></b>(int <i>msecs</i> = 30000) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#waitForReadyRead" translate="no">waitForReadyRead</a></b>(int <i>msecs</i> = 30000) override</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#connected" translate="no">connected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#disconnected" translate="no">disconnected</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#errorOccurred" translate="no">errorOccurred</a></b>(QLocalSocket::LocalSocketError <i>socketError</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#stateChanged" translate="no">stateChanged</a></b>(QLocalSocket::LocalSocketState <i>socketState</i>)</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#readData" translate="no">readData</a></b>(char *<i>data</i>, qint64 <i>c</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qlocalsocket.htm#writeData" translate="no">writeData</a></b>(const char *<i>data</i>, qint64 <i>c</i>) override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QLocalSocket-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>On Windows this is a named pipe and on Unix this is a local domain socket.</p>
<p>If an error occurs, <a href="./qlocalsocket.htm#error" translate="no">error</a>() returns the type of error, and <a href="./qiodevice.htm#errorString" translate="no">errorString</a>() can be called to get a human readable description of what happened.</p>
<p>Although QLocalSocket is designed for use with an event loop, it's possible to use it without one. In that case, you must use <a href="./qlocalsocket.htm#waitForConnected" translate="no">waitForConnected</a>(), <a href="./qlocalsocket.htm#waitForReadyRead" translate="no">waitForReadyRead</a>(), <a href="./qlocalsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a>(), and <a href="./qlocalsocket.htm#waitForDisconnected" translate="no">waitForDisconnected</a>() which blocks until the operation is complete or the timeout expires.</p>
</div>
<p><b>See also </b><a href="./qlocalserver.htm" translate="no">QLocalServer</a>.</p>
<!-- @@@QLocalSocket -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$LocalSocketError$$$ConnectionRefusedError$$$PeerClosedError$$$ServerNotFoundError$$$SocketAccessError$$$SocketResourceError$$$SocketTimeoutError$$$DatagramTooLargeError$$$ConnectionError$$$UnsupportedSocketOperationError$$$UnknownSocketError$$$OperationError -->
<h3 class="fn" id="LocalSocketError-enum" translate="no"><a name="LocalSocketError-enum"></a>enum QLocalSocket::<span class="name">LocalSocketError</span><a class="plink" href="#LocalSocketError-enum" title="Direct link to this headline"></a></h3>
<p>The LocalServerError enumeration represents the errors that can occur. The most recent error can be retrieved through a call to <a href="./qlocalsocket.htm#error" translate="no">QLocalSocket::error</a>().</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::ConnectionRefusedError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::ConnectionRefusedError</code></td><td class="topAlign">The connection was refused by the peer (or timed out).</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::PeerClosedError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::RemoteHostClosedError</code></td><td class="topAlign">The remote socket closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::ServerNotFoundError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::HostNotFoundError</code></td><td class="topAlign">The local socket name was not found.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::SocketAccessError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::SocketAccessError</code></td><td class="topAlign">The socket operation failed because the application lacked the required privileges.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::SocketResourceError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::SocketResourceError</code></td><td class="topAlign">The local system ran out of resources (e.g., too many sockets).</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::SocketTimeoutError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::SocketTimeoutError</code></td><td class="topAlign">The socket operation timed out.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::DatagramTooLargeError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::DatagramTooLargeError</code></td><td class="topAlign">The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::ConnectionError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::NetworkError</code></td><td class="topAlign">An error occurred with the connection.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::UnsupportedSocketOperationError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::UnsupportedSocketOperationError</code></td><td class="topAlign">The requested socket operation is not supported by the local operating system.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::OperationError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::OperationError</code></td><td class="topAlign">An operation was attempted while the socket was in a state that did not permit it.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::UnknownSocketError</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::UnknownSocketError</code></td><td class="topAlign">An unidentified error occurred.</td></tr>
</tbody></table></div>
<!-- @@@LocalSocketError -->
<!-- $$$LocalSocketState$$$UnconnectedState$$$ConnectingState$$$ConnectedState$$$ClosingState -->
<h3 class="fn" id="LocalSocketState-enum" translate="no"><a name="LocalSocketState-enum"></a>enum QLocalSocket::<span class="name">LocalSocketState</span><a class="plink" href="#LocalSocketState-enum" title="Direct link to this headline"></a></h3>
<p>This enum describes the different states in which a socket can be.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::UnconnectedState</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::UnconnectedState</code></td><td class="topAlign">The socket is not connected.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::ConnectingState</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::ConnectingState</code></td><td class="topAlign">The socket has started establishing a connection.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::ConnectedState</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::ConnectedState</code></td><td class="topAlign">A connection is established.</td></tr>
<tr><td class="topAlign"><code translate="no">QLocalSocket::ClosingState</code></td><td class="topAlign tblval"><code translate="no">QAbstractSocket::ClosingState</code></td><td class="topAlign">The socket is about to close (data may still be waiting to be written).</td></tr>
</tbody></table></div>
<p><b>See also </b><a href="./qlocalsocket.htm#state" translate="no">QLocalSocket::state</a>().</p>
<!-- @@@LocalSocketState -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QLocalSocket[overload1]$$$QLocalSocketQObject* -->
<h3 class="fn" id="QLocalSocket" translate="no"><a name="QLocalSocket"></a>QLocalSocket::<span class="name">QLocalSocket</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QLocalSocket" title="Direct link to this headline"></a></h3>
<p>Creates a new local socket. The <i translate="no">parent</i> argument is passed to <a href="./qobject.htm" translate="no">QObject</a>'s constructor.</p>
<!-- @@@QLocalSocket -->
<!-- $$$connected[overload1]$$$connected -->
<h3 class="fn" id="connected" translate="no"><a name="connected"></a><code translate="no">[signal] </code><span class="type">void</span> QLocalSocket::<span class="name">connected</span>()<a class="plink" href="#connected" title="Direct link to this headline"></a></h3>
<p>This signal is emitted after <a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>() has been called and a connection has been successfully established.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>() and <a href="./qlocalsocket.htm#disconnected" translate="no">disconnected</a>().</p>
<!-- @@@connected -->
<!-- $$$disconnected[overload1]$$$disconnected -->
<h3 class="fn" id="disconnected" translate="no"><a name="disconnected"></a><code translate="no">[signal] </code><span class="type">void</span> QLocalSocket::<span class="name">disconnected</span>()<a class="plink" href="#disconnected" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the socket has been disconnected.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>(), <a href="./qlocalsocket.htm#disconnectFromServer" translate="no">disconnectFromServer</a>(), <a href="./qlocalsocket.htm#abort" translate="no">abort</a>(), and <a href="./qlocalsocket.htm#connected" translate="no">connected</a>().</p>
<!-- @@@disconnected -->
<!-- $$$errorOccurred[overload1]$$$errorOccurredQLocalSocket::LocalSocketError -->
<h3 class="fn" id="errorOccurred" translate="no"><a name="errorOccurred"></a><code translate="no">[signal] </code><span class="type">void</span> QLocalSocket::<span class="name">errorOccurred</span>(<span class="type"><a href="./qlocalsocket.htm#LocalSocketError-enum" translate="no">QLocalSocket::LocalSocketError</a></span> <i>socketError</i>)<a class="plink" href="#errorOccurred" title="Direct link to this headline"></a></h3>
<p>This signal is emitted after an error occurred. The <i translate="no">socketError</i> parameter describes the type of error that occurred.</p>
<p><a href="./qlocalsocket.htm#LocalSocketError-enum" translate="no">QLocalSocket::LocalSocketError</a> is not a registered metatype, so for queued connections, you will have to register it with <a href="./qmetatype.htm#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() and <a href="./qmetatype.htm#qRegisterMetaType-1" translate="no">qRegisterMetaType</a>().</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#error" translate="no">error</a>(), <a href="./qiodevice.htm#errorString" translate="no">errorString</a>(), and <a href="./custom-types.htm" translate="no">Creating Custom Qt Types</a>.</p>
<!-- @@@errorOccurred -->
<!-- $$$stateChanged[overload1]$$$stateChangedQLocalSocket::LocalSocketState -->
<h3 class="fn" id="stateChanged" translate="no"><a name="stateChanged"></a><code translate="no">[signal] </code><span class="type">void</span> QLocalSocket::<span class="name">stateChanged</span>(<span class="type"><a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">QLocalSocket::LocalSocketState</a></span> <i>socketState</i>)<a class="plink" href="#stateChanged" title="Direct link to this headline"></a></h3>
<p>This signal is emitted whenever <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a>'s state changes. The <i translate="no">socketState</i> parameter is the new state.</p>
<p>QLocalSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with <a href="./qmetatype.htm#Q_DECLARE_METATYPE" translate="no">Q_DECLARE_METATYPE</a>() and <a href="./qmetatype.htm#qRegisterMetaType-1" translate="no">qRegisterMetaType</a>().</p>
<p><b>See also </b><a href="./qlocalsocket.htm#state" translate="no">state</a>() and <a href="./custom-types.htm" translate="no">Creating Custom Qt Types</a>.</p>
<!-- @@@stateChanged -->
<!-- $$$~QLocalSocket[overload1]$$$~QLocalSocket -->
<h3 class="fn" id="dtor.QLocalSocket" translate="no"><a name="dtor.QLocalSocket"></a><code translate="no">[virtual] </code>QLocalSocket::<span class="name">~QLocalSocket</span>()<a class="plink" href="#dtor.QLocalSocket" title="Direct link to this headline"></a></h3>
<p>Destroys the socket, closing the connection if necessary.</p>
<!-- @@@~QLocalSocket -->
<!-- $$$abort[overload1]$$$abort -->
<h3 class="fn" id="abort" translate="no"><a name="abort"></a><span class="type">void</span> QLocalSocket::<span class="name">abort</span>()<a class="plink" href="#abort" title="Direct link to this headline"></a></h3>
<p>Aborts the current connection and resets the socket. Unlike <a href="./qlocalsocket.htm#disconnectFromServer" translate="no">disconnectFromServer</a>(), this function immediately closes the socket, clearing any pending data in the write buffer.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#disconnectFromServer" translate="no">disconnectFromServer</a>() and <a href="./qlocalsocket.htm#close" translate="no">close</a>().</p>
<!-- @@@abort -->
<!-- $$$bytesAvailable[overload1]$$$bytesAvailable -->
<h3 class="fn" id="bytesAvailable" translate="no"><a name="bytesAvailable"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QLocalSocket::<span class="name">bytesAvailable</span>() const<a class="plink" href="#bytesAvailable" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#bytesAvailable" translate="no">QIODevice::bytesAvailable</a>() const.</p>
<!-- @@@bytesAvailable -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn" id="bytesToWrite" translate="no"><a name="bytesToWrite"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QLocalSocket::<span class="name">bytesToWrite</span>() const<a class="plink" href="#bytesToWrite" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#bytesToWrite" translate="no">QIODevice::bytesToWrite</a>() const.</p>
<!-- @@@bytesToWrite -->
<!-- $$$canReadLine[overload1]$$$canReadLine -->
<h3 class="fn" id="canReadLine" translate="no"><a name="canReadLine"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QLocalSocket::<span class="name">canReadLine</span>() const<a class="plink" href="#canReadLine" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#canReadLine" translate="no">QIODevice::canReadLine</a>() const.</p>
<!-- @@@canReadLine -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" id="close" translate="no"><a name="close"></a><code translate="no">[override virtual] </code><span class="type">void</span> QLocalSocket::<span class="name">close</span>()<a class="plink" href="#close" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#close" translate="no">QIODevice::close</a>().</p>
<!-- @@@close -->
<!-- $$$connectToServer[overload1]$$$connectToServerQIODevice::OpenMode -->
<h3 class="fn" id="connectToServer" translate="no"><a name="connectToServer"></a><span class="type">void</span> QLocalSocket::<span class="name">connectToServer</span>(<span class="type"><a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">QIODevice::OpenMode</a></span> <i>openMode</i> = ReadWrite)<a class="plink" href="#connectToServer" title="Direct link to this headline"></a></h3>
<p>Attempts to make a connection to <a href="./qlocalsocket.htm#serverName" translate="no">serverName</a>(). <a href="./qlocalsocket.htm#setServerName" translate="no">setServerName</a>() must be called before you open the connection. Alternatively you can use connectToServer(const <a href="./qstring.htm" translate="no">QString</a> &amp;name, <a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">OpenMode</a> <a href="./qiodevice.htm#openMode" translate="no">openMode</a>);</p>
<p>The socket is opened in the given <i translate="no">openMode</i> and first enters <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">ConnectingState</a>. If a connection is established, <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> enters <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">ConnectedState</a> and emits <a href="./qlocalsocket.htm#connected" translate="no">connected</a>().</p>
<p>After calling this function, the socket can emit <a href="./qlocalsocket.htm#errorOccurred" translate="no">errorOccurred</a>() to signal that an error occurred.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#state" translate="no">state</a>(), <a href="./qlocalsocket.htm#serverName" translate="no">serverName</a>(), and <a href="./qlocalsocket.htm#waitForConnected" translate="no">waitForConnected</a>().</p>
<!-- @@@connectToServer -->
<!-- $$$connectToServer$$$connectToServerconstQString&QIODevice::OpenMode -->
<h3 class="fn" id="connectToServer-1" translate="no"><a name="connectToServer-1"></a><span class="type">void</span> QLocalSocket::<span class="name">connectToServer</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>name</i>, <span class="type"><a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">QIODevice::OpenMode</a></span> <i>openMode</i> = ReadWrite)<a class="plink" href="#connectToServer-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Set the server <i translate="no">name</i> and attempts to make a connection to it.</p>
<p>The socket is opened in the given <i translate="no">openMode</i> and first enters <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">ConnectingState</a>. If a connection is established, <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> enters <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">ConnectedState</a> and emits <a href="./qlocalsocket.htm#connected" translate="no">connected</a>().</p>
<p>After calling this function, the socket can emit <a href="./qlocalsocket.htm#errorOccurred" translate="no">errorOccurred</a>() to signal that an error occurred.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#state" translate="no">state</a>(), <a href="./qlocalsocket.htm#serverName" translate="no">serverName</a>(), and <a href="./qlocalsocket.htm#waitForConnected" translate="no">waitForConnected</a>().</p>
<!-- @@@connectToServer -->
<!-- $$$disconnectFromServer[overload1]$$$disconnectFromServer -->
<h3 class="fn" id="disconnectFromServer" translate="no"><a name="disconnectFromServer"></a><span class="type">void</span> QLocalSocket::<span class="name">disconnectFromServer</span>()<a class="plink" href="#disconnectFromServer" title="Direct link to this headline"></a></h3>
<p>Attempts to close the socket. If there is pending data waiting to be written, <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> will enter <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">ClosingState</a> and wait until all data has been written. Eventually, it will enter <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">UnconnectedState</a> and emit the disconnectedFromServer() signal.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>().</p>
<!-- @@@disconnectFromServer -->
<!-- $$$error[overload1]$$$error -->
<h3 class="fn" id="error" translate="no"><a name="error"></a><span class="type"><a href="./qlocalsocket.htm#LocalSocketError-enum" translate="no">QLocalSocket::LocalSocketError</a></span> QLocalSocket::<span class="name">error</span>() const<a class="plink" href="#error" title="Direct link to this headline"></a></h3>
<p>Returns the type of error that last occurred.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#state" translate="no">state</a>() and <a href="./qiodevice.htm#errorString" translate="no">errorString</a>().</p>
<!-- @@@error -->
<!-- $$$flush[overload1]$$$flush -->
<h3 class="fn" id="flush" translate="no"><a name="flush"></a><span class="type">bool</span> QLocalSocket::<span class="name">flush</span>()<a class="plink" href="#flush" title="Direct link to this headline"></a></h3>
<p>This function writes as much as possible from the internal write buffer to the socket, without blocking. If any data was written, this function returns <code translate="no">true</code>; otherwise false is returned.</p>
<p>Call this function if you need <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <a href="./qlocalsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a>() instead.</p>
<p><b>See also </b><a href="./qiodevice.htm#write" translate="no">write</a>() and <a href="./qlocalsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a>().</p>
<!-- @@@flush -->
<!-- $$$fullServerName[overload1]$$$fullServerName -->
<h3 class="fn" id="fullServerName" translate="no"><a name="fullServerName"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QLocalSocket::<span class="name">fullServerName</span>() const<a class="plink" href="#fullServerName" title="Direct link to this headline"></a></h3>
<p>Returns the server path that the socket is connected to.</p>
<div class="admonition note">
<p><b>Note: </b>The return value of this function is platform specific.</p>
</div>
<p><b>See also </b><a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>() and <a href="./qlocalsocket.htm#serverName" translate="no">serverName</a>().</p>
<!-- @@@fullServerName -->
<!-- $$$isSequential[overload1]$$$isSequential -->
<h3 class="fn" id="isSequential" translate="no"><a name="isSequential"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QLocalSocket::<span class="name">isSequential</span>() const<a class="plink" href="#isSequential" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#isSequential" translate="no">QIODevice::isSequential</a>() const.</p>
<!-- @@@isSequential -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QLocalSocket::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the socket is valid and ready for use; otherwise returns <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The socket's state must be <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">ConnectedState</a> before reading and writing can occur.</p>
</div>
<p><b>See also </b><a href="./qlocalsocket.htm#state" translate="no">state</a>() and <a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>().</p>
<!-- @@@isValid -->
<!-- $$$open[overload1]$$$openQIODevice::OpenMode -->
<h3 class="fn" id="open" translate="no"><a name="open"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QLocalSocket::<span class="name">open</span>(<span class="type"><a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">QIODevice::OpenMode</a></span> <i>openMode</i> = ReadWrite)<a class="plink" href="#open" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#open" translate="no">QIODevice::open</a>(QIODevice::OpenMode mode).</p>
<p>Equivalent to <a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>(<a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">OpenMode</a> mode). The socket is opened in the given <i translate="no">openMode</i> to the server defined by <a href="./qlocalsocket.htm#setServerName" translate="no">setServerName</a>().</p>
<p>Note that unlike in most other <a href="./qiodevice.htm" translate="no">QIODevice</a> subclasses, open() may not open the device directly. The function return false if the socket was already connected or if the server to connect to was not defined and true in any other case. The <a href="./qlocalsocket.htm#connected" translate="no">connected</a>() or <a href="./qlocalsocket.htm#errorOccurred" translate="no">errorOccurred</a>() signals will be emitted once the device is actually open (or the connection failed).</p>
<p>See <a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>() for more details.</p>
<!-- @@@open -->
<!-- $$$readBufferSize[overload1]$$$readBufferSize -->
<h3 class="fn" id="readBufferSize" translate="no"><a name="readBufferSize"></a><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QLocalSocket::<span class="name">readBufferSize</span>() const<a class="plink" href="#readBufferSize" title="Direct link to this headline"></a></h3>
<p>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <a href="./qiodevice.htm#read" translate="no">read</a>() or <a href="./qiodevice.htm#readAll" translate="no">readAll</a>(). A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#setReadBufferSize" translate="no">setReadBufferSize</a>() and <a href="./qiodevice.htm#read" translate="no">read</a>().</p>
<!-- @@@readBufferSize -->
<!-- $$$readData[overload1]$$$readDatachar*qint64 -->
<h3 class="fn" id="readData" translate="no"><a name="readData"></a><code translate="no">[override virtual protected] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QLocalSocket::<span class="name">readData</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>c</i>)<a class="plink" href="#readData" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#readData" translate="no">QIODevice::readData</a>(char *data, qint64 maxSize).</p>
<!-- @@@readData -->
<!-- $$$serverName[overload1]$$$serverName -->
<h3 class="fn" id="serverName" translate="no"><a name="serverName"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QLocalSocket::<span class="name">serverName</span>() const<a class="plink" href="#serverName" title="Direct link to this headline"></a></h3>
<p>Returns the name of the peer as specified by <a href="./qlocalsocket.htm#setServerName" translate="no">setServerName</a>(), or an empty <a href="./qstring.htm" translate="no">QString</a> if <a href="./qlocalsocket.htm#setServerName" translate="no">setServerName</a>() has not been called or <a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>() failed.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#setServerName" translate="no">setServerName</a>(), <a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>(), and <a href="./qlocalsocket.htm#fullServerName" translate="no">fullServerName</a>().</p>
<!-- @@@serverName -->
<!-- $$$setReadBufferSize[overload1]$$$setReadBufferSizeqint64 -->
<h3 class="fn" id="setReadBufferSize" translate="no"><a name="setReadBufferSize"></a><span class="type">void</span> QLocalSocket::<span class="name">setReadBufferSize</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>size</i>)<a class="plink" href="#setReadBufferSize" title="Direct link to this headline"></a></h3>
<p>Sets the size of <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a>'s internal read buffer to be <i translate="no">size</i> bytes.</p>
<p>If the buffer size is limited to a certain size, <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</p>
<p>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#readBufferSize" translate="no">readBufferSize</a>() and <a href="./qiodevice.htm#read" translate="no">read</a>().</p>
<!-- @@@setReadBufferSize -->
<!-- $$$setServerName[overload1]$$$setServerNameconstQString& -->
<h3 class="fn" id="setServerName" translate="no"><a name="setServerName"></a><span class="type">void</span> QLocalSocket::<span class="name">setServerName</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>name</i>)<a class="plink" href="#setServerName" title="Direct link to this headline"></a></h3>
<p>Set the <i translate="no">name</i> of the peer to connect to. On Windows name is the name of a named pipe; on Unix name is the name of a local domain socket.</p>
<p>This function must be called when the socket is not connected.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#serverName" translate="no">serverName</a>().</p>
<!-- @@@setServerName -->
<!-- $$$setSocketDescriptor[overload1]$$$setSocketDescriptorqintptrQLocalSocket::LocalSocketStateQIODevice::OpenMode -->
<h3 class="fn" id="setSocketDescriptor" translate="no"><a name="setSocketDescriptor"></a><span class="type">bool</span> QLocalSocket::<span class="name">setSocketDescriptor</span>(<span class="type"><a href="./qtglobal.htm#qintptr-typedef" translate="no">qintptr</a></span> <i>socketDescriptor</i>, <span class="type"><a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">QLocalSocket::LocalSocketState</a></span> <i>socketState</i> = ConnectedState, <span class="type"><a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">QIODevice::OpenMode</a></span> <i>openMode</i> = ReadWrite)<a class="plink" href="#setSocketDescriptor" title="Direct link to this headline"></a></h3>
<p>Initializes <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> with the native socket descriptor <i translate="no">socketDescriptor</i>. Returns <code translate="no">true</code> if <a href="./qlocalsocket.htm#socketDescriptor" translate="no">socketDescriptor</a> is accepted as a valid socket descriptor; otherwise returns <code translate="no">false</code>. The socket is opened in the mode specified by <i translate="no">openMode</i>, and enters the socket state specified by <i translate="no">socketState</i>.</p>
<div class="admonition note">
<p><b>Note: </b>It is not possible to initialize two local sockets with the same native socket descriptor.</p>
</div>
<p><b>See also </b><a href="./qlocalsocket.htm#socketDescriptor" translate="no">socketDescriptor</a>(), <a href="./qlocalsocket.htm#state" translate="no">state</a>(), and <a href="./qiodevice.htm#openMode" translate="no">openMode</a>().</p>
<!-- @@@setSocketDescriptor -->
<!-- $$$socketDescriptor[overload1]$$$socketDescriptor -->
<h3 class="fn" id="socketDescriptor" translate="no"><a name="socketDescriptor"></a><span class="type"><a href="./qtglobal.htm#qintptr-typedef" translate="no">qintptr</a></span> QLocalSocket::<span class="name">socketDescriptor</span>() const<a class="plink" href="#socketDescriptor" title="Direct link to this headline"></a></h3>
<p>Returns the native socket descriptor of the <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> object if this is available; otherwise returns -1.</p>
<p>The socket descriptor is not available when <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> is in <a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">UnconnectedState</a>. The type of the descriptor depends on the platform:</p>
<ul>
<li>On Windows, the returned value is a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740522(v=vs.85).aspx" translate="no">Winsock 2 Socket Handle</a>.</li>
<li>With WinRT and on INTEGRITY, the returned value is the <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a> socket descriptor and the type is defined by <a href="./qabstractsocket.htm#socketDescriptor" translate="no">socketDescriptor</a>.</li>
<li>On all other UNIX-like operating systems, the type is a file descriptor representing a socket.</li>
</ul>
<p><b>See also </b><a href="./qlocalsocket.htm#setSocketDescriptor" translate="no">setSocketDescriptor</a>().</p>
<!-- @@@socketDescriptor -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" id="state" translate="no"><a name="state"></a><span class="type"><a href="./qlocalsocket.htm#LocalSocketState-enum" translate="no">QLocalSocket::LocalSocketState</a></span> QLocalSocket::<span class="name">state</span>() const<a class="plink" href="#state" title="Direct link to this headline"></a></h3>
<p>Returns the state of the socket.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#error" translate="no">error</a>().</p>
<!-- @@@state -->
<!-- $$$waitForBytesWritten[overload1]$$$waitForBytesWrittenint -->
<h3 class="fn" id="waitForBytesWritten" translate="no"><a name="waitForBytesWritten"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QLocalSocket::<span class="name">waitForBytesWritten</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForBytesWritten" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#waitForBytesWritten" translate="no">QIODevice::waitForBytesWritten</a>(int msecs).</p>
<!-- @@@waitForBytesWritten -->
<!-- $$$waitForConnected[overload1]$$$waitForConnectedint -->
<h3 class="fn" id="waitForConnected" translate="no"><a name="waitForConnected"></a><span class="type">bool</span> QLocalSocket::<span class="name">waitForConnected</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForConnected" title="Direct link to this headline"></a></h3>
<p>Waits until the socket is connected, up to <i translate="no">msecs</i> milliseconds. If the connection has been established, this function returns <code translate="no">true</code>; otherwise it returns <code translate="no">false</code>. In the case where it returns <code translate="no">false</code>, you can call <a href="./qlocalsocket.htm#error" translate="no">error</a>() to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be established:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">socket<span class="operator">-</span><span class="operator">&gt;</span>connectToServer(<span class="string">"market"</span>);
<span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>waitForConnected(<span class="number">1000</span>))
    <a href="./qtglobal.htm#qDebug" translate="no">qDebug</a>(<span class="string">"Connected!"</span>);</pre></div>
<p>If <i translate="no">msecs</i> is -1, this function will not time out.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#connectToServer" translate="no">connectToServer</a>() and <a href="./qlocalsocket.htm#connected" translate="no">connected</a>().</p>
<!-- @@@waitForConnected -->
<!-- $$$waitForDisconnected[overload1]$$$waitForDisconnectedint -->
<h3 class="fn" id="waitForDisconnected" translate="no"><a name="waitForDisconnected"></a><span class="type">bool</span> QLocalSocket::<span class="name">waitForDisconnected</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForDisconnected" title="Direct link to this headline"></a></h3>
<p>Waits until the socket has disconnected, up to <i translate="no">msecs</i> milliseconds. If the connection was successfully disconnected, this function returns <code translate="no">true</code>; otherwise it returns <code translate="no">false</code> (if the operation timed out, if an error occurred, or if this <a href="./qlocalsocket.htm" translate="no">QLocalSocket</a> is already disconnected). In the case where it returns <code translate="no">false</code>, you can call <a href="./qlocalsocket.htm#error" translate="no">error</a>() to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be closed:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">socket<span class="operator">-</span><span class="operator">&gt;</span>disconnectFromServer();
<span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>state() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="./qlocalsocket.htm#QLocalSocket" translate="no">QLocalSocket</a></span><span class="operator">::</span>UnconnectedState
    <span class="operator">|</span><span class="operator">|</span> socket<span class="operator">-</span><span class="operator">&gt;</span>waitForDisconnected(<span class="number">1000</span>)) {
    <a href="./qtglobal.htm#qDebug" translate="no">qDebug</a>(<span class="string">"Disconnected!"</span>);
}</pre></div>
<p>If <i translate="no">msecs</i> is -1, this function will not time out.</p>
<p><b>See also </b><a href="./qlocalsocket.htm#disconnectFromServer" translate="no">disconnectFromServer</a>() and <a href="./qlocalsocket.htm#close" translate="no">close</a>().</p>
<!-- @@@waitForDisconnected -->
<!-- $$$waitForReadyRead[overload1]$$$waitForReadyReadint -->
<h3 class="fn" id="waitForReadyRead" translate="no"><a name="waitForReadyRead"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QLocalSocket::<span class="name">waitForReadyRead</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForReadyRead" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#waitForReadyRead" translate="no">QIODevice::waitForReadyRead</a>(int msecs).</p>
<p>This function blocks until data is available for reading and the <a href="./qiodevice.htm#readyRead" translate="no">readyRead()</a> signal has been emitted. The function will timeout after <i translate="no">msecs</i> milliseconds; the default timeout is 30000 milliseconds.</p>
<p>The function returns <code translate="no">true</code> if data is available for reading; otherwise it returns <code translate="no">false</code> (if an error occurred or the operation timed out).</p>
<p><b>See also </b><a href="./qlocalsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a>().</p>
<!-- @@@waitForReadyRead -->
<!-- $$$writeData[overload1]$$$writeDataconstchar*qint64 -->
<h3 class="fn" id="writeData" translate="no"><a name="writeData"></a><code translate="no">[override virtual protected] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QLocalSocket::<span class="name">writeData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>c</i>)<a class="plink" href="#writeData" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qiodevice.htm#writeData" translate="no">QIODevice::writeData</a>(const char *data, qint64 maxSize).</p>
<!-- @@@writeData -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>