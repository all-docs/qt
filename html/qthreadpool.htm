<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QThreadPool | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qthreadpool.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QThreadPool</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QThreadPool Class</h1>
<!-- $$$QThreadPool-brief -->
<p>The QThreadPool class manages a collection of QThreads. <a href="#details">More...</a></p>
<!-- @@@QThreadPool -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QThreadPool&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.4</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qobject.htm" translate="no">QObject</a></td></tr></tbody></table></div><p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="./qthreadpool-members.htm">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">thread-safe</a>.</p>
<a name="properties"></a>
<h2 id="properties">Properties<a class="plink" href="#properties" title="Direct link to this headline"></a></h2>
<ul>
<li class="fn" translate="no"><b><a href="./qthreadpool.htm#activeThreadCount-prop" translate="no">activeThreadCount</a></b> : const int</li>
<li class="fn" translate="no"><b><a href="./qthreadpool.htm#expiryTimeout-prop" translate="no">expiryTimeout</a></b> : int</li>
<li class="fn" translate="no"><b><a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">maxThreadCount</a></b> : int</li>
<li class="fn" translate="no"><b><a href="./qthreadpool.htm#stackSize-prop" translate="no">stackSize</a></b> : uint</li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#QThreadPool" translate="no">QThreadPool</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#dtor.QThreadPool" translate="no">~QThreadPool</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#activeThreadCount-prop" translate="no">activeThreadCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#expiryTimeout-prop" translate="no">expiryTimeout</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">maxThreadCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#expiryTimeout-prop" translate="no">setExpiryTimeout</a></b>(int <i>expiryTimeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">setMaxThreadCount</a></b>(int <i>maxThreadCount</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#stackSize-prop" translate="no">setStackSize</a></b>(uint <i>stackSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#stackSize-prop" translate="no">stackSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#start" translate="no">start</a></b>(QRunnable *<i>runnable</i>, int <i>priority</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#tryTake" translate="no">tryTake</a></b>(QRunnable *<i>runnable</i>)</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QThreadPool *</td><td class="memItemRight bottomAlign"><b><a href="./qthreadpool.htm#globalInstance" translate="no">globalInstance</a></b>()</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QThreadPool-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QThreadPool manages and recycles individual <a href="./qthread.htm" translate="no">QThread</a> objects to help reduce thread creation costs in programs that use threads. Each Qt application has one global QThreadPool object, which can be accessed by calling <a href="./qthreadpool.htm#globalInstance" translate="no">globalInstance</a>().</p>
<p>To use one of the QThreadPool threads, subclass <a href="./qrunnable.htm" translate="no">QRunnable</a> and implement the run() virtual function. Then create an object of that class and pass it to <a href="./qthreadpool.htm#start" translate="no">QThreadPool::start</a>().</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> HelloWorldTask : <span class="keyword">public</span> <span class="type"><a href="./qrunnable.htm" translate="no">QRunnable</a></span>
{
    <span class="type">void</span> run() override
    {
        <a href="./qtglobal.htm#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Hello world from thread"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type"><a href="./qthread.htm" translate="no">QThread</a></span><span class="operator">::</span>currentThread();
    }
};

HelloWorldTask <span class="operator">*</span>hello <span class="operator">=</span> <span class="keyword">new</span> HelloWorldTask();
<span class="comment">// QThreadPool takes ownership and deletes 'hello' automatically</span>
<span class="type"><a href="./qthreadpool.htm#QThreadPool" translate="no">QThreadPool</a></span><span class="operator">::</span>globalInstance()<span class="operator">-</span><span class="operator">&gt;</span>start(hello);</pre></div>
<p>QThreadPool deletes the <a href="./qrunnable.htm" translate="no">QRunnable</a> automatically by default. Use <a href="./qrunnable.htm#setAutoDelete" translate="no">QRunnable::setAutoDelete</a>() to change the auto-deletion flag.</p>
<p>QThreadPool supports executing the same <a href="./qrunnable.htm" translate="no">QRunnable</a> more than once by calling tryStart(this) from within <a href="./qrunnable.htm#run" translate="no">QRunnable::run</a>(). If autoDelete is enabled the <a href="./qrunnable.htm" translate="no">QRunnable</a> will be deleted when the last thread exits the run function. Calling <a href="./qthreadpool.htm#start" translate="no">start</a>() multiple times with the same <a href="./qrunnable.htm" translate="no">QRunnable</a> when autoDelete is enabled creates a race condition and is not recommended.</p>
<p>Threads that are unused for a certain amount of time will expire. The default expiry timeout is 30000 milliseconds (30 seconds). This can be changed using <a href="./qthreadpool.htm#expiryTimeout-prop" translate="no">setExpiryTimeout</a>(). Setting a negative expiry timeout disables the expiry mechanism.</p>
<p>Call <a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">maxThreadCount</a>() to query the maximum number of threads to be used. If needed, you can change the limit with <a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">setMaxThreadCount</a>(). The default <a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">maxThreadCount</a>() is <a href="./qthread.htm#idealThreadCount" translate="no">QThread::idealThreadCount</a>(). The <a href="./qthreadpool.htm#activeThreadCount-prop" translate="no">activeThreadCount</a>() function returns the number of threads currently doing work.</p>
<p>The reserveThread() function reserves a thread for external use. Use releaseThread() when your are done with the thread, so that it may be reused. Essentially, these functions temporarily increase or reduce the active thread count and are useful when implementing time-consuming operations that are not visible to the QThreadPool.</p>
<p>Note that QThreadPool is a low-level class for managing threads, see the Qt Concurrent module for higher level alternatives.</p>
</div>
<p><b>See also </b><a href="./qrunnable.htm" translate="no">QRunnable</a>.</p>
<!-- @@@QThreadPool -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$activeThreadCount-prop$$$activeThreadCount -->
<h3 class="fn" id="activeThreadCount-prop" translate="no"><a name="activeThreadCount-prop"></a><span class="name">activeThreadCount</span> : const <span class="type">int</span><a class="plink" href="#activeThreadCount-prop" title="Direct link to this headline"></a></h3>
<p>This property represents the number of active threads in the thread pool.</p>
<div class="admonition note">
<p><b>Note: </b>It is possible for this function to return a value that is greater than <a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">maxThreadCount</a>(). See reserveThread() for more details.</p>
</div>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>activeThreadCount</b></span>() const</td></tr>
</tbody></table></div>
<p><b>See also </b>reserveThread() and releaseThread().</p>
<!-- @@@activeThreadCount -->
<!-- $$$expiryTimeout-prop$$$expiryTimeout$$$setExpiryTimeoutint -->
<h3 class="fn" id="expiryTimeout-prop" translate="no"><a name="expiryTimeout-prop"></a><span class="name">expiryTimeout</span> : <span class="type">int</span><a class="plink" href="#expiryTimeout-prop" title="Direct link to this headline"></a></h3>
<p>Threads that are unused for <i translate="no">expiryTimeout</i> milliseconds are considered to have expired and will exit. Such threads will be restarted as needed. The default <i translate="no">expiryTimeout</i> is 30000 milliseconds (30 seconds). If <i translate="no">expiryTimeout</i> is negative, newly created threads will not expire, e.g., they will not exit until the thread pool is destroyed.</p>
<p>Note that setting <i translate="no">expiryTimeout</i> has no effect on already running threads. Only newly created threads will use the new <i translate="no">expiryTimeout</i>. We recommend setting the <i translate="no">expiryTimeout</i> immediately after creating the thread pool, but before calling <a href="./qthreadpool.htm#start" translate="no">start</a>().</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>expiryTimeout</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setExpiryTimeout</b></span>(int <i>expiryTimeout</i>)</td></tr>
</tbody></table></div>
<!-- @@@expiryTimeout -->
<!-- $$$maxThreadCount-prop$$$maxThreadCount$$$setMaxThreadCountint -->
<h3 class="fn" id="maxThreadCount-prop" translate="no"><a name="maxThreadCount-prop"></a><span class="name">maxThreadCount</span> : <span class="type">int</span><a class="plink" href="#maxThreadCount-prop" title="Direct link to this headline"></a></h3>
<p>This property represents the maximum number of threads used by the thread pool.</p>
<div class="admonition note">
<p><b>Note: </b>The thread pool will always use at least 1 thread, even if <i translate="no">maxThreadCount</i> limit is zero or negative.</p>
</div>
<p>The default <i translate="no">maxThreadCount</i> is <a href="./qthread.htm#idealThreadCount" translate="no">QThread::idealThreadCount</a>().</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>maxThreadCount</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMaxThreadCount</b></span>(int <i>maxThreadCount</i>)</td></tr>
</tbody></table></div>
<!-- @@@maxThreadCount -->
<!-- $$$stackSize-prop$$$stackSize$$$setStackSizeuint -->
<h3 class="fn" id="stackSize-prop" translate="no"><a name="stackSize-prop"></a><span class="name">stackSize</span> : <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span><a class="plink" href="#stackSize-prop" title="Direct link to this headline"></a></h3>
<p>This property contains the stack size for the thread pool worker threads.</p>
<p>The value of the property is only used when the thread pool creates new threads. Changing it has no effect for already created or running threads.</p>
<p>The default value is 0, which makes <a href="./qthread.htm" translate="no">QThread</a> use the operating system default stack size.</p>
<p>This property was introduced in Qt 5.10.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> uint </td><td class="memItemRight bottomAlign"><span class="name"><b>stackSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setStackSize</b></span>(uint <i>stackSize</i>)</td></tr>
</tbody></table></div>
<!-- @@@stackSize -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QThreadPool[overload1]$$$QThreadPoolQObject* -->
<h3 class="fn" id="QThreadPool" translate="no"><a name="QThreadPool"></a>QThreadPool::<span class="name">QThreadPool</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QThreadPool" title="Direct link to this headline"></a></h3>
<p>Constructs a thread pool with the given <i translate="no">parent</i>.</p>
<!-- @@@QThreadPool -->
<!-- $$$~QThreadPool[overload1]$$$~QThreadPool -->
<h3 class="fn" id="dtor.QThreadPool" translate="no"><a name="dtor.QThreadPool"></a><code translate="no">[virtual] </code>QThreadPool::<span class="name">~QThreadPool</span>()<a class="plink" href="#dtor.QThreadPool" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qthreadpool.htm" translate="no">QThreadPool</a>. This function will block until all runnables have been completed.</p>
<!-- @@@~QThreadPool -->
<!-- $$$globalInstance[overload1]$$$globalInstance -->
<h3 class="fn" id="globalInstance" translate="no"><a name="globalInstance"></a><code translate="no">[static] </code><span class="type"><a href="./qthreadpool.htm#QThreadPool" translate="no">QThreadPool</a></span> *QThreadPool::<span class="name">globalInstance</span>()<a class="plink" href="#globalInstance" title="Direct link to this headline"></a></h3>
<p>Returns the global <a href="./qthreadpool.htm" translate="no">QThreadPool</a> instance.</p>
<!-- @@@globalInstance -->
<!-- $$$start[overload1]$$$startQRunnable*int -->
<h3 class="fn" id="start" translate="no"><a name="start"></a><span class="type">void</span> QThreadPool::<span class="name">start</span>(<span class="type"><a href="./qrunnable.htm" translate="no">QRunnable</a></span> *<i>runnable</i>, <span class="type">int</span> <i>priority</i> = 0)<a class="plink" href="#start" title="Direct link to this headline"></a></h3>
<p>Reserves a thread and uses it to run <i translate="no">runnable</i>, unless this thread will make the current thread count exceed <a href="./qthreadpool.htm#maxThreadCount-prop" translate="no">maxThreadCount</a>(). In that case, <i translate="no">runnable</i> is added to a run queue instead. The <i translate="no">priority</i> argument can be used to control the run queue's order of execution.</p>
<p>Note that the thread pool takes ownership of the <i translate="no">runnable</i> if <a href="./qrunnable.htm#autoDelete" translate="no">runnable-&gt;autoDelete()</a> returns <code translate="no">true</code>, and the <i translate="no">runnable</i> will be deleted automatically by the thread pool after the <a href="./qrunnable.htm#run" translate="no">runnable-&gt;run()</a> returns. If <a href="./qrunnable.htm#autoDelete" translate="no">runnable-&gt;autoDelete()</a> returns <code translate="no">false</code>, ownership of <i translate="no">runnable</i> remains with the caller. Note that changing the auto-deletion on <i translate="no">runnable</i> after calling this functions results in undefined behavior.</p>
<!-- @@@start -->
<!-- $$$tryTake[overload1]$$$tryTakeQRunnable* -->
<h3 class="fn" id="tryTake" translate="no"><a name="tryTake"></a><span class="type">bool</span> QThreadPool::<span class="name">tryTake</span>(<span class="type"><a href="./qrunnable.htm" translate="no">QRunnable</a></span> *<i>runnable</i>)<a class="plink" href="#tryTake" title="Direct link to this headline"></a></h3>
<p>Attempts to remove the specified <i translate="no">runnable</i> from the queue if it is not yet started. If the runnable had not been started, returns <code translate="no">true</code>, and ownership of <i translate="no">runnable</i> is transferred to the caller (even when <code translate="no">runnable-&gt;autoDelete() == true</code>). Otherwise returns <code translate="no">false</code>.</p>
<div class="admonition note">
<p><b>Note: </b>If <code translate="no">runnable-&gt;autoDelete() == true</code>, this function may remove the wrong runnable. This is known as the <a href="https://en.wikipedia.org/wiki/ABA_problem" translate="no">ABA problem</a>: the original <i translate="no">runnable</i> may already have executed and has since been deleted. The memory is re-used for another runnable, which then gets removed instead of the intended one. For this reason, we recommend calling this function only for runnables that are not auto-deleting.</p>
</div>
<p>This function was introduced in Qt 5.9.</p>
<p><b>See also </b><a href="./qthreadpool.htm#start" translate="no">start</a>() and <a href="./qrunnable.htm#autoDelete" translate="no">QRunnable::autoDelete</a>().</p>
<!-- @@@tryTake -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>