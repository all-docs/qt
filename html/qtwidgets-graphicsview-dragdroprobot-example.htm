<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Drag and Drop Robot Example | Qt Widgets</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtwidgets-graphicsview-dragdroprobot-example.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtwidgets-index.htm" translate="no">Qt Widgets</a></li>
                            <li><a>Drag and Drop Robot Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Drag and Drop Robot Example</h1>
<span class="subtitle"></span>
<!-- $$$graphicsview/dragdroprobot-brief -->
<p>Demonstrates how to drag and drop items in a graphics view.</p>
<!-- @@@graphicsview/dragdroprobot -->
<!-- $$$graphicsview/dragdroprobot-description -->
<div class="descr"> <a name="details"></a>
<p>The Drag and Drop Robot example shows how to implement Drag and Drop in a <a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a> subclass, as well as how to animate items using Qt's <a href="./animation.htm" translate="no">Animation Framework</a>.</p>
<p class="centerAlign"><img alt="" src="./images/dragdroprobot-example.png"></p><p>Graphics View provides the <a href="./qgraphicsscene.htm" translate="no">QGraphicsScene</a> class for managing and interacting with a large number of custom-made 2D graphical items derived from the <a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a> class, and a <a href="./qgraphicsview.htm" translate="no">QGraphicsView</a> widget for visualizing the items, with support for zooming and rotation.</p>
<p>This example consists of a <code translate="no">Robot</code> class, a <code translate="no">ColorItem</code> class, and a main function: the <code translate="no">Robot</code> class describes a simple robot consisting of several <code translate="no">RobotPart</code> derived limbs, including <code translate="no">RobotHead</code> and <code translate="no">RobotLimb</code>, the <code translate="no">ColorItem</code> class provides a draggable colored ellipse, and the <code translate="no">main()</code> function provides the main application window.</p>
<p>We will first review the <code translate="no">Robot</code> class to see how to assemble the different parts so that they can be individually rotated and animated using <a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a>, and we will then review the <code translate="no">ColorItem</code> class to demonstrate how to implement Drag and Drop between items. Finally we will review the main() function to see how we can put all the pieces together, to form the final application.</p>
<a name="robot-class-definition"></a>
<h4 id="robot-class-definition">Robot Class Definition<a class="plink" href="#robot-class-definition" title="Direct link to this headline"></a></h4>
<p>The robot consists of three main classes: the <code translate="no">RobotHead</code>, the <code translate="no">RobotTorso</code>, and the <code translate="no">RobotLimb</code>, which is used for the upper and lower arms and legs. All parts derive from the <code translate="no">RobotPart</code> class, which in turn inherits <code translate="no">QGraphicsObject</code>. The <code translate="no">Robot</code> class itself has no visual appearance and serves only as a root node for the robot.</p>
<p>Let's start with the <code translate="no">RobotPart</code> class declaration.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> RobotPart : <span class="keyword">public</span> <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span>
{
<span class="keyword">public</span>:
    RobotPart(<span class="type"><a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);

<span class="keyword">protected</span>:
    <span class="type">void</span> dragEnterEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event) override;
    <span class="type">void</span> dragLeaveEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event) override;
    <span class="type">void</span> dropEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event) override;

    <span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span> color <span class="operator">=</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>lightGray;
    bool dragOver <span class="operator">=</span> <span class="keyword">false</span>;
};</pre></div>
<p>This base class inherits <a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a>. <a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a> provides signals and slots through inheriting <a href="./qobject.htm" translate="no">QObject</a>, and it also declares <a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a>'s properties using <a href="./qobject.htm#Q_PROPERTY" translate="no">Q_PROPERTY</a>, which makes the properties accessible for <a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a>.</p>
<p>RobotPart also implements the three most important event handlers for accepting drop events: <a href="./qgraphicsitem.htm#dragEnterEvent" translate="no">dragEnterEvent()</a>, <a href="./qgraphicsitem.htm#dragLeaveEvent" translate="no">dragLeaveEvent()</a>, and <a href="./qgraphicsitem.htm#dropEvent" translate="no">dropEvent()</a>.</p>
<p>The color is stored as a member variable, along with the <code translate="no">dragOver</code> variable, which we will use later to indicate visually that the limb can accept colors that are is dragged onto it.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">RobotPart<span class="operator">::</span>RobotPart(<span class="type"><a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a></span> <span class="operator">*</span>parent)
    : <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span>(parent)<span class="operator">,</span> color(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>lightGray)
{
    setAcceptDrops(<span class="keyword">true</span>);
}</pre></div>
<p><code translate="no">RobotPart</code>'s constructor initializes the dragOver member and sets the color to <a href="./qt.htm#GlobalColor-enum" translate="no">Qt::lightGray</a>. In the constructor body we enable support for accepting drop events by calling <a href="./qgraphicsitem.htm#setAcceptDrops" translate="no">setAcceptDrops(true)</a>.</p>
<p>The rest of this class's implementation is to support Drag and Drop.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> RobotPart<span class="operator">::</span>dragEnterEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event)
{
    <span class="keyword">if</span> (event<span class="operator">-</span><span class="operator">&gt;</span>mimeData()<span class="operator">-</span><span class="operator">&gt;</span>hasColor()) {
        event<span class="operator">-</span><span class="operator">&gt;</span>setAccepted(<span class="keyword">true</span>);
        dragOver <span class="operator">=</span> <span class="keyword">true</span>;
        update();
    } <span class="keyword">else</span> {
        event<span class="operator">-</span><span class="operator">&gt;</span>setAccepted(<span class="keyword">false</span>);
    }
}</pre></div>
<p>The <a href="./qgraphicsitem.htm#dragEnterEvent" translate="no">dragEnterEvent()</a> handler is called when a Drag and Drop element is dragged into the robot part's area.</p>
<p>The handler implementation determines whether or not this item as a whole can accept the mime data assiciated with the incoming drag object. <code translate="no">RobotPart</code> provides a base behavior for all parts that accepts color drops. So if the incoming drag object contains a color, the event is accepted, we set <code translate="no">dragOver</code> to <code translate="no">true</code> and call update() to help provide positive visual feedback to the user; otherwise the event is ignored, which in turn allows the event to propagate to parent elements.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> RobotPart<span class="operator">::</span>dragLeaveEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event)
{
    Q_UNUSED(event);
    dragOver <span class="operator">=</span> <span class="keyword">false</span>;
    update();
}</pre></div>
<p>The <a href="./qgraphicsitem.htm#dragLeaveEvent" translate="no">dragLeaveEvent()</a> handler is called when a Drag and Drop element is dragged away from the robot part's area. Our implementation simply resets <i>dragOver</i> to false and calls <a href="./qgraphicsitem.htm#update" translate="no">update()</a> to help provide visual feedback that the drag has left this item.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> RobotPart<span class="operator">::</span>dropEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event)
{
    dragOver <span class="operator">=</span> <span class="keyword">false</span>;
    <span class="keyword">if</span> (event<span class="operator">-</span><span class="operator">&gt;</span>mimeData()<span class="operator">-</span><span class="operator">&gt;</span>hasColor())
        color <span class="operator">=</span> qvariant_cast<span class="operator">&lt;</span><span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span><span class="operator">&gt;</span>(event<span class="operator">-</span><span class="operator">&gt;</span>mimeData()<span class="operator">-</span><span class="operator">&gt;</span>colorData());
    update();
}</pre></div>
<p>The <a href="./qgraphicsitem.htm#dropEvent" translate="no">dropEvent()</a> handler is called when a Drag and Drop element is dropped onto an item (i.e., when the mouse button is released over the item while dragging).</p>
<p>We reset <code translate="no">dragOver</code> to false, assign the item's new color, and call <a href="./qgraphicsitem.htm#update" translate="no">update()</a>.</p>
<p>The declaration and implementation of <code translate="no">RobotHead</code>, <code translate="no">RobotTorso</code>, and <code translate="no">RobotLimb</code> are practically identical. We will review <code translate="no">RobotHead</code> in detail, as this class has one minor difference, and leave the other classes as an exercise for the reader.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> RobotHead : <span class="keyword">public</span> RobotPart
{
<span class="keyword">public</span>:
    RobotHead(<span class="type"><a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);

    <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> boundingRect() <span class="keyword">const</span> override;
    <span class="type">void</span> paint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstyleoptiongraphicsitem.htm" translate="no">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span>option<span class="operator">,</span> <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>widget <span class="operator">=</span> nullptr) override;

<span class="keyword">protected</span>:
    <span class="type">void</span> dragEnterEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event) override;
    <span class="type">void</span> dropEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event) override;

<span class="keyword">private</span>:
    <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> pixmap;
};</pre></div>
<p>The <code translate="no">RobotHead</code> class inherits <code translate="no">RobotPart</code> and provides the necessary implementations of <a href="./qgraphicsitem.htm#boundingRect" translate="no">boundingRect()</a> and <a href="./qgraphicsitem.htm#paint" translate="no">paint()</a>. It also reimplements <a href="./qgraphicsitem.htm#dragEnterEvent" translate="no">dragEnterEvent()</a> and dropEvent() to provide special handling of image drops.</p>
<p>The class contains a private pixmap member that we can use to implement support for accepting image drops.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">RobotHead<span class="operator">::</span>RobotHead(<span class="type"><a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a></span> <span class="operator">*</span>parent)
    : RobotPart(parent)
{
}</pre></div>
<p><code translate="no">RobotHead</code> has a rather plain constructor that simply forwards to <code translate="no">RobotPart</code>'s constructor.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> RobotHead<span class="operator">::</span>boundingRect() <span class="keyword">const</span>
{
    <span class="keyword">return</span> <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span>(<span class="operator">-</span><span class="number">15</span><span class="operator">,</span> <span class="operator">-</span><span class="number">50</span><span class="operator">,</span> <span class="number">30</span><span class="operator">,</span> <span class="number">50</span>);
}</pre></div>
<p>The <a href="./qgraphicsitem.htm#boundingRect" translate="no">boundingRect()</a> reimplementation returns the extents for the head. Because we want the center of rotation to be the bottom center of the item, we have chosen a bounding rectangle that starts at (-15, -50) and extends to 30 units wide and 50 units tall. When rotating the head, the "neck" will stay still while the top of the head tilts from side to side.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> RobotHead<span class="operator">::</span>paint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span>
           <span class="keyword">const</span> <span class="type"><a href="./qstyleoptiongraphicsitem.htm" translate="no">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span>option<span class="operator">,</span> <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>widget)
{
    Q_UNUSED(option);
    Q_UNUSED(widget);
    <span class="keyword">if</span> (pixmap<span class="operator">.</span>isNull()) {
        painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(dragOver <span class="operator">?</span> color<span class="operator">.</span>lighter(<span class="number">130</span>) : color);
        painter<span class="operator">-</span><span class="operator">&gt;</span>drawRoundedRect(<span class="operator">-</span><span class="number">10</span><span class="operator">,</span> <span class="operator">-</span><span class="number">30</span><span class="operator">,</span> <span class="number">20</span><span class="operator">,</span> <span class="number">30</span><span class="operator">,</span> <span class="number">25</span><span class="operator">,</span> <span class="number">25</span><span class="operator">,</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>RelativeSize);
        painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>white);
        painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="operator">-</span><span class="number">7</span><span class="operator">,</span> <span class="operator">-</span><span class="number">3</span> <span class="operator">-</span> <span class="number">20</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">7</span>);
        painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="number">0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">3</span> <span class="operator">-</span> <span class="number">20</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">7</span>);
        painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>black);
        painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="operator">-</span><span class="number">5</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">-</span> <span class="number">20</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>);
        painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="number">2</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">-</span> <span class="number">20</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span>);
        painter<span class="operator">-</span><span class="operator">&gt;</span>setPen(<span class="type"><a href="./qpen.htm" translate="no">QPen</a></span>(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>black<span class="operator">,</span> <span class="number">2</span>));
        painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>NoBrush);
        painter<span class="operator">-</span><span class="operator">&gt;</span>drawArc(<span class="operator">-</span><span class="number">6</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span> <span class="operator">-</span> <span class="number">20</span><span class="operator">,</span> <span class="number">12</span><span class="operator">,</span> <span class="number">15</span><span class="operator">,</span> <span class="number">190</span> <span class="operator">*</span> <span class="number">16</span><span class="operator">,</span> <span class="number">160</span> <span class="operator">*</span> <span class="number">16</span>);
    } <span class="keyword">else</span> {
        painter<span class="operator">-</span><span class="operator">&gt;</span>scale(<span class="operator">.</span><span class="number">2272</span><span class="operator">,</span> <span class="operator">.</span><span class="number">2824</span>);
        painter<span class="operator">-</span><span class="operator">&gt;</span>drawPixmap(<span class="type"><a href="./qpointf.htm" translate="no">QPointF</a></span>(<span class="operator">-</span><span class="number">15</span> <span class="operator">*</span> <span class="number">4.4</span><span class="operator">,</span> <span class="operator">-</span><span class="number">50</span> <span class="operator">*</span> <span class="number">3.54</span>)<span class="operator">,</span> pixmap);
    }
}</pre></div>
<p>In <a href="./qgraphicsitem.htm#paint" translate="no">paint()</a> we draw the actual head. The implementation is split into two sections; if an image has been dropped onto the head, we draw the image, otherwise we draw a round rectangular robot head with simple vector graphics.</p>
<p>For performance reasons, depending on the complexity of what is painted, it can often be faster to draw the head as an image rather than using a sequence of vector operations.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> RobotHead<span class="operator">::</span>dragEnterEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event)
{
    <span class="keyword">if</span> (event<span class="operator">-</span><span class="operator">&gt;</span>mimeData()<span class="operator">-</span><span class="operator">&gt;</span>hasImage()) {
        event<span class="operator">-</span><span class="operator">&gt;</span>setAccepted(<span class="keyword">true</span>);
        dragOver <span class="operator">=</span> <span class="keyword">true</span>;
        update();
    } <span class="keyword">else</span> {
        RobotPart<span class="operator">::</span>dragEnterEvent(event);
    }
}</pre></div>
<p>The robot head can accept image drops. In order to support this, its reimplementation of <a href="./qgraphicsitem.htm#dragEnterEvent" translate="no">dragEnterEvent()</a> checks if the drag object contains image data, and if it does, then the event is accepted. Otherwise we fall back to the base <code translate="no">RobotPart</code> implementation.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> RobotHead<span class="operator">::</span>dropEvent(<span class="type"><a href="./qgraphicsscenedragdropevent.htm" translate="no">QGraphicsSceneDragDropEvent</a></span> <span class="operator">*</span>event)
{
    <span class="keyword">if</span> (event<span class="operator">-</span><span class="operator">&gt;</span>mimeData()<span class="operator">-</span><span class="operator">&gt;</span>hasImage()) {
        dragOver <span class="operator">=</span> <span class="keyword">false</span>;
        pixmap <span class="operator">=</span> qvariant_cast<span class="operator">&lt;</span><span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span><span class="operator">&gt;</span>(event<span class="operator">-</span><span class="operator">&gt;</span>mimeData()<span class="operator">-</span><span class="operator">&gt;</span>imageData());
        update();
    } <span class="keyword">else</span> {
        RobotPart<span class="operator">::</span>dropEvent(event);
    }
}</pre></div>
<p>To follow up on image support, we must also implement <a href="./qgraphicsitem.htm#dropEvent" translate="no">dropEvent()</a>. We check if the drag object contains image data, and if it does, we store this data as a member pixmap and call <a href="./qgraphicsitem.htm#update" translate="no">update()</a>. This pixmap is used inside the <a href="./qgraphicsitem.htm#paint" translate="no">paint()</a> implementation that we reviewed before.</p>
<p><code translate="no">RobotTorso</code> and <code translate="no">RobotLimb</code> are similar to <code translate="no">RobotHead</code>, so let's skip directly to the <code translate="no">Robot</code> class.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> Robot : <span class="keyword">public</span> RobotPart
{
<span class="keyword">public</span>:
    Robot(<span class="type"><a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a></span> <span class="operator">*</span>parent <span class="operator">=</span> nullptr);

    <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> boundingRect() <span class="keyword">const</span> override;
    <span class="type">void</span> paint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstyleoptiongraphicsitem.htm" translate="no">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span>option<span class="operator">,</span> <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>widget <span class="operator">=</span> nullptr) override;
};</pre></div>
<p>The <code translate="no">Robot</code> class also inherits <code translate="no">RobotPart</code>, and like the other parts it also implements <a href="./qgraphicsitem.htm#boundingRect" translate="no">boundingRect()</a> and <a href="./qgraphicsitem.htm#paint" translate="no">paint()</a>. It provides a rather special implementation, though:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> Robot<span class="operator">::</span>boundingRect() <span class="keyword">const</span>
{
    <span class="keyword">return</span> <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span>();
}

<span class="type">void</span> Robot<span class="operator">::</span>paint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span>
                  <span class="keyword">const</span> <span class="type"><a href="./qstyleoptiongraphicsitem.htm" translate="no">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span>option<span class="operator">,</span> <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>widget)
{
    Q_UNUSED(painter);
    Q_UNUSED(option);
    Q_UNUSED(widget);
}</pre></div>
<p>Because the <code translate="no">Robot</code> class is only used as a base node for the rest of the robot, it has no visual representation. Its <a href="./qgraphicsitem.htm#boundingRect" translate="no">boundingRect()</a> implementation can therefore return a null <a href="./qrectf.htm" translate="no">QRectF</a>, and its paint() function does nothing.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">Robot<span class="operator">::</span>Robot(<span class="type"><a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a></span> <span class="operator">*</span>parent)
    : RobotPart(parent)
{
    setFlag(ItemHasNoContents);

    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>torsoItem <span class="operator">=</span> <span class="keyword">new</span> RobotTorso(<span class="keyword">this</span>);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>headItem <span class="operator">=</span> <span class="keyword">new</span> RobotHead(torsoItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>upperLeftArmItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(torsoItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>lowerLeftArmItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(upperLeftArmItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>upperRightArmItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(torsoItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>lowerRightArmItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(upperRightArmItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>upperRightLegItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(torsoItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>lowerRightLegItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(upperRightLegItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>upperLeftLegItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(torsoItem);
    <span class="type"><a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a></span> <span class="operator">*</span>lowerLeftLegItem <span class="operator">=</span> <span class="keyword">new</span> RobotLimb(upperLeftLegItem);</pre></div>
<p>The constructor starts by setting the flag <a href="./qgraphicsitem.htm#GraphicsItemFlag-enum" translate="no">ItemHasNoContents</a>, which is a minor optimization for items that have no visual appearance.</p>
<p>We then construct all the robot parts (head, torso, and upper/lower arms and legs). The stacking order is very important, and we use the parent-child hierarchy to ensure the elements rotate and move properly. We construct the torso first, as this is the root element. We then construct the head and pass the torso to <code translate="no">HeadItem</code>'s constructor. This will make the head a child of the torso; if you rotate the torso, the head will follow. The same pattern is applied to the rest of the limbs.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    headItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">18</span>);
    upperLeftArmItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="operator">-</span><span class="number">15</span><span class="operator">,</span> <span class="operator">-</span><span class="number">10</span>);
    lowerLeftArmItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">30</span><span class="operator">,</span> <span class="number">0</span>);
    upperRightArmItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">15</span><span class="operator">,</span> <span class="operator">-</span><span class="number">10</span>);
    lowerRightArmItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">30</span><span class="operator">,</span> <span class="number">0</span>);
    upperRightLegItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">10</span><span class="operator">,</span> <span class="number">32</span>);
    lowerRightLegItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">30</span><span class="operator">,</span> <span class="number">0</span>);
    upperLeftLegItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="operator">-</span><span class="number">10</span><span class="operator">,</span> <span class="number">32</span>);
    lowerLeftLegItem<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">30</span><span class="operator">,</span> <span class="number">0</span>);</pre></div>
<p>Each robot part is carefully positioned. For example, the upper left arm is moved precisely to the top-left area of the torso, and the upper right arm is moved to the top-right area.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qparallelanimationgroup.htm" translate="no">QParallelAnimationGroup</a></span> <span class="operator">*</span>animation <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qparallelanimationgroup.htm" translate="no">QParallelAnimationGroup</a></span>(<span class="keyword">this</span>);

    <span class="type"><a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a></span> <span class="operator">*</span>headAnimation <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a></span>(headItem<span class="operator">,</span> <span class="string">"rotation"</span>);
    headAnimation<span class="operator">-</span><span class="operator">&gt;</span>setStartValue(<span class="number">20</span>);
    headAnimation<span class="operator">-</span><span class="operator">&gt;</span>setEndValue(<span class="operator">-</span><span class="number">20</span>);
    <span class="type"><a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a></span> <span class="operator">*</span>headScaleAnimation <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a></span>(headItem<span class="operator">,</span> <span class="string">"scale"</span>);
    headScaleAnimation<span class="operator">-</span><span class="operator">&gt;</span>setEndValue(<span class="number">1.1</span>);
    animation<span class="operator">-</span><span class="operator">&gt;</span>addAnimation(headAnimation);
    animation<span class="operator">-</span><span class="operator">&gt;</span>addAnimation(headScaleAnimation);</pre></div>
<p>The next section creates all animation objects. This snippet shows the two animations that operate on the head's scale and rotation. The two <a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a> instances simply set the object, property, and respective start and end values.</p>
<p>All animations are controlled by one top-level parallel animation group. The scale and rotation animations are added to this group.</p>
<p>The rest of the animations are defined in a similar way.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> animation<span class="operator">-</span><span class="operator">&gt;</span>animationCount(); <span class="operator">+</span><span class="operator">+</span>i) {
        <span class="type"><a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a></span> <span class="operator">*</span>anim <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qpropertyanimation.htm" translate="no">QPropertyAnimation</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(animation<span class="operator">-</span><span class="operator">&gt;</span>animationAt(i));
        anim<span class="operator">-</span><span class="operator">&gt;</span>setEasingCurve(<span class="type"><a href="./qeasingcurve.htm" translate="no">QEasingCurve</a></span><span class="operator">::</span>SineCurve);
        anim<span class="operator">-</span><span class="operator">&gt;</span>setDuration(<span class="number">2000</span>);
    }

    animation<span class="operator">-</span><span class="operator">&gt;</span>setLoopCount(<span class="operator">-</span><span class="number">1</span>);
    animation<span class="operator">-</span><span class="operator">&gt;</span>start();</pre></div>
<p>Finally we set an easing curve and duration on each animation, ensure the toplevel animation group loops forever, and start the toplevel animation.</p>
<a name="coloritem-class-definition"></a>
<h4 id="coloritem-class-definition">ColorItem Class Definition<a class="plink" href="#coloritem-class-definition" title="Direct link to this headline"></a></h4>
<p>The <code translate="no">ColorItem</code> class represents a circular item that can be pressed to drag colors onto robot parts.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> ColorItem : <span class="keyword">public</span> <span class="type"><a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a></span>
{
<span class="keyword">public</span>:
    ColorItem();

    <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> boundingRect() <span class="keyword">const</span> override;
    <span class="type">void</span> paint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstyleoptiongraphicsitem.htm" translate="no">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span>option<span class="operator">,</span> <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>widget) override;

<span class="keyword">protected</span>:
    <span class="type">void</span> mousePressEvent(<span class="type"><a href="./qgraphicsscenemouseevent.htm" translate="no">QGraphicsSceneMouseEvent</a></span> <span class="operator">*</span>event) override;
    <span class="type">void</span> mouseMoveEvent(<span class="type"><a href="./qgraphicsscenemouseevent.htm" translate="no">QGraphicsSceneMouseEvent</a></span> <span class="operator">*</span>event) override;
    <span class="type">void</span> mouseReleaseEvent(<span class="type"><a href="./qgraphicsscenemouseevent.htm" translate="no">QGraphicsSceneMouseEvent</a></span> <span class="operator">*</span>event) override;

<span class="keyword">private</span>:
    <span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span> color;
};</pre></div>
<p>This class is very simple. It does not use animations, and has no need for properties nor signals and slots, so to save resources, it's most natural that it inherits <a href="./qgraphicsitem.htm" translate="no">QGraphicsItem</a> (as opposed to <a href="./qgraphicsobject.htm" translate="no">QGraphicsObject</a>).</p>
<p>It declares the mandatory <a href="./qgraphicsitem.htm#boundingRect" translate="no">boundingRect()</a> and <a href="./qgraphicsitem.htm#paint" translate="no">paint()</a> functions, and adds reimplementations of <a href="./qgraphicsitem.htm#mousePressEvent" translate="no">mousePressEvent()</a>, <a href="./qgraphicsitem.htm#mouseMoveEvent" translate="no">mouseMoveEvent()</a>, and <a href="./qgraphicsitem.htm#mouseReleaseEvent" translate="no">mouseReleaseEvent()</a>. It contains a single private color member.</p>
<p>Let's take a look at its implementation.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">ColorItem<span class="operator">::</span>ColorItem()
    : color(<span class="type"><a href="./qrandomgenerator.htm" translate="no">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">256</span>)<span class="operator">,</span> <span class="type"><a href="./qrandomgenerator.htm" translate="no">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">256</span>)<span class="operator">,</span> <span class="type"><a href="./qrandomgenerator.htm" translate="no">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">256</span>))
{
    setToolTip(<span class="type"><a href="./qstring.htm" translate="no">QString</a></span>(<span class="string">"QColor(%1, %2, %3)\n%4"</span>)
              <span class="operator">.</span>arg(color<span class="operator">.</span>red())<span class="operator">.</span>arg(color<span class="operator">.</span>green())<span class="operator">.</span>arg(color<span class="operator">.</span>blue())
              <span class="operator">.</span>arg(<span class="string">"Click and drag this color onto the robot!"</span>));
    setCursor(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>OpenHandCursor);
    setAcceptedMouseButtons(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>LeftButton);
}</pre></div>
<p><code translate="no">ColorItem</code>'s constructor assigns an opaque random color to its color member by making use of <a href="./qrandomgenerator.htm" translate="no">QRandomGenerator</a>. For improved usability, it assigns a tooltip that provides a useful hint to the user, and it also sets a suitable cursor. This ensures that the cursor will chance to <a href="./qt.htm#CursorShape-enum" translate="no">Qt::OpenHandCursor</a> when the mouse pointer hovers over the item.</p>
<p>Finally, we call <a href="./qgraphicsitem.htm#setAcceptedMouseButtons" translate="no">setAcceptedMouseButtons()</a> to ensure that this item can only process <a href="./qt.htm#MouseButton-enum" translate="no">Qt::LeftButton</a>. This simplifies the mouse event handlers greatly, as we can always assume that only the left mouse button is pressed and released.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> ColorItem<span class="operator">::</span>boundingRect() <span class="keyword">const</span>
{
    <span class="keyword">return</span> <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span>(<span class="operator">-</span><span class="number">15.5</span><span class="operator">,</span> <span class="operator">-</span><span class="number">15.5</span><span class="operator">,</span> <span class="number">34</span><span class="operator">,</span> <span class="number">34</span>);
}</pre></div>
<p>The item's bounding rect is a fixed 30x30 units centered around the item's origin (0, 0), and adjusted by 0.5 units in all directions to allow a scalable pen to draw its outline. For a final visual touch the bounds also compensate with a few units down and to the right to make room for a simple dropshadow.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> ColorItem<span class="operator">::</span>paint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">*</span>painter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstyleoptiongraphicsitem.htm" translate="no">QStyleOptionGraphicsItem</a></span> <span class="operator">*</span>option<span class="operator">,</span> <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>widget)
{
    Q_UNUSED(option);
    Q_UNUSED(widget);
    painter<span class="operator">-</span><span class="operator">&gt;</span>setPen(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>NoPen);
    painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>darkGray);
    painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="operator">-</span><span class="number">12</span><span class="operator">,</span> <span class="operator">-</span><span class="number">12</span><span class="operator">,</span> <span class="number">30</span><span class="operator">,</span> <span class="number">30</span>);
    painter<span class="operator">-</span><span class="operator">&gt;</span>setPen(<span class="type"><a href="./qpen.htm" translate="no">QPen</a></span>(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>black<span class="operator">,</span> <span class="number">1</span>));
    painter<span class="operator">-</span><span class="operator">&gt;</span>setBrush(<span class="type"><a href="./qbrush.htm" translate="no">QBrush</a></span>(color));
    painter<span class="operator">-</span><span class="operator">&gt;</span>drawEllipse(<span class="operator">-</span><span class="number">15</span><span class="operator">,</span> <span class="operator">-</span><span class="number">15</span><span class="operator">,</span> <span class="number">30</span><span class="operator">,</span> <span class="number">30</span>);
}</pre></div>
<p>The <a href="./qgraphicsitem.htm#paint" translate="no">paint()</a> implementation draws an ellipse with a 1-unit black outline, a plain color fill, and a dark gray dropshadow.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> ColorItem<span class="operator">::</span>mousePressEvent(<span class="type"><a href="./qgraphicsscenemouseevent.htm" translate="no">QGraphicsSceneMouseEvent</a></span> <span class="operator">*</span>)
{
    setCursor(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>ClosedHandCursor);
}</pre></div>
<p>The <a href="./qgraphicsitem.htm#mousePressEvent" translate="no">mousePressEvent()</a> handler is called when you press the mouse button inside the item's area. Our implementation simply sets the cursor to <a href="./qt.htm#CursorShape-enum" translate="no">Qt::ClosedHandCursor</a>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> ColorItem<span class="operator">::</span>mouseReleaseEvent(<span class="type"><a href="./qgraphicsscenemouseevent.htm" translate="no">QGraphicsSceneMouseEvent</a></span> <span class="operator">*</span>)
{
    setCursor(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>OpenHandCursor);
}</pre></div>
<p>The <a href="./qgraphicsitem.htm#mouseReleaseEvent" translate="no">mouseReleaseEvent()</a> handler is called when you release the mouse button after having pressed it inside an item's area. Our implementation sets the cursor back to <a href="./qt.htm#CursorShape-enum" translate="no">Qt::OpenHandCursor</a>. The mouse press and release event handlers together provide useful visual feedback to the user: when you move the mouse pointer over a <code translate="no">CircleItem</code>, the cursor changes to an open hand. Pressing the item will show a closed hand cursor. Releasing will restore to an open hand cursor again.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> ColorItem<span class="operator">::</span>mouseMoveEvent(<span class="type"><a href="./qgraphicsscenemouseevent.htm" translate="no">QGraphicsSceneMouseEvent</a></span> <span class="operator">*</span>event)
{
    <span class="keyword">if</span> (<span class="type"><a href="./qlinef.htm" translate="no">QLineF</a></span>(event<span class="operator">-</span><span class="operator">&gt;</span>screenPos()<span class="operator">,</span> event<span class="operator">-</span><span class="operator">&gt;</span>buttonDownScreenPos(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>LeftButton))
        <span class="operator">.</span>length() <span class="operator">&lt;</span> <span class="type"><a href="./qapplication.htm" translate="no">QApplication</a></span><span class="operator">::</span>startDragDistance()) {
        <span class="keyword">return</span>;
    }

    <span class="type"><a href="./qdrag.htm" translate="no">QDrag</a></span> <span class="operator">*</span>drag <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qdrag.htm" translate="no">QDrag</a></span>(event<span class="operator">-</span><span class="operator">&gt;</span>widget());
    <span class="type"><a href="./qmimedata.htm" translate="no">QMimeData</a></span> <span class="operator">*</span>mime <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qmimedata.htm" translate="no">QMimeData</a></span>;
    drag<span class="operator">-</span><span class="operator">&gt;</span>setMimeData(mime);</pre></div>
<p>The <a href="./qgraphicsitem.htm#mouseMoveEvent" translate="no">mouseMoveEvent()</a> handler is called when you move the mouse around after pressing the mouse button inside the <code translate="no">ColorItem</code>'s area. This implementation provides the most important piece of logic for <code translate="no">CircleItem</code>: the code that starts and manages drags.</p>
<p>The implementation starts by checking if the mouse has been dragged far enough to eliminate mouse jitter noise. We only want to start a drag if the mouse has been dragged farther than the application start drag distance.</p>
<p>Continuing, we create a <a href="./qdrag.htm" translate="no">QDrag</a> object, passing the event <a href="./qgraphicssceneevent.htm#widget" translate="no">widget</a> (i.e., the <a href="./qgraphicsview.htm" translate="no">QGraphicsView</a> viewport) to its constructor. Qt will ensure that this object is deleted at the right time. We also create a <a href="./qmimedata.htm" translate="no">QMimeData</a> instance that can contain our color or image data, and assign this to the drag object.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="keyword">static</span> <span class="type">int</span> n <span class="operator">=</span> <span class="number">0</span>;
    <span class="keyword">if</span> (n<span class="operator">+</span><span class="operator">+</span> <span class="operator">&gt;</span> <span class="number">2</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="type"><a href="./qrandomgenerator.htm" translate="no">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">3</span>) <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) {
        <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> image(<span class="string">":/images/head.png"</span>);
        mime<span class="operator">-</span><span class="operator">&gt;</span>setImageData(image);

        drag<span class="operator">-</span><span class="operator">&gt;</span>setPixmap(<span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span><span class="operator">::</span>fromImage(image)<span class="operator">.</span>scaled(<span class="number">30</span><span class="operator">,</span> <span class="number">40</span>));
        drag<span class="operator">-</span><span class="operator">&gt;</span>setHotSpot(<span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span>(<span class="number">15</span><span class="operator">,</span> <span class="number">30</span>));</pre></div>
<p>This snippet has a somewhat random outcome: once in a while, a special image is assigned to the drag object's mime data. The pixmap is also assiged as the drag object's pixmap. This will ensure that you can see the image that is being dragged as a pixmap under the mouse cursor.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    } <span class="keyword">else</span> {
        mime<span class="operator">-</span><span class="operator">&gt;</span>setColorData(color);
        mime<span class="operator">-</span><span class="operator">&gt;</span>setText(<span class="type"><a href="./qstring.htm" translate="no">QString</a></span>(<span class="string">"#%1%2%3"</span>)
                      <span class="operator">.</span>arg(color<span class="operator">.</span>red()<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> QLatin1Char(<span class="char">'0'</span>))
                      <span class="operator">.</span>arg(color<span class="operator">.</span>green()<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> QLatin1Char(<span class="char">'0'</span>))
                      <span class="operator">.</span>arg(color<span class="operator">.</span>blue()<span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">16</span><span class="operator">,</span> QLatin1Char(<span class="char">'0'</span>)));

        <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> pixmap(<span class="number">34</span><span class="operator">,</span> <span class="number">34</span>);
        pixmap<span class="operator">.</span>fill(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>white);

        <span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> painter(<span class="operator">&amp;</span>pixmap);
        painter<span class="operator">.</span>translate(<span class="number">15</span><span class="operator">,</span> <span class="number">15</span>);
        painter<span class="operator">.</span>setRenderHint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span><span class="operator">::</span>Antialiasing);
        paint(<span class="operator">&amp;</span>painter<span class="operator">,</span> nullptr<span class="operator">,</span> nullptr);
        painter<span class="operator">.</span>end();

        pixmap<span class="operator">.</span>setMask(pixmap<span class="operator">.</span>createHeuristicMask());

        drag<span class="operator">-</span><span class="operator">&gt;</span>setPixmap(pixmap);
        drag<span class="operator">-</span><span class="operator">&gt;</span>setHotSpot(<span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span>(<span class="number">15</span><span class="operator">,</span> <span class="number">20</span>));
    }</pre></div>
<p>Otherwise, and this is the most common outcome, a simple color is assigned to the drag object's mime data. We render this <code translate="no">ColorItem</code> into a new pixmap to give the user visual feedback that the color is being "dragged".</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    drag<span class="operator">-</span><span class="operator">&gt;</span>exec();
    setCursor(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>OpenHandCursor);
}</pre></div>
<p>Finally we execute the drag. <a href="./qdrag.htm#exec" translate="no">QDrag::exec</a>() will reenter the event loop, and only exit if the drag has either been dropped, or canceled. In any case we reset the cursor to <a href="./qt.htm#CursorShape-enum" translate="no">Qt::OpenHandCursor</a>.</p>
<a name="the-main-function"></a>
<h4 id="the-main-function">The main() Function<a class="plink" href="#the-main-function" title="Direct link to this headline"></a></h4>
<p>Now that the <code translate="no">Robot</code> and <code translate="no">ColorItem</code> classes are complete, we can put all the pieces together inside the main() function.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span><span class="operator">*</span>argv)
{
    <span class="type"><a href="./qapplication.htm" translate="no">QApplication</a></span> app(argc<span class="operator">,</span> argv);</pre></div>
<p>We start off by constructing <a href="./qapplication.htm" translate="no">QApplication</a>, and initializing the random number generator. This ensures that the color items have different colors every time the application starts.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="type"><a href="./qgraphicsscene.htm" translate="no">QGraphicsScene</a></span> scene(<span class="operator">-</span><span class="number">200</span><span class="operator">,</span> <span class="operator">-</span><span class="number">200</span><span class="operator">,</span> <span class="number">400</span><span class="operator">,</span> <span class="number">400</span>);

    <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">10</span>; <span class="operator">+</span><span class="operator">+</span>i) {
        ColorItem <span class="operator">*</span>item <span class="operator">=</span> <span class="keyword">new</span> ColorItem;
        item<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="operator">::</span>sin((i <span class="operator">*</span> <span class="number">6.28</span>) <span class="operator">/</span> <span class="number">10.0</span>) <span class="operator">*</span> <span class="number">150</span><span class="operator">,</span>
                     <span class="operator">::</span>cos((i <span class="operator">*</span> <span class="number">6.28</span>) <span class="operator">/</span> <span class="number">10.0</span>) <span class="operator">*</span> <span class="number">150</span>);

        scene<span class="operator">.</span>addItem(item);
    }

    Robot <span class="operator">*</span>robot <span class="operator">=</span> <span class="keyword">new</span> Robot;
    robot<span class="operator">-</span><span class="operator">&gt;</span>setTransform(<span class="type"><a href="./qtransform.htm" translate="no">QTransform</a></span><span class="operator">::</span>fromScale(<span class="number">1.2</span><span class="operator">,</span> <span class="number">1.2</span>)<span class="operator">,</span> <span class="keyword">true</span>);
    robot<span class="operator">-</span><span class="operator">&gt;</span>setPos(<span class="number">0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">20</span>);
    scene<span class="operator">.</span>addItem(robot);</pre></div>
<p>We construct a fixed size scene, and create 10 <code translate="no">ColorItem</code> instances arranged in a circle. Each item is added to the scene.</p>
<p>In the center of this circle we create one <code translate="no">Robot</code> instance. The robot is scaled and moved up a few units. It is then added to the scene.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    GraphicsView view(<span class="operator">&amp;</span>scene);
    view<span class="operator">.</span>setRenderHint(<span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span><span class="operator">::</span>Antialiasing);
    view<span class="operator">.</span>setViewportUpdateMode(<span class="type"><a href="./qgraphicsview.htm" translate="no">QGraphicsView</a></span><span class="operator">::</span>BoundingRectViewportUpdate);
    view<span class="operator">.</span>setBackgroundBrush(<span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span>(<span class="number">230</span><span class="operator">,</span> <span class="number">200</span><span class="operator">,</span> <span class="number">167</span>));
    view<span class="operator">.</span>setWindowTitle(<span class="string">"Drag and Drop Robot"</span>);
    view<span class="operator">.</span>show();

    <span class="keyword">return</span> app<span class="operator">.</span>exec();
}</pre></div>
<p>Finally we create a <a href="./qgraphicsview.htm" translate="no">QGraphicsView</a> window, and assign the scene to it.</p>
<p>For increased visual quality, we enable antialiasing. We also choose to use bounding rectangle updates to simplify visual update handling. The view is given a fixed sand-colored background, and a window title.</p>
<p>We then show the view. The animations start immediately after control enters the event loop.</p>
<p><a href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/graphicsview/dragdroprobot?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@graphicsview/dragdroprobot -->
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>