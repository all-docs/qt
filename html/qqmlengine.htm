<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QQmlEngine | Qt QML</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qqmlengine.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtqml-index.htm" translate="no">Qt QML</a></li>
                            <li><a href="./qtqml-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QQmlEngine</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QQmlEngine Class</h1>
<!-- $$$QQmlEngine-brief -->
<p>The QQmlEngine class provides an environment for instantiating QML components. <a href="#details">More...</a></p>
<!-- @@@QQmlEngine -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQmlEngine&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += qml</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qjsengine.htm" translate="no">QJSEngine</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qqmlapplicationengine.htm" translate="no">QQmlApplicationEngine</a></p>
</td></tr></tbody></table></div><p>This class was introduced in Qt 5.0.</p>
<ul>
<li><a href="./qqmlengine-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qqmlengine-obsolete.htm">Obsolete members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#ObjectOwnership-enum" translate="no">ObjectOwnership</a></b> { CppOwnership, JavaScriptOwnership }</td></tr>
</tbody></table></div>
<a name="properties"></a>
<h2 id="properties">Properties<a class="plink" href="#properties" title="Direct link to this headline"></a></h2>
<ul>
<li class="fn" translate="no"><b><a href="./qqmlengine.htm#offlineStoragePath-prop" translate="no">offlineStoragePath</a></b> : QString</li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#dtor.QQmlEngine" translate="no">~QQmlEngine</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#addImageProvider" translate="no">addImageProvider</a></b>(const QString &amp;<i>providerId</i>, QQmlImageProviderBase *<i>provider</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#addImportPath" translate="no">addImportPath</a></b>(const QString &amp;<i>path</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#addPluginPath" translate="no">addPluginPath</a></b>(const QString &amp;<i>path</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#baseUrl" translate="no">baseUrl</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#clearComponentCache" translate="no">clearComponentCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlImageProviderBase *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#imageProvider" translate="no">imageProvider</a></b>(const QString &amp;<i>providerId</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#importPathList" translate="no">importPathList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#importPlugin" translate="no">importPlugin</a></b>(const QString &amp;<i>filePath</i>, const QString &amp;<i>uri</i>, QList&lt;QQmlError&gt; *<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlIncubationController *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#incubationController" translate="no">incubationController</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkAccessManager *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#networkAccessManager" translate="no">networkAccessManager</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlNetworkAccessManagerFactory *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#networkAccessManagerFactory" translate="no">networkAccessManagerFactory</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#offlineStorageDatabaseFilePath" translate="no">offlineStorageDatabaseFilePath</a></b>(const QString &amp;<i>databaseName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#offlineStoragePath-prop" translate="no">offlineStoragePath</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#outputWarningsToStandardError" translate="no">outputWarningsToStandardError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#pluginPathList" translate="no">pluginPathList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#removeImageProvider" translate="no">removeImageProvider</a></b>(const QString &amp;<i>providerId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#rootContext" translate="no">rootContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setBaseUrl" translate="no">setBaseUrl</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setImportPathList" translate="no">setImportPathList</a></b>(const QStringList &amp;<i>paths</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setIncubationController" translate="no">setIncubationController</a></b>(QQmlIncubationController *<i>controller</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setNetworkAccessManagerFactory" translate="no">setNetworkAccessManagerFactory</a></b>(QQmlNetworkAccessManagerFactory *<i>factory</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#offlineStoragePath-prop" translate="no">setOfflineStoragePath</a></b>(const QString &amp;<i>dir</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setOutputWarningsToStandardError" translate="no">setOutputWarningsToStandardError</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setPluginPathList" translate="no">setPluginPathList</a></b>(const QStringList &amp;<i>paths</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#singletonInstance" translate="no">singletonInstance</a></b>(int <i>qmlTypeId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#trimComponentCache" translate="no">trimComponentCache</a></b>()</td></tr>
</tbody></table></div>
<a name="public-slots"></a>
<h2 id="public-slots">Public Slots<a class="plink" href="#public-slots" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#retranslate" translate="no">retranslate</a></b>()</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#exit" translate="no">exit</a></b>(int <i>retCode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#quit" translate="no">quit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#warnings" translate="no">warnings</a></b>(const QList&lt;QQmlError&gt; &amp;<i>warnings</i>)</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#contextForObject" translate="no">contextForObject</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlEngine::ObjectOwnership </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#objectOwnership" translate="no">objectOwnership</a></b>(QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setContextForObject" translate="no">setContextForObject</a></b>(QObject *<i>object</i>, QQmlContext *<i>context</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#setObjectOwnership" translate="no">setObjectOwnership</a></b>(QObject *<i>object</i>, QQmlEngine::ObjectOwnership <i>ownership</i>)</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
</tbody></table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members<a class="plink" href="#related-non-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlAttachedPropertiesObject" translate="no">qmlAttachedPropertiesObject</a></b>(const QObject *<i>attachee</i>, bool <i>create</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlClearTypeRegistrations" translate="no">qmlClearTypeRegistrations</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlContext" translate="no">qmlContext</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlEngine *</td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlEngine" translate="no">qmlEngine</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlProtectModule" translate="no">qmlProtectModule</a></b>(const char *<i>uri</i>, int <i>majVersion</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterAnonymousType" translate="no">qmlRegisterAnonymousType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterExtendedType" translate="no">qmlRegisterExtendedType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterExtendedUncreatableType" translate="no">qmlRegisterExtendedUncreatableType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterInterface" translate="no">qmlRegisterInterface</a></b>(const char *<i>typeName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterModule" translate="no">qmlRegisterModule</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterRevision" translate="no">qmlRegisterRevision</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterSingletonInstance" translate="no">qmlRegisterSingletonInstance</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, QObject *<i>cppObject</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, QJSValue (*)(QQmlEngine *, QJSEngine *) <i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterSingletonType-1" translate="no">qmlRegisterSingletonType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, QObject *(*)(QQmlEngine *, QJSEngine *) <i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterSingletonType-2" translate="no">qmlRegisterSingletonType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, int <i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterSingletonType-3" translate="no">qmlRegisterSingletonType</a></b>(const QUrl &amp;<i>url</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterType" translate="no">qmlRegisterType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterType-2" translate="no">qmlRegisterType</a></b>(const QUrl &amp;<i>url</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterTypeNotAvailable" translate="no">qmlRegisterTypeNotAvailable</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterUncreatableMetaObject" translate="no">qmlRegisterUncreatableMetaObject</a></b>(const QMetaObject &amp;<i>staticMetaObject</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlRegisterUncreatableType" translate="no">qmlRegisterUncreatableType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#qmlTypeId" translate="no">qmlTypeId</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
</tbody></table></div>
<a name="macros"></a>
<h2 id="macros">Macros<a class="plink" href="#macros" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_ADDED_IN_MINOR_VERSION" translate="no">QML_ADDED_IN_MINOR_VERSION</a></b>(<i>VERSION</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_ATTACHED" translate="no">QML_ATTACHED</a></b>(<i>ATTACHED_TYPE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_DECLARE_TYPE" translate="no">QML_DECLARE_TYPE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_DECLARE_TYPEINFO" translate="no">QML_DECLARE_TYPEINFO</a></b>(<i>Type</i>, <i>Flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_EXTENDED" translate="no">QML_EXTENDED</a></b>(<i>EXTENDED_TYPE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_FOREIGN" translate="no">QML_FOREIGN</a></b>(<i>FOREIGN_TYPE</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_INTERFACE" translate="no">QML_INTERFACE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a></b>(<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_REMOVED_IN_MINOR_VERSION" translate="no">QML_REMOVED_IN_MINOR_VERSION</a></b>(<i>VERSION</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_UNAVAILABLE" translate="no">QML_UNAVAILABLE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a></b>(<i>reason</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QQmlEngine-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>Each QML component is instantiated in a <a href="./qqmlcontext.htm" translate="no">QQmlContext</a>. <a href="./qqmlcontext.htm" translate="no">QQmlContext</a>'s are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the QQmlEngine.</p>
<p>Prior to creating any QML components, an application must have created a QQmlEngine to gain access to a QML context. The following example shows how to create a simple Text item.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> engine;
<span class="type"><a href="./qqmlcomponent.htm" translate="no">QQmlComponent</a></span> component(<span class="operator">&amp;</span>engine);
component<span class="operator">.</span>setData(<span class="string">"import QtQuick 2.0\nText { text: \"Hello world!\" }"</span><span class="operator">,</span> <span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span>());
<span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span> <span class="operator">*</span>item <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(component<span class="operator">.</span>create());

<span class="comment">//add item to view, etc</span>
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span></pre></div>
<p>In this case, the Text item will be created in the engine's <a href="./qqmlengine.htm#rootContext" translate="no">root context</a>.</p>
</div>
<p><b>See also </b><a href="./qqmlcomponent.htm" translate="no">QQmlComponent</a>, <a href="./qqmlcontext.htm" translate="no">QQmlContext</a>, and <a href="./qtqml-javascript-qmlglobalobject.htm" translate="no">QML Global Object</a>.</p>
<!-- @@@QQmlEngine -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ObjectOwnership$$$CppOwnership$$$JavaScriptOwnership -->
<h3 class="fn" id="ObjectOwnership-enum" translate="no"><a name="ObjectOwnership-enum"></a>enum QQmlEngine::<span class="name">ObjectOwnership</span><a class="plink" href="#ObjectOwnership-enum" title="Direct link to this headline"></a></h3>
<p>ObjectOwnership controls whether or not QML automatically destroys the <a href="./qobject.htm" translate="no">QObject</a> when the corresponding JavaScript object is garbage collected by the engine. The two ownership options are:</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQmlEngine::CppOwnership</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The object is owned by C++ code and QML will never delete it. The JavaScript destroy() method cannot be used on these objects. This option is similar to <a href="./qscriptengine.htm#ValueOwnership-enum" translate="no">QScriptEngine::QtOwnership</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QQmlEngine::JavaScriptOwnership</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The object is owned by JavaScript. When the object is returned to QML as the return value of a method call, QML will track it and delete it if there are no remaining JavaScript references to it and it has no <a href="./qobject.htm#parent" translate="no">QObject::parent</a>(). An object tracked by one <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> will be deleted during that <a href="./qqmlengine.htm" translate="no">QQmlEngine</a>'s destructor. Thus, JavaScript references between objects with JavaScriptOwnership from two different engines will not be valid if one of these engines is deleted. This option is similar to <a href="./qscriptengine.htm#ValueOwnership-enum" translate="no">QScriptEngine::ScriptOwnership</a>.</td></tr>
</tbody></table></div>
<p>Generally an application doesn't need to set an object's ownership explicitly. QML uses a heuristic to set the default ownership. By default, an object that is created by QML has JavaScriptOwnership. The exception to this are the root objects created by calling <a href="./qqmlcomponent.htm#create" translate="no">QQmlComponent::create</a>() or <a href="./qqmlcomponent.htm#beginCreate" translate="no">QQmlComponent::beginCreate</a>(), which have CppOwnership by default. The ownership of these root-level objects is considered to have been transferred to the C++ caller.</p>
<p>Objects not-created by QML have CppOwnership by default. The exception to this are objects returned from C++ method calls; their ownership will be set to JavaScriptOwnership. This applies only to explicit invocations of <a href="./qobject.htm#Q_INVOKABLE" translate="no">Q_INVOKABLE</a> methods or slots, but not to property getter invocations.</p>
<p>Calling <a href="./qqmlengine.htm#setObjectOwnership" translate="no">setObjectOwnership</a>() overrides the default ownership heuristic used by QML.</p>
<!-- @@@ObjectOwnership -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$offlineStoragePath-prop$$$offlineStoragePath$$$setOfflineStoragePathconstQString& -->
<h3 class="fn" id="offlineStoragePath-prop" translate="no"><a name="offlineStoragePath-prop"></a><span class="name">offlineStoragePath</span> : <span class="type"><a href="./qstring.htm" translate="no">QString</a></span><a class="plink" href="#offlineStoragePath-prop" title="Direct link to this headline"></a></h3>
<p>This property holds the directory for storing offline user data</p>
<p>Returns the directory where SQL and other offline storage is placed.</p>
<p>The SQL databases created with openDatabase() are stored here.</p>
<p>The default is QML/OfflineStorage in the platform-standard user application data directory.</p>
<p>Note that the path may not currently exist on the filesystem, so callers wanting to <i>create</i> new files at this location should create it first - see <a href="./qdir.htm#mkpath" translate="no">QDir::mkpath</a>().</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>offlineStoragePath</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setOfflineStoragePath</b></span>(const QString &amp;<i>dir</i>)</td></tr>
</tbody></table></div>
<!-- @@@offlineStoragePath -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQmlEngine[overload1]$$$QQmlEngineQObject* -->
<h3 class="fn" id="QQmlEngine" translate="no"><a name="QQmlEngine"></a>QQmlEngine::<span class="name">QQmlEngine</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QQmlEngine" title="Direct link to this headline"></a></h3>
<p>Create a new QQmlEngine with the given <i translate="no">parent</i>.</p>
<!-- @@@QQmlEngine -->
<!-- $$$exit[overload1]$$$exitint -->
<h3 class="fn" id="exit" translate="no"><a name="exit"></a><code translate="no">[signal] </code><span class="type">void</span> QQmlEngine::<span class="name">exit</span>(<span class="type">int</span> <i>retCode</i>)<a class="plink" href="#exit" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the QML loaded by the engine would like to exit from the event loop with the specified return code <i translate="no">retCode</i>.</p>
<p>This function was introduced in Qt 5.8.</p>
<p><b>See also </b><a href="./qqmlengine.htm#quit" translate="no">quit</a>().</p>
<!-- @@@exit -->
<!-- $$$quit[overload1]$$$quit -->
<h3 class="fn" id="quit" translate="no"><a name="quit"></a><code translate="no">[signal] </code><span class="type">void</span> QQmlEngine::<span class="name">quit</span>()<a class="plink" href="#quit" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the QML loaded by the engine would like to quit.</p>
<p><b>See also </b><a href="./qqmlengine.htm#exit" translate="no">exit</a>().</p>
<!-- @@@quit -->
<!-- $$$retranslate[overload1]$$$retranslate -->
<h3 class="fn" id="retranslate" translate="no"><a name="retranslate"></a><code translate="no">[slot] </code><span class="type">void</span> QQmlEngine::<span class="name">retranslate</span>()<a class="plink" href="#retranslate" title="Direct link to this headline"></a></h3>
<p>Refreshes all binding expressions that use strings marked for translation.</p>
<p>Call this function after you have installed a new translator with <a href="./qcoreapplication.htm#installTranslator" translate="no">QCoreApplication::installTranslator</a>, to ensure that your user-interface shows up-to-date translations.</p>
<div class="admonition note">
<p><b>Note: </b>Due to a limitation in the implementation, this function refreshes all the engine's bindings, not only those that use strings marked for translation. This may be optimized in a future release.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<!-- @@@retranslate -->
<!-- $$$warnings[overload1]$$$warningsconstQList<QQmlError>& -->
<h3 class="fn" id="warnings" translate="no"><a name="warnings"></a><code translate="no">[signal] </code><span class="type">void</span> QQmlEngine::<span class="name">warnings</span>(const <span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qqmlerror.htm" translate="no">QQmlError</a></span>&gt; &amp;<i>warnings</i>)<a class="plink" href="#warnings" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when <i translate="no">warnings</i> messages are generated by QML.</p>
<!-- @@@warnings -->
<!-- $$$~QQmlEngine[overload1]$$$~QQmlEngine -->
<h3 class="fn" id="dtor.QQmlEngine" translate="no"><a name="dtor.QQmlEngine"></a><code translate="no">[override virtual] </code>QQmlEngine::<span class="name">~QQmlEngine</span>()<a class="plink" href="#dtor.QQmlEngine" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a>.</p>
<p>Any <a href="./qqmlcontext.htm" translate="no">QQmlContext</a>'s created on this engine will be invalidated, but not destroyed (unless they are parented to the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> object).</p>
<p>See <a href="./qjsengine.htm" translate="no">QJSEngine</a> docs for details on cleaning up the JS engine.</p>
<!-- @@@~QQmlEngine -->
<!-- $$$addImageProvider[overload1]$$$addImageProviderconstQString&QQmlImageProviderBase* -->
<h3 class="fn" id="addImageProvider" translate="no"><a name="addImageProvider"></a><span class="type">void</span> QQmlEngine::<span class="name">addImageProvider</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>providerId</i>, <span class="type"><a href="./qqmlimageproviderbase.htm" translate="no">QQmlImageProviderBase</a></span> *<i>provider</i>)<a class="plink" href="#addImageProvider" title="Direct link to this headline"></a></h3>
<p>Sets the <i translate="no">provider</i> to use for images requested via the <i>image</i>: url scheme, with host <i translate="no">providerId</i>. The <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> takes ownership of <i translate="no">provider</i>.</p>
<p>Image providers enable support for pixmap and threaded image requests. See the <a href="./qquickimageprovider.htm" translate="no">QQuickImageProvider</a> documentation for details on implementing and using image providers.</p>
<p>All required image providers should be added to the engine before any QML sources files are loaded.</p>
<p><b>See also </b><a href="./qqmlengine.htm#removeImageProvider" translate="no">removeImageProvider</a>(), <a href="./qquickimageprovider.htm" translate="no">QQuickImageProvider</a>, and <a href="./qqmlimageproviderbase.htm" translate="no">QQmlImageProviderBase</a>.</p>
<!-- @@@addImageProvider -->
<!-- $$$addImportPath[overload1]$$$addImportPathconstQString& -->
<h3 class="fn" id="addImportPath" translate="no"><a name="addImportPath"></a><span class="type">void</span> QQmlEngine::<span class="name">addImportPath</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>path</i>)<a class="plink" href="#addImportPath" title="Direct link to this headline"></a></h3>
<p>Adds <i translate="no">path</i> as a directory where the engine searches for installed modules in a URL-based directory structure.</p>
<p>The <i translate="no">path</i> may be a local filesystem directory, a <a href="./resources.htm" translate="no">Qt Resource</a> path (<code translate="no">:/imports</code>), a <a href="./resources.htm" translate="no">Qt Resource</a> url (<code translate="no">qrc:/imports</code>) or a URL.</p>
<p>The <i translate="no">path</i> will be converted into canonical form before it is added to the import path list.</p>
<p>The newly added <i translate="no">path</i> will be first in the <a href="./qqmlengine.htm#importPathList" translate="no">importPathList</a>().</p>
<p><b>See also </b><a href="./qqmlengine.htm#setImportPathList" translate="no">setImportPathList</a>() and <a href="./qtqml-modules-topic.htm" translate="no">QML Modules</a>.</p>
<!-- @@@addImportPath -->
<!-- $$$addPluginPath[overload1]$$$addPluginPathconstQString& -->
<h3 class="fn" id="addPluginPath" translate="no"><a name="addPluginPath"></a><span class="type">void</span> QQmlEngine::<span class="name">addPluginPath</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>path</i>)<a class="plink" href="#addPluginPath" title="Direct link to this headline"></a></h3>
<p>Adds <i translate="no">path</i> as a directory where the engine searches for native plugins for imported modules (referenced in the <code translate="no">qmldir</code> file).</p>
<p>By default, the list contains only <code translate="no">.</code>, i.e. the engine searches in the directory of the <code translate="no">qmldir</code> file itself.</p>
<p>The newly added <i translate="no">path</i> will be first in the <a href="./qqmlengine.htm#pluginPathList" translate="no">pluginPathList</a>().</p>
<p><b>See also </b><a href="./qqmlengine.htm#setPluginPathList" translate="no">setPluginPathList</a>().</p>
<!-- @@@addPluginPath -->
<!-- $$$baseUrl[overload1]$$$baseUrl -->
<h3 class="fn" id="baseUrl" translate="no"><a name="baseUrl"></a><span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span> QQmlEngine::<span class="name">baseUrl</span>() const<a class="plink" href="#baseUrl" title="Direct link to this headline"></a></h3>
<p>Return the base URL for this engine. The base URL is only used to resolve components when a relative URL is passed to the <a href="./qqmlcomponent.htm" translate="no">QQmlComponent</a> constructor.</p>
<p>If a base URL has not been explicitly set, this method returns the application's current working directory.</p>
<p><b>See also </b><a href="./qqmlengine.htm#setBaseUrl" translate="no">setBaseUrl</a>().</p>
<!-- @@@baseUrl -->
<!-- $$$clearComponentCache[overload1]$$$clearComponentCache -->
<h3 class="fn" id="clearComponentCache" translate="no"><a name="clearComponentCache"></a><span class="type">void</span> QQmlEngine::<span class="name">clearComponentCache</span>()<a class="plink" href="#clearComponentCache" title="Direct link to this headline"></a></h3>
<p>Clears the engine's internal component cache.</p>
<p>This function causes the property metadata of all components previously loaded by the engine to be destroyed. All previously loaded components and the property bindings for all extant objects created from those components will cease to function.</p>
<p>This function returns the engine to a state where it does not contain any loaded component data. This may be useful in order to reload a smaller subset of the previous component set, or to load a new version of a previously loaded component.</p>
<p>Once the component cache has been cleared, components must be loaded before any new objects can be created.</p>
<div class="admonition note">
<p><b>Note: </b>Any existing objects created from QML components retain their types, even if you clear the component cache. This includes singleton objects. If you create more objects from the same QML code after clearing the cache, the new objects will be of different types than the old ones. Assigning such a new object to a property of its declared type belonging to an object created before clearing the cache won't work.</p>
</div>
<p>As a general rule of thumb, make sure that no objects created from QML components are alive when you clear the component cache.</p>
<p><b>See also </b><a href="./qqmlengine.htm#trimComponentCache" translate="no">trimComponentCache</a>().</p>
<!-- @@@clearComponentCache -->
<!-- $$$contextForObject[overload1]$$$contextForObjectconstQObject* -->
<h3 class="fn" id="contextForObject" translate="no"><a name="contextForObject"></a><code translate="no">[static] </code><span class="type"><a href="./qqmlcontext.htm" translate="no">QQmlContext</a></span> *QQmlEngine::<span class="name">contextForObject</span>(const <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>object</i>)<a class="plink" href="#contextForObject" title="Direct link to this headline"></a></h3>
<p>Returns the <a href="./qqmlcontext.htm" translate="no">QQmlContext</a> for the <i translate="no">object</i>, or 0 if no context has been set.</p>
<p>When the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> instantiates a <a href="./qobject.htm" translate="no">QObject</a>, the context is set automatically.</p>
<p><b>See also </b><a href="./qqmlengine.htm#setContextForObject" translate="no">setContextForObject</a>(), <a href="./qqmlengine.htm#qmlContext" translate="no">qmlContext</a>(), and <a href="./qqmlengine.htm#qmlEngine" translate="no">qmlEngine</a>().</p>
<!-- @@@contextForObject -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event" translate="no"><a name="event"></a><code translate="no">[override virtual protected] </code><span class="type">bool</span> QQmlEngine::<span class="name">event</span>(<span class="type"><a href="./qevent.htm" translate="no">QEvent</a></span> *<i>e</i>)<a class="plink" href="#event" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qobject.htm#event" translate="no">QObject::event</a>(QEvent *e).</p>
<!-- @@@event -->
<!-- $$$imageProvider[overload1]$$$imageProviderconstQString& -->
<h3 class="fn" id="imageProvider" translate="no"><a name="imageProvider"></a><span class="type"><a href="./qqmlimageproviderbase.htm" translate="no">QQmlImageProviderBase</a></span> *QQmlEngine::<span class="name">imageProvider</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>providerId</i>) const<a class="plink" href="#imageProvider" title="Direct link to this headline"></a></h3>
<p>Returns the image provider set for <i translate="no">providerId</i> if found; otherwise returns <code translate="no">nullptr</code>.</p>
<p><b>See also </b><a href="./qquickimageprovider.htm" translate="no">QQuickImageProvider</a>.</p>
<!-- @@@imageProvider -->
<!-- $$$importPathList[overload1]$$$importPathList -->
<h3 class="fn" id="importPathList" translate="no"><a name="importPathList"></a><span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> QQmlEngine::<span class="name">importPathList</span>() const<a class="plink" href="#importPathList" title="Direct link to this headline"></a></h3>
<p>Returns the list of directories where the engine searches for installed modules in a URL-based directory structure.</p>
<p>For example, if <code translate="no">/opt/MyApp/lib/imports</code> is in the path, then QML that imports <code translate="no">com.mycompany.Feature</code> will cause the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> to look in <code translate="no">/opt/MyApp/lib/imports/com/mycompany/Feature/</code> for the components provided by that module. A <code translate="no">qmldir</code> file is required for defining the type version mapping and possibly QML extensions plugins.</p>
<p>By default, the list contains the directory of the application executable, paths specified in the <code translate="no">QML2_IMPORT_PATH</code> environment variable, and the builtin <code translate="no">Qml2ImportsPath</code> from <a href="./qlibraryinfo.htm" translate="no">QLibraryInfo</a>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#addImportPath" translate="no">addImportPath</a>() and <a href="./qqmlengine.htm#setImportPathList" translate="no">setImportPathList</a>().</p>
<!-- @@@importPathList -->
<!-- $$$importPlugin[overload1]$$$importPluginconstQString&constQString&QList<QQmlError>* -->
<h3 class="fn" id="importPlugin" translate="no"><a name="importPlugin"></a><span class="type">bool</span> QQmlEngine::<span class="name">importPlugin</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>filePath</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>uri</i>, <span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qqmlerror.htm" translate="no">QQmlError</a></span>&gt; *<i>errors</i>)<a class="plink" href="#importPlugin" title="Direct link to this headline"></a></h3>
<p>Imports the plugin named <i translate="no">filePath</i> with the <i translate="no">uri</i> provided. Returns true if the plugin was successfully imported; otherwise returns false.</p>
<p>On failure and if non-null, the <i translate="no">errors</i> list will have any errors which occurred prepended to it.</p>
<p>The plugin has to be a Qt plugin which implements the <a href="./qqmlengineextensionplugin.htm" translate="no">QQmlEngineExtensionPlugin</a> interface.</p>
<!-- @@@importPlugin -->
<!-- $$$incubationController[overload1]$$$incubationController -->
<h3 class="fn" id="incubationController" translate="no"><a name="incubationController"></a><span class="type"><a href="./qqmlincubationcontroller.htm" translate="no">QQmlIncubationController</a></span> *QQmlEngine::<span class="name">incubationController</span>() const<a class="plink" href="#incubationController" title="Direct link to this headline"></a></h3>
<p>Returns the currently set incubation controller, or 0 if no controller has been set.</p>
<p><b>See also </b><a href="./qqmlengine.htm#setIncubationController" translate="no">setIncubationController</a>().</p>
<!-- @@@incubationController -->
<!-- $$$networkAccessManager[overload1]$$$networkAccessManager -->
<h3 class="fn" id="networkAccessManager" translate="no"><a name="networkAccessManager"></a><span class="type">QNetworkAccessManager</span> *QQmlEngine::<span class="name">networkAccessManager</span>() const<a class="plink" href="#networkAccessManager" title="Direct link to this headline"></a></h3>
<p>Returns a common QNetworkAccessManager which can be used by any QML type instantiated by this engine.</p>
<p>If a <a href="./qqmlnetworkaccessmanagerfactory.htm" translate="no">QQmlNetworkAccessManagerFactory</a> has been set and a QNetworkAccessManager has not yet been created, the <a href="./qqmlnetworkaccessmanagerfactory.htm" translate="no">QQmlNetworkAccessManagerFactory</a> will be used to create the QNetworkAccessManager; otherwise the returned QNetworkAccessManager will have no proxy or cache set.</p>
<p><b>See also </b><a href="./qqmlengine.htm#setNetworkAccessManagerFactory" translate="no">setNetworkAccessManagerFactory</a>().</p>
<!-- @@@networkAccessManager -->
<!-- $$$networkAccessManagerFactory[overload1]$$$networkAccessManagerFactory -->
<h3 class="fn" id="networkAccessManagerFactory" translate="no"><a name="networkAccessManagerFactory"></a><span class="type"><a href="./qqmlnetworkaccessmanagerfactory.htm" translate="no">QQmlNetworkAccessManagerFactory</a></span> *QQmlEngine::<span class="name">networkAccessManagerFactory</span>() const<a class="plink" href="#networkAccessManagerFactory" title="Direct link to this headline"></a></h3>
<p>Returns the current <a href="./qqmlnetworkaccessmanagerfactory.htm" translate="no">QQmlNetworkAccessManagerFactory</a>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#setNetworkAccessManagerFactory" translate="no">setNetworkAccessManagerFactory</a>().</p>
<!-- @@@networkAccessManagerFactory -->
<!-- $$$objectOwnership[overload1]$$$objectOwnershipQObject* -->
<h3 class="fn" id="objectOwnership" translate="no"><a name="objectOwnership"></a><code translate="no">[static] </code><span class="type"><a href="./qqmlengine.htm#ObjectOwnership-enum" translate="no">QQmlEngine::ObjectOwnership</a></span> QQmlEngine::<span class="name">objectOwnership</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>object</i>)<a class="plink" href="#objectOwnership" title="Direct link to this headline"></a></h3>
<p>Returns the ownership of <i translate="no">object</i>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#setObjectOwnership" translate="no">setObjectOwnership</a>().</p>
<!-- @@@objectOwnership -->
<!-- $$$offlineStorageDatabaseFilePath[overload1]$$$offlineStorageDatabaseFilePathconstQString& -->
<h3 class="fn" id="offlineStorageDatabaseFilePath" translate="no"><a name="offlineStorageDatabaseFilePath"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QQmlEngine::<span class="name">offlineStorageDatabaseFilePath</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>databaseName</i>) const<a class="plink" href="#offlineStorageDatabaseFilePath" title="Direct link to this headline"></a></h3>
<p>Returns the file path where a <a href="./qtquick-localstorage-qmlmodule.htm" translate="no">Local Storage</a> database with the identifier <i translate="no">databaseName</i> is (or would be) located.</p>
<p>This function was introduced in Qt 5.9.</p>
<p><b>See also </b><a href="./qtquick-localstorage-qmlmodule.htm#opendatabasesync" translate="no">LocalStorage.openDatabaseSync</a>().</p>
<!-- @@@offlineStorageDatabaseFilePath -->
<!-- $$$outputWarningsToStandardError[overload1]$$$outputWarningsToStandardError -->
<h3 class="fn" id="outputWarningsToStandardError" translate="no"><a name="outputWarningsToStandardError"></a><span class="type">bool</span> QQmlEngine::<span class="name">outputWarningsToStandardError</span>() const<a class="plink" href="#outputWarningsToStandardError" title="Direct link to this headline"></a></h3>
<p>Returns true if warning messages will be output to stderr in addition to being emitted by the <a href="./qqmlengine.htm#warnings" translate="no">warnings</a>() signal, otherwise false.</p>
<p>The default value is true.</p>
<p><b>See also </b><a href="./qqmlengine.htm#setOutputWarningsToStandardError" translate="no">setOutputWarningsToStandardError</a>().</p>
<!-- @@@outputWarningsToStandardError -->
<!-- $$$pluginPathList[overload1]$$$pluginPathList -->
<h3 class="fn" id="pluginPathList" translate="no"><a name="pluginPathList"></a><span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> QQmlEngine::<span class="name">pluginPathList</span>() const<a class="plink" href="#pluginPathList" title="Direct link to this headline"></a></h3>
<p>Returns the list of directories where the engine searches for native plugins for imported modules (referenced in the <code translate="no">qmldir</code> file).</p>
<p>By default, the list contains only <code translate="no">.</code>, i.e. the engine searches in the directory of the <code translate="no">qmldir</code> file itself.</p>
<p><b>See also </b><a href="./qqmlengine.htm#addPluginPath" translate="no">addPluginPath</a>() and <a href="./qqmlengine.htm#setPluginPathList" translate="no">setPluginPathList</a>().</p>
<!-- @@@pluginPathList -->
<!-- $$$removeImageProvider[overload1]$$$removeImageProviderconstQString& -->
<h3 class="fn" id="removeImageProvider" translate="no"><a name="removeImageProvider"></a><span class="type">void</span> QQmlEngine::<span class="name">removeImageProvider</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>providerId</i>)<a class="plink" href="#removeImageProvider" title="Direct link to this headline"></a></h3>
<p>Removes the image provider for <i translate="no">providerId</i>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#addImageProvider" translate="no">addImageProvider</a>() and <a href="./qquickimageprovider.htm" translate="no">QQuickImageProvider</a>.</p>
<!-- @@@removeImageProvider -->
<!-- $$$rootContext[overload1]$$$rootContext -->
<h3 class="fn" id="rootContext" translate="no"><a name="rootContext"></a><span class="type"><a href="./qqmlcontext.htm" translate="no">QQmlContext</a></span> *QQmlEngine::<span class="name">rootContext</span>() const<a class="plink" href="#rootContext" title="Direct link to this headline"></a></h3>
<p>Returns the engine's root context.</p>
<p>The root context is automatically created by the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a>. Data that should be available to all QML component instances instantiated by the engine should be put in the root context.</p>
<p>Additional data that should only be available to a subset of component instances should be added to sub-contexts parented to the root context.</p>
<!-- @@@rootContext -->
<!-- $$$setBaseUrl[overload1]$$$setBaseUrlconstQUrl& -->
<h3 class="fn" id="setBaseUrl" translate="no"><a name="setBaseUrl"></a><span class="type">void</span> QQmlEngine::<span class="name">setBaseUrl</span>(const <span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span> &amp;<i>url</i>)<a class="plink" href="#setBaseUrl" title="Direct link to this headline"></a></h3>
<p>Set the base URL for this engine to <i translate="no">url</i>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#baseUrl" translate="no">baseUrl</a>().</p>
<!-- @@@setBaseUrl -->
<!-- $$$setContextForObject[overload1]$$$setContextForObjectQObject*QQmlContext* -->
<h3 class="fn" id="setContextForObject" translate="no"><a name="setContextForObject"></a><code translate="no">[static] </code><span class="type">void</span> QQmlEngine::<span class="name">setContextForObject</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>object</i>, <span class="type"><a href="./qqmlcontext.htm" translate="no">QQmlContext</a></span> *<i>context</i>)<a class="plink" href="#setContextForObject" title="Direct link to this headline"></a></h3>
<p>Sets the <a href="./qqmlcontext.htm" translate="no">QQmlContext</a> for the <i translate="no">object</i> to <i translate="no">context</i>. If the <i translate="no">object</i> already has a context, a warning is output, but the context is not changed.</p>
<p>When the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> instantiates a <a href="./qobject.htm" translate="no">QObject</a>, the context is set automatically.</p>
<p><b>See also </b><a href="./qqmlengine.htm#contextForObject" translate="no">contextForObject</a>().</p>
<!-- @@@setContextForObject -->
<!-- $$$setImportPathList[overload1]$$$setImportPathListconstQStringList& -->
<h3 class="fn" id="setImportPathList" translate="no"><a name="setImportPathList"></a><span class="type">void</span> QQmlEngine::<span class="name">setImportPathList</span>(const <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> &amp;<i>paths</i>)<a class="plink" href="#setImportPathList" title="Direct link to this headline"></a></h3>
<p>Sets <i translate="no">paths</i> as the list of directories where the engine searches for installed modules in a URL-based directory structure.</p>
<p>By default, the list contains the directory of the application executable, paths specified in the <code translate="no">QML2_IMPORT_PATH</code> environment variable, and the builtin <code translate="no">Qml2ImportsPath</code> from <a href="./qlibraryinfo.htm" translate="no">QLibraryInfo</a>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#importPathList" translate="no">importPathList</a>() and <a href="./qqmlengine.htm#addImportPath" translate="no">addImportPath</a>().</p>
<!-- @@@setImportPathList -->
<!-- $$$setIncubationController[overload1]$$$setIncubationControllerQQmlIncubationController* -->
<h3 class="fn" id="setIncubationController" translate="no"><a name="setIncubationController"></a><span class="type">void</span> QQmlEngine::<span class="name">setIncubationController</span>(<span class="type"><a href="./qqmlincubationcontroller.htm" translate="no">QQmlIncubationController</a></span> *<i>controller</i>)<a class="plink" href="#setIncubationController" title="Direct link to this headline"></a></h3>
<p>Sets the engine's incubation <i translate="no">controller</i>. The engine can only have one active controller and it does not take ownership of it.</p>
<p><b>See also </b><a href="./qqmlengine.htm#incubationController" translate="no">incubationController</a>().</p>
<!-- @@@setIncubationController -->
<!-- $$$setNetworkAccessManagerFactory[overload1]$$$setNetworkAccessManagerFactoryQQmlNetworkAccessManagerFactory* -->
<h3 class="fn" id="setNetworkAccessManagerFactory" translate="no"><a name="setNetworkAccessManagerFactory"></a><span class="type">void</span> QQmlEngine::<span class="name">setNetworkAccessManagerFactory</span>(<span class="type"><a href="./qqmlnetworkaccessmanagerfactory.htm" translate="no">QQmlNetworkAccessManagerFactory</a></span> *<i>factory</i>)<a class="plink" href="#setNetworkAccessManagerFactory" title="Direct link to this headline"></a></h3>
<p>Sets the <i translate="no">factory</i> to use for creating QNetworkAccessManager(s).</p>
<p>QNetworkAccessManager is used for all network access by QML. By implementing a factory it is possible to create custom QNetworkAccessManager with specialized caching, proxy and cookie support.</p>
<p>The factory must be set before executing the engine.</p>
<div class="admonition note">
<p><b>Note: </b><a href="./qqmlengine.htm" translate="no">QQmlEngine</a> does not take ownership of the factory.</p>
</div>
<p><b>See also </b><a href="./qqmlengine.htm#networkAccessManagerFactory" translate="no">networkAccessManagerFactory</a>().</p>
<!-- @@@setNetworkAccessManagerFactory -->
<!-- $$$setObjectOwnership[overload1]$$$setObjectOwnershipQObject*QQmlEngine::ObjectOwnership -->
<h3 class="fn" id="setObjectOwnership" translate="no"><a name="setObjectOwnership"></a><code translate="no">[static] </code><span class="type">void</span> QQmlEngine::<span class="name">setObjectOwnership</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>object</i>, <span class="type"><a href="./qqmlengine.htm#ObjectOwnership-enum" translate="no">QQmlEngine::ObjectOwnership</a></span> <i>ownership</i>)<a class="plink" href="#setObjectOwnership" title="Direct link to this headline"></a></h3>
<p>Sets the <i translate="no">ownership</i> of <i translate="no">object</i>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#objectOwnership" translate="no">objectOwnership</a>().</p>
<!-- @@@setObjectOwnership -->
<!-- $$$setOutputWarningsToStandardError[overload1]$$$setOutputWarningsToStandardErrorbool -->
<h3 class="fn" id="setOutputWarningsToStandardError" translate="no"><a name="setOutputWarningsToStandardError"></a><span class="type">void</span> QQmlEngine::<span class="name">setOutputWarningsToStandardError</span>(<span class="type">bool</span> <i>enabled</i>)<a class="plink" href="#setOutputWarningsToStandardError" title="Direct link to this headline"></a></h3>
<p>Set whether warning messages will be output to stderr to <i translate="no">enabled</i>.</p>
<p>If <i translate="no">enabled</i> is true, any warning messages generated by QML will be output to stderr and emitted by the <a href="./qqmlengine.htm#warnings" translate="no">warnings</a>() signal. If <i translate="no">enabled</i> is false, only the <a href="./qqmlengine.htm#warnings" translate="no">warnings</a>() signal will be emitted. This allows applications to handle warning output themselves.</p>
<p>The default value is true.</p>
<p><b>See also </b><a href="./qqmlengine.htm#outputWarningsToStandardError" translate="no">outputWarningsToStandardError</a>().</p>
<!-- @@@setOutputWarningsToStandardError -->
<!-- $$$setPluginPathList[overload1]$$$setPluginPathListconstQStringList& -->
<h3 class="fn" id="setPluginPathList" translate="no"><a name="setPluginPathList"></a><span class="type">void</span> QQmlEngine::<span class="name">setPluginPathList</span>(const <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> &amp;<i>paths</i>)<a class="plink" href="#setPluginPathList" title="Direct link to this headline"></a></h3>
<p>Sets the list of directories where the engine searches for native plugins for imported modules (referenced in the <code translate="no">qmldir</code> file) to <i translate="no">paths</i>.</p>
<p>By default, the list contains only <code translate="no">.</code>, i.e. the engine searches in the directory of the <code translate="no">qmldir</code> file itself.</p>
<p><b>See also </b><a href="./qqmlengine.htm#pluginPathList" translate="no">pluginPathList</a>() and <a href="./qqmlengine.htm#addPluginPath" translate="no">addPluginPath</a>().</p>
<!-- @@@setPluginPathList -->
<!-- $$$singletonInstance[overload1]$$$singletonInstanceint -->
<h3 class="fn" id="singletonInstance" translate="no"><a name="singletonInstance"></a>template &lt;typename T&gt; <span class="type">T</span> QQmlEngine::<span class="name">singletonInstance</span>(<span class="type">int</span> <i>qmlTypeId</i>)<a class="plink" href="#singletonInstance" title="Direct link to this headline"></a></h3>
<p>Returns the instance of a singleton type that was registered under <i translate="no">qmlTypeId</i>.</p>
<p>The template argument <i>T</i> may be either <a href="./qjsvalue.htm" translate="no">QJSValue</a> or a pointer to a <a href="./qobject.htm" translate="no">QObject</a>-derived type and depends on how the singleton was registered. If no instance of <i>T</i> has been created yet, it is created now. If <i translate="no">qmlTypeId</i> does not represent a valid singleton type, either a default constructed <a href="./qjsvalue.htm" translate="no">QJSValue</a> or a <code translate="no">nullptr</code> is returned.</p>
<p><a href="./qobject.htm" translate="no">QObject</a>* example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> MySingleton : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> {
  Q_OBJECT

  <span class="comment">// Register as default constructed singleton.</span>
  QML_ELEMENT
  QML_SINGLETON

  <span class="keyword">static</span> <span class="type">int</span> typeId;
  <span class="comment">// ...</span>
};

MySingleton<span class="operator">::</span>typeId <span class="operator">=</span> qmlTypeId(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);

<span class="comment">// Retrieve as QObject*</span>
<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> engine;
MySingleton<span class="operator">*</span> instance <span class="operator">=</span> engine<span class="operator">.</span>singletonInstance<span class="operator">&lt;</span>MySingleton<span class="operator">*</span><span class="operator">&gt;</span>(MySingleton<span class="operator">::</span>typeId);</pre></div>
<p><a href="./qjsvalue.htm" translate="no">QJSValue</a> example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Register with QJSValue callback</span>
<span class="type">int</span> typeId <span class="operator">=</span> qmlRegisterSingletonType(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);

<span class="comment">// Retrieve as QJSValue</span>
<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> engine;
<span class="type"><a href="./qjsvalue.htm" translate="no">QJSValue</a></span> instance <span class="operator">=</span> engine<span class="operator">.</span>singletonInstance<span class="operator">&lt;</span><span class="type"><a href="./qjsvalue.htm" translate="no">QJSValue</a></span><span class="operator">&gt;</span>(typeId);</pre></div>
<p>It is recommended to store the QML type id, e.g. as a static member in the singleton class. The lookup via <a href="./qqmlengine.htm#qmlTypeId" translate="no">qmlTypeId</a>() is costly.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="./qqmlengine.htm#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>(), and <a href="./qqmlengine.htm#qmlTypeId" translate="no">qmlTypeId</a>().</p>
<!-- @@@singletonInstance -->
<!-- $$$trimComponentCache[overload1]$$$trimComponentCache -->
<h3 class="fn" id="trimComponentCache" translate="no"><a name="trimComponentCache"></a><span class="type">void</span> QQmlEngine::<span class="name">trimComponentCache</span>()<a class="plink" href="#trimComponentCache" title="Direct link to this headline"></a></h3>
<p>Trims the engine's internal component cache.</p>
<p>This function causes the property metadata of any loaded components which are not currently in use to be destroyed.</p>
<p>A component is considered to be in use if there are any extant instances of the component itself, any instances of other components that use the component, or any objects instantiated by any of those components.</p>
<p><b>See also </b><a href="./qqmlengine.htm#clearComponentCache" translate="no">clearComponentCache</a>().</p>
<!-- @@@trimComponentCache -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qmlAttachedPropertiesObject[overload1]$$$qmlAttachedPropertiesObjectconstQObject*bool -->
<h3 class="fn" id="qmlAttachedPropertiesObject" translate="no"><a name="qmlAttachedPropertiesObject"></a>template &lt;typename T&gt; <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<span class="name">qmlAttachedPropertiesObject</span>(const <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>attachee</i>, <span class="type">bool</span> <i>create</i> = true)<a class="plink" href="#qmlAttachedPropertiesObject" title="Direct link to this headline"></a></h3>
<p>The form of this template function is:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> <span class="operator">*</span>qmlAttachedPropertiesObject(<span class="keyword">const</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> <span class="operator">*</span>attachee<span class="operator">,</span> bool create <span class="operator">=</span> <span class="keyword">true</span>)</pre></div>
<p>This returns the attached object instance that has been attached to the specified <i translate="no">attachee</i> by the attaching type <i>T</i>.</p>
<p>If <i translate="no">create</i> is true and type <i>T</i> is a valid attaching type, this creates and returns a new attached object instance.</p>
<p>Returns 0 if type <i>T</i> is not a valid attaching type, or if <i translate="no">create</i> is false and no attachment object instance has previously been created for <i translate="no">attachee</i>.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ATTACHED" translate="no">QML_ATTACHED</a>() and <a href="./qtqml-cppintegration-definetypes.htm#providing-attached-properties" translate="no">Providing Attached Properties</a>.</p>
<!-- @@@qmlAttachedPropertiesObject -->
<!-- $$$qmlClearTypeRegistrations[overload1]$$$qmlClearTypeRegistrations -->
<h3 class="fn" id="qmlClearTypeRegistrations" translate="no"><a name="qmlClearTypeRegistrations"></a><span class="type">void</span> <span class="name">qmlClearTypeRegistrations</span>()<a class="plink" href="#qmlClearTypeRegistrations" title="Direct link to this headline"></a></h3>
<p>Clears all stored type registrations, such as those produced with <a href="./qqmlengine-obsolete.htm#qmlRegisterType-1" translate="no">qmlRegisterType</a>().</p>
<p>Do not call this function while a <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> exists or behavior will be undefined. Any existing QQmlEngines must be deleted before calling this function. This function only affects the application global cache. Delete the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> to clear all cached data relating to that engine.</p>
<!-- @@@qmlClearTypeRegistrations -->
<!-- $$$qmlContext[overload1]$$$qmlContextconstQObject* -->
<h3 class="fn" id="qmlContext" translate="no"><a name="qmlContext"></a><span class="type"><a href="./qqmlcontext.htm" translate="no">QQmlContext</a></span> *<span class="name">qmlContext</span>(const <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>object</i>)<a class="plink" href="#qmlContext" title="Direct link to this headline"></a></h3>
<p>Returns the <a href="./qqmlcontext.htm" translate="no">QQmlContext</a> associated with <i translate="no">object</i>, if any. This is equivalent to <a href="./qqmlengine.htm#contextForObject" translate="no">QQmlEngine::contextForObject</a>(object).</p>
<div class="admonition note">
<p><b>Note: </b>Add <code translate="no">#include &lt;QtQml&gt;</code> to use this function.</p>
</div>
<p><b>See also </b><a href="./qqmlengine.htm#contextForObject" translate="no">contextForObject</a>() and <a href="./qqmlengine.htm#qmlEngine" translate="no">qmlEngine</a>().</p>
<!-- @@@qmlContext -->
<!-- $$$qmlEngine[overload1]$$$qmlEngineconstQObject* -->
<h3 class="fn" id="qmlEngine" translate="no"><a name="qmlEngine"></a><span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> *<span class="name">qmlEngine</span>(const <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>object</i>)<a class="plink" href="#qmlEngine" title="Direct link to this headline"></a></h3>
<p>Returns the <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> associated with <i translate="no">object</i>, if any. This is equivalent to <a href="./qqmlengine.htm#contextForObject" translate="no">QQmlEngine::contextForObject</a>(object)-&gt;engine(), but more efficient.</p>
<div class="admonition note">
<p><b>Note: </b>Add <code translate="no">#include &lt;QtQml&gt;</code> to use this function.</p>
</div>
<p><b>See also </b><a href="./qqmlengine.htm#contextForObject" translate="no">contextForObject</a>() and <a href="./qqmlengine.htm#qmlContext" translate="no">qmlContext</a>().</p>
<!-- @@@qmlEngine -->
<!-- $$$qmlProtectModule[overload1]$$$qmlProtectModuleconstchar*int -->
<h3 class="fn" id="qmlProtectModule" translate="no"><a name="qmlProtectModule"></a><span class="type">bool</span> <span class="name">qmlProtectModule</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>majVersion</i>)<a class="plink" href="#qmlProtectModule" title="Direct link to this headline"></a></h3>
<p>This function protects a module from having types registered into it. This can be used to prevent other plugins from injecting types into your module. It can also be a performance improvement, as it allows the engine to skip checking for the possibility of new types or plugins when this import is reached.</p>
<p>The performance benefit is primarily seen when registering application specific types from within the application instead of through a plugin. Using qmlProtectModule allows the engine to skip checking for a plugin when that uri is imported, which can be noticeable with slow file systems.</p>
<p>After this function is called, any attempt to register C++ types into this uri, major version combination will lead to a runtime error. Call this after you have registered all of your types with the engine.</p>
<p>Returns true if the module with <i translate="no">uri</i> as a <a href="./qtqml-modules-identifiedmodules.htm" translate="no">module identifier</a> and <i translate="no">majVersion</i> as a major version number was found and locked, otherwise returns false. The module must contain exported types in order to be found.</p>
<!-- @@@qmlProtectModule -->
<!-- $$$qmlRegisterAnonymousType[overload1]$$$qmlRegisterAnonymousTypeconstchar*int -->
<h3 class="fn" id="qmlRegisterAnonymousType" translate="no"><a name="qmlRegisterAnonymousType"></a>template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterAnonymousType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>)<a class="plink" href="#qmlRegisterAnonymousType" title="Direct link to this headline"></a></h3>
<p>This template function registers the C++ type in the QML system as an anonymous type. The resulting QML type does not have a name. Therefore, instances of this type cannot be created from the QML system. You can, however, access instances of the type when they are exposed as properties of other types.</p>
<p>Use this function when the type will not be referenced by name, specifically for C++ types that are used on the left-hand side of a property binding. To indicate to which module the type belongs use <i translate="no">uri</i> and <i translate="no">versionMajor</i>.</p>
<p>For example, consider the following two classes:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> Bar : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    Q_PROPERTY(<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> baz READ baz WRITE setBaz NOTIFY bazChanged)

<span class="keyword">public</span>:
    Bar() {}

    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> baz() <span class="keyword">const</span> { <span class="keyword">return</span> mBaz; }

    <span class="type">void</span> setBaz(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>baz)
    {
        <span class="keyword">if</span> (baz <span class="operator">=</span><span class="operator">=</span> mBaz)
            <span class="keyword">return</span>;

        mBaz <span class="operator">=</span> baz;
        <span class="keyword">emit</span> bazChanged();
    }

<span class="keyword">signals</span>:
    <span class="type">void</span> bazChanged();

<span class="keyword">private</span>:
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> mBaz;
};

<span class="keyword">class</span> Foo : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    Q_PROPERTY(Bar <span class="operator">*</span>bar READ bar CONSTANT FINAL)

<span class="keyword">public</span>:
    Foo() {}

    Bar <span class="operator">*</span>bar() { <span class="keyword">return</span> <span class="operator">&amp;</span>mBar; }

<span class="keyword">private</span>:
    Bar mBar;
};</pre></div>
<p>In QML, we assign a string to the <code translate="no">baz</code> property of <code translate="no">bar</code>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">Foo {
    bar<span class="operator">.</span>baz: <span class="string">"abc"</span>
    Component<span class="operator">.</span>onCompleted: print(bar<span class="operator">.</span>baz)
}</pre></div>
<p>For the QML engine to know that the <code translate="no">Bar</code> type has a <code translate="no">baz</code> property, we have to make <code translate="no">Bar</code> known:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">qmlRegisterType<span class="operator">&lt;</span>Foo<span class="operator">&gt;</span>(<span class="string">"App"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"Foo"</span>);
qmlRegisterAnonymousType<span class="operator">&lt;</span>Bar<span class="operator">&gt;</span>(<span class="string">"App"</span><span class="operator">,</span> <span class="number">1</span>);</pre></div>
<p>As the <code translate="no">Foo</code> type is instantiated in QML, it must be registered with the version of <a href="./qqmlengine-obsolete.htm#qmlRegisterType-1" translate="no">qmlRegisterType</a>() that takes an element name.</p>
<p>Returns the QML type id.</p>
<p>This function was introduced in Qt 5.14.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a> and <a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterAnonymousType -->
<!-- $$$qmlRegisterExtendedType[overload1]$$$qmlRegisterExtendedTypeconstchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterExtendedType" translate="no"><a name="qmlRegisterExtendedType"></a>template &lt;typename T, typename E&gt; <span class="type">int</span> <span class="name">qmlRegisterExtendedType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)<a class="plink" href="#qmlRegisterExtendedType" title="Direct link to this headline"></a></h3>
<p>This template function registers the C++ type and its extension object in the QML system with the name <i translate="no">qmlName</i> in the library imported from <i translate="no">uri</i> having version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>. Properties not available in the main type will be searched for in the extension object.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_EXTENDED" translate="no">QML_EXTENDED</a>(), <a href="./qqmlengine-obsolete.htm#qmlRegisterType-1" translate="no">qmlRegisterType</a>(), and <a href="./qtqml-cppintegration-definetypes.htm#registering-extension-objects" translate="no">Registering Extension Objects</a>.</p>
<!-- @@@qmlRegisterExtendedType -->
<!-- $$$qmlRegisterExtendedUncreatableType[overload1]$$$qmlRegisterExtendedUncreatableTypeconstchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterExtendedUncreatableType" translate="no"><a name="qmlRegisterExtendedUncreatableType"></a>template &lt;typename T, typename E&gt; <span class="type">int</span> <span class="name">qmlRegisterExtendedUncreatableType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>reason</i>)<a class="plink" href="#qmlRegisterExtendedUncreatableType" title="Direct link to this headline"></a></h3>
<p>This template function registers the C++ type and its extension in the QML system with the name <i translate="no">qmlName</i> in the library imported from <i translate="no">uri</i> having version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>While the type has a name and a type, it cannot be created. An error message with the given <i translate="no">reason</i> is printed if the user attempts to create an instance of this type.</p>
<p>This is useful where the type is only intended for providing attached properties, enum values or an abstract base class with its extension.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_EXTENDED" translate="no">QML_EXTENDED</a>(), <a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="./qqmlengine.htm#qmlRegisterUncreatableType" translate="no">qmlRegisterUncreatableType</a>().</p>
<!-- @@@qmlRegisterExtendedUncreatableType -->
<!-- $$$qmlRegisterInterface[overload1]$$$qmlRegisterInterfaceconstchar* -->
<h3 class="fn" id="qmlRegisterInterface" translate="no"><a name="qmlRegisterInterface"></a>template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterInterface</span>(const <span class="type">char</span> *<i>typeName</i>)<a class="plink" href="#qmlRegisterInterface" title="Direct link to this headline"></a></h3>
<p>This template function registers the C++ type in the QML system under the name <i translate="no">typeName</i>.</p>
<p>Types registered as an interface with the engine should also declare themselves as an interface with the <a href="./metaobjects.htm" translate="no">meta object system</a>. For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">struct</span> FooInterface
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="operator">~</span>FooInterface();
    <span class="keyword">virtual</span> <span class="type">void</span> doSomething() <span class="operator">=</span> <span class="number">0</span>;
};

Q_DECLARE_INTERFACE(FooInterface<span class="operator">,</span> <span class="string">"org.foo.FooInterface"</span>)</pre></div>
<p>When registered with the QML engine in this way, they can be used as property types:</p>
<p><a href="./qobject.htm#Q_PROPERTY" translate="no">Q_PROPERTY</a>(FooInterface *foo READ foo WRITE setFoo)</p>
<p>When you assign a <a href="./qobject.htm" translate="no">QObject</a> sub-class to this property, the QML engine does the interface cast to <code translate="no">FooInterface*</code> automatically.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_INTERFACE" translate="no">QML_INTERFACE</a>.</p>
<!-- @@@qmlRegisterInterface -->
<!-- $$$qmlRegisterModule[overload1]$$$qmlRegisterModuleconstchar*intint -->
<h3 class="fn" id="qmlRegisterModule" translate="no"><a name="qmlRegisterModule"></a><span class="type">void</span> <span class="name">qmlRegisterModule</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>)<a class="plink" href="#qmlRegisterModule" title="Direct link to this headline"></a></h3>
<p>This function registers a module in a particular <i translate="no">uri</i> with a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>This can be used to make a certain module version available, even if no types are registered for that version. This is particularly useful for keeping the versions of related modules in sync.</p>
<p>This function was introduced in Qt 5.9.</p>
<!-- @@@qmlRegisterModule -->
<!-- $$$qmlRegisterRevision[overload1]$$$qmlRegisterRevisionconstchar*intint -->
<h3 class="fn" id="qmlRegisterRevision" translate="no"><a name="qmlRegisterRevision"></a>template &lt;typename T, int metaObjectRevision&gt; <span class="type">int</span> <span class="name">qmlRegisterRevision</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>)<a class="plink" href="#qmlRegisterRevision" title="Direct link to this headline"></a></h3>
<p>This template function registers the specified revision of a C++ type in the QML system with the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Returns the QML type id.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">,</span> <span class="type">int</span> metaObjectRevision<span class="operator">&gt;</span>
<span class="type">int</span> qmlRegisterRevision(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor);</pre></div>
<p>This function is typically used to register the revision of a base class to use for the specified version of the type (see <a href="./qtqml-cppintegration-definetypes.htm#type-revisions-and-versions" translate="no">Type Revisions and Versions</a>).</p>
<!-- @@@qmlRegisterRevision -->
<!-- $$$qmlRegisterSingletonInstance[overload1]$$$qmlRegisterSingletonInstanceconstchar*intintconstchar*QObject* -->
<h3 class="fn" id="qmlRegisterSingletonInstance" translate="no"><a name="qmlRegisterSingletonInstance"></a><span class="type">int</span> <span class="name">qmlRegisterSingletonInstance</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>cppObject</i>)<a class="plink" href="#qmlRegisterSingletonInstance" title="Direct link to this headline"></a></h3>
<p>This function is used to register a singleton object <i translate="no">cppObject</i>, with a particular <i translate="no">uri</i> and <i translate="no">typeName</i>. Its version is a combination of <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Installing a singleton type into a URI allows you to provide arbitrary functionality (methods and properties) to QML code without requiring individual instances of the type to be instantiated by the client.</p>
<p>Use this function to register an object of the given type T as a singleton type.</p>
<p>A <a href="./qobject.htm" translate="no">QObject</a> singleton type may be referenced via the type name with which it was registered; in turn this type name may be used as the target in a <a href="./qml-qtqml-connections.htm" translate="no">Connections</a> type, or like any other type ID. However, there's one exception: a <a href="./qobject.htm" translate="no">QObject</a> singleton type property can't be aliased because the singleton type name does not identify an object within the same component as any other item.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">cppObject</i> must outlive the QML engine in which it is used. Moreover, cppObject must have the same thread affinity as the engine. If you want separate singleton instances for multiple engines, you need to use <a href="./qqmlengine.htm#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>. See <a href="./threads-qobject.htm" translate="no">Threads and QObjects</a> for more information about thread safety.</p>
</div>
<p>Usage:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// First, define your QObject which provides the functionality.</span>
<span class="keyword">class</span> SingletonTypeExample : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    Q_PROPERTY(<span class="type">int</span> someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

<span class="keyword">public</span>:
    <span class="keyword">explicit</span> SingletonTypeExample(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span><span class="operator">*</span> parent <span class="operator">=</span> nullptr) : <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>(parent) {}

    Q_INVOKABLE <span class="type">int</span> doSomething()
    {
        setSomeProperty(<span class="number">5</span>);
        <span class="keyword">return</span> m_someProperty;
    }

    <span class="type">int</span> someProperty() <span class="keyword">const</span> { <span class="keyword">return</span> m_someProperty; }
    <span class="type">void</span> setSomeProperty(<span class="type">int</span> val) {
        <span class="keyword">if</span> (m_someProperty <span class="operator">!</span><span class="operator">=</span> val) {
            m_someProperty <span class="operator">=</span> val;
            <span class="keyword">emit</span> somePropertyChanged(val);
        }
    }

<span class="keyword">signals</span>:
    <span class="type">void</span> somePropertyChanged(<span class="type">int</span> newValue);

<span class="keyword">private</span>:
    <span class="type">int</span> m_someProperty <span class="operator">=</span> <span class="number">0</span>;
};</pre></div>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Second, create an instance of the object</span>

<span class="comment">// allocate example before the engine to ensure that it outlives it</span>
<span class="type"><a href="./qscopedpointer.htm" translate="no">QScopedPointer</a></span><span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span> example(<span class="keyword">new</span> SingletonTypeExample);
<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> engine;

<span class="comment">// Third, register the singleton type provider with QML by calling this</span>
<span class="comment">// function in an initialization function.</span>
qmlRegisterSingletonInstance(<span class="string">"Qt.example.qobjectSingleton"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"MyApi"</span><span class="operator">,</span> example<span class="operator">.</span>get());</pre></div>
<p>In order to use the registered singleton type in QML, you must import the URI with the corresponding version.</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
<span class="type"><a href="./qml-qtquick-item.htm" translate="no">Item</a></span> {
    <span class="name">id</span>: <span class="name">root</span>
    property <span class="type"><a href="./qml-int.htm" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">MyApi</span>.<span class="name">someProperty</span>

    <span class="name">Component</span>.onCompleted: {
        <span class="name">console</span>.<span class="name">log</span>(<span class="name">MyApi</span>.<span class="name">doSomething</span>())
    }
}</pre></div>
<p>This function was introduced in Qt 5.14.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a> and <a href="./qqmlengine.htm#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>.</p>
<!-- @@@qmlRegisterSingletonInstance -->
<!-- $$$qmlRegisterSingletonType[overload1]$$$qmlRegisterSingletonTypeconstchar*intintconstchar*QJSValue(*)(QQmlEngine*,QJSEngine*) -->
<h3 class="fn" id="qmlRegisterSingletonType" translate="no"><a name="qmlRegisterSingletonType"></a><span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type"><a href="./qjsvalue.htm" translate="no">QJSValue</a></span> (*)(<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> *, <span class="type"><a href="./qjsengine.htm#QJSEngine" translate="no">QJSEngine</a></span> *) <i>callback</i>)<a class="plink" href="#qmlRegisterSingletonType" title="Direct link to this headline"></a></h3>
<p>This function may be used to register a singleton type provider <i translate="no">callback</i> in a particular <i translate="no">uri</i> and <i translate="no">typeName</i> with a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Installing a singleton type allows developers to provide arbitrary functionality (methods and properties) to a client without requiring individual instances of the type to be instantiated by the client.</p>
<p>A singleton type may be either a <a href="./qobject.htm" translate="no">QObject</a> or a <a href="./qjsvalue.htm" translate="no">QJSValue</a>. This function should be used to register a singleton type provider function which returns a <a href="./qjsvalue.htm" translate="no">QJSValue</a> as a singleton type.</p>
<p><b>NOTE:</b> <a href="./qjsvalue.htm" translate="no">QJSValue</a> singleton type properties will <b>not</b> trigger binding re-evaluation if changed.</p>
<p>Usage:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// First, define the singleton type provider function (callback).</span>
<span class="keyword">static</span> <span class="type"><a href="./qjsvalue.htm" translate="no">QJSValue</a></span> example_qjsvalue_singletontype_provider(<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="./qjsengine.htm#QJSEngine" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine)
{
    Q_UNUSED(engine)

    <span class="keyword">static</span> <span class="type">int</span> seedValue <span class="operator">=</span> <span class="number">5</span>;
    <span class="type"><a href="./qjsvalue.htm" translate="no">QJSValue</a></span> example <span class="operator">=</span> scriptEngine<span class="operator">-</span><span class="operator">&gt;</span>newObject();
    example<span class="operator">.</span>setProperty(<span class="string">"someProperty"</span><span class="operator">,</span> seedValue<span class="operator">+</span><span class="operator">+</span>);
    <span class="keyword">return</span> example;
}

<span class="comment">// Second, register the singleton type provider with QML by calling this function in an initialization function.</span>
qmlRegisterSingletonType(<span class="string">"Qt.example.qjsvalueApi"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"MyApi"</span><span class="operator">,</span> example_qjsvalue_singletontype_provider);</pre></div>
<p>Alternatively, you can use a C++11 lambda:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">qmlRegisterSingletonType(<span class="string">"Qt.example.qjsvalueApi"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"MyApi"</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="./qjsengine.htm#QJSEngine" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type"><a href="./qjsvalue.htm" translate="no">QJSValue</a></span> {
    Q_UNUSED(engine)

    <span class="keyword">static</span> <span class="type">int</span> seedValue <span class="operator">=</span> <span class="number">5</span>;
    <span class="type"><a href="./qjsvalue.htm" translate="no">QJSValue</a></span> example <span class="operator">=</span> scriptEngine<span class="operator">-</span><span class="operator">&gt;</span>newObject();
    example<span class="operator">.</span>setProperty(<span class="string">"someProperty"</span><span class="operator">,</span> seedValue<span class="operator">+</span><span class="operator">+</span>);
    <span class="keyword">return</span> example;
});</pre></div>
<p>In order to use the registered singleton type in QML, you must import the singleton type.</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick 2.0
import Qt.example.qjsvalueApi 1.0 as ExampleApi
<span class="type"><a href="./qml-qtquick-item.htm" translate="no">Item</a></span> {
    <span class="name">id</span>: <span class="name">root</span>
    property <span class="type"><a href="./qml-int.htm" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">ExampleApi</span>.<span class="name">MyApi</span>.<span class="name">someProperty</span>
}</pre></div>
<p><b>See also </b><a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a> and <a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterSingletonType$$$qmlRegisterSingletonTypeconstchar*intintconstchar*QObject*(*)(QQmlEngine*,QJSEngine*) -->
<h3 class="fn" id="qmlRegisterSingletonType-1" translate="no"><a name="qmlRegisterSingletonType-1"></a>template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *(*)(<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> *, <span class="type"><a href="./qjsengine.htm#QJSEngine" translate="no">QJSEngine</a></span> *) <i>callback</i>)<a class="plink" href="#qmlRegisterSingletonType-1" title="Direct link to this headline"></a></h3>
<p>This function may be used to register a singleton type provider <i translate="no">callback</i> in a particular <i translate="no">uri</i> and <i translate="no">typeName</i> with a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Installing a singleton type into a uri allows developers to provide arbitrary functionality (methods and properties) to clients without requiring individual instances ot the type to be instantiated by the client.</p>
<p>A singleton type may be either a <a href="./qobject.htm" translate="no">QObject</a> or a <a href="./qjsvalue.htm" translate="no">QJSValue</a>. This function should be used to register a singleton type provider function which returns a <a href="./qobject.htm" translate="no">QObject</a> of the given type T as a singleton type.</p>
<p>A <a href="./qobject.htm" translate="no">QObject</a> singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <a href="./qml-qtqml-connections.htm" translate="no">Connections</a> type or otherwise used as any other type id would. One exception to this is that a <a href="./qobject.htm" translate="no">QObject</a> singleton type property may not be aliased.</p>
<p><b>NOTE:</b> A <a href="./qobject.htm" translate="no">QObject</a> singleton type instance returned from a singleton type provider is owned by the QML engine unless the object has explicit <a href="./qqmlengine.htm#ObjectOwnership-enum" translate="no">QQmlEngine::CppOwnership</a> flag set.</p>
<p>Usage:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// First, define your QObject which provides the functionality.</span>
<span class="keyword">class</span> SingletonTypeExample : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    Q_PROPERTY (<span class="type">int</span> someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

<span class="keyword">public</span>:
    SingletonTypeExample(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span><span class="operator">*</span> parent <span class="operator">=</span> <span class="number">0</span>)
        : <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>(parent)<span class="operator">,</span> m_someProperty(<span class="number">0</span>)
    {
    }

    <span class="operator">~</span>SingletonTypeExample() {}

    Q_INVOKABLE <span class="type">int</span> doSomething() { setSomeProperty(<span class="number">5</span>); <span class="keyword">return</span> m_someProperty; }

    <span class="type">int</span> someProperty() <span class="keyword">const</span> { <span class="keyword">return</span> m_someProperty; }
    <span class="type">void</span> setSomeProperty(<span class="type">int</span> val) { m_someProperty <span class="operator">=</span> val; <span class="keyword">emit</span> somePropertyChanged(val); }

<span class="keyword">signals</span>:
    <span class="type">void</span> somePropertyChanged(<span class="type">int</span> newValue);

<span class="keyword">private</span>:
    <span class="type">int</span> m_someProperty;
};

<span class="comment">// Second, define the singleton type provider function (callback).</span>
<span class="keyword">static</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> <span class="operator">*</span>example_qobject_singletontype_provider(<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="./qjsengine.htm#QJSEngine" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine)
{
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)

    SingletonTypeExample <span class="operator">*</span>example <span class="operator">=</span> <span class="keyword">new</span> SingletonTypeExample();
    <span class="keyword">return</span> example;
}

<span class="comment">// Third, register the singleton type provider with QML by calling this function in an initialization function.</span>
qmlRegisterSingletonType<span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span>(<span class="string">"Qt.example.qobjectSingleton"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"MyApi"</span><span class="operator">,</span> example_qobject_singletontype_provider);</pre></div>
<p>Alternatively, you can use a C++11 lambda:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">qmlRegisterSingletonType<span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span>(<span class="string">"Qt.example.qobjectSingleton"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"MyApi"</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type"><a href="./qqmlengine.htm#QQmlEngine" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="./qjsengine.htm#QJSEngine" translate="no">QJSEngine</a></span> <span class="operator">*</span>scriptEngine) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> <span class="operator">*</span> {
    Q_UNUSED(engine)
    Q_UNUSED(scriptEngine)

    SingletonTypeExample <span class="operator">*</span>example <span class="operator">=</span> <span class="keyword">new</span> SingletonTypeExample();
    <span class="keyword">return</span> example;
});</pre></div>
<p>In order to use the registered singleton type in QML, you must import the singleton type.</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
<span class="type"><a href="./qml-qtquick-item.htm" translate="no">Item</a></span> {
    <span class="name">id</span>: <span class="name">root</span>
    property <span class="type"><a href="./qml-int.htm" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">MyApi</span>.<span class="name">someProperty</span>

    <span class="name">Component</span>.onCompleted: {
        <span class="name">someValue</span> <span class="operator">=</span> <span class="name">MyApi</span>.<span class="name">doSomething</span>()
    }
}</pre></div>
<p><b>See also </b><a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a> and <a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterSingletonType$$$qmlRegisterSingletonTypeconstchar*intintconstchar*int -->
<h3 class="fn" id="qmlRegisterSingletonType-2" translate="no"><a name="qmlRegisterSingletonType-2"></a>template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type">int</span> <i>callback</i>)<a class="plink" href="#qmlRegisterSingletonType-2" title="Direct link to this headline"></a></h3>
<p>This function overloads qmlRegisterSingletonType.</p>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterSingletonType$$$qmlRegisterSingletonTypeconstQUrl&constchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterSingletonType-3" translate="no"><a name="qmlRegisterSingletonType-3"></a><span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span> &amp;<i>url</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)<a class="plink" href="#qmlRegisterSingletonType-3" title="Direct link to this headline"></a></h3>
<p>This function may be used to register a singleton type with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>. The type is defined by the QML file located at <i translate="no">url</i>. The url must be an absolute URL, i.e. url.isRelative() == false.</p>
<p>In addition the type's QML file must have pragma Singleton statement among its import statements.</p>
<p>A singleton type may be referenced via the type name with which it was registered, and this typename may be used as the target in a <a href="./qml-qtqml-connections.htm" translate="no">Connections</a> type or otherwise used as any other type id would. One exception to this is that a singleton type property may not be aliased (because the singleton type name does not identify an object within the same component as any other item).</p>
<p>Usage:</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="comment">// First, define your QML singleton type which provides the functionality.</span>
pragma Singleton
import QtQuick 2.0
<span class="type"><a href="./qml-qtquick-item.htm" translate="no">Item</a></span> {
    property <span class="type"><a href="./qml-int.htm" translate="no">int</a></span> <span class="name">testProp1</span>: <span class="number">125</span>
}</pre></div>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Second, register the QML singleton type by calling this function in an initialization function.</span>
qmlRegisterSingletonType(<span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span>(<span class="string">"file:///absolute/path/SingletonType.qml"</span>)<span class="operator">,</span> <span class="string">"Qt.example.qobjectSingleton"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"RegisteredSingleton"</span>);</pre></div>
<p>In order to use the registered singleton type in QML, you must import the singleton type.</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick 2.0
import Qt.example.qobjectSingleton 1.0
<span class="type"><a href="./qml-qtquick-item.htm" translate="no">Item</a></span> {
    <span class="name">id</span>: <span class="name">root</span>
    property <span class="type"><a href="./qml-int.htm" translate="no">int</a></span> <span class="name">someValue</span>: <span class="name">RegisteredSingleton</span>.<span class="name">testProp1</span>
}</pre></div>
<p>It is also possible to have QML singleton types registered without using the qmlRegisterSingletonType function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a>.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterType[overload1]$$$qmlRegisterTypeconstchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterType" translate="no"><a name="qmlRegisterType"></a>template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)<a class="plink" href="#qmlRegisterType" title="Direct link to this headline"></a></h3>
<p>This template function registers the C++ type in the QML system with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>Returns the QML type id.</p>
<p>There are two forms of this template function:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
<span class="type">int</span> qmlRegisterType(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>qmlName);

<span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">,</span> <span class="type">int</span> metaObjectRevision<span class="operator">&gt;</span>
<span class="type">int</span> qmlRegisterType(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>qmlName);</pre></div>
<p>The former is the standard form which registers the type <i>T</i> as a new type. The latter allows a particular revision of a class to be registered in a specified version (see <a href="./qtqml-cppintegration-definetypes.htm#type-revisions-and-versions" translate="no">Type Revisions and Versions</a>).</p>
<p>For example, this registers a C++ class <code translate="no">MySliderItem</code> as a QML type named <code translate="no">Slider</code> for version 1.0 of a type namespace called "com.mycompany.qmlcomponents":</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">qmlRegisterType<span class="operator">&lt;</span>MySliderItem<span class="operator">&gt;</span>(<span class="string">"com.mycompany.qmlcomponents"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"Slider"</span>);</pre></div>
<p>Once this is registered, the type can be used in QML by importing the specified type namespace and version number:</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import com.mycompany.qmlcomponents 1.0

<span class="type"><a href="./qml-qtquick-controls2-slider.htm" translate="no">Slider</a></span> {
    <span class="comment">// ...</span>
}</pre></div>
<p>Note that it's perfectly reasonable for a library to register types to older versions than the actual version of the library. Indeed, it is normal for the new library to allow QML written to previous versions to continue to work, even if more advanced versions of some of its types are available.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterType -->
<!-- $$$qmlRegisterType$$$qmlRegisterTypeconstQUrl&constchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterType-2" translate="no"><a name="qmlRegisterType-2"></a><span class="type">int</span> <span class="name">qmlRegisterType</span>(const <span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span> &amp;<i>url</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)<a class="plink" href="#qmlRegisterType-2" title="Direct link to this headline"></a></h3>
<p>This function registers a type in the QML system with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>. The type is defined by the QML file located at <i translate="no">url</i>. The url must be an absolute URL, i.e. url.isRelative() == false.</p>
<p>Normally QML files can be loaded as types directly from other QML files, or using a qmldir file. This function allows registration of files to types from C++ code, such as when the type mapping needs to be procedurally determined at startup.</p>
<p>Returns -1 if the registration was not successful.</p>
<!-- @@@qmlRegisterType -->
<!-- $$$qmlRegisterTypeNotAvailable[overload1]$$$qmlRegisterTypeNotAvailableconstchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterTypeNotAvailable" translate="no"><a name="qmlRegisterTypeNotAvailable"></a><span class="type">int</span> <span class="name">qmlRegisterTypeNotAvailable</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>message</i>)<a class="plink" href="#qmlRegisterTypeNotAvailable" title="Direct link to this headline"></a></h3>
<p>This function registers a type in the QML system with the name <i translate="no">qmlName</i>, in the type namespace imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>, but any attempt to instantiate the type will produce the given error <i translate="no">message</i>.</p>
<p>Normally, the types exported by a plugin should be fixed. However, if a C++ type is not available, you should at least "reserve" the QML type name, and give the user of the unavailable type a meaningful error message.</p>
<p>Returns the QML type id.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor">#ifdef NO_GAMES_ALLOWED</span>
qmlRegisterTypeNotAvailable(<span class="string">"MinehuntCore"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="string">"Game"</span><span class="operator">,</span> <span class="string">"Get back to work, slacker!"</span>);
<span class="preprocessor">#else</span>
qmlRegisterType<span class="operator">&lt;</span>MinehuntGame<span class="operator">&gt;</span>(<span class="string">"MinehuntCore"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="string">"Game"</span>);
<span class="preprocessor">#endif</span></pre></div>
<p>This will cause any QML which imports the "MinehuntCore" type namespace and attempts to use the type to produce an error message:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">fun<span class="operator">.</span>qml: Get back to work<span class="operator">,</span> slacker<span class="operator">!</span>
   Game {
   <span class="operator">^</span></pre></div>
<p>Without this, a generic "Game is not a type" message would be given.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_UNAVAILABLE" translate="no">QML_UNAVAILABLE</a>, <a href="./qqmlengine.htm#qmlRegisterUncreatableType" translate="no">qmlRegisterUncreatableType</a>(), and <a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterTypeNotAvailable -->
<!-- $$$qmlRegisterUncreatableMetaObject[overload1]$$$qmlRegisterUncreatableMetaObjectconstQMetaObject&constchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterUncreatableMetaObject" translate="no"><a name="qmlRegisterUncreatableMetaObject"></a><span class="type">int</span> <span class="name">qmlRegisterUncreatableMetaObject</span>(const <span class="type"><a href="./qmetaobject.htm" translate="no">QMetaObject</a></span> &amp;<i>staticMetaObject</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>reason</i>)<a class="plink" href="#qmlRegisterUncreatableMetaObject" title="Direct link to this headline"></a></h3>
<p>This function registers the <i translate="no">staticMetaObject</i> and its extension in the QML system with the name <i translate="no">qmlName</i> in the library imported from <i translate="no">uri</i> having version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>An instance of the meta object cannot be created. An error message with the given <i translate="no">reason</i> is printed if the user attempts to create it.</p>
<p>This function is useful for registering <a href="./qobject.htm#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> namespaces.</p>
<p>Returns the QML type id.</p>
<p>For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">namespace</span> MyNamespace {
  Q_NAMESPACE
  <span class="keyword">enum</span> MyEnum {
      Key1<span class="operator">,</span>
      Key2<span class="operator">,</span>
  };
  Q_ENUMS(MyEnum)
}

<span class="comment">//...</span>
qmlRegisterUncreatableMetaObject(MyNamespace<span class="operator">::</span>staticMetaObject<span class="operator">,</span> <span class="string">"io.qt"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"MyNamespace"</span><span class="operator">,</span> <span class="string">"Access to enums &amp; flags only"</span>);</pre></div>
<p>On the QML side, you can now use the registered enums:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">Component<span class="operator">.</span>onCompleted: console<span class="operator">.</span>log(MyNamespace<span class="operator">.</span>Key2)</pre></div>
<p>This function was introduced in Qt 5.8.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>().</p>
<!-- @@@qmlRegisterUncreatableMetaObject -->
<!-- $$$qmlRegisterUncreatableType[overload1]$$$qmlRegisterUncreatableTypeconstchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterUncreatableType" translate="no"><a name="qmlRegisterUncreatableType"></a>template &lt;typename T&gt; <span class="type">int</span> <span class="name">qmlRegisterUncreatableType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>message</i>)<a class="plink" href="#qmlRegisterUncreatableType" title="Direct link to this headline"></a></h3>
<p>This template function registers the C++ type in the QML system with the name <i translate="no">qmlName</i>, in the library imported from <i translate="no">uri</i> having the version number composed from <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>While the type has a name and a type, it cannot be created, and the given error <i translate="no">message</i> will result if creation is attempted.</p>
<p>This is useful where the type is only intended for providing attached properties or enum values.</p>
<p>Returns the QML type id.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), <a href="./qqmlengine.htm#qmlRegisterTypeNotAvailable" translate="no">qmlRegisterTypeNotAvailable</a>(), and <a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>.</p>
<!-- @@@qmlRegisterUncreatableType -->
<!-- $$$qmlTypeId[overload1]$$$qmlTypeIdconstchar*intintconstchar* -->
<h3 class="fn" id="qmlTypeId" translate="no"><a name="qmlTypeId"></a><span class="type">int</span> <span class="name">qmlTypeId</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)<a class="plink" href="#qmlTypeId" title="Direct link to this headline"></a></h3>
<p>Returns the QML type id of a type that was registered with the name <i translate="no">qmlName</i> in a particular <i translate="no">uri</i> and a version specified in <i translate="no">versionMajor</i> and <i translate="no">versionMinor</i>.</p>
<p>This function returns the same value as the QML type registration functions such as qmlRegisterType() and <a href="./qqmlengine.htm#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>().</p>
<p>If <i translate="no">qmlName</i>, <i translate="no">uri</i> and <i translate="no">versionMajor</i> match a registered type, but the specified minor version in <i translate="no">versionMinor</i> is higher, then the id of the type with the closest minor version is returned.</p>
<p>Returns -1 if no matching type was found or one of the given parameters was invalid.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>, <a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="./qqmlengine-obsolete.htm#qmlRegisterType-1" translate="no">qmlRegisterType</a>(), and <a href="./qqmlengine.htm#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>().</p>
<!-- @@@qmlTypeId -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QML_ADDED_IN_MINOR_VERSION[overload1]$$$QML_ADDED_IN_MINOR_VERSION -->
<h3 class="fn" id="QML_ADDED_IN_MINOR_VERSION" translate="no"><a name="QML_ADDED_IN_MINOR_VERSION"></a><span class="name">QML_ADDED_IN_MINOR_VERSION</span>(<i>VERSION</i>)<a class="plink" href="#QML_ADDED_IN_MINOR_VERSION" title="Direct link to this headline"></a></h3>
<p>Declares that the enclosing type or namespace was added in the specified minor <i translate="no">VERSION</i>, relative to the module major version. The minor version is assumed to be in line with any revisions given by <a href="./qobject.htm#Q_REVISION" translate="no">Q_REVISION</a>() macros on methods, slots, or signals, and any REVISION tags on properties declared with <a href="./qobject.htm#Q_PROPERTY" translate="no">Q_PROPERTY</a>().</p>
<p>QML_ADDED_IN_MINOR_VERSION() only takes effect if the type or namespace is available in QML, by having a <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>, or <a href="./qqmlengine.htm#QML_INTERFACE" translate="no">QML_INTERFACE</a> macro.</p>
<p>If the QML module the type belongs to is imported with a lower version than the one determined this way, the QML type is invisible.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> and <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>().</p>
<!-- @@@QML_ADDED_IN_MINOR_VERSION -->
<!-- $$$QML_ANONYMOUS[overload1]$$$QML_ANONYMOUS -->
<h3 class="fn" id="QML_ANONYMOUS" translate="no"><a name="QML_ANONYMOUS"></a><span class="name">QML_ANONYMOUS</span><a class="plink" href="#QML_ANONYMOUS" title="Direct link to this headline"></a></h3>
<p>Declares the enclosing type to be available, but anonymous in QML. The type cannot be created or used as property type, but when passed from C++, it is recognized.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="./qqmlengine.htm#QML_INTERFACE" translate="no">QML_INTERFACE</a>.</p>
<!-- @@@QML_ANONYMOUS -->
<!-- $$$QML_ATTACHED[overload1]$$$QML_ATTACHED -->
<h3 class="fn" id="QML_ATTACHED" translate="no"><a name="QML_ATTACHED"></a><span class="name">QML_ATTACHED</span>(<i>ATTACHED_TYPE</i>)<a class="plink" href="#QML_ATTACHED" title="Direct link to this headline"></a></h3>
<p>Declares that the enclosing type attaches <i translate="no">ATTACHED_TYPE</i> as an <a href="./qtqml-syntax-objectattributes.htm#attached-properties-and-attached-signal-handlers" translate="no">attached property</a> to other types. This takes effect if the type is exposed to QML using a <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qqmlengine.htm#qmlAttachedPropertiesObject" translate="no">qmlAttachedPropertiesObject</a>(), and <a href="./qtqml-cppintegration-definetypes.htm#providing-attached-properties" translate="no">Providing Attached Properties</a>.</p>
<!-- @@@QML_ATTACHED -->
<!-- $$$QML_DECLARE_TYPE[overload1]$$$QML_DECLARE_TYPE -->
<h3 class="fn" id="QML_DECLARE_TYPE" translate="no"><a name="QML_DECLARE_TYPE"></a><span class="name">QML_DECLARE_TYPE</span><a class="plink" href="#QML_DECLARE_TYPE" title="Direct link to this headline"></a></h3>
<p>Equivalent to <code translate="no">Q_DECLARE_METATYPE(TYPE *)</code> and <code translate="no">Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</code></p>
<!-- @@@QML_DECLARE_TYPE -->
<!-- $$$QML_DECLARE_TYPEINFO[overload1]$$$QML_DECLARE_TYPEINFO -->
<h3 class="fn" id="QML_DECLARE_TYPEINFO" translate="no"><a name="QML_DECLARE_TYPEINFO"></a><span class="name">QML_DECLARE_TYPEINFO</span>(<i>Type</i>, <i>Flags</i>)<a class="plink" href="#QML_DECLARE_TYPEINFO" title="Direct link to this headline"></a></h3>
<p>Declares additional properties of the given <i translate="no">Type</i> as described by the specified <i translate="no">Flags</i>.</p>
<p>Current the only supported type info is <code translate="no">QML_HAS_ATTACHED_PROPERTIES</code> which declares that the <i translate="no">Type</i> supports <a href="./qtqml-syntax-objectattributes.htm#attached-properties-and-attached-signal-handlers" translate="no">attached properties</a>. QML_DECLARE_TYPEINFO() is not necessary if <i translate="no">Type</i> contains the <a href="./qqmlengine.htm#QML_ATTACHED" translate="no">QML_ATTACHED</a> macro.</p>
<!-- @@@QML_DECLARE_TYPEINFO -->
<!-- $$$QML_ELEMENT[overload1]$$$QML_ELEMENT -->
<h3 class="fn" id="QML_ELEMENT" translate="no"><a name="QML_ELEMENT"></a><span class="name">QML_ELEMENT</span><a class="plink" href="#QML_ELEMENT" title="Direct link to this headline"></a></h3>
<p>Declares the enclosing type or namespace to be available in QML, using its class or namespace name as the QML element name.</p>
<p>For example, this makes the C++ class <code translate="no">Slider</code> available as a QML type named <code translate="no">Slider</code>.</p>
<div class="pre"><pre class="cpp" translate="no"><span class="keyword">class</span> Slider : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    QML_ELEMENT
    <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
}</pre></div>
<p>You can use the build system to register the type in the type namespace <i>com.mycompany.qmlcomponents</i> with major version <code translate="no">1</code> by specifying the following in your project file:</p>
<div class="pre"><pre class="cpp plain" translate="no">CONFIG += qmltypes
QML_IMPORT_NAME = com.mycompany.qmlcomponents
QML_IMPORT_MAJOR_VERSION = 1</pre></div>
<p>Once registered, the type can be used in QML by importing the same type namespace and version number:</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import com.mycompany.qmlcomponents 1.0

<span class="type"><a href="./qml-qtquick-controls2-slider.htm" translate="no">Slider</a></span> {
    <span class="comment">// ...</span>
}</pre></div>
<p>You can also make namespaces tagged with <a href="./qobject.htm#Q_NAMESPACE" translate="no">Q_NAMESPACE</a> available this way, in order to expose any enums tagged with <a href="./qobject.htm#Q_ENUM_NS" translate="no">Q_ENUM_NS</a> they contain.</p>
<p><b>See also </b><a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qobject.htm#Q_REVISION" translate="no">Q_REVISION</a>(), and <a href="./qqmlengine.htm#QML_ADDED_IN_MINOR_VERSION" translate="no">QML_ADDED_IN_MINOR_VERSION</a>().</p>
<!-- @@@QML_ELEMENT -->
<!-- $$$QML_EXTENDED[overload1]$$$QML_EXTENDED -->
<h3 class="fn" id="QML_EXTENDED" translate="no"><a name="QML_EXTENDED"></a><span class="name">QML_EXTENDED</span>(<i>EXTENDED_TYPE</i>)<a class="plink" href="#QML_EXTENDED" title="Direct link to this headline"></a></h3>
<p>Declares that the enclosing type uses <i translate="no">EXTENDED_TYPE</i> as an extension to provide further properties and methods in QML. This takes effect if the type is exposed to QML using a <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="./qtqml-cppintegration-definetypes.htm#registering-extension-objects" translate="no">Registering Extension Objects</a>.</p>
<!-- @@@QML_EXTENDED -->
<!-- $$$QML_FOREIGN[overload1]$$$QML_FOREIGN -->
<h3 class="fn" id="QML_FOREIGN" translate="no"><a name="QML_FOREIGN"></a><span class="name">QML_FOREIGN</span>(<i>FOREIGN_TYPE</i>)<a class="plink" href="#QML_FOREIGN" title="Direct link to this headline"></a></h3>
<p>Declares that any <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>, <a href="./qqmlengine.htm#QML_INTERFACE" translate="no">QML_INTERFACE</a>, <a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), <a href="./qqmlengine.htm#QML_SINGLETON" translate="no">QML_SINGLETON</a>, <a href="./qqmlengine.htm#QML_ADDED_IN_MINOR_VERSION" translate="no">QML_ADDED_IN_MINOR_VERSION</a>(), <a href="./qqmlengine.htm#QML_REMOVED_IN_MINOR_VERSION" translate="no">QML_REMOVED_IN_MINOR_VERSION</a>(), <a href="./qqmlengine.htm#QML_ATTACHED" translate="no">QML_ATTACHED</a>(), or <a href="./qqmlengine.htm#QML_EXTENDED" translate="no">QML_EXTENDED</a>() macros in the enclosing C++ type do not apply to the enclosing type but instead to <i translate="no">FOREIGN_TYPE</i>. The enclosing type still needs to be registered with the <a href="./metaobjects.htm" translate="no">meta object system</a> using a <a href="./qobject.htm#Q_GADGET" translate="no">Q_GADGET</a> or <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> macro.</p>
<p>This is useful for registering types that cannot be amended to add the macros, for example because they belong to 3rdparty libraries.</p>
<p><b>NOTE:</b> You may want to use <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() instead of <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> due to the fact that the element will be named like the struct it is contained in, not the foreign type. See <a href="./qtqml-referenceexamples-extended-example.htm" translate="no">Extending QML - Extension Objects Example</a> for an example.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> and <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>().</p>
<!-- @@@QML_FOREIGN -->
<!-- $$$QML_INTERFACE[overload1]$$$QML_INTERFACE -->
<h3 class="fn" id="QML_INTERFACE" translate="no"><a name="QML_INTERFACE"></a><span class="name">QML_INTERFACE</span><a class="plink" href="#QML_INTERFACE" title="Direct link to this headline"></a></h3>
<p>This macro registers the enclosing C++ type in the QML system as an interface.</p>
<p>Types registered as an interface in QML should also declare themselves as an interface with the <a href="./metaobjects.htm" translate="no">meta object system</a>. For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">struct</span> FooInterface
{
    QML_INTERFACE
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="operator">~</span>FooInterface();
    <span class="keyword">virtual</span> <span class="type">void</span> doSomething() <span class="operator">=</span> <span class="number">0</span>;
};

Q_DECLARE_INTERFACE(FooInterface<span class="operator">,</span> <span class="string">"org.foo.FooInterface"</span>)</pre></div>
<p>When registered with QML in this way, they can be used as property types:</p>
<p><a href="./qobject.htm#Q_PROPERTY" translate="no">Q_PROPERTY</a>(FooInterface *foo READ foo WRITE setFoo)</p>
<p>When you assign a <a href="./qobject.htm" translate="no">QObject</a> sub-class to this property, the QML engine does the interface cast to <code translate="no">FooInterface*</code> automatically.</p>
<p>Interface types are implicitly anonymous and uncreatable in QML.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>.</p>
<!-- @@@QML_INTERFACE -->
<!-- $$$QML_NAMED_ELEMENT[overload1]$$$QML_NAMED_ELEMENT -->
<h3 class="fn" id="QML_NAMED_ELEMENT" translate="no"><a name="QML_NAMED_ELEMENT"></a><span class="name">QML_NAMED_ELEMENT</span>(<i>name</i>)<a class="plink" href="#QML_NAMED_ELEMENT" title="Direct link to this headline"></a></h3>
<p>Declares the enclosing type or namespace to be available in QML, using <i translate="no">name</i> as the element name. Otherwise behaves the same as <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> SqlEventDatabase : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    QML_NAMED_ELEMENT(EventDatabase)

    <span class="comment">// ...</span>
};</pre></div>
<p><b>See also </b><a href="./qtqml-cppintegration-overview.htm#choosing-the-correct-integration-method-between-c-and-qml" translate="no">Choosing the Correct Integration Method Between C++ and QML</a> and <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>.</p>
<!-- @@@QML_NAMED_ELEMENT -->
<!-- $$$QML_REMOVED_IN_MINOR_VERSION[overload1]$$$QML_REMOVED_IN_MINOR_VERSION -->
<h3 class="fn" id="QML_REMOVED_IN_MINOR_VERSION" translate="no"><a name="QML_REMOVED_IN_MINOR_VERSION"></a><span class="name">QML_REMOVED_IN_MINOR_VERSION</span>(<i>VERSION</i>)<a class="plink" href="#QML_REMOVED_IN_MINOR_VERSION" title="Direct link to this headline"></a></h3>
<p>Declares that the enclosing type or namespace was removed in the specified minor <i translate="no">VERSION</i>, relative to the module major version. This is primarily useful when replacing the implementation of a QML type. If a corresponding <a href="./qqmlengine.htm#QML_ADDED_IN_MINOR_VERSION" translate="no">QML_ADDED_IN_MINOR_VERSION</a>() is present on a different type or namespace of the same QML name, then the removed type is used when importing versions of the module lower than <i translate="no">VERSION</i>, and the added type is used when importing versions of the module greater or equal <i translate="no">VERSION</i>.</p>
<p>QML_REMOVED_IN_MINOR_VERSION() only takes effect if type or namespace is available in QML, by having a <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>, or <a href="./qqmlengine.htm#QML_INTERFACE" translate="no">QML_INTERFACE</a> macro.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> and <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>().</p>
<!-- @@@QML_REMOVED_IN_MINOR_VERSION -->
<!-- $$$QML_SINGLETON[overload1]$$$QML_SINGLETON -->
<h3 class="fn" id="QML_SINGLETON" translate="no"><a name="QML_SINGLETON"></a><span class="name">QML_SINGLETON</span><a class="plink" href="#QML_SINGLETON" title="Direct link to this headline"></a></h3>
<p>Declares the enclosing type to be a singleton in QML. This only takes effect if the type is a <a href="./qobject.htm#Q_OBJECT" translate="no">Q_OBJECT</a> and is available in QML (by having a <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro). By default, each <a href="./qqmlengine.htm" translate="no">QQmlEngine</a> will try to create a singleton instance using the type's default constructor when the type is first accessed. If there is no default constructor the singleton is initially inaccessible. This behavior can be overridden by calling <a href="./qqmlengine.htm#qmlRegisterSingletonType" translate="no">qmlRegisterSingletonType</a>() with a specific factory function or <a href="./qqmlengine.htm#qmlRegisterSingletonInstance" translate="no">qmlRegisterSingletonInstance</a>() with a specific instance for the same class and the same type namespace and version.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="./qqmlengine.htm#qmlRegisterSingletonInstance" translate="no">qmlRegisterSingletonInstance</a>().</p>
<!-- @@@QML_SINGLETON -->
<!-- $$$QML_UNAVAILABLE[overload1]$$$QML_UNAVAILABLE -->
<h3 class="fn" id="QML_UNAVAILABLE" translate="no"><a name="QML_UNAVAILABLE"></a><span class="name">QML_UNAVAILABLE</span><a class="plink" href="#QML_UNAVAILABLE" title="Direct link to this headline"></a></h3>
<p>This macro declares the enclosing type to be unavailable in QML. It registers an internal dummy type called <code translate="no">QQmlTypeNotAvailable</code> as <a href="./qqmlengine.htm#QML_FOREIGN" translate="no">QML_FOREIGN</a>() type, using any further QML macros you specify.</p>
<p>Normally, the types exported by a module should be fixed. However, if a C++ type is not available, you should at least "reserve" the QML type name, and give the user of the unavailable type a meaningful error message.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor">#ifdef NO_GAMES_ALLOWED</span>
<span class="keyword">struct</span> MinehuntGame
{
    Q_GADGET
    QML_NAMED_ELEMENT(Game)
    QML_UNAVAILABLE
    QML_UNCREATABLE(<span class="string">"Get back to work, slacker!"</span>);
};
<span class="preprocessor">#else</span>
<span class="keyword">class</span> MinehuntGame : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    QML_NAMED_ELEMENT(Game)
    <span class="comment">// ...</span>
};
<span class="preprocessor">#endif</span></pre></div>
<p>This will cause any QML which attempts to use the "Game" type to produce an error message:</p>
<div class="pre"><pre class="cpp plain" translate="no">fun.qml: Get back to work, slacker!
   Game {
   ^</pre></div>
<p>Using this technique, you only need a <a href="./qobject.htm#Q_GADGET" translate="no">Q_GADGET</a> struct to customize the error message, not a full-blown <a href="./qobject.htm" translate="no">QObject</a>. Without <a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), QML_UNAVAILABLE still results in a more specific error message than the usual "is not a type" for completely unknown types.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), <a href="./qqmlengine.htm#QML_UNCREATABLE" translate="no">QML_UNCREATABLE</a>(), and <a href="./qqmlengine.htm#QML_FOREIGN" translate="no">QML_FOREIGN</a>().</p>
<!-- @@@QML_UNAVAILABLE -->
<!-- $$$QML_UNCREATABLE[overload1]$$$QML_UNCREATABLE -->
<h3 class="fn" id="QML_UNCREATABLE" translate="no"><a name="QML_UNCREATABLE"></a><span class="name">QML_UNCREATABLE</span>(<i>reason</i>)<a class="plink" href="#QML_UNCREATABLE" title="Direct link to this headline"></a></h3>
<p>Declares that the enclosing type shall not be creatable from QML. This takes effect if the type is available in QML, by having a <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>() macro. The <i translate="no">reason</i> will be emitted as error message if an attempt to create the type from QML is detected.</p>
<p>Some QML types are implicitly uncreatable, in particular types exposed with <a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a> or namespaces exposed with <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> or <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(). For such types, QML_UNCREATABLE() can be used to provide a custom error message.</p>
<p><b>See also </b><a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a>, <a href="./qqmlengine.htm#QML_NAMED_ELEMENT" translate="no">QML_NAMED_ELEMENT</a>(), and <a href="./qqmlengine.htm#QML_ANONYMOUS" translate="no">QML_ANONYMOUS</a>.</p>
<!-- @@@QML_UNCREATABLE -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>