<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QSGTexture | Qt Quick</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qsgtexture.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a href="./qtquick-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QSGTexture</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QSGTexture Class</h1>
<!-- $$$QSGTexture-brief -->
<p>The QSGTexture class is a baseclass for textures used in the scene graph. <a href="#details">More...</a></p>
<!-- @@@QSGTexture -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSGTexture&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qobject.htm" translate="no">QObject</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qsgdynamictexture.htm" translate="no">QSGDynamicTexture</a></p>
</td></tr></tbody></table></div><ul>
<li><a href="./qsgtexture-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture-nativetexture.htm" translate="no">NativeTexture</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#AnisotropyLevel-enum" translate="no">AnisotropyLevel</a></b> { AnisotropyNone, Anisotropy2x, Anisotropy4x, Anisotropy8x, Anisotropy16x }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#Filtering-enum" translate="no">Filtering</a></b> { None, Nearest, Linear }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#WrapMode-enum" translate="no">WrapMode</a></b> { Repeat, ClampToEdge, MirroredRepeat }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#QSGTexture" translate="no">QSGTexture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#dtor.QSGTexture" translate="no">~QSGTexture</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture::AnisotropyLevel </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#anisotropyLevel" translate="no">anisotropyLevel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#bind" translate="no">bind</a></b>() = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#comparisonKey" translate="no">comparisonKey</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#convertToNormalizedSourceRect" translate="no">convertToNormalizedSourceRect</a></b>(const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture::Filtering </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#filtering" translate="no">filtering</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#hasAlphaChannel" translate="no">hasAlphaChannel</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#hasMipmaps" translate="no">hasMipmaps</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture::WrapMode </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#horizontalWrapMode" translate="no">horizontalWrapMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#isAtlasTexture" translate="no">isAtlasTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture::Filtering </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#mipmapFiltering" translate="no">mipmapFiltering</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture::NativeTexture </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#nativeTexture" translate="no">nativeTexture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QRectF </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#normalizedTextureSubRect" translate="no">normalizedTextureSubRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGTexture *</td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#removedFromAtlas" translate="no">removedFromAtlas</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#setAnisotropyLevel" translate="no">setAnisotropyLevel</a></b>(QSGTexture::AnisotropyLevel <i>level</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#setFiltering" translate="no">setFiltering</a></b>(QSGTexture::Filtering <i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#setHorizontalWrapMode" translate="no">setHorizontalWrapMode</a></b>(QSGTexture::WrapMode <i>hwrap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#setMipmapFiltering" translate="no">setMipmapFiltering</a></b>(QSGTexture::Filtering <i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#setVerticalWrapMode" translate="no">setVerticalWrapMode</a></b>(QSGTexture::WrapMode <i>vwrap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#textureId" translate="no">textureId</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#textureSize" translate="no">textureSize</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#updateBindOptions" translate="no">updateBindOptions</a></b>(bool <i>force</i> = false)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#updateRhiTexture" translate="no">updateRhiTexture</a></b>(QRhi *<i>rhi</i>, QRhiResourceUpdateBatch *<i>resourceUpdates</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture::WrapMode </td><td class="memItemRight bottomAlign"><b><a href="./qsgtexture.htm#verticalWrapMode" translate="no">verticalWrapMode</a></b>() const</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QSGTexture-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>Users can freely implement their own texture classes to support arbitrary input textures, such as YUV video frames or 8 bit alpha masks. The scene graph backend provides a default implementation of normal color textures. As the implementation of these may be hardware specific, they are constructed via the factory function <a href="./qquickwindow.htm#createTextureFromImage" translate="no">QQuickWindow::createTextureFromImage</a>().</p>
<p>The texture is a wrapper around an OpenGL texture, which texture id is given by <a href="./qsgtexture.htm#textureId" translate="no">textureId</a>() and which size in pixels is given by <a href="./qsgtexture.htm#textureSize" translate="no">textureSize</a>(). <a href="./qsgtexture.htm#hasAlphaChannel" translate="no">hasAlphaChannel</a>() reports if the texture contains opacity values and <a href="./qsgtexture.htm#hasMipmaps" translate="no">hasMipmaps</a>() reports if the texture contains mipmap levels.</p>
<p>To use a texture, call the <a href="./qsgtexture.htm#bind" translate="no">bind</a>() function. The texture parameters specifying how the texture is bound, can be specified with <a href="./qsgtexture.htm#setMipmapFiltering" translate="no">setMipmapFiltering</a>(), <a href="./qsgtexture.htm#setFiltering" translate="no">setFiltering</a>(), <a href="./qsgtexture.htm#setHorizontalWrapMode" translate="no">setHorizontalWrapMode</a>() and <a href="./qsgtexture.htm#setVerticalWrapMode" translate="no">setVerticalWrapMode</a>(). The texture will internally try to store these values to minimize the OpenGL state changes when the texture is bound.</p>
<a name="texture-atlasses"></a>
<h3 id="texture-atlasses">Texture Atlasses<a class="plink" href="#texture-atlasses" title="Direct link to this headline"></a></h3>
<p>Some scene graph backends use texture atlasses, grouping multiple small textures into one large texture. If this is the case, the function <a href="./qsgtexture.htm#isAtlasTexture" translate="no">isAtlasTexture</a>() will return true. Atlasses are used to aid the rendering algorithm to do better sorting which increases performance. The location of the texture inside the atlas is given with the <a href="./qsgtexture.htm#normalizedTextureSubRect" translate="no">normalizedTextureSubRect</a>() function.</p>
<p>If the texture is used in such a way that atlas is not preferable, the function <a href="./qsgtexture.htm#removedFromAtlas" translate="no">removedFromAtlas</a>() can be used to extract a non-atlassed copy.</p>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="./qtquick-visualcanvas-scenegraph.htm#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
</div>
<p><b>See also </b><a href="./qtquick-scenegraph-fboitem-example.htm" translate="no">Scene Graph - Rendering FBOs</a> and <a href="./qtquick-scenegraph-textureinthread-example.htm" translate="no">Scene Graph - Rendering FBOs in a thread</a>.</p>
<!-- @@@QSGTexture -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$AnisotropyLevel$$$AnisotropyNone$$$Anisotropy2x$$$Anisotropy4x$$$Anisotropy8x$$$Anisotropy16x -->
<h3 class="fn" id="AnisotropyLevel-enum" translate="no"><a name="AnisotropyLevel-enum"></a>enum QSGTexture::<span class="name">AnisotropyLevel</span><a class="plink" href="#AnisotropyLevel-enum" title="Direct link to this headline"></a></h3>
<p>Specifies the anisotropic filtering level to be used when the texture is not screen aligned.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::AnisotropyNone</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No anisotropic filtering.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::Anisotropy2x</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">2x anisotropic filtering.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::Anisotropy4x</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">4x anisotropic filtering.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::Anisotropy8x</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">8x anisotropic filtering.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::Anisotropy16x</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">16x anisotropic filtering.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 5.9.</p>
<!-- @@@AnisotropyLevel -->
<!-- $$$Filtering$$$None$$$Nearest$$$Linear -->
<h3 class="fn" id="Filtering-enum" translate="no"><a name="Filtering-enum"></a>enum QSGTexture::<span class="name">Filtering</span><a class="plink" href="#Filtering-enum" title="Direct link to this headline"></a></h3>
<p>Specifies how sampling of texels should filter when texture coordinates are not pixel aligned.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::None</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No filtering should occur. This value is only used together with <a href="./qsgtexture.htm#setMipmapFiltering" translate="no">setMipmapFiltering</a>().</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::Nearest</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Sampling returns the nearest texel.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::Linear</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Sampling returns a linear interpolation of the neighboring texels.</td></tr>
</tbody></table></div>
<!-- @@@Filtering -->
<!-- $$$WrapMode$$$Repeat$$$ClampToEdge$$$MirroredRepeat -->
<h3 class="fn" id="WrapMode-enum" translate="no"><a name="WrapMode-enum"></a>enum QSGTexture::<span class="name">WrapMode</span><a class="plink" href="#WrapMode-enum" title="Direct link to this headline"></a></h3>
<p>Specifies how the texture should treat texture coordinates.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::Repeat</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Only the fractional part of the texture coordinate is used, causing values above 1 and below 0 to repeat.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::ClampToEdge</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Values above 1 are clamped to 1 and values below 0 are clamped to 0.</td></tr>
<tr><td class="topAlign"><code translate="no">QSGTexture::MirroredRepeat</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">When the texture coordinate is even, only the fractional part is used. When odd, the texture coordinate is set to <code translate="no">1 - fractional part</code>. This value has been introduced in Qt 5.10.</td></tr>
</tbody></table></div>
<!-- @@@WrapMode -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSGTexture[overload1]$$$QSGTexture -->
<h3 class="fn" id="QSGTexture" translate="no"><a name="QSGTexture"></a>QSGTexture::<span class="name">QSGTexture</span>()<a class="plink" href="#QSGTexture" title="Direct link to this headline"></a></h3>
<p>Constructs the QSGTexture base class.</p>
<!-- @@@QSGTexture -->
<!-- $$$~QSGTexture[overload1]$$$~QSGTexture -->
<h3 class="fn" id="dtor.QSGTexture" translate="no"><a name="dtor.QSGTexture"></a><code translate="no">[override virtual] </code>QSGTexture::<span class="name">~QSGTexture</span>()<a class="plink" href="#dtor.QSGTexture" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qsgtexture.htm" translate="no">QSGTexture</a>.</p>
<!-- @@@~QSGTexture -->
<!-- $$$anisotropyLevel[overload1]$$$anisotropyLevel -->
<h3 class="fn" id="anisotropyLevel" translate="no"><a name="anisotropyLevel"></a><span class="type"><a href="./qsgtexture.htm#AnisotropyLevel-enum" translate="no">QSGTexture::AnisotropyLevel</a></span> QSGTexture::<span class="name">anisotropyLevel</span>() const<a class="plink" href="#anisotropyLevel" title="Direct link to this headline"></a></h3>
<p>Returns the anisotropy level in use for filtering this texture.</p>
<p>This function was introduced in Qt 5.9.</p>
<p><b>See also </b><a href="./qsgtexture.htm#setAnisotropyLevel" translate="no">setAnisotropyLevel</a>().</p>
<!-- @@@anisotropyLevel -->
<!-- $$$bind[overload1]$$$bind -->
<h3 class="fn" id="bind" translate="no"><a name="bind"></a><code translate="no">[pure virtual] </code><span class="type">void</span> QSGTexture::<span class="name">bind</span>()<a class="plink" href="#bind" title="Direct link to this headline"></a></h3>
<p>Call this function to bind this texture to the current texture target.</p>
<p>Binding a texture may also include uploading the texture data from a previously set <a href="./qimage.htm" translate="no">QImage</a>.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function should only be called when running with the direct OpenGL rendering path.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the rendering thread.</p>
</div>
<!-- @@@bind -->
<!-- $$$comparisonKey[overload1]$$$comparisonKey -->
<h3 class="fn" id="comparisonKey" translate="no"><a name="comparisonKey"></a><span class="type">int</span> QSGTexture::<span class="name">comparisonKey</span>() const<a class="plink" href="#comparisonKey" title="Direct link to this headline"></a></h3>
<p>Returns a key suitable for comparing textures. Typically used in <a href="./qsgmaterial.htm#compare" translate="no">QSGMaterial::compare</a>() implementations.</p>
<p>Just comparing <a href="./qsgtexture.htm" translate="no">QSGTexture</a> pointers is not always sufficient because two <a href="./qsgtexture.htm" translate="no">QSGTexture</a> instances that refer to the same native texture object underneath should also be considered equal. Hence this function.</p>
<div class="admonition note">
<p><b>Note: </b>Unlike <a href="./qsgtexture.htm#textureId" translate="no">textureId</a>(), implementations of this function are not expected to and should not create any graphics resources (so texture objects) in case there is none yet.</p>
</div>
<p>A <a href="./qsgtexture.htm" translate="no">QSGTexture</a> that does not have a native texture object underneath is typically not equal to any other <a href="./qsgtexture.htm" translate="no">QSGTexture</a>. There are exceptions to this, in particular when atlasing is used (where multiple textures share the same atlas texture under the hood), that is then up to the subclass implementations to deal with as appropriate.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the rendering thread.</p>
</div>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@comparisonKey -->
<!-- $$$convertToNormalizedSourceRect[overload1]$$$convertToNormalizedSourceRectconstQRectF& -->
<h3 class="fn" id="convertToNormalizedSourceRect" translate="no"><a name="convertToNormalizedSourceRect"></a><span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> QSGTexture::<span class="name">convertToNormalizedSourceRect</span>(const <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> &amp;<i>rect</i>) const<a class="plink" href="#convertToNormalizedSourceRect" title="Direct link to this headline"></a></h3>
<p>Returns <i translate="no">rect</i> converted to normalized coordinates.</p>
<p><b>See also </b><a href="./qsgtexture.htm#normalizedTextureSubRect" translate="no">normalizedTextureSubRect</a>().</p>
<!-- @@@convertToNormalizedSourceRect -->
<!-- $$$filtering[overload1]$$$filtering -->
<h3 class="fn" id="filtering" translate="no"><a name="filtering"></a><span class="type"><a href="./qsgtexture.htm#Filtering-enum" translate="no">QSGTexture::Filtering</a></span> QSGTexture::<span class="name">filtering</span>() const<a class="plink" href="#filtering" title="Direct link to this headline"></a></h3>
<p>Returns the sampling mode to be used for this texture.</p>
<p><b>See also </b><a href="./qsgtexture.htm#setFiltering" translate="no">setFiltering</a>().</p>
<!-- @@@filtering -->
<!-- $$$hasAlphaChannel[overload1]$$$hasAlphaChannel -->
<h3 class="fn" id="hasAlphaChannel" translate="no"><a name="hasAlphaChannel"></a><code translate="no">[pure virtual] </code><span class="type">bool</span> QSGTexture::<span class="name">hasAlphaChannel</span>() const<a class="plink" href="#hasAlphaChannel" title="Direct link to this headline"></a></h3>
<p>Returns true if the texture data contains an alpha channel.</p>
<!-- @@@hasAlphaChannel -->
<!-- $$$hasMipmaps[overload1]$$$hasMipmaps -->
<h3 class="fn" id="hasMipmaps" translate="no"><a name="hasMipmaps"></a><code translate="no">[pure virtual] </code><span class="type">bool</span> QSGTexture::<span class="name">hasMipmaps</span>() const<a class="plink" href="#hasMipmaps" title="Direct link to this headline"></a></h3>
<p>Returns true if the texture data contains mipmap levels.</p>
<!-- @@@hasMipmaps -->
<!-- $$$horizontalWrapMode[overload1]$$$horizontalWrapMode -->
<h3 class="fn" id="horizontalWrapMode" translate="no"><a name="horizontalWrapMode"></a><span class="type"><a href="./qsgtexture.htm#WrapMode-enum" translate="no">QSGTexture::WrapMode</a></span> QSGTexture::<span class="name">horizontalWrapMode</span>() const<a class="plink" href="#horizontalWrapMode" title="Direct link to this headline"></a></h3>
<p>Returns the horizontal wrap mode to be used for this texture.</p>
<p><b>See also </b><a href="./qsgtexture.htm#setHorizontalWrapMode" translate="no">setHorizontalWrapMode</a>().</p>
<!-- @@@horizontalWrapMode -->
<!-- $$$isAtlasTexture[overload1]$$$isAtlasTexture -->
<h3 class="fn" id="isAtlasTexture" translate="no"><a name="isAtlasTexture"></a><code translate="no">[virtual] </code><span class="type">bool</span> QSGTexture::<span class="name">isAtlasTexture</span>() const<a class="plink" href="#isAtlasTexture" title="Direct link to this headline"></a></h3>
<p>Returns weither this texture is part of an atlas or not.</p>
<p>The default implementation returns false.</p>
<!-- @@@isAtlasTexture -->
<!-- $$$mipmapFiltering[overload1]$$$mipmapFiltering -->
<h3 class="fn" id="mipmapFiltering" translate="no"><a name="mipmapFiltering"></a><span class="type"><a href="./qsgtexture.htm#Filtering-enum" translate="no">QSGTexture::Filtering</a></span> QSGTexture::<span class="name">mipmapFiltering</span>() const<a class="plink" href="#mipmapFiltering" title="Direct link to this headline"></a></h3>
<p>Returns whether mipmapping should be used when sampling from this texture.</p>
<p><b>See also </b><a href="./qsgtexture.htm#setMipmapFiltering" translate="no">setMipmapFiltering</a>().</p>
<!-- @@@mipmapFiltering -->
<!-- $$$nativeTexture[overload1]$$$nativeTexture -->
<h3 class="fn" id="nativeTexture" translate="no"><a name="nativeTexture"></a><span class="type"><a href="./qsgtexture-nativetexture.htm" translate="no">QSGTexture::NativeTexture</a></span> QSGTexture::<span class="name">nativeTexture</span>() const<a class="plink" href="#nativeTexture" title="Direct link to this headline"></a></h3>
<p>Returns the platform-specific texture data for this texture.</p>
<div class="admonition note">
<p><b>Note: </b>This is only available when running the graphics API independent rendering path of the scene graph. Use <a href="./qsgtexture.htm#textureId" translate="no">textureId</a>() otherwise.</p>
</div>
<p>Returns an empty result (<code translate="no">object</code> is null) if there is no available underlying native texture.</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qquickwindow.htm#createTextureFromNativeObject" translate="no">QQuickWindow::createTextureFromNativeObject</a>().</p>
<!-- @@@nativeTexture -->
<!-- $$$normalizedTextureSubRect[overload1]$$$normalizedTextureSubRect -->
<h3 class="fn" id="normalizedTextureSubRect" translate="no"><a name="normalizedTextureSubRect"></a><code translate="no">[virtual] </code><span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> QSGTexture::<span class="name">normalizedTextureSubRect</span>() const<a class="plink" href="#normalizedTextureSubRect" title="Direct link to this headline"></a></h3>
<p>Returns the rectangle inside <a href="./qsgtexture.htm#textureSize" translate="no">textureSize</a>() that this texture represents in normalized coordinates.</p>
<p>The default implementation returns a rect at position (0, 0) with width and height of 1.</p>
<!-- @@@normalizedTextureSubRect -->
<!-- $$$removedFromAtlas[overload1]$$$removedFromAtlas -->
<h3 class="fn" id="removedFromAtlas" translate="no"><a name="removedFromAtlas"></a><code translate="no">[virtual] </code><span class="type"><a href="./qsgtexture.htm#QSGTexture" translate="no">QSGTexture</a></span> *QSGTexture::<span class="name">removedFromAtlas</span>() const<a class="plink" href="#removedFromAtlas" title="Direct link to this headline"></a></h3>
<p>This function returns a copy of the current texture which is removed from its atlas.</p>
<p>The current texture remains unchanged, so texture coordinates do not need to be updated.</p>
<p>Removing a texture from an atlas is primarily useful when passing it to a shader that operates on the texture coordinates 0-1 instead of the texture subrect inside the atlas.</p>
<p>If the texture is not part of a texture atlas, this function returns 0.</p>
<p>Implementations of this function are recommended to return the same instance for multiple calls to limit memory usage.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the rendering thread.</p>
</div>
<!-- @@@removedFromAtlas -->
<!-- $$$setAnisotropyLevel[overload1]$$$setAnisotropyLevelQSGTexture::AnisotropyLevel -->
<h3 class="fn" id="setAnisotropyLevel" translate="no"><a name="setAnisotropyLevel"></a><span class="type">void</span> QSGTexture::<span class="name">setAnisotropyLevel</span>(<span class="type"><a href="./qsgtexture.htm#AnisotropyLevel-enum" translate="no">QSGTexture::AnisotropyLevel</a></span> <i>level</i>)<a class="plink" href="#setAnisotropyLevel" title="Direct link to this headline"></a></h3>
<p>Sets the level of anisotropic filtering to be used for the upcoming <a href="./qsgtexture.htm#bind" translate="no">bind</a>() call to <i translate="no">level</i>. The default value is <a href="./qsgtexture.htm#AnisotropyLevel-enum" translate="no">QSGTexture::AnisotropyNone</a>, which means no anisotropic filtering is enabled.</p>
<p>This function was introduced in Qt 5.9.</p>
<p><b>See also </b><a href="./qsgtexture.htm#anisotropyLevel" translate="no">anisotropyLevel</a>().</p>
<!-- @@@setAnisotropyLevel -->
<!-- $$$setFiltering[overload1]$$$setFilteringQSGTexture::Filtering -->
<h3 class="fn" id="setFiltering" translate="no"><a name="setFiltering"></a><span class="type">void</span> QSGTexture::<span class="name">setFiltering</span>(<span class="type"><a href="./qsgtexture.htm#Filtering-enum" translate="no">QSGTexture::Filtering</a></span> <i>filter</i>)<a class="plink" href="#setFiltering" title="Direct link to this headline"></a></h3>
<p>Sets the sampling mode to be used for the upcoming <a href="./qsgtexture.htm#bind" translate="no">bind</a>() call to <i translate="no">filter</i>.</p>
<p><b>See also </b><a href="./qsgtexture.htm#filtering" translate="no">filtering</a>().</p>
<!-- @@@setFiltering -->
<!-- $$$setHorizontalWrapMode[overload1]$$$setHorizontalWrapModeQSGTexture::WrapMode -->
<h3 class="fn" id="setHorizontalWrapMode" translate="no"><a name="setHorizontalWrapMode"></a><span class="type">void</span> QSGTexture::<span class="name">setHorizontalWrapMode</span>(<span class="type"><a href="./qsgtexture.htm#WrapMode-enum" translate="no">QSGTexture::WrapMode</a></span> <i>hwrap</i>)<a class="plink" href="#setHorizontalWrapMode" title="Direct link to this headline"></a></h3>
<p>Sets the horizontal wrap mode to be used for the upcoming <a href="./qsgtexture.htm#bind" translate="no">bind</a>() call to <i translate="no">hwrap</i></p>
<p><b>See also </b><a href="./qsgtexture.htm#horizontalWrapMode" translate="no">horizontalWrapMode</a>().</p>
<!-- @@@setHorizontalWrapMode -->
<!-- $$$setMipmapFiltering[overload1]$$$setMipmapFilteringQSGTexture::Filtering -->
<h3 class="fn" id="setMipmapFiltering" translate="no"><a name="setMipmapFiltering"></a><span class="type">void</span> QSGTexture::<span class="name">setMipmapFiltering</span>(<span class="type"><a href="./qsgtexture.htm#Filtering-enum" translate="no">QSGTexture::Filtering</a></span> <i>filter</i>)<a class="plink" href="#setMipmapFiltering" title="Direct link to this headline"></a></h3>
<p>Sets the mipmap sampling mode to be used for the upcoming <a href="./qsgtexture.htm#bind" translate="no">bind</a>() call to <i translate="no">filter</i>.</p>
<p>Setting the mipmap filtering has no effect it the texture does not have mipmaps.</p>
<p><b>See also </b><a href="./qsgtexture.htm#mipmapFiltering" translate="no">mipmapFiltering</a>() and <a href="./qsgtexture.htm#hasMipmaps" translate="no">hasMipmaps</a>().</p>
<!-- @@@setMipmapFiltering -->
<!-- $$$setVerticalWrapMode[overload1]$$$setVerticalWrapModeQSGTexture::WrapMode -->
<h3 class="fn" id="setVerticalWrapMode" translate="no"><a name="setVerticalWrapMode"></a><span class="type">void</span> QSGTexture::<span class="name">setVerticalWrapMode</span>(<span class="type"><a href="./qsgtexture.htm#WrapMode-enum" translate="no">QSGTexture::WrapMode</a></span> <i>vwrap</i>)<a class="plink" href="#setVerticalWrapMode" title="Direct link to this headline"></a></h3>
<p>Sets the vertical wrap mode to be used for the upcoming <a href="./qsgtexture.htm#bind" translate="no">bind</a>() call to <i translate="no">vwrap</i></p>
<p><b>See also </b><a href="./qsgtexture.htm#verticalWrapMode" translate="no">verticalWrapMode</a>().</p>
<!-- @@@setVerticalWrapMode -->
<!-- $$$textureId[overload1]$$$textureId -->
<h3 class="fn" id="textureId" translate="no"><a name="textureId"></a><code translate="no">[pure virtual] </code><span class="type">int</span> QSGTexture::<span class="name">textureId</span>() const<a class="plink" href="#textureId" title="Direct link to this headline"></a></h3>
<p>Returns the OpenGL texture id for this texture.</p>
<p>The default value is 0, indicating that it is an invalid texture id.</p>
<p>The function should at all times return the correct texture id.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the rendering thread.</p>
</div>
<!-- @@@textureId -->
<!-- $$$textureSize[overload1]$$$textureSize -->
<h3 class="fn" id="textureSize" translate="no"><a name="textureSize"></a><code translate="no">[pure virtual] </code><span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> QSGTexture::<span class="name">textureSize</span>() const<a class="plink" href="#textureSize" title="Direct link to this headline"></a></h3>
<p>Returns the size of the texture.</p>
<!-- @@@textureSize -->
<!-- $$$updateBindOptions[overload1]$$$updateBindOptionsbool -->
<h3 class="fn" id="updateBindOptions" translate="no"><a name="updateBindOptions"></a><span class="type">void</span> QSGTexture::<span class="name">updateBindOptions</span>(<span class="type">bool</span> <i>force</i> = false)<a class="plink" href="#updateBindOptions" title="Direct link to this headline"></a></h3>
<p>Update the texture state to match the filtering, mipmap and wrap options currently set.</p>
<p>If <i translate="no">force</i> is true, all properties will be updated regardless of weither they have changed or not.</p>
<!-- @@@updateBindOptions -->
<!-- $$$updateRhiTexture[overload1]$$$updateRhiTextureQRhi*QRhiResourceUpdateBatch* -->
<h3 class="fn" id="updateRhiTexture" translate="no"><a name="updateRhiTexture"></a><span class="type">void</span> QSGTexture::<span class="name">updateRhiTexture</span>(<span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qrhi.html" translate="no">QRhi</a></span> *<i>rhi</i>, <span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qrhiresourceupdatebatch.html" translate="no">QRhiResourceUpdateBatch</a></span> *<i>resourceUpdates</i>)<a class="plink" href="#updateRhiTexture" title="Direct link to this headline"></a></h3>
<p>Call this function to enqueue image upload operations to <i translate="no">resourceUpdates</i>, in case there are any pending ones. When there is no new data (for example, because there was no setImage() since the last call to this function), the function does nothing.</p>
<p>Materials involving <i translate="no">rhi</i> textures are expected to call this function from their updateSampledImage() implementation, typically without any conditions.</p>
<div class="admonition note">
<p><b>Note: </b>This function is only used when running the graphics API independent rendering path of the scene graph.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the rendering thread.</p>
</div>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@updateRhiTexture -->
<!-- $$$verticalWrapMode[overload1]$$$verticalWrapMode -->
<h3 class="fn" id="verticalWrapMode" translate="no"><a name="verticalWrapMode"></a><span class="type"><a href="./qsgtexture.htm#WrapMode-enum" translate="no">QSGTexture::WrapMode</a></span> QSGTexture::<span class="name">verticalWrapMode</span>() const<a class="plink" href="#verticalWrapMode" title="Direct link to this headline"></a></h3>
<p>Returns the vertical wrap mode to be used for this texture.</p>
<p><b>See also </b><a href="./qsgtexture.htm#setVerticalWrapMode" translate="no">setVerticalWrapMode</a>().</p>
<!-- @@@verticalWrapMode -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>