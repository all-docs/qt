<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QOpenGLWindow | Qt GUI</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qopenglwindow.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtgui-index.htm" translate="no">Qt GUI</a></li>
                            <li><a href="./qtgui-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QOpenGLWindow</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QOpenGLWindow Class</h1>
<!-- $$$QOpenGLWindow-brief -->
<p>The QOpenGLWindow class is a convenience subclass of <a href="./qwindow.htm" translate="no">QWindow</a> to perform OpenGL painting. <a href="#details">More...</a></p>
<!-- @@@QOpenGLWindow -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QOpenGLWindow&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.4</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qpaintdevicewindow.htm" translate="no">QPaintDeviceWindow</a></td></tr></tbody></table></div><p>This class was introduced in Qt 5.4.</p>
<ul>
<li><a href="./qopenglwindow-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">UpdateBehavior</a></b> { NoPartialUpdate, PartialUpdateBlit, PartialUpdateBlend }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#QOpenGLWindow-1" translate="no">QOpenGLWindow</a></b>(QOpenGLContext *<i>shareContext</i>, QOpenGLWindow::UpdateBehavior <i>updateBehavior</i> = NoPartialUpdate, QWindow *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#QOpenGLWindow" translate="no">QOpenGLWindow</a></b>(QOpenGLWindow::UpdateBehavior <i>updateBehavior</i> = NoPartialUpdate, QWindow *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#dtor.QOpenGLWindow" translate="no">~QOpenGLWindow</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#context" translate="no">context</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#defaultFramebufferObject" translate="no">defaultFramebufferObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#doneCurrent" translate="no">doneCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#grabFramebuffer" translate="no">grabFramebuffer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#makeCurrent" translate="no">makeCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#shareContext" translate="no">shareContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLWindow::UpdateBehavior </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#updateBehavior" translate="no">updateBehavior</a></b>() const</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#frameSwapped" translate="no">frameSwapped</a></b>()</td></tr>
</tbody></table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions<a class="plink" href="#protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#initializeGL" translate="no">initializeGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#paintOverGL" translate="no">paintOverGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#paintUnderGL" translate="no">paintUnderGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#resizeGL" translate="no">resizeGL</a></b>(int <i>w</i>, int <i>h</i>)</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#paintEvent" translate="no">paintEvent</a></b>(QPaintEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qopenglwindow.htm#resizeEvent" translate="no">resizeEvent</a></b>(QResizeEvent *<i>event</i>) override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QOpenGLWindow-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QOpenGLWindow is an enhanced <a href="./qwindow.htm" translate="no">QWindow</a> that allows easily creating windows that perform OpenGL rendering using an API that is compatible with <a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a> and is similar to the legacy QGLWidget. Unlike <a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a>, QOpenGLWindow has no dependency on the widgets module and offers better performance.</p>
<p>A typical application will subclass QOpenGLWindow and reimplement the following virtual functions:</p>
<ul>
<li><a href="./qopenglwindow.htm#initializeGL" translate="no">initializeGL</a>() to perform OpenGL resource initialization</li>
<li><a href="./qopenglwindow.htm#resizeGL" translate="no">resizeGL</a>() to set up the transformation matrices and other window size dependent resources</li>
<li><a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() to issue OpenGL commands or draw using <a href="./qpainter.htm" translate="no">QPainter</a></li>
</ul>
<p>To schedule a repaint, call the <a href="./qpaintdevicewindow.htm#update-2" translate="no">update</a>() function. Note that this will not immediately result in a call to <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(). Calling <a href="./qpaintdevicewindow.htm#update-2" translate="no">update</a>() multiple times in a row will not change the behavior in any way.</p>
<p>This is a slot so it can be connected to a <a href="./qtimer.htm#timeout" translate="no">QTimer::timeout</a>() signal to perform animation. Note however that in the modern OpenGL world it is a much better choice to rely on synchronization to the vertical refresh rate of the display. See <a href="./qsurfaceformat.htm#setSwapInterval" translate="no">setSwapInterval()</a> on a description of the swap interval. With a swap interval of <code translate="no">1</code>, which is the case on most systems by default, the <a href="./qopenglcontext.htm#swapBuffers" translate="no">swapBuffers()</a> call, that is executed internally by QOpenGLWindow after each repaint, will block and wait for vsync. This means that whenever the swap is done, an update can be scheduled again by calling <a href="./qpaintdevicewindow.htm#update-2" translate="no">update</a>(), without relying on timers.</p>
<p>To request a specific configuration for the context, use <a href="./qwindow.htm#setFormat" translate="no">setFormat</a>() like for any other <a href="./qwindow.htm" translate="no">QWindow</a>. This allows, among others, requesting a given OpenGL version and profile, or enabling depth and stencil buffers.</p>
<p>Unlike <a href="./qwindow.htm" translate="no">QWindow</a>, QOpenGLWindow allows opening a painter on itself and perform <a href="./qpainter.htm" translate="no">QPainter</a>-based drawing.</p>
<p>QOpenGLWindow supports multiple update behaviors. The default, <code translate="no">NoPartialUpdate</code> is equivalent to a regular, OpenGL-based <a href="./qwindow.htm" translate="no">QWindow</a> or the legacy QGLWidget. In contrast, <code translate="no">PartialUpdateBlit</code> and <code translate="no">PartialUpdateBlend</code> are more in line with <a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a>'s way of working, where there is always an extra, dedicated framebuffer object present. These modes allow, by sacrificing some performance, redrawing only a smaller area on each paint and having the rest of the content preserved from of the previous frame. This is useful for applications than render incrementally using <a href="./qpainter.htm" translate="no">QPainter</a>, because this way they do not have to redraw the entire window content on each <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() call.</p>
<p>Similarly to <a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a>, QOpenGLWindow supports the <a href="./qt.htm#ApplicationAttribute-enum" translate="no">Qt::AA_ShareOpenGLContexts</a> attribute. When enabled, the OpenGL contexts of all QOpenGLWindow instances will share with each other. This allows accessing each other's shareable OpenGL resources.</p>
<p>For more information on graphics in Qt, see <a href="./graphicsview.htm" translate="no">Graphics</a>.</p>
</div>
<!-- @@@QOpenGLWindow -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$UpdateBehavior$$$NoPartialUpdate$$$PartialUpdateBlit$$$PartialUpdateBlend -->
<h3 class="fn" id="UpdateBehavior-enum" translate="no"><a name="UpdateBehavior-enum"></a>enum QOpenGLWindow::<span class="name">UpdateBehavior</span><a class="plink" href="#UpdateBehavior-enum" title="Direct link to this headline"></a></h3>
<p>This enum describes the update strategy of the <a href="./qopenglwindow.htm" translate="no">QOpenGLWindow</a>.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLWindow::NoPartialUpdate</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Indicates that the entire window surface will redrawn on each update and so no additional framebuffers are needed. This is the setting used in most cases and is equivalent to how drawing directly via <a href="./qwindow.htm" translate="no">QWindow</a> would function.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLWindow::PartialUpdateBlit</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Indicates that the drawing performed in <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() does not cover the entire window. In this case an extra framebuffer object is created under the hood, and rendering performed in <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() will target this framebuffer. This framebuffer is then blitted onto the window surface's default framebuffer after each paint. This allows having <a href="./qpainter.htm" translate="no">QPainter</a>-based drawing code in <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() which only repaints a smaller area at a time, because, unlike NoPartialUpdate, the previous content is preserved.</td></tr>
<tr><td class="topAlign"><code translate="no">QOpenGLWindow::PartialUpdateBlend</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Similar to PartialUpdateBlit, but instead of using framebuffer blits, the contents of the extra framebuffer is rendered by drawing a textured quad with blending enabled. This, unlike PartialUpdateBlit, allows alpha blended content and works even when the glBlitFramebuffer is not available. Performance-wise this setting is likely to be somewhat slower than PartialUpdateBlit.</td></tr>
</tbody></table></div>
<!-- @@@UpdateBehavior -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QOpenGLWindow$$$QOpenGLWindowQOpenGLContext*QOpenGLWindow::UpdateBehaviorQWindow* -->
<h3 class="fn" id="QOpenGLWindow-1" translate="no"><a name="QOpenGLWindow-1"></a>QOpenGLWindow::<span class="name">QOpenGLWindow</span>(<span class="type"><a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a></span> *<i>shareContext</i>, <span class="type"><a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">QOpenGLWindow::UpdateBehavior</a></span> <i>updateBehavior</i> = NoPartialUpdate, <span class="type"><a href="./qwindow.htm#QWindow" translate="no">QWindow</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QOpenGLWindow-1" title="Direct link to this headline"></a></h3>
<p>Constructs a new QOpenGLWindow with the given <i translate="no">parent</i> and <i translate="no">updateBehavior</i>. The QOpenGLWindow's context will share with <i translate="no">shareContext</i>.</p>
<p><b>See also </b><a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">QOpenGLWindow::UpdateBehavior</a> and <a href="./qopenglwindow.htm#shareContext" translate="no">shareContext</a>.</p>
<!-- @@@QOpenGLWindow -->
<!-- $$$QOpenGLWindow[overload1]$$$QOpenGLWindowQOpenGLWindow::UpdateBehaviorQWindow* -->
<h3 class="fn" id="QOpenGLWindow" translate="no"><a name="QOpenGLWindow"></a>QOpenGLWindow::<span class="name">QOpenGLWindow</span>(<span class="type"><a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">QOpenGLWindow::UpdateBehavior</a></span> <i>updateBehavior</i> = NoPartialUpdate, <span class="type"><a href="./qwindow.htm#QWindow" translate="no">QWindow</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QOpenGLWindow" title="Direct link to this headline"></a></h3>
<p>Constructs a new QOpenGLWindow with the given <i translate="no">parent</i> and <i translate="no">updateBehavior</i>.</p>
<p><b>See also </b><a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">QOpenGLWindow::UpdateBehavior</a>.</p>
<!-- @@@QOpenGLWindow -->
<!-- $$$frameSwapped[overload1]$$$frameSwapped -->
<h3 class="fn" id="frameSwapped" translate="no"><a name="frameSwapped"></a><code translate="no">[signal] </code><span class="type">void</span> QOpenGLWindow::<span class="name">frameSwapped</span>()<a class="plink" href="#frameSwapped" title="Direct link to this headline"></a></h3>
<p>This signal is emitted after the potentially blocking <a href="./qopenglcontext.htm#swapBuffers" translate="no">buffer swap</a> has been done. Applications that wish to continuously repaint synchronized to the vertical refresh, should issue an <a href="./qpaintdevicewindow.htm#update-2" translate="no">update</a>() upon this signal. This allows for a much smoother experience compared to the traditional usage of timers.</p>
<!-- @@@frameSwapped -->
<!-- $$$~QOpenGLWindow[overload1]$$$~QOpenGLWindow -->
<h3 class="fn" id="dtor.QOpenGLWindow" translate="no"><a name="dtor.QOpenGLWindow"></a><code translate="no">[virtual] </code>QOpenGLWindow::<span class="name">~QOpenGLWindow</span>()<a class="plink" href="#dtor.QOpenGLWindow" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qopenglwindow.htm" translate="no">QOpenGLWindow</a> instance, freeing its resources.</p>
<p>The OpenGLWindow's context is made current in the destructor, allowing for safe destruction of any child object that may need to release OpenGL resources belonging to the context provided by this window.</p>
<div class="admonition warning">
<p><b>Warning: </b>if you have objects wrapping OpenGL resources (such as <a href="./qopenglbuffer.htm" translate="no">QOpenGLBuffer</a>, <a href="./qopenglshaderprogram.htm" translate="no">QOpenGLShaderProgram</a>, etc.) as members of a <a href="./qopenglwindow.htm" translate="no">QOpenGLWindow</a> subclass, you may need to add a call to <a href="./qopenglwindow.htm#makeCurrent" translate="no">makeCurrent</a>() in that subclass' destructor as well. Due to the rules of C++ object destruction, those objects will be destroyed <i>before</i> calling this function (but after that the destructor of the subclass has run), therefore making the OpenGL context current in this function happens too late for their safe disposal.</p>
</div>
<p>This function was introduced in Qt 5.5.</p>
<p><b>See also </b><a href="./qopenglwindow.htm#makeCurrent" translate="no">makeCurrent</a>.</p>
<!-- @@@~QOpenGLWindow -->
<!-- $$$context[overload1]$$$context -->
<h3 class="fn" id="context" translate="no"><a name="context"></a><span class="type"><a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a></span> *QOpenGLWindow::<span class="name">context</span>() const<a class="plink" href="#context" title="Direct link to this headline"></a></h3>
<p>Returns The <a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a> used by this window or <code translate="no">0</code> if not yet initialized.</p>
<!-- @@@context -->
<!-- $$$defaultFramebufferObject[overload1]$$$defaultFramebufferObject -->
<h3 class="fn" id="defaultFramebufferObject" translate="no"><a name="defaultFramebufferObject"></a><span class="type">GLuint</span> QOpenGLWindow::<span class="name">defaultFramebufferObject</span>() const<a class="plink" href="#defaultFramebufferObject" title="Direct link to this headline"></a></h3>
<p>The framebuffer object handle used by this window.</p>
<p>When the update behavior is set to <code translate="no">NoPartialUpdate</code>, there is no separate framebuffer object. In this case the returned value is the ID of the default framebuffer.</p>
<p>Otherwise the value of the ID of the framebuffer object or <code translate="no">0</code> if not yet initialized.</p>
<!-- @@@defaultFramebufferObject -->
<!-- $$$doneCurrent[overload1]$$$doneCurrent -->
<h3 class="fn" id="doneCurrent" translate="no"><a name="doneCurrent"></a><span class="type">void</span> QOpenGLWindow::<span class="name">doneCurrent</span>()<a class="plink" href="#doneCurrent" title="Direct link to this headline"></a></h3>
<p>Releases the context.</p>
<p>It is not necessary to call this function in most cases, since the widget will make sure the context is bound and released properly when invoking <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>().</p>
<p><b>See also </b><a href="./qopenglwindow.htm#makeCurrent" translate="no">makeCurrent</a>().</p>
<!-- @@@doneCurrent -->
<!-- $$$grabFramebuffer[overload1]$$$grabFramebuffer -->
<h3 class="fn" id="grabFramebuffer" translate="no"><a name="grabFramebuffer"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QOpenGLWindow::<span class="name">grabFramebuffer</span>()<a class="plink" href="#grabFramebuffer" title="Direct link to this headline"></a></h3>
<p>Returns a copy of the framebuffer.</p>
<div class="admonition note">
<p><b>Note: </b>This is a potentially expensive operation because it relies on glReadPixels() to read back the pixels. This may be slow and can stall the GPU pipeline.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When used together with update behavior <code translate="no">NoPartialUpdate</code>, the returned image may not contain the desired content when called after the front and back buffers have been swapped (unless preserved swap is enabled in the underlying windowing system interface). In this mode the function reads from the back buffer and the contents of that may not match the content on the screen (the front buffer). In this case the only place where this function can safely be used is <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() or <a href="./qopenglwindow.htm#paintOverGL" translate="no">paintOverGL</a>().</p>
</div>
<!-- @@@grabFramebuffer -->
<!-- $$$initializeGL[overload1]$$$initializeGL -->
<h3 class="fn" id="initializeGL" translate="no"><a name="initializeGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QOpenGLWindow::<span class="name">initializeGL</span>()<a class="plink" href="#initializeGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is called once before the first call to <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() or <a href="./qopenglwindow.htm#resizeGL" translate="no">resizeGL</a>(). Reimplement it in a subclass.</p>
<p>This function should set up any required OpenGL resources and state.</p>
<p>There is no need to call <a href="./qopenglwindow.htm#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called. Note however that the framebuffer, in case partial update mode is used, is not yet available at this stage, so avoid issuing draw calls from here. Defer such calls to <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() instead.</p>
<p><b>See also </b><a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() and <a href="./qopenglwindow.htm#resizeGL" translate="no">resizeGL</a>().</p>
<!-- @@@initializeGL -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QOpenGLWindow::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the window's OpenGL resources, like the context, have been successfully initialized. Note that the return value is always <code translate="no">false</code> until the window becomes exposed (shown).</p>
<!-- @@@isValid -->
<!-- $$$makeCurrent[overload1]$$$makeCurrent -->
<h3 class="fn" id="makeCurrent" translate="no"><a name="makeCurrent"></a><span class="type">void</span> QOpenGLWindow::<span class="name">makeCurrent</span>()<a class="plink" href="#makeCurrent" title="Direct link to this headline"></a></h3>
<p>Prepares for rendering OpenGL content for this window by making the corresponding context current and binding the framebuffer object, if there is one, in that context context.</p>
<p>It is not necessary to call this function in most cases, because it is called automatically before invoking <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(). It is provided nonetheless to support advanced, multi-threaded scenarios where a thread different than the GUI or main thread may want to update the surface or framebuffer contents. See <a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a> for more information on threading related issues.</p>
<p>This function is suitable for calling also when the underlying platform window is already destroyed. This means that it is safe to call this function from a <a href="./qopenglwindow.htm" translate="no">QOpenGLWindow</a> subclass' destructor. If there is no native window anymore, an offscreen surface is used instead. This ensures that OpenGL resource cleanup operations in the destructor will always work, as long as this function is called first.</p>
<p><b>See also </b><a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a>, <a href="./qopenglwindow.htm#context" translate="no">context</a>(), <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(), and <a href="./qopenglwindow.htm#doneCurrent" translate="no">doneCurrent</a>().</p>
<!-- @@@makeCurrent -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" id="paintEvent" translate="no"><a name="paintEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QOpenGLWindow::<span class="name">paintEvent</span>(<span class="type"><a href="./qpaintevent.htm" translate="no">QPaintEvent</a></span> *<i>event</i>)<a class="plink" href="#paintEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qpaintdevicewindow.htm#paintEvent" translate="no">QPaintDeviceWindow::paintEvent</a>(QPaintEvent *event).</p>
<p>Paint <i translate="no">event</i> handler. Calls <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>().</p>
<p><b>See also </b><a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>().</p>
<!-- @@@paintEvent -->
<!-- $$$paintGL[overload1]$$$paintGL -->
<h3 class="fn" id="paintGL" translate="no"><a name="paintGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QOpenGLWindow::<span class="name">paintGL</span>()<a class="plink" href="#paintGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is called whenever the window contents needs to be painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="./qopenglwindow.htm#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called.</p>
<p>Before invoking this function, the context and the framebuffer, if there is one, are bound, and the viewport is set up by a call to glViewport(). No other state is set and no clearing or drawing is performed by the framework.</p>
<div class="admonition note">
<p><b>Note: </b>When using a partial update behavior, like <code translate="no">PartialUpdateBlend</code>, the output of the previous paintGL() call is preserved and, after the additional drawing perfomed in the current invocation of the function, the content is blitted or blended over the content drawn directly to the window in <a href="./qopenglwindow.htm#paintUnderGL" translate="no">paintUnderGL</a>().</p>
</div>
<p><b>See also </b><a href="./qopenglwindow.htm#initializeGL" translate="no">initializeGL</a>(), <a href="./qopenglwindow.htm#resizeGL" translate="no">resizeGL</a>(), <a href="./qopenglwindow.htm#paintUnderGL" translate="no">paintUnderGL</a>(), <a href="./qopenglwindow.htm#paintOverGL" translate="no">paintOverGL</a>(), and <a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">UpdateBehavior</a>.</p>
<!-- @@@paintGL -->
<!-- $$$paintOverGL[overload1]$$$paintOverGL -->
<h3 class="fn" id="paintOverGL" translate="no"><a name="paintOverGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QOpenGLWindow::<span class="name">paintOverGL</span>()<a class="plink" href="#paintOverGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is called after each invocation of <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>().</p>
<p>When the update mode is set to <a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">NoPartialUpdate</a>, there is no difference between this function and <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(), performing rendering in either of them leads to the same result.</p>
<p>Like <a href="./qopenglwindow.htm#paintUnderGL" translate="no">paintUnderGL</a>(), rendering in this function targets the default framebuffer of the window, regardless of the update behavior. It gets called after <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() has returned and the blit (<a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">PartialUpdateBlit</a>) or quad drawing (<a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">PartialUpdateBlend</a>) has been done.</p>
<p><b>See also </b><a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(), <a href="./qopenglwindow.htm#paintUnderGL" translate="no">paintUnderGL</a>(), and <a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">UpdateBehavior</a>.</p>
<!-- @@@paintOverGL -->
<!-- $$$paintUnderGL[overload1]$$$paintUnderGL -->
<h3 class="fn" id="paintUnderGL" translate="no"><a name="paintUnderGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QOpenGLWindow::<span class="name">paintUnderGL</span>()<a class="plink" href="#paintUnderGL" title="Direct link to this headline"></a></h3>
<p>The virtual function is called before each invocation of <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>().</p>
<p>When the update mode is set to <code translate="no">NoPartialUpdate</code>, there is no difference between this function and <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(), performing rendering in either of them leads to the same result.</p>
<p>The difference becomes significant when using <code translate="no">PartialUpdateBlend</code>, where an extra framebuffer object is used. There, <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() targets this additional framebuffer object, which preserves its contents, while paintUnderGL() and <a href="./qopenglwindow.htm#paintOverGL" translate="no">paintOverGL</a>() target the default framebuffer, i.e. directly the window surface, the contents of which is lost after each displayed frame.</p>
<div class="admonition note">
<p><b>Note: </b>Avoid relying on this function when the update behavior is <code translate="no">PartialUpdateBlit</code>. This mode involves blitting the extra framebuffer used by <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>() onto the default framebuffer after each invocation of <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(), thus overwriting all drawing generated in this function.</p>
</div>
<p><b>See also </b><a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>(), <a href="./qopenglwindow.htm#paintOverGL" translate="no">paintOverGL</a>(), and <a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">UpdateBehavior</a>.</p>
<!-- @@@paintUnderGL -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" id="resizeEvent" translate="no"><a name="resizeEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QOpenGLWindow::<span class="name">resizeEvent</span>(<span class="type"><a href="./qresizeevent.htm" translate="no">QResizeEvent</a></span> *<i>event</i>)<a class="plink" href="#resizeEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#resizeEvent" translate="no">QWindow::resizeEvent</a>(QResizeEvent *ev).</p>
<p>Resize <i translate="no">event</i> handler. Calls <a href="./qopenglwindow.htm#resizeGL" translate="no">resizeGL</a>().</p>
<p><b>See also </b><a href="./qopenglwindow.htm#resizeGL" translate="no">resizeGL</a>().</p>
<!-- @@@resizeEvent -->
<!-- $$$resizeGL[overload1]$$$resizeGLintint -->
<h3 class="fn" id="resizeGL" translate="no"><a name="resizeGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QOpenGLWindow::<span class="name">resizeGL</span>(<span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)<a class="plink" href="#resizeGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is called whenever the widget has been resized. Reimplement it in a subclass. The new size is passed in <i translate="no">w</i> and <i translate="no">h</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This is merely a convenience function in order to provide an API that is compatible with <a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a>. Unlike with <a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a>, derived classes are free to choose to override <a href="./qopenglwindow.htm#resizeEvent" translate="no">resizeEvent</a>() instead of this function.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Avoid issuing OpenGL commands from this function as there may not be a context current when it is invoked. If it cannot be avoided, call <a href="./qopenglwindow.htm#makeCurrent" translate="no">makeCurrent</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Scheduling updates from here is not necessary. The windowing systems will send expose events that trigger an update automatically.</p>
</div>
<p><b>See also </b><a href="./qopenglwindow.htm#initializeGL" translate="no">initializeGL</a>() and <a href="./qopenglwindow.htm#paintGL" translate="no">paintGL</a>().</p>
<!-- @@@resizeGL -->
<!-- $$$shareContext[overload1]$$$shareContext -->
<h3 class="fn" id="shareContext" translate="no"><a name="shareContext"></a><span class="type"><a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a></span> *QOpenGLWindow::<span class="name">shareContext</span>() const<a class="plink" href="#shareContext" title="Direct link to this headline"></a></h3>
<p>Returns The <a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a> requested to be shared with this window's <a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a>.</p>
<!-- @@@shareContext -->
<!-- $$$updateBehavior[overload1]$$$updateBehavior -->
<h3 class="fn" id="updateBehavior" translate="no"><a name="updateBehavior"></a><span class="type"><a href="./qopenglwindow.htm#UpdateBehavior-enum" translate="no">QOpenGLWindow::UpdateBehavior</a></span> QOpenGLWindow::<span class="name">updateBehavior</span>() const<a class="plink" href="#updateBehavior" title="Direct link to this headline"></a></h3>
<p>Returns the update behavior for this <a href="./qopenglwindow.htm" translate="no">QOpenGLWindow</a>.</p>
<!-- @@@updateBehavior -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>