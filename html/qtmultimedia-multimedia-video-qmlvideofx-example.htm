<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QML Video Shader Effects Example | Qt Multimedia</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtmultimedia-index.htm" translate="no">Qt Multimedia</a></li>
                            <li><a href="./multimedia-examples.htm" translate="no">Qt Multimedia Examples</a></li>
                            <li><a>QML Video Shader Effects Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">QML Video Shader Effects Example</h1>
<span class="subtitle"></span>
<!-- $$$multimedia/video/qmlvideofx-brief -->
<p>Applying shader effects on video and camera viewfinder content.</p>
<!-- @@@multimedia/video/qmlvideofx -->
<!-- $$$multimedia/video/qmlvideofx-description -->
<div class="descr"> <a name="details"></a>
<a name="running-the-example"></a>
<h4 id="running-the-example">Running the Example<a class="plink" href="#running-the-example" title="Direct link to this headline"></a></h4>
<p>To run the example from <a href="https://doc.qt.io/qtcreator/index.html" translate="no">Qt Creator</a>, open the <b>Welcome</b> mode and select the example from <b>Examples</b>. For more information, visit <a href="https://doc.qt.io/qtcreator/creator-build-example-application.html" translate="no">Building and Running an Example</a>.</p>
<a name="overview"></a>
<h4 id="overview">Overview<a class="plink" href="#overview" title="Direct link to this headline"></a></h4>
<p><i>QML Video Shader Effects</i> demonstrates how a <a href="./qml-qtquick-shadereffect.htm" translate="no">ShaderEffect</a> can be used to apply postprocessing effects, expressed in GLSL, to QML <a href="./qml-qtmultimedia-videooutput.htm" translate="no">VideoOutput</a> type.</p>
<p>It also shows how native code can be combined with QML to implement more advanced functionality - in this case, C++ code is used to calculate the QML frame rate. This value is rendered in QML in a semi-transparent item overlaid on the video content.</p>
<p>The following screenshots show shader effects being applied. In each case, the effect is implemented using a fragment shader.</p>
<p>Here we see an edge detection algorithm being applied to a video clip (<a href="http://durian.blender.org/" translate="no">Sintel from blender.org</a>).</p>
<p class="centerAlign"><img alt="" src="./images/qmlvideofx-video-edgedetection.jpg"></p><p>This image shows a page curl effect, applied to the same video clip.</p>
<p class="centerAlign"><img alt="" src="./images/qmlvideofx-video-pagecurl.jpg"></p><p>Here we see a 'glow' effect (edge detection plus colour quantization) being applied to the camera viewfinder.</p>
<p class="centerAlign"><img alt="" src="./images/qmlvideofx-camera-glow.jpg"></p><p>This image shows a 'wobble' effect applied to the viewfinder.</p>
<p class="centerAlign"><img alt="" src="./images/qmlvideofx-camera-wobble.jpg"></p><p>The application includes many more effects than the ones shown here - look for Effect*.qml files in the list of files below to see the full range.</p>
<a name="application-structure"></a>
<h4 id="application-structure">Application Structure<a class="plink" href="#application-structure" title="Direct link to this headline"></a></h4>
<p>Shader effects can be applied to video or viewfinder content using <a href="./qml-qtquick-shadereffect.htm" translate="no">ShaderEffect</a>, as shown in the following example, which applies a wiggly effect to the content:</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick 2.0
import QtMultimedia 5.0

<span class="type"><a href="./qml-qtquick-rectangle.htm" translate="no">Rectangle</a></span> {
    <span class="name">width</span>: <span class="number">300</span>
    <span class="name">height</span>: <span class="number">300</span>
    <span class="name">color</span>: <span class="string">"black"</span>

    <span class="type"><a href="./qml-qtmultimedia-mediaplayer.htm" translate="no">MediaPlayer</a></span> {
        <span class="name">id</span>: <span class="name">mediaPlayer</span>
        <span class="name">source</span>: <span class="string">"test.mp4"</span>
        <span class="name">playing</span>: <span class="number">true</span>
    }

    <span class="type"><a href="./qml-qtmultimedia-videooutput.htm" translate="no">VideoOutput</a></span> {
        <span class="name">id</span>: <span class="name">video</span>
        <span class="name">anchors</span>.fill: <span class="name">parent</span>
        <span class="name">source</span>: <span class="name">mediaPlayer</span>
    }

    <span class="type"><a href="./qml-qtquick-shadereffect.htm" translate="no">ShaderEffect</a></span> {
        property <span class="type"><a href="./qml-variant.htm" translate="no">variant</a></span> <span class="name">source</span>: <span class="name">ShaderEffectSource</span> { <span class="name">sourceItem</span>: <span class="name">video</span>; <span class="name">hideSource</span>: <span class="number">true</span> }
        property <span class="type"><a href="./qml-real.htm" translate="no">real</a></span> <span class="name">wiggleAmount</span>: <span class="number">0.005</span>
        <span class="name">anchors</span>.fill: <span class="name">video</span>

        <span class="name">fragmentShader</span>: <span class="string">"
            varying highp vec2 qt_TexCoord0;
            uniform sampler2D source;
            uniform highp float wiggleAmount;
            void main(void)
            {
                highp vec2 wiggledTexCoord = qt_TexCoord0;
                wiggledTexCoord.s += sin(4.0 * 3.141592653589 * wiggledTexCoord.t) * wiggleAmount;
                gl_FragColor = texture2D(source, wiggledTexCoord.st);
            }
        "</span>
    }
}</pre></div>
<p>In this application, the usage of the <a href="./qml-qtquick-shadereffect.htm" translate="no">ShaderEffect</a> and <a href="./qml-qtmultimedia-videooutput.htm" translate="no">VideoOutput</a> types is a bit more complicated, for the following reasons:</p>
<ul>
<li>Each effect can be applied to either a <a href="./qml-qtmultimedia-videooutput.htm" translate="no">VideoOutput</a> or an <a href="./qml-qtquick-image.htm" translate="no">Image</a> item, so the type of the source item must be abstracted away from the effect implementation</li>
<li>For some effects (such as the edge detection and glow examples shown in the screenshots above), the transformation is applied only to pixels to the left of a dividing line - this allows the effect to be easily compared with the untransformed image on the right</li>
<li>Most effects have one or more parameters which can be modified by the user - these are controlled by sliders in the UI which are connected to uniform values passed into the GLSL code</li>
</ul>
<p>The abstraction of source item type is achieved by the <code translate="no">Content</code>, which uses a <a href="./qml-qtquick-loader.htm" translate="no">Loader</a> to create either a <a href="./qml-qtmultimedia-mediaplayer.htm" translate="no">MediaPlayer</a>, <a href="./qml-qtmultimedia-camera.htm" translate="no">Camera</a>, or an <a href="./qml-qtquick-image.htm" translate="no">Image</a>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">import QtQuick 2.1

<span class="type"><a href="./qml-qtquick-rectangle.htm" translate="no">Rectangle</a></span> {
    ...
    <span class="type"><a href="./qml-qtquick-loader.htm" translate="no">Loader</a></span> {
        <span class="name">id</span>: <span class="name">contentLoader</span>
    }
    ...
    <span class="keyword">function </span><span class="name">openImage</span>(path) {
        <span class="name">stop</span>()
        <span class="name">contentLoader</span>.<span class="name">source</span> <span class="operator">=</span> <span class="string">"ContentImage.qml"</span>
        <span class="name">contentLoader</span>.<span class="name">item</span>.<span class="name">source</span> <span class="operator">=</span> <span class="name">path</span>
    }

    <span class="keyword">function </span><span class="name">openVideo</span>(path) {
        <span class="name">stop</span>()
        <span class="name">contentLoader</span>.<span class="name">source</span> <span class="operator">=</span> <span class="string">"ContentVideo.qml"</span>
        <span class="name">contentLoader</span>.<span class="name">item</span>.<span class="name">mediaSource</span> <span class="operator">=</span> <span class="name">path</span>
    }

    <span class="keyword">function </span><span class="name">openCamera</span>() {
        <span class="name">stop</span>()
        <span class="name">contentLoader</span>.<span class="name">source</span> <span class="operator">=</span> <span class="string">"ContentCamera.qml"</span>
    }

}</pre></div>
<p>Each effect is implemented as a QML item which is based on the <code translate="no">Effect</code>, which in turn is based on the <a href="./qml-qtquick-shadereffect.htm" translate="no">ShaderEffect</a>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">import QtQuick 2.0

<span class="type"><a href="./qml-qtquick-shadereffect.htm" translate="no">ShaderEffect</a></span> {
    property <span class="type">variant</span> <span class="name">source</span>
    property <span class="type">ListModel</span> <span class="name">parameters</span>: <span class="name">ListModel</span> { }
    property <span class="type">bool</span> <span class="name">divider</span>: <span class="number">true</span>
    property <span class="type">real</span> <span class="name">dividerValue</span>: <span class="number">0.5</span>
    property <span class="type">real</span> <span class="name">targetWidth</span>: <span class="number">0</span>
    property <span class="type">real</span> <span class="name">targetHeight</span>: <span class="number">0</span>
    property <span class="type">string</span> <span class="name">fragmentShaderFilename</span>
    property <span class="type">string</span> <span class="name">vertexShaderFilename</span>

    <span class="type"><a href="./qml-qtqml-qtobject.htm" translate="no">QtObject</a></span> {
        <span class="name">id</span>: <span class="name">d</span>
        property <span class="type">string</span> <span class="name">fragmentShaderCommon</span>: <span class="string">"
            #ifdef GL_ES
                precision mediump float;
            #else
            #   define lowp
            #   define mediump
            #   define highp
            #endif // GL_ES
        "</span>
    }

    <span class="comment">// The following is a workaround for the fact that ShaderEffect</span>
    <span class="comment">// doesn't provide a way for shader programs to be read from a file,</span>
    <span class="comment">// rather than being inline in the QML file</span>

    <span class="name">onFragmentShaderFilenameChanged</span>:
        <span class="name">fragmentShader</span> <span class="operator">=</span> <span class="name">d</span>.<span class="name">fragmentShaderCommon</span> <span class="operator">+</span> <span class="name">fileReader</span>.<span class="name">readFile</span>(<span class="string">":shaders/"</span> <span class="operator">+</span> <span class="name">fragmentShaderFilename</span>)
    <span class="name">onVertexShaderFilenameChanged</span>:
        <span class="name">vertexShader</span> <span class="operator">=</span> <span class="name">fileReader</span>.<span class="name">readFile</span>(<span class="name">vertexShaderFilename</span>)
}</pre></div>
<p>The interface of Effect allows for derived effects to specify the number of parameters which they support (and therefore the number of sliders which should be displayed), and whether a vertical dividing line should be drawn between transformed and untransformed image regions. As an example, here is the implementation of the pixelation effect. As you can see, the pixelation effect supports one parameter (which controls the pixelation granularity), and states that the divider should be displayed.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">import QtQuick 2.0

<span class="type">Effect</span> {
    <span class="name">parameters</span>: <span class="name">ListModel</span> {
        <span class="type">ListElement</span> {
            <span class="name">name</span>: <span class="string">"Granularity"</span>
            <span class="name">value</span>: <span class="number">0.5</span>
        }
        <span class="name">onDataChanged</span>: <span class="name">updateParameters</span>()
    }

    <span class="keyword">function </span><span class="name">updateParameters</span>()
    {
            <span class="name">granularity</span> <span class="operator">=</span> <span class="name">parameters</span>.<span class="name">get</span>(<span class="number">0</span>).<span class="name">value</span> <span class="operator">*</span> <span class="number">20.0</span>;
    }

    <span class="comment">// Transform slider values, and bind result to shader uniforms</span>
    property <span class="type">real</span> <span class="name">granularity</span>: <span class="number">0.5</span> <span class="operator">*</span> <span class="number">20</span>

    <span class="name">fragmentShaderFilename</span>: <span class="string">"pixelate.fsh"</span>
}</pre></div>
<p>The main.qml file shows a <code translate="no">FileOpen</code> item, which allows the user to select the input source and an <code translate="no">EffectSelectionList</code> item, which lists each of the available shader effects. As described above, a <code translate="no">Content</code> item is used to load the appropriate input and effect type. A <code translate="no">Divider</code> item draws the vertical dividing line, which can be dragged left or right by the user. Finally, a <code translate="no">ParameterPanel</code> item renders the sliders corresponding to each effect parameter.</p>
<p class="centerAlign"><img alt="" src="./images/qmlvideofx-effects-menu.jpg"></p><p class="figCaption">The effect selection menu</p>
<a name="calculating-and-displaying-qml-painting-rate"></a>
<h4 id="calculating-and-displaying-qml-painting-rate">Calculating and Displaying QML Painting Rate<a class="plink" href="#calculating-and-displaying-qml-painting-rate" title="Direct link to this headline"></a></h4>
<p>The QML painting rate is calculated by the FrequencyMonitor class, which turns a stream of events (received via the notify() slot), into an instantaneous and an averaged frequency:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> FrequencyMonitor : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span>
{
    Q_OBJECT
    Q_PROPERTY(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> instantaneousFrequency READ instantaneousFrequency NOTIFY instantaneousFrequencyChanged)
    Q_PROPERTY(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> averageFrequency READ averageFrequency NOTIFY averageFrequencyChanged)

<span class="keyword">public</span>:
    ...
    <span class="keyword">static</span> <span class="type">void</span> qmlRegisterType();

<span class="keyword">public</span> <span class="keyword">slots</span>:
    Q_INVOKABLE <span class="type">void</span> notify();
};</pre></div>
<p>The FrequencyMonitor class is exposed to QML like this</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> FrequencyMonitor<span class="operator">::</span>qmlRegisterType()
{
    <span class="operator">::</span>qmlRegisterType<span class="operator">&lt;</span>FrequencyMonitor<span class="operator">&gt;</span>(<span class="string">"FrequencyMonitor"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">"FrequencyMonitor"</span>);
}</pre></div>
<p>and its data is displayed by defining a QML item called FrequencyItem, like this:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">import FrequencyMonitor 1.0

<span class="type"><a href="./qml-qtquick-rectangle.htm" translate="no">Rectangle</a></span> {
    <span class="name">id</span>: <span class="name">root</span>
    ...
    <span class="keyword">function </span><span class="name">notify</span>() {
        <span class="name">monitor</span>.<span class="name">notify</span>()
    }

    <span class="type">FrequencyMonitor</span> {
        <span class="name">id</span>: <span class="name">monitor</span>
        <span class="name">onAverageFrequencyChanged</span>: {
            <span class="name">averageFrequencyText</span>.<span class="name">text</span> <span class="operator">=</span> <span class="name">monitor</span>.<span class="name">averageFrequency</span>.<span class="name">toFixed</span>(<span class="number">2</span>)
        }
    }

    <span class="type"><a href="./qml-qtquick-text.htm" translate="no">Text</a></span> {
        <span class="name">id</span>: <span class="name">labelText</span>
        <span class="type">anchors</span> {
            <span class="name">left</span>: <span class="name">parent</span>.<span class="name">left</span>
            <span class="name">top</span>: <span class="name">parent</span>.<span class="name">top</span>
            <span class="name">margins</span>: <span class="number">10</span>
        }
        <span class="name">color</span>: <span class="name">root</span>.<span class="name">textColor</span>
        <span class="name">font</span>.pixelSize: <span class="number">0.6</span> <span class="operator">*</span> <span class="name">root</span>.<span class="name">textSize</span>
        <span class="name">text</span>: <span class="name">root</span>.<span class="name">label</span>
        <span class="name">width</span>: <span class="name">root</span>.<span class="name">width</span> <span class="operator">-</span> <span class="number">2</span><span class="operator">*</span><span class="name">anchors</span>.<span class="name">margins</span>
        <span class="name">elide</span>: <span class="name">Text</span>.<span class="name">ElideRight</span>
    }

    <span class="type"><a href="./qml-qtquick-text.htm" translate="no">Text</a></span> {
        <span class="name">id</span>: <span class="name">averageFrequencyText</span>
        <span class="type">anchors</span> {
            <span class="name">right</span>: <span class="name">parent</span>.<span class="name">right</span>
            <span class="name">bottom</span>: <span class="name">parent</span>.<span class="name">bottom</span>
            <span class="name">margins</span>: <span class="number">10</span>
        }
        <span class="name">color</span>: <span class="name">root</span>.<span class="name">textColor</span>
        <span class="name">font</span>.pixelSize: <span class="name">root</span>.<span class="name">textSize</span>
    }
}</pre></div>
<p>The result looks like this:</p>
<p class="centerAlign"><img alt="" src="./images/video-qml-paint-rate.png"></p><p>All that remains is to connect the afterRendering() signal of the <a href="./qquickview.htm" translate="no">QQuickView</a> object to a JavaScript function, which will eventually call frequencyItem.notify():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor">#include &lt;QtGui/QGuiApplication&gt;</span>
<span class="preprocessor">#include &lt;QtQuick/QQuickItem&gt;</span>
<span class="preprocessor">#include &lt;QtQuick/QQuickView&gt;</span>
<span class="preprocessor">#include "filereader.h"</span>
<span class="preprocessor">#include "trace.h"</span>

<span class="preprocessor">#ifdef PERFORMANCEMONITOR_SUPPORT</span>
<span class="preprocessor">#include "performancemonitordeclarative.h"</span>
<span class="preprocessor">#endif</span>

<span class="preprocessor">#ifdef REQUEST_PERMISSIONS_ON_ANDROID</span>
<span class="preprocessor">#include &lt;QtAndroid&gt;</span>

bool requestStoragePermission() {
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="type">QtAndroid</span>;
    ...
    <span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span> <span class="operator">*</span>rootObject <span class="operator">=</span> viewer<span class="operator">.</span>rootObject();
    ...
    <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">::</span>connect(<span class="operator">&amp;</span>viewer<span class="operator">,</span> SIGNAL(afterRendering())<span class="operator">,</span>
                     rootObject<span class="operator">,</span> SLOT(qmlFramePainted()));</pre></div>
<p><a href="https://code.qt.io/cgit/qt/qtmultimedia.git/tree/examples/multimedia/video/qmlvideofx?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@multimedia/video/qmlvideofx -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>