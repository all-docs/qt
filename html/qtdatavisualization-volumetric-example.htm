<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Volumetric rendering Example | Qt Data Visualization</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtdatavisualization-index.htm" translate="no">Qt Data Visualization</a></li>
                            <li class="last"><a>Volumetric rendering Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Volumetric rendering Example</h1>
<span class="subtitle"></span>
<!-- $$$volumetric-brief -->
<p>Rendering volumetric objects.</p>
<!-- @@@volumetric -->
<!-- $$$volumetric-description -->
<div class="descr"> <a name="details"></a>
<p>This example shows how to use <a href="./qcustom3dvolume.htm" translate="no">QCustom3DVolume</a> items to display volumetric data.</p>
<p class="centerAlign"><img alt="" src="./images/volumetric-example.png"></p><a name="running-the-example"></a>
<h4 id="running-the-example">Running the Example<a class="plink" href="#running-the-example" title="Direct link to this headline"></a></h4>
<p>To run the example from <a href="http://doc.qt.io/qtcreator/index.html" translate="no">Qt Creator</a>, open the <b>Welcome</b> mode and select the example from <b>Examples</b>. For more information, visit <a href="https://doc.qt.io/qtcreator/creator-build-example-application.html" translate="no">Building and Running an Example</a>.</p>
<a name="initializing-volume-item"></a>
<h4 id="initializing-volume-item">Initializing Volume Item<a class="plink" href="#initializing-volume-item" title="Direct link to this headline"></a></h4>
<p>The <a href="./qcustom3dvolume.htm" translate="no">QCustom3DVolume</a> items are special custom items (see <a href="./qcustom3ditem.htm" translate="no">QCustom3DItem</a>), which can be used to display volumetric data. The volume items are only supported with orthographic projection, so first we make sure the graph is using it:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_graph<span class="operator">-</span><span class="operator">&gt;</span>setOrthoProjection(<span class="keyword">true</span>);</pre></div>
<p>The following code shows how to create a volumetric item tied to the data ranges of the axes:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem <span class="operator">=</span> <span class="keyword">new</span> QCustom3DVolume;
<span class="comment">// Adjust water level to zero with a minor tweak to y-coordinate position and scaling</span>
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setScaling(
            QVector3D(m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>min()<span class="operator">,</span>
                      (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">*</span> <span class="number">0.91f</span><span class="operator">,</span>
                      m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>min()));
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setPosition(
            QVector3D((m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">/</span> <span class="number">2.0f</span><span class="operator">,</span>
                      <span class="operator">-</span><span class="number">0.045f</span> <span class="operator">*</span> (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">+</span>
                      (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">/</span> <span class="number">2.0f</span><span class="operator">,</span>
                      (m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">-</span><span class="operator">&gt;</span>min()) <span class="operator">/</span> <span class="number">2.0f</span>));
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setScalingAbsolute(<span class="keyword">false</span>);</pre></div>
<p>By setting the <a href="./qcustom3ditem.htm#scalingAbsolute-prop" translate="no">QCustom3DItem::scalingAbsolute</a> property to <code translate="no">false</code>, we indicate that the scaling of the volume should follow the changes in the data ranges. Next we define the internal contents of the volume:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureWidth(lowDetailSize);
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureHeight(lowDetailSize <span class="operator">/</span> <span class="number">2</span>);
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureDepth(lowDetailSize);
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureFormat(<span class="type"><a href="./qimage.htm" translate="no">QImage</a></span><span class="operator">::</span>Format_Indexed8);
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setTextureData(<span class="keyword">new</span> <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span><span class="operator">&gt;</span>(<span class="operator">*</span>m_lowDetailData));</pre></div>
<p>We use eight bit indexed color for our texture, as it is compact and makes it easy to adjust the colors without needing to reset the whole texture. For the texture data we use the data we created earlier based on some height maps. Typically the data for volume items comes pregenerated in a form of a stack of images, so we are not going to explain the data generation in detail. Please refer to the example code if you are interested in the actual data generation process.</p>
<p>Since we are using eight bit indexed colors, we need a color table to map the eight bit color indexes to actual colors. We use one we populated on our own, but in a typical use case you would get the color table from the source images:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setColorTable(m_colorTable1);</pre></div>
<p>We want to optionally show slice frames around the volume, so we initialize their properties. Initially, the frames will be hidden:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceFrameGaps(QVector3D(<span class="number">0.01f</span><span class="operator">,</span> <span class="number">0.02f</span><span class="operator">,</span> <span class="number">0.01f</span>));
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceFrameThicknesses(QVector3D(<span class="number">0.0025f</span><span class="operator">,</span> <span class="number">0.005f</span><span class="operator">,</span> <span class="number">0.0025f</span>));
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceFrameWidths(QVector3D(<span class="number">0.0025f</span><span class="operator">,</span> <span class="number">0.005f</span><span class="operator">,</span> <span class="number">0.0025f</span>));
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setDrawSliceFrames(<span class="keyword">false</span>);</pre></div>
<p>Finally we add the volume as a custom item to the graph to display it:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_graph<span class="operator">-</span><span class="operator">&gt;</span>addCustomItem(m_volumeItem);</pre></div>
<a name="slicing-into-the-volume"></a>
<h4 id="slicing-into-the-volume">Slicing into the Volume<a class="plink" href="#slicing-into-the-volume" title="Direct link to this headline"></a></h4>
<p>Unless the volume is largely transparent, you can only see the surface of it, which is often not very helpful. One way to inspect the internal structure of the volume is to view the slices of the volume. <a href="./qcustom3dvolume.htm" translate="no">QCustom3DVolume</a> provides two ways to display the slices. The first is to show the selected slices in place of the volume. For example, to specify a slice perpendicular to the X-axis, you can use the following method:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setSliceIndexX(m_sliceIndexX);</pre></div>
<p>To actually draw the slice specified above, the <a href="./qcustom3dvolume.htm#drawSlices-prop" translate="no">QCustom3DVolume::drawSlices</a> property must be also set:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setDrawSlices(<span class="keyword">true</span>);</pre></div>
<p>The second way to view slices is to use <a href="./qcustom3dvolume.htm#renderSlice" translate="no">QCustom3DVolume::renderSlice</a>() method, which produces a <a href="./qimage.htm" translate="no">QImage</a> from the specified slice. This image can then be displayed on another widget, such as a <a href="./qlabel.htm" translate="no">QLabel</a> here:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_sliceLabelX<span class="operator">-</span><span class="operator">&gt;</span>setPixmap(
            <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span><span class="operator">::</span>fromImage(m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>renderSlice(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>XAxis<span class="operator">,</span> m_sliceIndexX)));</pre></div>
<a name="adjusting-volume-transparency"></a>
<h4 id="adjusting-volume-transparency">Adjusting Volume Transparency<a class="plink" href="#adjusting-volume-transparency" title="Direct link to this headline"></a></h4>
<p>Sometimes viewing just the slices doesn't give you a good understanding of the volume's internal structure. <a href="./qcustom3dvolume.htm" translate="no">QCustom3DVolume</a> provides two properties that can be used to adjust the volume transparency:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setAlphaMultiplier(mult);
    ...
m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setPreserveOpacity(enabled);</pre></div>
<p>The <a href="./qcustom3dvolume.htm#alphaMultiplier-prop" translate="no">QCustom3DVolume::alphaMultiplier</a> is a general multiplier that is applied to the alpha value of each voxel of the volume. It makes it possible to add uniform transparency to the already somewhat transparent portions of the volume to reveal internal opaque details. This multiplier doesn't affect colors that are fully opaque, unless the <a href="./qcustom3dvolume.htm#preserveOpacity-prop" translate="no">QCustom3DVolume::preserveOpacity</a> property is set to <code translate="no">false</code>.</p>
<p>An alternative way to adjust the transparency of the volume is adjust the alpha values of the voxels directly. For eight bit indexed textures, this is done simply by modifying and resetting the color table:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> newAlpha <span class="operator">=</span> enabled <span class="operator">?</span> terrainTransparency : <span class="number">255</span>;
<span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> aboveWaterGroundColorsMin; i <span class="operator">&lt;</span> underWaterGroundColorsMax; i<span class="operator">+</span><span class="operator">+</span>) {
    <span class="type"><a href="./qcolor.htm#QRgb-typedef" translate="no">QRgb</a></span> oldColor1 <span class="operator">=</span> m_colorTable1<span class="operator">.</span>at(i);
    <span class="type"><a href="./qcolor.htm#QRgb-typedef" translate="no">QRgb</a></span> oldColor2 <span class="operator">=</span> m_colorTable2<span class="operator">.</span>at(i);
    m_colorTable1<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <a href="./qcolor.htm#qRgba" translate="no">qRgba</a>(<a href="./qcolor.htm#qRed" translate="no">qRed</a>(oldColor1)<span class="operator">,</span> <a href="./qcolor.htm#qGreen" translate="no">qGreen</a>(oldColor1)<span class="operator">,</span> <a href="./qcolor.htm#qBlue" translate="no">qBlue</a>(oldColor1)<span class="operator">,</span> newAlpha);
    m_colorTable2<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <a href="./qcolor.htm#qRgba" translate="no">qRgba</a>(<a href="./qcolor.htm#qRed" translate="no">qRed</a>(oldColor2)<span class="operator">,</span> <a href="./qcolor.htm#qGreen" translate="no">qGreen</a>(oldColor2)<span class="operator">,</span> <a href="./qcolor.htm#qBlue" translate="no">qBlue</a>(oldColor2)<span class="operator">,</span> newAlpha);
}
<span class="keyword">if</span> (m_usingPrimaryTable)
    m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setColorTable(m_colorTable1);
<span class="keyword">else</span>
    m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setColorTable(m_colorTable2);</pre></div>
<a name="high-definition-vs-low-definition-shader"></a>
<h4 id="high-definition-vs-low-definition-shader">High Definition vs. Low Definition Shader<a class="plink" href="#high-definition-vs-low-definition-shader" title="Direct link to this headline"></a></h4>
<p>By default the volume rendering uses the high definition shader. It accounts for each voxel of the volume with correct weight when ray-tracing the volume contents, providing an accurate representation of even the finer details of the volume. However, this is computationally very expensive, so the frame rate suffers. If rendering speed is more important than pixel-perfect accuracy of the volume contents, you can take the much faster low definition shader into use by setting <code translate="no">false</code> for <a href="./qcustom3dvolume.htm#useHighDefShader-prop" translate="no">QCustom3DVolume::useHighDefShader</a> property. The low definition shader achieves the speed by making compromises on the accuracy, so it doesn't guarantee each voxel of the volume will be sampled. This can lead to flickering and/or other rendering artifacts on the finer details of the volume.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_volumeItem<span class="operator">-</span><span class="operator">&gt;</span>setUseHighDefShader(enabled);</pre></div>
<a name="example-contents"></a>
<h4 id="example-contents">Example Contents<a class="plink" href="#example-contents" title="Direct link to this headline"></a></h4>
<p><a href="https://code.qt.io/cgit/qt/qtdatavis3d.git/tree/examples/datavisualization/volumetric?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@volumetric -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>