<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Using VirtualCAN Plugin | Qt Serial Bus</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtserialbus-virtualcan-overview.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtserialbus-index.htm" translate="no">Qt Serial Bus</a></li>
                            <li><a>Using VirtualCAN Plugin</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Using VirtualCAN Plugin</h1>
<span class="subtitle"></span>
<!-- $$$qtserialbus-virtualcan-overview.html-description -->
<div class="descr"> <a name="details"></a>
<p>The VirtualCAN plugin allows testing of CAN applications with a local TCP/IP connection without CAN hardware. The TCP server is created, when the first client calls createDevice(). The default TCP port is 35468, which can be changed by giving the fully qualified URL to createDevice(). Once the server is running, no further server is started on the same system.</p>
<p>Afterwards, all clients send their CAN frames to the server, which distributes them to the other clients.</p>
<a name="creating-can-bus-devices"></a>
<h2 id="creating-can-bus-devices">Creating CAN Bus Devices<a class="plink" href="#creating-can-bus-devices" title="Direct link to this headline"></a></h2>
<p>At first it is necessary to check that <a href="./qcanbus.htm" translate="no">QCanBus</a> provides the desired plugin:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">if</span> (<span class="type"><a href="./qcanbus.htm" translate="no">QCanBus</a></span><span class="operator">::</span>instance()<span class="operator">-</span><span class="operator">&gt;</span>plugins()<span class="operator">.</span>contains(<span class="type"><a href="./qstring.htm#QStringLiteral" translate="no">QStringLiteral</a></span>(<span class="string">"virtualcan"</span>))) {
    <span class="comment">// plugin available</span>
}</pre></div>
<p>Where <i>virtualcan</i> is the plugin name.</p>
<p>Next, a connection to a specific interface can be established:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qcanbusdevice.htm" translate="no">QCanBusDevice</a></span> <span class="operator">*</span>device <span class="operator">=</span> <span class="type"><a href="./qcanbus.htm" translate="no">QCanBus</a></span><span class="operator">::</span>instance()<span class="operator">-</span><span class="operator">&gt;</span>createDevice(
    <span class="type"><a href="./qstring.htm#QStringLiteral" translate="no">QStringLiteral</a></span>(<span class="string">"virtualcan"</span>)<span class="operator">,</span> <span class="type"><a href="./qstring.htm#QStringLiteral" translate="no">QStringLiteral</a></span>(<span class="string">"can0"</span>));
device<span class="operator">-</span><span class="operator">&gt;</span>connectDevice();</pre></div>
<p>Where <i>can0</i> is the active CAN channel name. The VirtualCAN plugin provides two channels "can0" and "can1". Both can be used as CAN 2.0 or CAN FD channels. All applications connected to one of these channels receive all messages that are sent to this channel.</p>
<p>To connect to a remote server, use the following fully qualified URL as interface name:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">tcp:<span class="comment">//server:port/canX</span></pre></div>
<p>for example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">tcp:<span class="comment">//192.168.1.2:35468/can0</span></pre></div>
<p>The device is now open for writing and reading CAN frames:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qcanbusframe.htm" translate="no">QCanBusFrame</a></span> frame;
frame<span class="operator">.</span>setFrameId(<span class="number">8</span>);
<span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> payload(<span class="string">"A36E"</span>);
frame<span class="operator">.</span>setPayload(payload);
device<span class="operator">-</span><span class="operator">&gt;</span>writeFrame(frame);</pre></div>
<p>The reading can be done using the readFrame() method. The <a href="./qcanbusdevice.htm#framesReceived" translate="no">framesReceived()</a> signal is emitted when at least one new frame is available for reading:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qcanbusframe.htm" translate="no">QCanBusFrame</a></span> frame <span class="operator">=</span> device<span class="operator">-</span><span class="operator">&gt;</span>readFrame();</pre></div>
<p>VirtualCAN supports the following configurations that can be controlled through setConfigurationParameter():</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Configuration parameter key</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><a href="./qcanbusdevice.htm#ConfigurationKey-enum" translate="no">QCanBusDevice::CanFdKey</a></td><td>Determines whether the virtual CAN bus operates in CAN FD mode or not. This option is disabled by default.</td></tr>
<tr class="even" valign="top"><td><a href="./qcanbusdevice.htm#ConfigurationKey-enum" translate="no">QCanBusDevice::ReceiveOwnKey</a></td><td>The reception of the CAN frames on the same device that was sending the CAN frame is disabled by default. When enabling this option, all CAN frames sent to the CAN bus immediately appear in the receive buffer. This can be used to check if sending was successful. If this option is enabled, the therefore received frames are marked with <a href="./qcanbusframe.htm#hasLocalEcho" translate="no">QCanBusFrame::hasLocalEcho</a>()</td></tr>
</tbody></table></div>
</div>
<!-- @@@qtserialbus-virtualcan-overview.html -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>