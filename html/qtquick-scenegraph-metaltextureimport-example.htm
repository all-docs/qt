<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Scene Graph - Metal Texture Import | Qt Quick</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtquick-scenegraph-metaltextureimport-example.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a>Scene Graph - Metal Texture Import</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Scene Graph - Metal Texture Import</h1>
<span class="subtitle"></span>
<!-- $$$scenegraph/metaltextureimport-brief -->
<p>Shows how to use a texture created directly with Metal.</p>
<!-- @@@scenegraph/metaltextureimport -->
<!-- $$$scenegraph/metaltextureimport-description -->
<div class="descr"> <a name="details"></a>
<p class="centerAlign"><img alt="" src="./images/metaltextureimport-example.jpg"></p><p>The Metal Texture Import example shows how an application can import and use a <a href="https://developer.apple.com/documentation/metal/mtltexture" translate="no">MTLTexture</a> in the Qt Quick scene. This provides an alternative to the <a href="./qtquick-scenegraph-metalunderqml-example.htm" translate="no">underlay</a>, overlay, or <a href="./qtquick-scenegraph-rendernode-example.htm" translate="no">render node</a> approaches when it comes to integrating native Metal rendering. In many cases going through a texture, and therefore "flattening" the 3D contents first, is the best option to integrate and mix custom 3D contents with the 2D UI elements provided by Qt Quick.</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import MetalTextureImport 1.0
<span class="type">CustomTextureItem</span> {
    <span class="name">id</span>: <span class="name">renderer</span>
    <span class="name">anchors</span>.fill: <span class="name">parent</span>
    <span class="name">anchors</span>.margins: <span class="number">10</span>

    SequentialAnimation on <span class="name">t</span> {
        <span class="type"><a href="./qml-qtquick-numberanimation.htm" translate="no">NumberAnimation</a></span> { <span class="name">to</span>: <span class="number">1</span>; <span class="name">duration</span>: <span class="number">2500</span>; <span class="name">easing</span>.type: <span class="name">Easing</span>.<span class="name">InQuad</span> }
        <span class="type"><a href="./qml-qtquick-numberanimation.htm" translate="no">NumberAnimation</a></span> { <span class="name">to</span>: <span class="number">0</span>; <span class="name">duration</span>: <span class="number">2500</span>; <span class="name">easing</span>.type: <span class="name">Easing</span>.<span class="name">OutQuad</span> }
        <span class="name">loops</span>: <span class="name">Animation</span>.<span class="name">Infinite</span>
        <span class="name">running</span>: <span class="number">true</span>
    }</pre></div>
<p>The application exposes a custom <a href="./qquickitem.htm" translate="no">QQuickItem</a> subclass under ther name of CustomTextureItem. This is instantiated in QML. The value of the <code translate="no">t</code> property is animated as well.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> CustomTextureItem : <span class="keyword">public</span> <span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span>
{
    Q_OBJECT
    Q_PROPERTY(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t READ t WRITE setT NOTIFY tChanged)
    QML_ELEMENT

<span class="keyword">public</span>:
    CustomTextureItem();

    <span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t() <span class="keyword">const</span> { <span class="keyword">return</span> m_t; }
    <span class="type">void</span> setT(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t);

<span class="keyword">signals</span>:
    <span class="type">void</span> tChanged();

<span class="keyword">protected</span>:
    <span class="type"><a href="./qsgnode.htm" translate="no">QSGNode</a></span> <span class="operator">*</span>updatePaintNode(<span class="type"><a href="./qsgnode.htm" translate="no">QSGNode</a></span> <span class="operator">*</span><span class="operator">,</span> UpdatePaintNodeData <span class="operator">*</span>) override;
    <span class="type">void</span> geometryChanged(<span class="keyword">const</span> <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> <span class="operator">&amp;</span>newGeometry<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> <span class="operator">&amp;</span>oldGeometry) override;

<span class="keyword">private</span> <span class="keyword">slots</span>:
    <span class="type">void</span> invalidateSceneGraph();

<span class="keyword">private</span>:
    <span class="type">void</span> releaseResources() override;

    CustomTextureNode <span class="operator">*</span>m_node <span class="operator">=</span> nullptr;
    <span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> m_t <span class="operator">=</span> <span class="number">0</span>;
};</pre></div>
<p>The implementation of our custom item involves overriding <a href="./qquickitem.htm#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>(), as well as functions and slots related to geometry changes and cleanup.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">class CustomTextureNode : public QSGTextureProvider, public QSGSimpleTextureNode
{
    Q_OBJECT

public:
    CustomTextureNode(QQuickItem *item);
    ~CustomTextureNode();

    QSGTexture *texture() const override;

    void sync();</pre></div>
<p>We also need a scenegraph node. Instead of deriving directly from <a href="./qsgnode.htm" translate="no">QSGNode</a>, we can use QSGSimpleTextureNode which gives us some of the functionality pre-implemented as a convenience.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">QSGNode *CustomTextureItem::updatePaintNode(QSGNode *node, UpdatePaintNodeData *)
{
    CustomTextureNode *n = static_cast&lt;CustomTextureNode *&gt;(node);

    if (!n &amp;&amp; (width() &lt;= 0 || height() &lt;= 0))
        return nullptr;

    if (!n) {
        m_node = new CustomTextureNode(this);
        n = m_node;
    }

    m_node-&gt;sync();

    n-&gt;setTextureCoordinatesTransform(QSGSimpleTextureNode::NoTransform);
    n-&gt;setFiltering(QSGTexture::Linear);
    n-&gt;setRect(0, 0, width(), height());

    window()-&gt;update(); // ensure getting to beforeRendering() at some point

    return n;
}</pre></div>
<p>The updatePaintNode() function of the item is called on the render thread (if there is one), with the main (GUI) thread blocked. Here we create a new node if there has not yet been one, and update it. Accessing Qt objects living on the main thread is safe here, so sync() will calculate and copy the values it needs from <a href="./qquickitem.htm" translate="no">QQuickItem</a> or <a href="./qquickwindow.htm" translate="no">QQuickWindow</a>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">CustomTextureNode::CustomTextureNode(QQuickItem *item)
    : m_item(item)
{
    m_window = m_item-&gt;window();
    connect(m_window, &amp;QQuickWindow::beforeRendering, this, &amp;CustomTextureNode::render);
    connect(m_window, &amp;QQuickWindow::screenChanged, this, [this]() {
        if (m_window-&gt;effectiveDevicePixelRatio() != m_dpr)
            m_item-&gt;update();
    });</pre></div>
<p>The node does not merely rely on the typical <a href="./qquickitem.htm" translate="no">QQuickItem</a> - <a href="./qsgnode.htm" translate="no">QSGNode</a> update sequence, it connects to <a href="./qquickwindow.htm#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>() as well. That is where the contents of the Metal texture will be updated by encoding a full render pass, targeting the texture, on the Qt Quicks scenegraph's command buffer. beforeRendering() is the right place for this, because the signal is emitted before Qt Quick starts to encode its own rendering commands. Choosing <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">QQuickWindow::beforeRenderPassRecording</a>() instead would be an error in this exanple.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">void CustomTextureNode::sync()
{
    m_dpr = m_window-&gt;effectiveDevicePixelRatio();
    const QSize newSize = m_window-&gt;size() * m_dpr;
    bool needsNew = false;

    if (!texture())
        needsNew = true;

    if (newSize != m_size) {
        needsNew = true;
        m_size = newSize;
    }

    if (needsNew) {
        delete texture();
        [m_texture release];

        QSGRendererInterface *rif = m_window-&gt;rendererInterface();
        m_device = (id&lt;MTLDevice&gt;) rif-&gt;getResource(m_window, QSGRendererInterface::DeviceResource);
        Q_ASSERT(m_device);

        MTLTextureDescriptor *desc = [[MTLTextureDescriptor alloc] init];
        desc.textureType = MTLTextureType2D;
        desc.pixelFormat = MTLPixelFormatRGBA8Unorm;
        desc.width = m_size.width();
        desc.height = m_size.height();
        desc.mipmapLevelCount = 1;
        desc.resourceOptions = MTLResourceStorageModePrivate;
        desc.storageMode = MTLStorageModePrivate;
        desc.usage = MTLTextureUsageShaderRead | MTLTextureUsageRenderTarget;
        m_texture = [m_device newTextureWithDescriptor: desc];
        [desc release];

        QSGTexture *wrapper = m_window-&gt;createTextureFromNativeObject(QQuickWindow::NativeObjectTexture,
                                                                      &amp;m_texture,
                                                                      0,
                                                                      m_size);

        qDebug() &lt;&lt; "Got QSGTexture wrapper" &lt;&lt; wrapper &lt;&lt; "for an MTLTexture of size" &lt;&lt; m_size;

        setTexture(wrapper);
    }
    m_t = float(static_cast&lt;CustomTextureItem *&gt;(m_item)-&gt;t());</pre></div>
<p>After copying the values we need, sync() also performs some graphics resource initialization. The MTLDevice is queried from the scenegraph. Once a MTLTexture is available, a <a href="./qsgtexture.htm" translate="no">QSGTexture</a> wrapping (not owning) it is created via <a href="./qquickwindow.htm#createTextureFromNativeObject" translate="no">QQuickWindow::createTextureFromNativeObject</a>(). This function is a modern equivalent to QQuickWindow::createTextureFromId() that is not tied to OpenGL. Finally, the <a href="./qsgtexture.htm" translate="no">QSGTexture</a> is associated with the underlying materials by calling the base class' setTexture() function.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">void CustomTextureNode::render()
{
    if (!m_initialized)
        return;

    // Render to m_texture.
    MTLRenderPassDescriptor *renderpassdesc = [MTLRenderPassDescriptor renderPassDescriptor];
    MTLClearColor c = MTLClearColorMake(0, 0, 0, 1);
    renderpassdesc.colorAttachments[0].loadAction = MTLLoadActionClear;
    renderpassdesc.colorAttachments[0].storeAction = MTLStoreActionStore;
    renderpassdesc.colorAttachments[0].clearColor = c;
    renderpassdesc.colorAttachments[0].texture = m_texture;

    QSGRendererInterface *rif = m_window-&gt;rendererInterface();
    id&lt;MTLCommandBuffer&gt; cb = (id&lt;MTLCommandBuffer&gt;) rif-&gt;getResource(m_window, QSGRendererInterface::CommandListResource);
    Q_ASSERT(cb);
    id&lt;MTLRenderCommandEncoder&gt; encoder = [cb renderCommandEncoderWithDescriptor: renderpassdesc];

    const QQuickWindow::GraphicsStateInfo &amp;stateInfo(m_window-&gt;graphicsStateInfo());
    void *p = [m_ubuf[stateInfo.currentFrameSlot] contents];
    memcpy(p, &amp;m_t, 4);

    MTLViewport vp;
    vp.originX = 0;
    vp.originY = 0;
    vp.width = m_size.width();
    vp.height = m_size.height();
    vp.znear = 0;
    vp.zfar = 1;
    [encoder setViewport: vp];

    [encoder setFragmentBuffer: m_ubuf[stateInfo.currentFrameSlot] offset: 0 atIndex: 0];
    [encoder setVertexBuffer: m_vbuf offset: 0 atIndex: 1];
    [encoder setRenderPipelineState: m_pipeline];
    [encoder drawPrimitives: MTLPrimitiveTypeTriangleStrip vertexStart: 0 vertexCount: 4 instanceCount: 1 baseInstance: 0];

    [encoder endEncoding];
}</pre></div>
<p>render(), the slot connected to beforeRendering(), encodes the rendering commands using the buffers and pipeline state objects created in sync().</p>
<p><a href="https://code.qt.io/cgit/qt/qtdeclarative.git/tree/examples/quick/scenegraph/metaltextureimport?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@scenegraph/metaltextureimport -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>