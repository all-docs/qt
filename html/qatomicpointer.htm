<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QAtomicPointer | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qatomicpointer.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QAtomicPointer</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QAtomicPointer Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QAtomicPointer</span>
<!-- $$$QAtomicPointer-brief -->
<p>The QAtomicPointer class is a template class that provides platform-independent atomic operations on pointers. <a href="#details">More...</a></p>
<!-- @@@QAtomicPointer -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QAtomicPointer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.4</td></tr></tbody></table></div><p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="./qatomicpointer-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qatomicpointer-obsolete.htm">Obsolete members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#QAtomicPointer-1" translate="no">QAtomicPointer</a></b>(const QAtomicPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#QAtomicPointer" translate="no">QAtomicPointer</a></b>(T *<i>value</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAtomicPointer&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#operator-eq" translate="no">operator=</a></b>(const QAtomicPointer&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndAddAcquire" translate="no">fetchAndAddAcquire</a></b>(qptrdiff <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndAddOrdered" translate="no">fetchAndAddOrdered</a></b>(qptrdiff <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndAddRelaxed" translate="no">fetchAndAddRelaxed</a></b>(qptrdiff <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndAddRelease" translate="no">fetchAndAddRelease</a></b>(qptrdiff <i>valueToAdd</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndStoreAcquire" translate="no">fetchAndStoreAcquire</a></b>(T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndStoreOrdered" translate="no">fetchAndStoreOrdered</a></b>(T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndStoreRelaxed" translate="no">fetchAndStoreRelaxed</a></b>(T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#fetchAndStoreRelease" translate="no">fetchAndStoreRelease</a></b>(T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#loadAcquire" translate="no">loadAcquire</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#loadRelaxed" translate="no">loadRelaxed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#storeRelaxed" translate="no">storeRelaxed</a></b>(T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#storeRelease" translate="no">storeRelease</a></b>(T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#testAndSetAcquire" translate="no">testAndSetAcquire</a></b>(T *<i>expectedValue</i>, T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#testAndSetOrdered" translate="no">testAndSetOrdered</a></b>(T *<i>expectedValue</i>, T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#testAndSetRelaxed" translate="no">testAndSetRelaxed</a></b>(T *<i>expectedValue</i>, T *<i>newValue</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#testAndSetRelease" translate="no">testAndSetRelease</a></b>(T *<i>expectedValue</i>, T *<i>newValue</i>)</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#isFetchAndAddNative" translate="no">isFetchAndAddNative</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#isFetchAndAddWaitFree" translate="no">isFetchAndAddWaitFree</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#isFetchAndStoreNative" translate="no">isFetchAndStoreNative</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#isFetchAndStoreWaitFree" translate="no">isFetchAndStoreWaitFree</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#isTestAndSetNative" translate="no">isTestAndSetNative</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#isTestAndSetWaitFree" translate="no">isTestAndSetWaitFree</a></b>()</td></tr>
</tbody></table></div>
<a name="macros"></a>
<h2 id="macros">Macros<a class="plink" href="#macros" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</a></b></td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QAtomicPointer-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>For atomic operations on integers, see the <a href="./qatomicinteger.htm" translate="no">QAtomicInteger</a> class.</p>
<p>An <i>atomic</i> operation is a complex operation that completes without interruption. The QAtomicPointer class provides atomic test-and-set, fetch-and-store, and fetch-and-add for pointers.</p>
<a name="the-atomic-api"></a>
<h3 id="the-atomic-api">The Atomic API<a class="plink" href="#the-atomic-api" title="Direct link to this headline"></a></h3>
<a name="memory-ordering"></a>
<h4 id="memory-ordering">Memory ordering<a class="plink" href="#memory-ordering" title="Direct link to this headline"></a></h4>
<p>QAtomicPointer provides several implementations of the atomic test-and-set, fetch-and-store, and fetch-and-add functions. Each implementation defines a memory ordering semantic that describes how memory accesses surrounding the atomic instruction are executed by the processor. Since many modern architectures allow out-of-order execution and memory ordering, using the correct semantic is necessary to ensure that your application functions properly on all processors.</p>
<ul>
<li>Relaxed - memory ordering is unspecified, leaving the compiler and processor to freely reorder memory accesses.</li>
<li>Acquire - memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</li>
<li>Release - memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</li>
<li>Ordered - the same Acquire and Release semantics combined.</li>
</ul>
<a name="test-and-set"></a>
<h4 id="test-and-set">Test-and-set<a class="plink" href="#test-and-set" title="Direct link to this headline"></a></h4>
<p>If the current value of the QAtomicPointer is an expected value, the test-and-set functions assign a new value to the QAtomicPointer and return true. If values are <i translate="no">not</i> the same, these functions do nothing and return false. This operation equates to the following code:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">if</span> (currentValue <span class="operator">=</span><span class="operator">=</span> expectedValue) {
    currentValue <span class="operator">=</span> newValue;
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
<span class="keyword">return</span> <span class="keyword">false</span>;</pre></div>
<p>There are 4 test-and-set functions: <a href="./qatomicpointer.htm#testAndSetRelaxed" translate="no">testAndSetRelaxed</a>(), <a href="./qatomicpointer.htm#testAndSetAcquire" translate="no">testAndSetAcquire</a>(), <a href="./qatomicpointer.htm#testAndSetRelease" translate="no">testAndSetRelease</a>(), and <a href="./qatomicpointer.htm#testAndSetOrdered" translate="no">testAndSetOrdered</a>(). See above for an explanation of the different memory ordering semantics.</p>
<a name="fetch-and-store"></a>
<h4 id="fetch-and-store">Fetch-and-store<a class="plink" href="#fetch-and-store" title="Direct link to this headline"></a></h4>
<p>The atomic fetch-and-store functions read the current value of the QAtomicPointer and then assign a new value, returning the original value. This operation equates to the following code:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">T <span class="operator">*</span>originalValue <span class="operator">=</span> currentValue;
currentValue <span class="operator">=</span> newValue;
<span class="keyword">return</span> originalValue;</pre></div>
<p>There are 4 fetch-and-store functions: <a href="./qatomicpointer.htm#fetchAndStoreRelaxed" translate="no">fetchAndStoreRelaxed</a>(), <a href="./qatomicpointer.htm#fetchAndStoreAcquire" translate="no">fetchAndStoreAcquire</a>(), <a href="./qatomicpointer.htm#fetchAndStoreRelease" translate="no">fetchAndStoreRelease</a>(), and <a href="./qatomicpointer.htm#fetchAndStoreOrdered" translate="no">fetchAndStoreOrdered</a>(). See above for an explanation of the different memory ordering semantics.</p>
<a name="fetch-and-add"></a>
<h4 id="fetch-and-add">Fetch-and-add<a class="plink" href="#fetch-and-add" title="Direct link to this headline"></a></h4>
<p>The atomic fetch-and-add functions read the current value of the QAtomicPointer and then add the given value to the current value, returning the original value. This operation equates to the following code:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">T <span class="operator">*</span>originalValue <span class="operator">=</span> currentValue;
currentValue <span class="operator">+</span><span class="operator">=</span> valueToAdd;
<span class="keyword">return</span> originalValue;</pre></div>
<p>There are 4 fetch-and-add functions: <a href="./qatomicpointer.htm#fetchAndAddRelaxed" translate="no">fetchAndAddRelaxed</a>(), <a href="./qatomicpointer.htm#fetchAndAddAcquire" translate="no">fetchAndAddAcquire</a>(), <a href="./qatomicpointer.htm#fetchAndAddRelease" translate="no">fetchAndAddRelease</a>(), and <a href="./qatomicpointer.htm#fetchAndAddOrdered" translate="no">fetchAndAddOrdered</a>(). See above for an explanation of the different memory ordering semantics.</p>
<a name="feature-tests-for-the-atomic-api"></a>
<h3 id="feature-tests-for-the-atomic-api">Feature Tests for the Atomic API<a class="plink" href="#feature-tests-for-the-atomic-api" title="Direct link to this headline"></a></h3>
<p>Providing a platform-independent atomic API that works on all processors is challenging. The API provided by QAtomicPointer is guaranteed to work atomically on all processors. However, since not all processors implement support for every operation provided by QAtomicPointer, it is necessary to expose information about the processor.</p>
<p>You can check at compile time which features are supported on your hardware using various macros. These will tell you if your hardware always, sometimes, or does not support a particular operation. The macros have the form Q_ATOMIC_POINTER_<i>OPERATION</i>_IS_<i>HOW</i>_NATIVE. <i>OPERATION</i> is one of <a href="./qatomicpointer.htm#test-and-set" translate="no">TEST_AND_SET</a>, <a href="./qatomicpointer.htm#fetch-and-store" translate="no">FETCH_AND_STORE</a>, or <a href="./qatomicpointer.htm#fetch-and-add" translate="no">FETCH_AND_ADD</a>, and <i>HOW</i> is one of ALWAYS, SOMETIMES, or NOT. There will always be exactly one defined macro per operation. For example, if <a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</a> is defined, neither <a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</a> nor <a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</a> will be defined.</p>
<p>An operation that completes in constant time is said to be wait-free. Such operations are not implemented using locks or loops of any kind. For atomic operations that are always supported, and that are wait-free, Qt defines the Q_ATOMIC_POINTER_<i>OPERATION</i>_IS_WAIT_FREE in addition to the Q_ATOMIC_POINTER_<i>OPERATION</i>_IS_ALWAYS_NATIVE.</p>
<p>In cases where an atomic operation is only supported in newer generations of the processor, QAtomicPointer also provides a way to check at runtime what your hardware supports with the <a href="./qatomicpointer.htm#isTestAndSetNative" translate="no">isTestAndSetNative</a>(), <a href="./qatomicpointer.htm#isFetchAndStoreNative" translate="no">isFetchAndStoreNative</a>(), and <a href="./qatomicpointer.htm#isFetchAndAddNative" translate="no">isFetchAndAddNative</a>() functions. Wait-free implementations can be detected using the <a href="./qatomicpointer.htm#isTestAndSetWaitFree" translate="no">isTestAndSetWaitFree</a>(), <a href="./qatomicpointer.htm#isFetchAndStoreWaitFree" translate="no">isFetchAndStoreWaitFree</a>(), and <a href="./qatomicpointer.htm#isFetchAndAddWaitFree" translate="no">isFetchAndAddWaitFree</a>() functions.</p>
<p>Below is a complete list of all feature macros for QAtomicPointer:</p>
<ul>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</a></li>
<li><a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</a></li>
</ul>
</div>
<p><b>See also </b><a href="./qatomicinteger.htm" translate="no">QAtomicInteger</a>.</p>
<!-- @@@QAtomicPointer -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QAtomicPointer$$$QAtomicPointerconstQAtomicPointer<T>& -->
<h3 class="fn" id="QAtomicPointer-1" translate="no"><a name="QAtomicPointer-1"></a>QAtomicPointer::<span class="name">QAtomicPointer</span>(const <span class="type"><a href="./qatomicpointer.htm#QAtomicPointer" translate="no">QAtomicPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#QAtomicPointer-1" title="Direct link to this headline"></a></h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<!-- @@@QAtomicPointer -->
<!-- $$$QAtomicPointer[overload1]$$$QAtomicPointerT* -->
<h3 class="fn" id="QAtomicPointer" translate="no"><a name="QAtomicPointer"></a>QAtomicPointer::<span class="name">QAtomicPointer</span>(<span class="type">T</span> *<i>value</i> = nullptr)<a class="plink" href="#QAtomicPointer" title="Direct link to this headline"></a></h3>
<p>Constructs a QAtomicPointer with the given <i translate="no">value</i>.</p>
<!-- @@@QAtomicPointer -->
<!-- $$$operator=[overload1]$$$operator=constQAtomicPointer<T>& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qatomicpointer.htm#QAtomicPointer" translate="no">QAtomicPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;QAtomicPointer::<span class="name">operator=</span>(const <span class="type"><a href="./qatomicpointer.htm#QAtomicPointer" translate="no">QAtomicPointer</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns <i translate="no">other</i> to this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and returns a reference to this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a>.</p>
<!-- @@@operator= -->
<!-- $$$fetchAndAddAcquire[overload1]$$$fetchAndAddAcquireqptrdiff -->
<h3 class="fn" id="fetchAndAddAcquire" translate="no"><a name="fetchAndAddAcquire"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndAddAcquire</span>(<span class="type"><a href="./qtglobal.htm#qptrdiff-typedef" translate="no">qptrdiff</a></span> <i>valueToAdd</i>)<a class="plink" href="#fetchAndAddAcquire" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then adds <i translate="no">valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<!-- @@@fetchAndAddAcquire -->
<!-- $$$fetchAndAddOrdered[overload1]$$$fetchAndAddOrderedqptrdiff -->
<h3 class="fn" id="fetchAndAddOrdered" translate="no"><a name="fetchAndAddOrdered"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndAddOrdered</span>(<span class="type"><a href="./qtglobal.htm#qptrdiff-typedef" translate="no">qptrdiff</a></span> <i>valueToAdd</i>)<a class="plink" href="#fetchAndAddOrdered" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then adds <i translate="no">valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<!-- @@@fetchAndAddOrdered -->
<!-- $$$fetchAndAddRelaxed[overload1]$$$fetchAndAddRelaxedqptrdiff -->
<h3 class="fn" id="fetchAndAddRelaxed" translate="no"><a name="fetchAndAddRelaxed"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndAddRelaxed</span>(<span class="type"><a href="./qtglobal.htm#qptrdiff-typedef" translate="no">qptrdiff</a></span> <i>valueToAdd</i>)<a class="plink" href="#fetchAndAddRelaxed" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then adds <i translate="no">valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<!-- @@@fetchAndAddRelaxed -->
<!-- $$$fetchAndAddRelease[overload1]$$$fetchAndAddReleaseqptrdiff -->
<h3 class="fn" id="fetchAndAddRelease" translate="no"><a name="fetchAndAddRelease"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndAddRelease</span>(<span class="type"><a href="./qtglobal.htm#qptrdiff-typedef" translate="no">qptrdiff</a></span> <i>valueToAdd</i>)<a class="plink" href="#fetchAndAddRelease" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-add.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then adds <i translate="no">valueToAdd</i> to the current value, returning the original value.</p>
<p>This function uses <i>release</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<!-- @@@fetchAndAddRelease -->
<!-- $$$fetchAndStoreAcquire[overload1]$$$fetchAndStoreAcquireT* -->
<h3 class="fn" id="fetchAndStoreAcquire" translate="no"><a name="fetchAndStoreAcquire"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndStoreAcquire</span>(<span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#fetchAndStoreAcquire" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then assigns it the <i translate="no">newValue</i>, returning the original value.</p>
<p>This function uses <i>acquire</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<!-- @@@fetchAndStoreAcquire -->
<!-- $$$fetchAndStoreOrdered[overload1]$$$fetchAndStoreOrderedT* -->
<h3 class="fn" id="fetchAndStoreOrdered" translate="no"><a name="fetchAndStoreOrdered"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndStoreOrdered</span>(<span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#fetchAndStoreOrdered" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then assigns it the <i translate="no">newValue</i>, returning the original value.</p>
<p>This function uses <i>ordered</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<!-- @@@fetchAndStoreOrdered -->
<!-- $$$fetchAndStoreRelaxed[overload1]$$$fetchAndStoreRelaxedT* -->
<h3 class="fn" id="fetchAndStoreRelaxed" translate="no"><a name="fetchAndStoreRelaxed"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndStoreRelaxed</span>(<span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#fetchAndStoreRelaxed" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then assigns it the <i translate="no">newValue</i>, returning the original value.</p>
<p>This function uses <i>relaxed</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<!-- @@@fetchAndStoreRelaxed -->
<!-- $$$fetchAndStoreRelease[overload1]$$$fetchAndStoreReleaseT* -->
<h3 class="fn" id="fetchAndStoreRelease" translate="no"><a name="fetchAndStoreRelease"></a><span class="type">T</span> *QAtomicPointer::<span class="name">fetchAndStoreRelease</span>(<span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#fetchAndStoreRelease" title="Direct link to this headline"></a></h3>
<p>Atomic fetch-and-store.</p>
<p>Reads the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and then assigns it the <i translate="no">newValue</i>, returning the original value.</p>
<p>This function uses <i>release</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<!-- @@@fetchAndStoreRelease -->
<!-- $$$isFetchAndAddNative[overload1]$$$isFetchAndAddNative -->
<h3 class="fn" id="isFetchAndAddNative" translate="no"><a name="isFetchAndAddNative"></a><code translate="no">[static] </code><span class="type">bool</span> QAtomicPointer::<span class="name">isFetchAndAddNative</span>()<a class="plink" href="#isFetchAndAddNative" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if fetch-and-add is implemented using atomic processor instructions, false otherwise.</p>
<!-- @@@isFetchAndAddNative -->
<!-- $$$isFetchAndAddWaitFree[overload1]$$$isFetchAndAddWaitFree -->
<h3 class="fn" id="isFetchAndAddWaitFree" translate="no"><a name="isFetchAndAddWaitFree"></a><code translate="no">[static] </code><span class="type">bool</span> QAtomicPointer::<span class="name">isFetchAndAddWaitFree</span>()<a class="plink" href="#isFetchAndAddWaitFree" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if atomic fetch-and-add is wait-free, false otherwise.</p>
<!-- @@@isFetchAndAddWaitFree -->
<!-- $$$isFetchAndStoreNative[overload1]$$$isFetchAndStoreNative -->
<h3 class="fn" id="isFetchAndStoreNative" translate="no"><a name="isFetchAndStoreNative"></a><code translate="no">[static] </code><span class="type">bool</span> QAtomicPointer::<span class="name">isFetchAndStoreNative</span>()<a class="plink" href="#isFetchAndStoreNative" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if fetch-and-store is implemented using atomic processor instructions, false otherwise.</p>
<!-- @@@isFetchAndStoreNative -->
<!-- $$$isFetchAndStoreWaitFree[overload1]$$$isFetchAndStoreWaitFree -->
<h3 class="fn" id="isFetchAndStoreWaitFree" translate="no"><a name="isFetchAndStoreWaitFree"></a><code translate="no">[static] </code><span class="type">bool</span> QAtomicPointer::<span class="name">isFetchAndStoreWaitFree</span>()<a class="plink" href="#isFetchAndStoreWaitFree" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if atomic fetch-and-store is wait-free, false otherwise.</p>
<!-- @@@isFetchAndStoreWaitFree -->
<!-- $$$isTestAndSetNative[overload1]$$$isTestAndSetNative -->
<h3 class="fn" id="isTestAndSetNative" translate="no"><a name="isTestAndSetNative"></a><code translate="no">[static] </code><span class="type">bool</span> QAtomicPointer::<span class="name">isTestAndSetNative</span>()<a class="plink" href="#isTestAndSetNative" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if test-and-set is implemented using atomic processor instructions, false otherwise.</p>
<!-- @@@isTestAndSetNative -->
<!-- $$$isTestAndSetWaitFree[overload1]$$$isTestAndSetWaitFree -->
<h3 class="fn" id="isTestAndSetWaitFree" translate="no"><a name="isTestAndSetWaitFree"></a><code translate="no">[static] </code><span class="type">bool</span> QAtomicPointer::<span class="name">isTestAndSetWaitFree</span>()<a class="plink" href="#isTestAndSetWaitFree" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if atomic test-and-set is wait-free, false otherwise.</p>
<!-- @@@isTestAndSetWaitFree -->
<!-- $$$loadAcquire[overload1]$$$loadAcquire -->
<h3 class="fn" id="loadAcquire" translate="no"><a name="loadAcquire"></a><span class="type">T</span> *QAtomicPointer::<span class="name">loadAcquire</span>() const<a class="plink" href="#loadAcquire" title="Direct link to this headline"></a></h3>
<p>Atomically loads the value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> using the "Acquire" memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</p>
<p><b>See also </b><a href="./qatomicpointer.htm#storeRelease" translate="no">storeRelease</a>() and <a href="./qatomicpointer.htm#loadRelaxed" translate="no">loadRelaxed</a>().</p>
<!-- @@@loadAcquire -->
<!-- $$$loadRelaxed[overload1]$$$loadRelaxed -->
<h3 class="fn" id="loadRelaxed" translate="no"><a name="loadRelaxed"></a><span class="type">T</span> *QAtomicPointer::<span class="name">loadRelaxed</span>() const<a class="plink" href="#loadRelaxed" title="Direct link to this headline"></a></h3>
<p>Atomically loads the value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> using relaxed memory ordering. The value is not modified in any way, but note that there's no guarantee that it remains so.</p>
<p>This function was introduced in Qt 5.14.</p>
<p><b>See also </b><a href="./qatomicpointer.htm#storeRelaxed" translate="no">storeRelaxed</a>() and <a href="./qatomicpointer.htm#loadAcquire" translate="no">loadAcquire</a>().</p>
<!-- @@@loadRelaxed -->
<!-- $$$storeRelaxed[overload1]$$$storeRelaxedT* -->
<h3 class="fn" id="storeRelaxed" translate="no"><a name="storeRelaxed"></a><span class="type">void</span> QAtomicPointer::<span class="name">storeRelaxed</span>(<span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#storeRelaxed" title="Direct link to this headline"></a></h3>
<p>Atomically stores the <i translate="no">newValue</i> value into this atomic type, using relaxed memory ordering.</p>
<p>This function was introduced in Qt 5.14.</p>
<p><b>See also </b><a href="./qatomicpointer.htm#storeRelease" translate="no">storeRelease</a>() and <a href="./qatomicpointer.htm#loadRelaxed" translate="no">loadRelaxed</a>().</p>
<!-- @@@storeRelaxed -->
<!-- $$$storeRelease[overload1]$$$storeReleaseT* -->
<h3 class="fn" id="storeRelease" translate="no"><a name="storeRelease"></a><span class="type">void</span> QAtomicPointer::<span class="name">storeRelease</span>(<span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#storeRelease" title="Direct link to this headline"></a></h3>
<p>Atomically stores the <i translate="no">newValue</i> value into this atomic type, using the "Release" memory ordering.</p>
<p><b>See also </b><a href="./qatomicpointer.htm#storeRelaxed" translate="no">storeRelaxed</a>() and <a href="./qatomicpointer.htm#loadRelaxed" translate="no">loadRelaxed</a>().</p>
<!-- @@@storeRelease -->
<!-- $$$testAndSetAcquire[overload1]$$$testAndSetAcquireT*T* -->
<h3 class="fn" id="testAndSetAcquire" translate="no"><a name="testAndSetAcquire"></a><span class="type">bool</span> QAtomicPointer::<span class="name">testAndSetAcquire</span>(<span class="type">T</span> *<i>expectedValue</i>, <span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#testAndSetAcquire" title="Direct link to this headline"></a></h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> is the <i translate="no">expectedValue</i>, the test-and-set functions assign the <i translate="no">newValue</i> to this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code translate="no">false</code>.</p>
<p>This function uses <i>acquire</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.</p>
<!-- @@@testAndSetAcquire -->
<!-- $$$testAndSetOrdered[overload1]$$$testAndSetOrderedT*T* -->
<h3 class="fn" id="testAndSetOrdered" translate="no"><a name="testAndSetOrdered"></a><span class="type">bool</span> QAtomicPointer::<span class="name">testAndSetOrdered</span>(<span class="type">T</span> *<i>expectedValue</i>, <span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#testAndSetOrdered" title="Direct link to this headline"></a></h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> is the <i translate="no">expectedValue</i>, the test-and-set functions assign the <i translate="no">newValue</i> to this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code translate="no">false</code>.</p>
<p>This function uses <i>ordered</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.</p>
<!-- @@@testAndSetOrdered -->
<!-- $$$testAndSetRelaxed[overload1]$$$testAndSetRelaxedT*T* -->
<h3 class="fn" id="testAndSetRelaxed" translate="no"><a name="testAndSetRelaxed"></a><span class="type">bool</span> QAtomicPointer::<span class="name">testAndSetRelaxed</span>(<span class="type">T</span> *<i>expectedValue</i>, <span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#testAndSetRelaxed" title="Direct link to this headline"></a></h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> is the <i translate="no">expectedValue</i>, the test-and-set functions assign the <i translate="no">newValue</i> to this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code translate="no">false</code>.</p>
<p>This function uses <i>relaxed</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, leaving the compiler and processor to freely reorder memory accesses.</p>
<!-- @@@testAndSetRelaxed -->
<!-- $$$testAndSetRelease[overload1]$$$testAndSetReleaseT*T* -->
<h3 class="fn" id="testAndSetRelease" translate="no"><a name="testAndSetRelease"></a><span class="type">bool</span> QAtomicPointer::<span class="name">testAndSetRelease</span>(<span class="type">T</span> *<i>expectedValue</i>, <span class="type">T</span> *<i>newValue</i>)<a class="plink" href="#testAndSetRelease" title="Direct link to this headline"></a></h3>
<p>Atomic test-and-set.</p>
<p>If the current value of this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> is the <i translate="no">expectedValue</i>, the test-and-set functions assign the <i translate="no">newValue</i> to this <a href="./qatomicpointer.htm" translate="no">QAtomicPointer</a> and return true. If the values are <i>not</i> the same, this function does nothing and returns <code translate="no">false</code>.</p>
<p>This function uses <i>release</i> <a href="./qatomicpointer.htm#memory-ordering" translate="no">memory ordering</a> semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.</p>
<!-- @@@testAndSetRelease -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined if and only if your processor supports atomic fetch-and-add on pointers.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined when the hardware does not support atomic fetch-and-add on pointers.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_NOT_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined when only certain generations of the processor support atomic fetch-and-add on pointers. Use the <a href="./qatomicpointer.htm#isFetchAndAddNative" translate="no">QAtomicPointer::isFetchAndAddNative</a>() function to check what your processor supports.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE" title="Direct link to this headline"></a></h3>
<p>This macro is defined together with <a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_ALWAYS_NATIVE</a> to indicate that the atomic fetch-and-add on pointers is wait-free.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_WAIT_FREE -->
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined if and only if your processor supports atomic fetch-and-store on pointers.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined when the hardware does not support atomic fetch-and-store on pointers.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_NOT_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined when only certain generations of the processor support atomic fetch-and-store on pointers. Use the <a href="./qatomicpointer.htm#isFetchAndStoreNative" translate="no">QAtomicPointer::isFetchAndStoreNative</a>() function to check what your processor supports.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE[overload1]$$$Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE" translate="no"><a name="Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE"></a><span class="name">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE</span><a class="plink" href="#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE" title="Direct link to this headline"></a></h3>
<p>This macro is defined together with <a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_ALWAYS_NATIVE</a> to indicate that the atomic fetch-and-store on pointers is wait-free.</p>
<!-- @@@Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_WAIT_FREE -->
<!-- $$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE[overload1]$$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined if and only if your processor supports atomic test-and-set on pointers.</p>
<!-- @@@Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE[overload1]$$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined when the hardware does not support atomic test-and-set on pointers.</p>
<!-- @@@Q_ATOMIC_POINTER_TEST_AND_SET_IS_NOT_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE[overload1]$$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE" translate="no"><a name="Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE"></a><span class="name">Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE</span><a class="plink" href="#Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE" title="Direct link to this headline"></a></h3>
<p>This macro is defined when only certain generations of the processor support atomic test-and-set on pointers. Use the <a href="./qatomicpointer.htm#isTestAndSetNative" translate="no">QAtomicPointer::isTestAndSetNative</a>() function to check what your processor supports.</p>
<!-- @@@Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE -->
<!-- $$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE[overload1]$$$Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE -->
<h3 class="fn" id="Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE" translate="no"><a name="Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE"></a><span class="name">Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE</span><a class="plink" href="#Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE" title="Direct link to this headline"></a></h3>
<p>This macro is defined together with <a href="./qatomicpointer.htm#Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE" translate="no">Q_ATOMIC_POINTER_TEST_AND_SET_IS_ALWAYS_NATIVE</a> to indicate that the atomic test-and-set on pointers is wait-free.</p>
<!-- @@@Q_ATOMIC_POINTER_TEST_AND_SET_IS_WAIT_FREE -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>