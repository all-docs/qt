<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QDtls | Qt Network</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qdtls.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtnetwork-index.htm" translate="no">Qt Network</a></li>
                            <li><a href="./qtnetwork-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QDtls</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QDtls Class</h1>
<!-- $$$QDtls-brief -->
<p>This class provides encryption for UDP sockets. <a href="#details">More...</a></p>
<!-- @@@QDtls -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QDtls&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.12</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qobject.htm" translate="no">QObject</a></td></tr></tbody></table></div><p>This class was introduced in Qt 5.12.</p>
<ul>
<li><a href="./qdtls-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> (alias) </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#GeneratorParameters-alias" translate="no">GeneratorParameters</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#HandshakeState-enum" translate="no">HandshakeState</a></b> { HandshakeNotStarted, HandshakeInProgress, PeerVerificationFailed, HandshakeComplete }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#QDtls" translate="no">QDtls</a></b>(QSslSocket::SslMode <i>mode</i>, QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#dtor.QDtls" translate="no">~QDtls</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#abortHandshake" translate="no">abortHandshake</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDtls::GeneratorParameters </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#cookieGeneratorParameters" translate="no">cookieGeneratorParameters</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#decryptDatagram" translate="no">decryptDatagram</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslConfiguration </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#dtlsConfiguration" translate="no">dtlsConfiguration</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDtlsError </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#dtlsError" translate="no">dtlsError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#dtlsErrorString" translate="no">dtlsErrorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#handleTimeout" translate="no">handleTimeout</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDtls::HandshakeState </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#handshakeState" translate="no">handshakeState</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a></b>(const QVector&lt;QSslError&gt; &amp;<i>errorsToIgnore</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#isConnectionEncrypted" translate="no">isConnectionEncrypted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#mtuHint" translate="no">mtuHint</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QHostAddress </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#peerAddress" translate="no">peerAddress</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#peerPort" translate="no">peerPort</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QSslError&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#peerVerificationErrors" translate="no">peerVerificationErrors</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#peerVerificationName" translate="no">peerVerificationName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#resumeHandshake" translate="no">resumeHandshake</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslCipher </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#sessionCipher" translate="no">sessionCipher</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSsl::SslProtocol </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#sessionProtocol" translate="no">sessionProtocol</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#setCookieGeneratorParameters" translate="no">setCookieGeneratorParameters</a></b>(const QDtls::GeneratorParameters &amp;<i>params</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#setDtlsConfiguration" translate="no">setDtlsConfiguration</a></b>(const QSslConfiguration &amp;<i>configuration</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#setMtuHint" translate="no">setMtuHint</a></b>(quint16 <i>mtuHint</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#setPeer" translate="no">setPeer</a></b>(const QHostAddress &amp;<i>address</i>, quint16 <i>port</i>, const QString &amp;<i>verificationName</i> = {})</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#setPeerVerificationName" translate="no">setPeerVerificationName</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#shutdown" translate="no">shutdown</a></b>(QUdpSocket *<i>socket</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslSocket::SslMode </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#sslMode" translate="no">sslMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#writeDatagramEncrypted" translate="no">writeDatagramEncrypted</a></b>(QUdpSocket *<i>socket</i>, const QByteArray &amp;<i>dgram</i>)</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#handshakeTimeout" translate="no">handshakeTimeout</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#pskRequired" translate="no">pskRequired</a></b>(QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td></tr>
</tbody></table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members<a class="plink" href="#related-non-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum class </td><td class="memItemRight bottomAlign"><b><a href="./qdtls.htm#QDtlsError-enum" translate="no">QDtlsError</a></b> { NoError, InvalidInputParameters, InvalidOperation, UnderlyingSocketError, RemoteClosedConnectionError, â€¦, TlsNonFatalError }</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QDtls-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>The QDtls class can be used to establish a secure connection with a network peer using User Datagram Protocol (UDP). DTLS connection over essentially connectionless UDP means that two peers first have to successfully complete a TLS handshake by calling <a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>(). After the handshake has completed, encrypted datagrams can be sent to the peer using <a href="./qdtls.htm#writeDatagramEncrypted" translate="no">writeDatagramEncrypted</a>(). Encrypted datagrams coming from the peer can be decrypted by <a href="./qdtls.htm#decryptDatagram" translate="no">decryptDatagram</a>().</p>
<p>QDtls is designed to work with <a href="./qudpsocket.htm" translate="no">QUdpSocket</a>. Since <a href="./qudpsocket.htm" translate="no">QUdpSocket</a> can receive datagrams coming from different peers, an application must implement demultiplexing, forwarding datagrams coming from different peers to their corresponding instances of QDtls. An association between a network peer and its QDtls object can be established using the peer's address and port number. Before starting a handshake, the application must set the peer's address and port number using <a href="./qdtls.htm#setPeer" translate="no">setPeer</a>().</p>
<p>QDtls does not read datagrams from <a href="./qudpsocket.htm" translate="no">QUdpSocket</a>, this is expected to be done by the application, for example, in a slot attached to the <a href="./qiodevice.htm#readyRead" translate="no">QUdpSocket::readyRead</a>() signal. Then, these datagrams must be processed by QDtls.</p>
<div class="admonition note">
<p><b>Note: </b>QDtls does <i>not</i> take ownership of the <a href="./qudpsocket.htm" translate="no">QUdpSocket</a> object.</p>
</div>
<p>Normally, several datagrams are to be received and sent by both peers during the handshake phase. Upon reading datagrams, server and client must pass these datagrams to <a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>() until some error is found or <a href="./qdtls.htm#handshakeState" translate="no">handshakeState</a>() returns <a href="./qdtls.htm#HandshakeState-enum" translate="no">HandshakeComplete</a>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// A client initiates a handshake:</span>
<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> clientSocket;
<span class="type"><a href="./qdtls.htm#QDtls" translate="no">QDtls</a></span> clientDtls;
clientDtls<span class="operator">.</span>setPeer(address<span class="operator">,</span> port<span class="operator">,</span> peerName);
clientDtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>clientSocket);

<span class="comment">// A server accepting an incoming connection; address, port, clientHello are</span>
<span class="comment">// read by QUdpSocket::readDatagram():</span>
<span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> clientHello(serverSocket<span class="operator">.</span>pendingDatagramSize()<span class="operator">,</span> <span class="type">Qt</span><span class="operator">::</span>Uninitialized);
<span class="type"><a href="./qhostaddress.htm" translate="no">QHostAddress</a></span> address;
quin16 port <span class="operator">=</span> {};
serverSocket<span class="operator">.</span>readDatagram(clientHello<span class="operator">.</span>data()<span class="operator">,</span> clientHello<span class="operator">.</span>size()<span class="operator">,</span> <span class="operator">&amp;</span>address<span class="operator">,</span> <span class="operator">&amp;</span>port);

<span class="type"><a href="./qdtls.htm#QDtls" translate="no">QDtls</a></span> serverDtls;
serverDtls<span class="operator">.</span>setPeer(address<span class="operator">,</span> port);
serverDtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>serverSocket<span class="operator">,</span> clientHello);

<span class="comment">// Handshake completion, both for server and client:</span>
<span class="type">void</span> DtlsConnection<span class="operator">::</span>continueHandshake(<span class="keyword">const</span> <span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> <span class="operator">&amp;</span>datagram)
{
    <span class="keyword">if</span> (dtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>udpSocket<span class="operator">,</span> datagram)) {
        <span class="comment">// Check handshake status:</span>
        <span class="keyword">if</span> (dtls<span class="operator">.</span>handshakeStatus() <span class="operator">=</span><span class="operator">=</span> <span class="type">QDlts</span><span class="operator">::</span>HandshakeComplete) {
            <span class="comment">// Secure DTLS connection is now established.</span>
        }
    } <span class="keyword">else</span> {
        <span class="comment">// Error handling.</span>
    }
}</pre></div>
<p>For a server, the first call to <a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>() requires a non-empty datagram containing a ClientHello message. If the server also deploys <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a>, the first ClientHello message is expected to be the one verified by <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a>.</p>
<p>In case the peer's identity cannot be validated during the handshake, the application must inspect errors returned by <a href="./qdtls.htm#peerVerificationErrors" translate="no">peerVerificationErrors</a>() and then either ignore errors by calling <a href="./qdtls.htm#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>() or abort the handshake by calling <a href="./qdtls.htm#abortHandshake" translate="no">abortHandshake</a>(). If errors were ignored, the handshake can be resumed by calling <a href="./qdtls.htm#resumeHandshake" translate="no">resumeHandshake</a>().</p>
<p>After the handshake has been completed, datagrams can be sent to and received from the network peer securely:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Sending an encrypted datagram:</span>
dtlsConnection<span class="operator">.</span>writeDatagramEncrypted(<span class="operator">&amp;</span>clientSocket<span class="operator">,</span> <span class="string">"Hello DTLS server!"</span>);

<span class="comment">// Decryption:</span>
<span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> encryptedMessage(dgramSize);
socket<span class="operator">.</span>readDatagram(encryptedMessage<span class="operator">.</span>data()<span class="operator">,</span> dgramSize);
<span class="keyword">const</span> <span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> plainText <span class="operator">=</span> dtlsConnection<span class="operator">.</span>decryptDatagram(<span class="operator">&amp;</span>socket<span class="operator">,</span> encryptedMessage);</pre></div>
<p>A DTLS connection may be closed using <a href="./qdtls.htm#shutdown" translate="no">shutdown</a>().</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">DtlsClient<span class="operator">::</span><span class="operator">~</span>DtlsClient()
{
    clientDtls<span class="operator">.</span>shutdown(<span class="operator">&amp;</span>clientSocket);
}</pre></div>
<div class="admonition warning">
<p><b>Warning: </b>It's recommended to call <a href="./qdtls.htm#shutdown" translate="no">shutdown</a>() before destroying the client's QDtls object if you are planning to re-use the same port number to connect to the server later. Otherwise, the server may drop incoming ClientHello messages, see <a href="https://tools.ietf.org/html/rfc6347#page-25" translate="no">RFC 6347, section 4.2.8</a> for more details and implementation hints.</p>
</div>
<p>If the server does not use <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a>, it <i>must</i> configure its QDtls objects to disable the cookie verification procedure:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">auto</span> config <span class="operator">=</span> <span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span><span class="operator">::</span>defaultDtlsConfiguration();
config<span class="operator">.</span>setDtlsCookieVerificationEnabled(<span class="keyword">false</span>);
<span class="comment">// Some other customization ...</span>
dtlsConnection<span class="operator">.</span>setDtlsConfiguration(config);</pre></div>
<p>A server that uses cookie verification with non-default generator parameters <i>must</i> set the same parameters for its QDtls object before starting the handshake.</p>
<div class="admonition note">
<p><b>Note: </b>The DTLS protocol leaves Path Maximum Transmission Unit (PMTU) discovery to the application. The application may provide QDtls with the MTU using <a href="./qdtls.htm#setMtuHint" translate="no">setMtuHint</a>(). This hint affects only the handshake phase, since only handshake messages can be fragmented and reassembled by the DTLS. All other messages sent by the application must fit into a single datagram.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>DTLS-specific headers add some overhead to application data further reducing the possible message size.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>A server configured to reply with HelloVerifyRequest will drop all fragmented ClientHello messages, never starting a handshake.</p>
</div>
<p>The <a href="./qtnetwork-secureudpserver-example.htm" translate="no">DTLS server</a> and <a href="./qtnetwork-secureudpclient-example.htm" translate="no">DTLS client</a> examples illustrate how to use QDtls in applications.</p>
</div>
<p><b>See also </b><a href="./qudpsocket.htm" translate="no">QUdpSocket</a>, <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a>, <a href="./qdtls.htm#HandshakeState-enum" translate="no">HandshakeState</a>, <a href="./qdtls.htm#QDtlsError-enum" translate="no">QDtlsError</a>, and <a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a>.</p>
<!-- @@@QDtls -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$GeneratorParameters -->
<h3 class="fn" id="GeneratorParameters-alias" translate="no"><a name="GeneratorParameters-alias"></a><code translate="no">[alias] </code>QDtls::<span class="name">GeneratorParameters</span><a class="plink" href="#GeneratorParameters-alias" title="Direct link to this headline"></a></h3>
<p>This is a type alias for <a href="./qdtlsclientverifier-generatorparameters.htm" translate="no">QDtlsClientVerifier::GeneratorParameters</a>.</p>
<!-- @@@GeneratorParameters -->
<!-- $$$HandshakeState$$$HandshakeNotStarted$$$HandshakeInProgress$$$PeerVerificationFailed$$$HandshakeComplete -->
<h3 class="fn" id="HandshakeState-enum" translate="no"><a name="HandshakeState-enum"></a>enum QDtls::<span class="name">HandshakeState</span><a class="plink" href="#HandshakeState-enum" title="Direct link to this headline"></a></h3>
<p>Describes the current state of DTLS handshake.</p>
<p>This enum describes the current state of DTLS handshake for a <a href="./qdtls.htm" translate="no">QDtls</a> connection.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QDtls::HandshakeNotStarted</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Nothing done yet.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::HandshakeInProgress</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Handshake was initiated and no errors were found so far.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::PeerVerificationFailed</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The identity of the peer can't be established.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::HandshakeComplete</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">Handshake completed successfully and encrypted connection was established.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 5.12.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">QDtls::doHandshake</a>() and <a href="./qdtls.htm#handshakeState" translate="no">QDtls::handshakeState</a>().</p>
<!-- @@@HandshakeState -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QDtls[overload1]$$$QDtlsQSslSocket::SslModeQObject* -->
<h3 class="fn" id="QDtls" translate="no"><a name="QDtls"></a>QDtls::<span class="name">QDtls</span>(<span class="type"><a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslMode</a></span> <i>mode</i>, <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QDtls" title="Direct link to this headline"></a></h3>
<p>Creates a QDtls object, <i translate="no">parent</i> is passed to the <a href="./qobject.htm" translate="no">QObject</a> constructor. <i translate="no">mode</i> is <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslServerMode</a> for a server-side DTLS connection or <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslClientMode</a> for a client.</p>
<p><b>See also </b><a href="./qdtls.htm#sslMode" translate="no">sslMode</a>() and <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslMode</a>.</p>
<!-- @@@QDtls -->
<!-- $$$handshakeTimeout[overload1]$$$handshakeTimeout -->
<h3 class="fn" id="handshakeTimeout" translate="no"><a name="handshakeTimeout"></a><code translate="no">[signal] </code><span class="type">void</span> QDtls::<span class="name">handshakeTimeout</span>()<a class="plink" href="#handshakeTimeout" title="Direct link to this headline"></a></h3>
<p>Packet loss can result in timeouts during the handshake phase. In this case <a href="./qdtls.htm" translate="no">QDtls</a> emits a handshakeTimeout() signal. Call <a href="./qdtls.htm#handleTimeout" translate="no">handleTimeout</a>() to retransmit the handshake messages:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">DtlsClient<span class="operator">::</span>DtlsClient()
{
    <span class="comment">// Some initialization code here ...</span>
    connect(<span class="operator">&amp;</span>clientDtls<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qdtls.htm#QDtls" translate="no">QDtls</a></span><span class="operator">::</span>handshakeTimeout<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>DtlsClient<span class="operator">::</span>handleTimeout);
}

<span class="type">void</span> DtlsClient<span class="operator">::</span>handleTimeout()
{
    clientDtls<span class="operator">.</span>handleTimeout(<span class="operator">&amp;</span>clientSocket);
}</pre></div>
<p><b>See also </b><a href="./qdtls.htm#handleTimeout" translate="no">handleTimeout</a>().</p>
<!-- @@@handshakeTimeout -->
<!-- $$$pskRequired[overload1]$$$pskRequiredQSslPreSharedKeyAuthenticator* -->
<h3 class="fn" id="pskRequired" translate="no"><a name="pskRequired"></a><code translate="no">[signal] </code><span class="type">void</span> QDtls::<span class="name">pskRequired</span>(<span class="type"><a href="./qsslpresharedkeyauthenticator.htm" translate="no">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)<a class="plink" href="#pskRequired" title="Direct link to this headline"></a></h3>
<p><a href="./qdtls.htm" translate="no">QDtls</a> emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</p>
<p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the TLS handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i translate="no">authenticator</i> object according to their needs.</p>
<div class="admonition note">
<p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">authenticator</i> object is owned by <a href="./qdtls.htm" translate="no">QDtls</a> and must not be deleted by the application.</p>
</div>
<p><b>See also </b><a href="./qsslpresharedkeyauthenticator.htm" translate="no">QSslPreSharedKeyAuthenticator</a>.</p>
<!-- @@@pskRequired -->
<!-- $$$~QDtls[overload1]$$$~QDtls -->
<h3 class="fn" id="dtor.QDtls" translate="no"><a name="dtor.QDtls"></a><code translate="no">[virtual] </code>QDtls::<span class="name">~QDtls</span>()<a class="plink" href="#dtor.QDtls" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qdtls.htm" translate="no">QDtls</a> object.</p>
<!-- @@@~QDtls -->
<!-- $$$abortHandshake[overload1]$$$abortHandshakeQUdpSocket* -->
<h3 class="fn" id="abortHandshake" translate="no"><a name="abortHandshake"></a><span class="type">bool</span> QDtls::<span class="name">abortHandshake</span>(<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> *<i>socket</i>)<a class="plink" href="#abortHandshake" title="Direct link to this headline"></a></h3>
<p>Aborts the ongoing handshake. Returns true if one was on-going on <i translate="no">socket</i>; otherwise, sets a suitable error and returns false.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>() and <a href="./qdtls.htm#resumeHandshake" translate="no">resumeHandshake</a>().</p>
<!-- @@@abortHandshake -->
<!-- $$$cookieGeneratorParameters[overload1]$$$cookieGeneratorParameters -->
<h3 class="fn" id="cookieGeneratorParameters" translate="no"><a name="cookieGeneratorParameters"></a><span class="type">QDtls::GeneratorParameters</span> QDtls::<span class="name">cookieGeneratorParameters</span>() const<a class="plink" href="#cookieGeneratorParameters" title="Direct link to this headline"></a></h3>
<p>Returns the current hash algorithm and secret, either default ones or previously set by a call to <a href="./qdtls.htm#setCookieGeneratorParameters" translate="no">setCookieGeneratorParameters</a>().</p>
<p>The default hash algorithm is <a href="./qcryptographichash.htm#Algorithm-enum" translate="no">QCryptographicHash::Sha256</a> if Qt was configured to support it, <a href="./qcryptographichash.htm#Algorithm-enum" translate="no">QCryptographicHash::Sha1</a> otherwise. The default secret is obtained from the backend-specific cryptographically strong pseudorandom number generator.</p>
<p><b>See also </b><a href="./qdtls.htm#setCookieGeneratorParameters" translate="no">setCookieGeneratorParameters</a>(), <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a>, and cookieGeneratorParameters().</p>
<!-- @@@cookieGeneratorParameters -->
<!-- $$$decryptDatagram[overload1]$$$decryptDatagramQUdpSocket*constQByteArray& -->
<h3 class="fn" id="decryptDatagram" translate="no"><a name="decryptDatagram"></a><span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> QDtls::<span class="name">decryptDatagram</span>(<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> &amp;<i>dgram</i>)<a class="plink" href="#decryptDatagram" title="Direct link to this headline"></a></h3>
<p>Decrypts <i translate="no">dgram</i> and returns its contents as plain text. The handshake must be completed before datagrams can be decrypted. Depending on the type of the TLS message the connection may write into <i translate="no">socket</i>, which must be a valid pointer.</p>
<!-- @@@decryptDatagram -->
<!-- $$$doHandshake[overload1]$$$doHandshakeQUdpSocket*constQByteArray& -->
<h3 class="fn" id="doHandshake" translate="no"><a name="doHandshake"></a><span class="type">bool</span> QDtls::<span class="name">doHandshake</span>(<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> &amp;<i>dgram</i> = {})<a class="plink" href="#doHandshake" title="Direct link to this headline"></a></h3>
<p>Starts or continues a DTLS handshake. <i translate="no">socket</i> must be a valid pointer. When starting a server-side DTLS handshake, <i translate="no">dgram</i> must contain the initial ClientHello message read from <a href="./qudpsocket.htm" translate="no">QUdpSocket</a>. This function returns <code translate="no">true</code> if no error was found. Handshake state can be tested using <a href="./qdtls.htm#handshakeState" translate="no">handshakeState</a>(). <code translate="no">false</code> return means some error occurred, use <a href="./qdtls.htm#dtlsError" translate="no">dtlsError</a>() for more detailed information.</p>
<div class="admonition note">
<p><b>Note: </b>If the identity of the peer can't be established, the error is set to QDtlsError::PeerVerificationError. If you want to ignore verification errors and continue connecting, you must call <a href="./qdtls.htm#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>() and then <a href="./qdtls.htm#resumeHandshake" translate="no">resumeHandshake</a>(). If the errors cannot be ignored, you must call <a href="./qdtls.htm#abortHandshake" translate="no">abortHandshake</a>().</p>
</div>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">if</span> (<span class="operator">!</span>dtls<span class="operator">.</span>doHandshake(<span class="operator">&amp;</span>socket<span class="operator">,</span> dgram)) {
    <span class="keyword">if</span> (dtls<span class="operator">.</span>dtlsError() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="./qdtls.htm#QDtlsError-enum" translate="no">QDtlsError</a></span><span class="operator">::</span>PeerVerificationError)
        dtls<span class="operator">.</span>abortAfterError(<span class="operator">&amp;</span>socket);
}</pre></div>
<p><b>See also </b><a href="./qdtls.htm#handshakeState" translate="no">handshakeState</a>(), <a href="./qdtls.htm#dtlsError" translate="no">dtlsError</a>(), <a href="./qdtls.htm#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>(), <a href="./qdtls.htm#resumeHandshake" translate="no">resumeHandshake</a>(), and <a href="./qdtls.htm#abortHandshake" translate="no">abortHandshake</a>().</p>
<!-- @@@doHandshake -->
<!-- $$$dtlsConfiguration[overload1]$$$dtlsConfiguration -->
<h3 class="fn" id="dtlsConfiguration" translate="no"><a name="dtlsConfiguration"></a><span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span> QDtls::<span class="name">dtlsConfiguration</span>() const<a class="plink" href="#dtlsConfiguration" title="Direct link to this headline"></a></h3>
<p>Returns either the default DTLS configuration or the configuration set by an earlier call to <a href="./qdtls.htm#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>().</p>
<p><b>See also </b><a href="./qdtls.htm#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>() and <a href="./qsslconfiguration.htm#defaultDtlsConfiguration" translate="no">QSslConfiguration::defaultDtlsConfiguration</a>().</p>
<!-- @@@dtlsConfiguration -->
<!-- $$$dtlsError[overload1]$$$dtlsError -->
<h3 class="fn" id="dtlsError" translate="no"><a name="dtlsError"></a><span class="type"><a href="./qdtls.htm#QDtlsError-enum" translate="no">QDtlsError</a></span> QDtls::<span class="name">dtlsError</span>() const<a class="plink" href="#dtlsError" title="Direct link to this headline"></a></h3>
<p>Returns the last error encountered by the connection or QDtlsError::NoError.</p>
<p><b>See also </b><a href="./qdtls.htm#dtlsErrorString" translate="no">dtlsErrorString</a>() and <a href="./qdtls.htm#QDtlsError-enum" translate="no">QDtlsError</a>.</p>
<!-- @@@dtlsError -->
<!-- $$$dtlsErrorString[overload1]$$$dtlsErrorString -->
<h3 class="fn" id="dtlsErrorString" translate="no"><a name="dtlsErrorString"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QDtls::<span class="name">dtlsErrorString</span>() const<a class="plink" href="#dtlsErrorString" title="Direct link to this headline"></a></h3>
<p>Returns a textual description for the last error encountered by the connection or empty string.</p>
<p><b>See also </b><a href="./qdtls.htm#dtlsError" translate="no">dtlsError</a>().</p>
<!-- @@@dtlsErrorString -->
<!-- $$$handleTimeout[overload1]$$$handleTimeoutQUdpSocket* -->
<h3 class="fn" id="handleTimeout" translate="no"><a name="handleTimeout"></a><span class="type">bool</span> QDtls::<span class="name">handleTimeout</span>(<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> *<i>socket</i>)<a class="plink" href="#handleTimeout" title="Direct link to this headline"></a></h3>
<p>If a timeout occurs during the handshake, the <a href="./qdtls.htm#handshakeTimeout" translate="no">handshakeTimeout</a>() signal is emitted. The application must call handleTimeout() to retransmit handshake messages; handleTimeout() returns <code translate="no">true</code> if a timeout has occurred, false otherwise. <i translate="no">socket</i> must be a valid pointer.</p>
<p><b>See also </b><a href="./qdtls.htm#handshakeTimeout" translate="no">handshakeTimeout</a>().</p>
<!-- @@@handleTimeout -->
<!-- $$$handshakeState[overload1]$$$handshakeState -->
<h3 class="fn" id="handshakeState" translate="no"><a name="handshakeState"></a><span class="type"><a href="./qdtls.htm#HandshakeState-enum" translate="no">QDtls::HandshakeState</a></span> QDtls::<span class="name">handshakeState</span>() const<a class="plink" href="#handshakeState" title="Direct link to this headline"></a></h3>
<p>Returns the current handshake state for this <a href="./qdtls.htm" translate="no">QDtls</a>.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>() and <a href="./qdtls.htm#HandshakeState-enum" translate="no">QDtls::HandshakeState</a>.</p>
<!-- @@@handshakeState -->
<!-- $$$ignoreVerificationErrors[overload1]$$$ignoreVerificationErrorsconstQVector<QSslError>& -->
<h3 class="fn" id="ignoreVerificationErrors" translate="no"><a name="ignoreVerificationErrors"></a><span class="type">void</span> QDtls::<span class="name">ignoreVerificationErrors</span>(const <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span>&gt; &amp;<i>errorsToIgnore</i>)<a class="plink" href="#ignoreVerificationErrors" title="Direct link to this headline"></a></h3>
<p>This method tells <a href="./qdtls.htm" translate="no">QDtls</a> to ignore only the errors given in <i translate="no">errorsToIgnore</i>.</p>
<p>If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span><span class="operator">&gt;</span> cert <span class="operator">=</span> <span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span><span class="operator">::</span>fromPath(QLatin1String(<span class="string">"server-certificate.pem"</span>));
<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span> error(<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span><span class="operator">::</span>SelfSignedCertificate<span class="operator">,</span> cert<span class="operator">.</span>at(<span class="number">0</span>));
<span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span><span class="operator">&gt;</span> expectedSslErrors;
expectedSslErrors<span class="operator">.</span>append(error);

<span class="type"><a href="./qdtls.htm#QDtls" translate="no">QDtls</a></span> dtls;
dtls<span class="operator">.</span>ignoreVerificationErrors(expectedSslErrors);
dtls<span class="operator">.</span>doHandshake(udpSocket);</pre></div>
<p>You can also call this function after <a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>() encountered the QDtlsError::PeerVerificationError error, and then resume the handshake by calling <a href="./qdtls.htm#resumeHandshake" translate="no">resumeHandshake</a>().</p>
<p>Later calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>(), <a href="./qdtls.htm#resumeHandshake" translate="no">resumeHandshake</a>(), and <a href="./qsslerror.htm" translate="no">QSslError</a>.</p>
<!-- @@@ignoreVerificationErrors -->
<!-- $$$isConnectionEncrypted[overload1]$$$isConnectionEncrypted -->
<h3 class="fn" id="isConnectionEncrypted" translate="no"><a name="isConnectionEncrypted"></a><span class="type">bool</span> QDtls::<span class="name">isConnectionEncrypted</span>() const<a class="plink" href="#isConnectionEncrypted" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if DTLS handshake completed successfully.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>() and <a href="./qdtls.htm#handshakeState" translate="no">handshakeState</a>().</p>
<!-- @@@isConnectionEncrypted -->
<!-- $$$mtuHint[overload1]$$$mtuHint -->
<h3 class="fn" id="mtuHint" translate="no"><a name="mtuHint"></a><span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> QDtls::<span class="name">mtuHint</span>() const<a class="plink" href="#mtuHint" title="Direct link to this headline"></a></h3>
<p>Returns the value previously set by <a href="./qdtls.htm#setMtuHint" translate="no">setMtuHint</a>(). The default value is 0.</p>
<p><b>See also </b><a href="./qdtls.htm#setMtuHint" translate="no">setMtuHint</a>().</p>
<!-- @@@mtuHint -->
<!-- $$$peerAddress[overload1]$$$peerAddress -->
<h3 class="fn" id="peerAddress" translate="no"><a name="peerAddress"></a><span class="type"><a href="./qhostaddress.htm" translate="no">QHostAddress</a></span> QDtls::<span class="name">peerAddress</span>() const<a class="plink" href="#peerAddress" title="Direct link to this headline"></a></h3>
<p>Returns the peer's address, set by <a href="./qdtls.htm#setPeer" translate="no">setPeer</a>(), or <a href="./qhostaddress.htm#SpecialAddress-enum" translate="no">QHostAddress::Null</a>.</p>
<p><b>See also </b><a href="./qdtls.htm#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@peerAddress -->
<!-- $$$peerPort[overload1]$$$peerPort -->
<h3 class="fn" id="peerPort" translate="no"><a name="peerPort"></a><span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> QDtls::<span class="name">peerPort</span>() const<a class="plink" href="#peerPort" title="Direct link to this headline"></a></h3>
<p>Returns the peer's port number, set by <a href="./qdtls.htm#setPeer" translate="no">setPeer</a>(), or 0.</p>
<p><b>See also </b><a href="./qdtls.htm#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@peerPort -->
<!-- $$$peerVerificationErrors[overload1]$$$peerVerificationErrors -->
<h3 class="fn" id="peerVerificationErrors" translate="no"><a name="peerVerificationErrors"></a><span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span>&gt; QDtls::<span class="name">peerVerificationErrors</span>() const<a class="plink" href="#peerVerificationErrors" title="Direct link to this headline"></a></h3>
<p>Returns errors found while establishing the identity of the peer.</p>
<p>If you want to continue connecting despite the errors that have occurred, you must call <a href="./qdtls.htm#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>().</p>
<!-- @@@peerVerificationErrors -->
<!-- $$$peerVerificationName[overload1]$$$peerVerificationName -->
<h3 class="fn" id="peerVerificationName" translate="no"><a name="peerVerificationName"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QDtls::<span class="name">peerVerificationName</span>() const<a class="plink" href="#peerVerificationName" title="Direct link to this headline"></a></h3>
<p>Returns the host name set by <a href="./qdtls.htm#setPeer" translate="no">setPeer</a>() or <a href="./qdtls.htm#setPeerVerificationName" translate="no">setPeerVerificationName</a>(). The default value is an empty string.</p>
<p><b>See also </b><a href="./qdtls.htm#setPeerVerificationName" translate="no">setPeerVerificationName</a>() and <a href="./qdtls.htm#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@peerVerificationName -->
<!-- $$$resumeHandshake[overload1]$$$resumeHandshakeQUdpSocket* -->
<h3 class="fn" id="resumeHandshake" translate="no"><a name="resumeHandshake"></a><span class="type">bool</span> QDtls::<span class="name">resumeHandshake</span>(<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> *<i>socket</i>)<a class="plink" href="#resumeHandshake" title="Direct link to this headline"></a></h3>
<p>If peer verification errors were ignored during the handshake, resumeHandshake() resumes and completes the handshake and returns <code translate="no">true</code>. <i translate="no">socket</i> must be a valid pointer. Returns <code translate="no">false</code> if the handshake could not be resumed.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>(), <a href="./qdtls.htm#abortHandshake" translate="no">abortHandshake</a>(), <a href="./qdtls.htm#peerVerificationErrors" translate="no">peerVerificationErrors</a>(), and <a href="./qdtls.htm#ignoreVerificationErrors" translate="no">ignoreVerificationErrors</a>().</p>
<!-- @@@resumeHandshake -->
<!-- $$$sessionCipher[overload1]$$$sessionCipher -->
<h3 class="fn" id="sessionCipher" translate="no"><a name="sessionCipher"></a><span class="type"><a href="./qsslcipher.htm" translate="no">QSslCipher</a></span> QDtls::<span class="name">sessionCipher</span>() const<a class="plink" href="#sessionCipher" title="Direct link to this headline"></a></h3>
<p>Returns the cryptographic <a href="./qsslcipher.htm" translate="no">cipher</a> used by this connection, or a null cipher if the connection isn't encrypted. The cipher for the session is selected during the handshake phase. The cipher is used to encrypt and decrypt data.</p>
<p><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a> provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</p>
<p><b>See also </b><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a>, <a href="./qdtls.htm#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>(), and <a href="./qdtls.htm#dtlsConfiguration" translate="no">dtlsConfiguration</a>().</p>
<!-- @@@sessionCipher -->
<!-- $$$sessionProtocol[overload1]$$$sessionProtocol -->
<h3 class="fn" id="sessionProtocol" translate="no"><a name="sessionProtocol"></a><span class="type"><a href="./qssl.htm#SslProtocol-enum" translate="no">QSsl::SslProtocol</a></span> QDtls::<span class="name">sessionProtocol</span>() const<a class="plink" href="#sessionProtocol" title="Direct link to this headline"></a></h3>
<p>Returns the DTLS protocol version used by this connection, or UnknownProtocol if the connection isn't encrypted yet. The protocol for the connection is selected during the handshake phase.</p>
<p><a href="./qdtls.htm#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>() can set the preferred version before the handshake starts.</p>
<p><b>See also </b><a href="./qdtls.htm#setDtlsConfiguration" translate="no">setDtlsConfiguration</a>(), <a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a>, <a href="./qsslconfiguration.htm#defaultDtlsConfiguration" translate="no">QSslConfiguration::defaultDtlsConfiguration</a>(), and <a href="./qsslconfiguration.htm#setProtocol" translate="no">QSslConfiguration::setProtocol</a>().</p>
<!-- @@@sessionProtocol -->
<!-- $$$setCookieGeneratorParameters[overload1]$$$setCookieGeneratorParametersconstQDtls::GeneratorParameters& -->
<h3 class="fn" id="setCookieGeneratorParameters" translate="no"><a name="setCookieGeneratorParameters"></a><span class="type">bool</span> QDtls::<span class="name">setCookieGeneratorParameters</span>(const <span class="type">QDtls::GeneratorParameters</span> &amp;<i>params</i>)<a class="plink" href="#setCookieGeneratorParameters" title="Direct link to this headline"></a></h3>
<p>Sets the cryptographic hash algorithm and the secret from <i translate="no">params</i>. This function is only needed for a server-side <a href="./qdtls.htm" translate="no">QDtls</a> connection. Returns <code translate="no">true</code> if successful.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the handshake starts.</p>
</div>
<p><b>See also </b><a href="./qdtls.htm#cookieGeneratorParameters" translate="no">cookieGeneratorParameters</a>(), <a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>(), <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a>, and <a href="./qdtlsclientverifier.htm#cookieGeneratorParameters" translate="no">QDtlsClientVerifier::cookieGeneratorParameters</a>().</p>
<!-- @@@setCookieGeneratorParameters -->
<!-- $$$setDtlsConfiguration[overload1]$$$setDtlsConfigurationconstQSslConfiguration& -->
<h3 class="fn" id="setDtlsConfiguration" translate="no"><a name="setDtlsConfiguration"></a><span class="type">bool</span> QDtls::<span class="name">setDtlsConfiguration</span>(const <span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span> &amp;<i>configuration</i>)<a class="plink" href="#setDtlsConfiguration" title="Direct link to this headline"></a></h3>
<p>Sets the connection's TLS configuration from <i translate="no">configuration</i> and returns <code translate="no">true</code> if successful.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the handshake starts.</p>
</div>
<p><b>See also </b><a href="./qdtls.htm#dtlsConfiguration" translate="no">dtlsConfiguration</a>() and <a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>().</p>
<!-- @@@setDtlsConfiguration -->
<!-- $$$setMtuHint[overload1]$$$setMtuHintquint16 -->
<h3 class="fn" id="setMtuHint" translate="no"><a name="setMtuHint"></a><span class="type">void</span> QDtls::<span class="name">setMtuHint</span>(<span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <i>mtuHint</i>)<a class="plink" href="#setMtuHint" title="Direct link to this headline"></a></h3>
<p><i translate="no">mtuHint</i> is the maximum transmission unit (MTU), either discovered or guessed by the application. The application is not required to set this value.</p>
<p><b>See also </b><a href="./qdtls.htm#mtuHint" translate="no">mtuHint</a>() and <a href="./qabstractsocket.htm#SocketOption-enum" translate="no">QAbstractSocket::PathMtuSocketOption</a>.</p>
<!-- @@@setMtuHint -->
<!-- $$$setPeer[overload1]$$$setPeerconstQHostAddress&quint16constQString& -->
<h3 class="fn" id="setPeer" translate="no"><a name="setPeer"></a><span class="type">bool</span> QDtls::<span class="name">setPeer</span>(const <span class="type"><a href="./qhostaddress.htm" translate="no">QHostAddress</a></span> &amp;<i>address</i>, <span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>verificationName</i> = {})<a class="plink" href="#setPeer" title="Direct link to this headline"></a></h3>
<p>Sets the peer's address, <i translate="no">port</i>, and host name and returns <code translate="no">true</code> if successful. <i translate="no">address</i> must not be null, multicast, or broadcast. <i translate="no">verificationName</i> is the host name used for the certificate validation.</p>
<p><b>See also </b><a href="./qdtls.htm#peerAddress" translate="no">peerAddress</a>(), <a href="./qdtls.htm#peerPort" translate="no">peerPort</a>(), and <a href="./qdtls.htm#peerVerificationName" translate="no">peerVerificationName</a>().</p>
<!-- @@@setPeer -->
<!-- $$$setPeerVerificationName[overload1]$$$setPeerVerificationNameconstQString& -->
<h3 class="fn" id="setPeerVerificationName" translate="no"><a name="setPeerVerificationName"></a><span class="type">bool</span> QDtls::<span class="name">setPeerVerificationName</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>name</i>)<a class="plink" href="#setPeerVerificationName" title="Direct link to this headline"></a></h3>
<p>Sets the host <i translate="no">name</i> that will be used for the certificate validation and returns <code translate="no">true</code> if successful.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the handshake starts.</p>
</div>
<p><b>See also </b><a href="./qdtls.htm#peerVerificationName" translate="no">peerVerificationName</a>() and <a href="./qdtls.htm#setPeer" translate="no">setPeer</a>().</p>
<!-- @@@setPeerVerificationName -->
<!-- $$$shutdown[overload1]$$$shutdownQUdpSocket* -->
<h3 class="fn" id="shutdown" translate="no"><a name="shutdown"></a><span class="type">bool</span> QDtls::<span class="name">shutdown</span>(<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> *<i>socket</i>)<a class="plink" href="#shutdown" title="Direct link to this headline"></a></h3>
<p>Sends an encrypted shutdown alert message and closes the DTLS connection. Handshake state changes to <a href="./qdtls.htm#HandshakeState-enum" translate="no">QDtls::HandshakeNotStarted</a>. <i translate="no">socket</i> must be a valid pointer. This function returns <code translate="no">true</code> on success.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>().</p>
<!-- @@@shutdown -->
<!-- $$$sslMode[overload1]$$$sslMode -->
<h3 class="fn" id="sslMode" translate="no"><a name="sslMode"></a><span class="type"><a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslMode</a></span> QDtls::<span class="name">sslMode</span>() const<a class="plink" href="#sslMode" title="Direct link to this headline"></a></h3>
<p>Returns <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslServerMode</a> for a server-side connection and <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslClientMode</a> for a client.</p>
<p><b>See also </b><a href="./qdtls.htm#QDtls" translate="no">QDtls</a>() and <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslMode</a>.</p>
<!-- @@@sslMode -->
<!-- $$$writeDatagramEncrypted[overload1]$$$writeDatagramEncryptedQUdpSocket*constQByteArray& -->
<h3 class="fn" id="writeDatagramEncrypted" translate="no"><a name="writeDatagramEncrypted"></a><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QDtls::<span class="name">writeDatagramEncrypted</span>(<span class="type"><a href="./qudpsocket.htm" translate="no">QUdpSocket</a></span> *<i>socket</i>, const <span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> &amp;<i>dgram</i>)<a class="plink" href="#writeDatagramEncrypted" title="Direct link to this headline"></a></h3>
<p>Encrypts <i translate="no">dgram</i> and writes the encrypted data into <i translate="no">socket</i>. Returns the number of bytes written, or -1 in case of error. The handshake must be completed before writing encrypted data. <i translate="no">socket</i> must be a valid pointer.</p>
<p><b>See also </b><a href="./qdtls.htm#doHandshake" translate="no">doHandshake</a>(), <a href="./qdtls.htm#handshakeState" translate="no">handshakeState</a>(), <a href="./qdtls.htm#isConnectionEncrypted" translate="no">isConnectionEncrypted</a>(), and <a href="./qdtls.htm#dtlsError" translate="no">dtlsError</a>().</p>
<!-- @@@writeDatagramEncrypted -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$QDtlsError$$$NoError$$$InvalidInputParameters$$$InvalidOperation$$$UnderlyingSocketError$$$RemoteClosedConnectionError$$$PeerVerificationError$$$TlsInitializationError$$$TlsFatalError$$$TlsNonFatalError -->
<h3 class="fn" id="QDtlsError-enum" translate="no"><a name="QDtlsError-enum"></a>enum class <span class="name">QDtlsError</span><a class="plink" href="#QDtlsError-enum" title="Direct link to this headline"></a></h3>
<p>Describes errors that can be found by <a href="./qdtls.htm" translate="no">QDtls</a> and <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a>.</p>
<p>This enum describes general and TLS-specific errors that can be encountered by objects of the classes <a href="./qdtlsclientverifier.htm" translate="no">QDtlsClientVerifier</a> and <a href="./qdtls.htm" translate="no">QDtls</a>.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::NoError</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No error occurred, the last operation was successful.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::InvalidInputParameters</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Input parameters provided by a caller were invalid.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::InvalidOperation</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">An operation was attempted in a state that did not permit it.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::UnderlyingSocketError</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign"><a href="./qudpsocket.htm#writeDatagram" translate="no">QUdpSocket::writeDatagram</a>() failed, <a href="./qabstractsocket.htm#error" translate="no">QUdpSocket::error</a>() and <a href="./qiodevice.htm#errorString" translate="no">QUdpSocket::errorString</a>() can provide more specific information.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::RemoteClosedConnectionError</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">TLS shutdown alert message was received.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::PeerVerificationError</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">Peer's identity could not be verified during the TLS handshake.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::TlsInitializationError</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">An error occurred while initializing an underlying TLS backend.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::TlsFatalError</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">A fatal error occurred during TLS handshake, other than peer verification error or TLS initialization error.</td></tr>
<tr><td class="topAlign"><code translate="no">QDtls::QDtlsError::TlsNonFatalError</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">A failure to encrypt or decrypt a datagram, non-fatal, meaning <a href="./qdtls.htm" translate="no">QDtls</a> can continue working after this error.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 5.12.</p>
<!-- @@@QDtlsError -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>