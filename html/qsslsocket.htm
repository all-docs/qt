<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QSslSocket | Qt Network</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qsslsocket.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtnetwork-index.htm" translate="no">Qt Network</a></li>
                            <li><a href="./qtnetwork-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QSslSocket</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QSslSocket Class</h1>
<!-- $$$QSslSocket-brief -->
<p>The QSslSocket class provides an SSL encrypted socket for both clients and servers. <a href="#details">More...</a></p>
<!-- @@@QSslSocket -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSslSocket&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += network</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.3</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a></td></tr></tbody></table></div><p>This class was introduced in Qt 4.3.</p>
<ul>
<li><a href="./qsslsocket-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qsslsocket-obsolete.htm">Obsolete members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">PeerVerifyMode</a></b> { VerifyNone, QueryPeer, VerifyPeer, AutoVerifyPeer }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#SslMode-enum" translate="no">SslMode</a></b> { UnencryptedMode, SslClientMode, SslServerMode }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#dtor.QSslSocket" translate="no">~QSslSocket</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#abort" translate="no">abort</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a></b>(const QString &amp;<i>hostName</i>, quint16 <i>port</i>, QIODevice::OpenMode <i>mode</i> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <i>protocol</i> = AnyIPProtocol)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#connectToHostEncrypted-1" translate="no">connectToHostEncrypted</a></b>(const QString &amp;<i>hostName</i>, quint16 <i>port</i>, const QString &amp;<i>sslPeerName</i>, QIODevice::OpenMode <i>mode</i> = ReadWrite, QAbstractSocket::NetworkLayerProtocol <i>protocol</i> = AnyIPProtocol)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#encryptedBytesAvailable" translate="no">encryptedBytesAvailable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#encryptedBytesToWrite" translate="no">encryptedBytesToWrite</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#flush" translate="no">flush</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#ignoreSslErrors-1" translate="no">ignoreSslErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#isEncrypted" translate="no">isEncrypted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslCertificate </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#localCertificate" translate="no">localCertificate</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QSslCertificate&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#localCertificateChain" translate="no">localCertificateChain</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslSocket::SslMode </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#mode" translate="no">mode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QOcspResponse&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#ocspResponses" translate="no">ocspResponses</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslCertificate </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#peerCertificate" translate="no">peerCertificate</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QSslCertificate&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#peerCertificateChain" translate="no">peerCertificateChain</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#peerVerifyDepth" translate="no">peerVerifyDepth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslSocket::PeerVerifyMode </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#peerVerifyMode" translate="no">peerVerifyMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#peerVerifyName" translate="no">peerVerifyName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslKey </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#privateKey" translate="no">privateKey</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSsl::SslProtocol </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#protocol" translate="no">protocol</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslCipher </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sessionCipher" translate="no">sessionCipher</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSsl::SslProtocol </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sessionProtocol" translate="no">sessionProtocol</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setLocalCertificate" translate="no">setLocalCertificate</a></b>(const QSslCertificate &amp;<i>certificate</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setLocalCertificate-1" translate="no">setLocalCertificate</a></b>(const QString &amp;<i>path</i>, QSsl::EncodingFormat <i>format</i> = QSsl::Pem)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setLocalCertificateChain" translate="no">setLocalCertificateChain</a></b>(const QList&lt;QSslCertificate&gt; &amp;<i>localChain</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setPeerVerifyDepth" translate="no">setPeerVerifyDepth</a></b>(int <i>depth</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setPeerVerifyMode" translate="no">setPeerVerifyMode</a></b>(QSslSocket::PeerVerifyMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setPeerVerifyName" translate="no">setPeerVerifyName</a></b>(const QString &amp;<i>hostName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setPrivateKey" translate="no">setPrivateKey</a></b>(const QSslKey &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setPrivateKey-1" translate="no">setPrivateKey</a></b>(const QString &amp;<i>fileName</i>, QSsl::KeyAlgorithm <i>algorithm</i> = QSsl::Rsa, QSsl::EncodingFormat <i>format</i> = QSsl::Pem, const QByteArray &amp;<i>passPhrase</i> = QByteArray())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setProtocol" translate="no">setProtocol</a></b>(QSsl::SslProtocol <i>protocol</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setSslConfiguration" translate="no">setSslConfiguration</a></b>(const QSslConfiguration &amp;<i>configuration</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSslConfiguration </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sslConfiguration" translate="no">sslConfiguration</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QSslError&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sslHandshakeErrors" translate="no">sslHandshakeErrors</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#waitForEncrypted" translate="no">waitForEncrypted</a></b>(int <i>msecs</i> = 30000)</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#atEnd" translate="no">atEnd</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#bytesAvailable" translate="no">bytesAvailable</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#bytesToWrite" translate="no">bytesToWrite</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#canReadLine" translate="no">canReadLine</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#close" translate="no">close</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#resume" translate="no">resume</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setReadBufferSize" translate="no">setReadBufferSize</a></b>(qint64 <i>size</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setSocketDescriptor" translate="no">setSocketDescriptor</a></b>(qintptr <i>socketDescriptor</i>, QAbstractSocket::SocketState <i>state</i> = ConnectedState, QIODevice::OpenMode <i>openMode</i> = ReadWrite) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#setSocketOption" translate="no">setSocketOption</a></b>(QAbstractSocket::SocketOption <i>option</i>, const QVariant &amp;<i>value</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#socketOption" translate="no">socketOption</a></b>(QAbstractSocket::SocketOption <i>option</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a></b>(int <i>msecs</i> = 30000) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#waitForConnected" translate="no">waitForConnected</a></b>(int <i>msecs</i> = 30000) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#waitForDisconnected" translate="no">waitForDisconnected</a></b>(int <i>msecs</i> = 30000) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#waitForReadyRead" translate="no">waitForReadyRead</a></b>(int <i>msecs</i> = 30000) override</td></tr>
</tbody></table></div>
<a name="public-slots"></a>
<h2 id="public-slots">Public Slots<a class="plink" href="#public-slots" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#ignoreSslErrors" translate="no">ignoreSslErrors</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#startClientEncryption" translate="no">startClientEncryption</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#startServerEncryption" translate="no">startServerEncryption</a></b>()</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#encryptedBytesWritten" translate="no">encryptedBytesWritten</a></b>(qint64 <i>written</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#modeChanged" translate="no">modeChanged</a></b>(QSslSocket::SslMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#newSessionTicketReceived" translate="no">newSessionTicketReceived</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#peerVerifyError" translate="no">peerVerifyError</a></b>(const QSslError &amp;<i>error</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#preSharedKeyAuthenticationRequired" translate="no">preSharedKeyAuthenticationRequired</a></b>(QSslPreSharedKeyAuthenticator *<i>authenticator</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sslErrors-1" translate="no">sslErrors</a></b>(const QList&lt;QSslError&gt; &amp;<i>errors</i>)</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> long </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sslLibraryBuildVersionNumber" translate="no">sslLibraryBuildVersionNumber</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sslLibraryBuildVersionString" translate="no">sslLibraryBuildVersionString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> long </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sslLibraryVersionNumber" translate="no">sslLibraryVersionNumber</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#sslLibraryVersionString" translate="no">sslLibraryVersionString</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#supportsSsl" translate="no">supportsSsl</a></b>()</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#readData" translate="no">readData</a></b>(char *<i>data</i>, qint64 <i>maxlen</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qsslsocket.htm#writeData" translate="no">writeData</a></b>(const char *<i>data</i>, qint64 <i>len</i>) override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QSslSocket-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QSslSocket establishes a secure, encrypted TCP connection you can use for transmitting encrypted data. It can operate in both client and server mode, and it supports modern SSL protocols, including SSL 3 and TLS 1.2. By default, QSslSocket uses only SSL protocols which are considered to be secure (<a href="./qssl.htm#SslProtocol-enum" translate="no">QSsl::SecureProtocols</a>), but you can change the SSL protocol by calling <a href="./qsslsocket.htm#setProtocol" translate="no">setProtocol</a>() as long as you do it before the handshake has started.</p>
<p>SSL encryption operates on top of the existing TCP stream after the socket enters the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">ConnectedState</a>. There are two simple ways to establish a secure connection using QSslSocket: With an immediate SSL handshake, or with a delayed SSL handshake occurring after the connection has been established in unencrypted mode.</p>
<p>The most common way to use QSslSocket is to construct an object and start a secure connection by calling <a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>(). This method starts an immediate SSL handshake once the connection has been established.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span> <span class="operator">*</span>socket <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span>(<span class="keyword">this</span>);
connect(socket<span class="operator">,</span> SIGNAL(encrypted())<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> SLOT(ready()));

socket<span class="operator">-</span><span class="operator">&gt;</span>connectToHostEncrypted(<span class="string">"imap.example.com"</span><span class="operator">,</span> <span class="number">993</span>);</pre></div>
<p>As with a plain <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a>, QSslSocket enters the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">HostLookupState</a>, <a href="./qabstractsocket.htm#SocketState-enum" translate="no">ConnectingState</a>, and finally the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">ConnectedState</a>, if the connection is successful. The handshake then starts automatically, and if it succeeds, the <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() signal is emitted to indicate the socket has entered the encrypted state and is ready for use.</p>
<p>Note that data can be written to the socket immediately after the return from <a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>() (i.e., before the <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() signal is emitted). The data is queued in QSslSocket until after the <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() signal is emitted.</p>
<p>An example of using the delayed SSL handshake to secure an existing connection is the case where an SSL server secures an incoming connection. Suppose you create an SSL server class as a subclass of <a href="./qtcpserver.htm" translate="no">QTcpServer</a>. You would override <a href="./qtcpserver.htm#incomingConnection" translate="no">QTcpServer::incomingConnection</a>() with something like the example below, which first constructs an instance of QSslSocket and then calls <a href="./qsslsocket.htm#setSocketDescriptor" translate="no">setSocketDescriptor</a>() to set the new socket's descriptor to the existing one passed in. It then initiates the SSL handshake by calling <a href="./qsslsocket.htm#startServerEncryption" translate="no">startServerEncryption</a>().</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> SslServer<span class="operator">::</span>incomingConnection(qintptr socketDescriptor)
{
    <span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span> <span class="operator">*</span>serverSocket <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span>;
    <span class="keyword">if</span> (serverSocket<span class="operator">-</span><span class="operator">&gt;</span>setSocketDescriptor(socketDescriptor)) {
        addPendingConnection(serverSocket);
        connect(serverSocket<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span><span class="operator">::</span>encrypted<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>SslServer<span class="operator">::</span>ready);
        serverSocket<span class="operator">-</span><span class="operator">&gt;</span>startServerEncryption();
    } <span class="keyword">else</span> {
        <span class="keyword">delete</span> serverSocket;
    }
}</pre></div>
<p>If an error occurs, QSslSocket emits the sslErrors() signal. In this case, if no action is taken to ignore the error(s), the connection is dropped. To continue, despite the occurrence of an error, you can call <a href="./qsslsocket.htm#ignoreSslErrors" translate="no">ignoreSslErrors</a>(), either from within this slot after the error occurs, or any time after construction of the QSslSocket and before the connection is attempted. This will allow QSslSocket to ignore the errors it encounters when establishing the identity of the peer. Ignoring errors during an SSL handshake should be used with caution, since a fundamental characteristic of secure connections is that they should be established with a successful handshake.</p>
<p>Once encrypted, you use QSslSocket as a regular <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a>. When <a href="./qiodevice.htm#readyRead" translate="no">readyRead</a>() is emitted, you can call <a href="./qiodevice.htm#read" translate="no">read</a>(), <a href="./qsslsocket.htm#canReadLine" translate="no">canReadLine</a>() and <a href="./qiodevice.htm#readLine" translate="no">readLine</a>(), or <a href="./qiodevice.htm#getChar" translate="no">getChar</a>() to read decrypted data from QSslSocket's internal buffer, and you can call <a href="./qiodevice.htm#write" translate="no">write</a>() or <a href="./qiodevice.htm#putChar" translate="no">putChar</a>() to write data back to the peer. QSslSocket will automatically encrypt the written data for you, and emit <a href="./qsslsocket.htm#encryptedBytesWritten" translate="no">encryptedBytesWritten</a>() once the data has been written to the peer.</p>
<p>As a convenience, QSslSocket supports <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a>'s blocking functions <a href="./qsslsocket.htm#waitForConnected" translate="no">waitForConnected</a>(), <a href="./qsslsocket.htm#waitForReadyRead" translate="no">waitForReadyRead</a>(), <a href="./qsslsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a>(), and <a href="./qsslsocket.htm#waitForDisconnected" translate="no">waitForDisconnected</a>(). It also provides <a href="./qsslsocket.htm#waitForEncrypted" translate="no">waitForEncrypted</a>(), which will block the calling thread until an encrypted connection has been established.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span> socket;
socket<span class="operator">.</span>connectToHostEncrypted(<span class="string">"http.example.com"</span><span class="operator">,</span> <span class="number">443</span>);
<span class="keyword">if</span> (<span class="operator">!</span>socket<span class="operator">.</span>waitForEncrypted()) {
    <a href="./qtglobal.htm#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> socket<span class="operator">.</span>errorString();
    <span class="keyword">return</span> <span class="keyword">false</span>;
}

socket<span class="operator">.</span>write(<span class="string">"GET / HTTP/1.0\r\n\r\n"</span>);
<span class="keyword">while</span> (socket<span class="operator">.</span>waitForReadyRead())
    <a href="./qtglobal.htm#qDebug" translate="no">qDebug</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> socket<span class="operator">.</span>readAll()<span class="operator">.</span>data();</pre></div>
<p>QSslSocket provides an extensive, easy-to-use API for handling cryptographic ciphers, private keys, and local, peer, and Certification Authority (CA) certificates. It also provides an API for handling errors that occur during the handshake phase.</p>
<p>The following features can also be customized:</p>
<ul>
<li>The socket's cryptographic cipher suite can be customized before the handshake phase with <a href="./qsslconfiguration.htm#setCiphers" translate="no">QSslConfiguration::setCiphers</a>() and QSslConfiguration::setDefaultCiphers().</li>
<li>The socket's local certificate and private key can be customized before the handshake phase with <a href="./qsslsocket.htm#setLocalCertificate" translate="no">setLocalCertificate</a>() and <a href="./qsslsocket.htm#setPrivateKey" translate="no">setPrivateKey</a>().</li>
<li>The CA certificate database can be extended and customized with <a href="./qsslconfiguration.htm#addCaCertificate" translate="no">QSslConfiguration::addCaCertificate</a>(), <a href="./qsslconfiguration.htm#addCaCertificates" translate="no">QSslConfiguration::addCaCertificates</a>().</li>
</ul>
<p>To extend the list of <i>default</i> CA certificates used by the SSL sockets during the SSL handshake you must update the default configuration, as in the snippet below:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span><span class="operator">&gt;</span> certificates <span class="operator">=</span> getCertificates();
<span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span> configuration <span class="operator">=</span> <span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span><span class="operator">::</span>defaultConfiguration();
configuration<span class="operator">.</span>addCaCertificates(certificates);
<span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span><span class="operator">::</span>setDefaultConfiguration(configuration);</pre></div>
<div class="admonition note">
<p><b>Note: </b>If available, root certificates on Unix (excluding macOS) will be loaded on demand from the standard certificate directories. If you do not want to load root certificates on demand, you need to call either <a href="./qsslconfiguration.htm#defaultConfiguration" translate="no">QSslConfiguration::defaultConfiguration</a>().setCaCertificates() before the first SSL handshake is made in your application (for example, via passing QSslSocket::systemCaCertificates() to it), or call <a href="./qsslconfiguration.htm#defaultConfiguration" translate="no">QSslConfiguration::defaultConfiguration</a>()::setCaCertificates() on your QSslSocket instance prior to the SSL handshake.</p>
</div>
<p>For more information about ciphers and certificates, refer to <a href="./qsslcipher.htm" translate="no">QSslCipher</a> and <a href="./qsslcertificate.htm" translate="no">QSslCertificate</a>.</p>
<p>This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (<a href="http://www.openssl.org/" translate="no">http://www.openssl.org/</a>).</p>
<div class="admonition note">
<p><b>Note: </b>Be aware of the difference between the <a href="./qiodevice.htm#bytesWritten" translate="no">bytesWritten</a>() signal and the <a href="./qsslsocket.htm#encryptedBytesWritten" translate="no">encryptedBytesWritten</a>() signal. For a <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a>, <a href="./qiodevice.htm#bytesWritten" translate="no">bytesWritten</a>() will get emitted as soon as data has been written to the TCP socket. For a QSslSocket, <a href="./qiodevice.htm#bytesWritten" translate="no">bytesWritten</a>() will get emitted when the data is being encrypted and <a href="./qsslsocket.htm#encryptedBytesWritten" translate="no">encryptedBytesWritten</a>() will get emitted as soon as data has been written to the TCP socket.</p>
</div>
</div>
<p><b>See also </b><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a>, <a href="./qsslcipher.htm" translate="no">QSslCipher</a>, and <a href="./qsslerror.htm" translate="no">QSslError</a>.</p>
<!-- @@@QSslSocket -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$PeerVerifyMode$$$VerifyNone$$$QueryPeer$$$VerifyPeer$$$AutoVerifyPeer -->
<h3 class="fn" id="PeerVerifyMode-enum" translate="no"><a name="PeerVerifyMode-enum"></a>enum QSslSocket::<span class="name">PeerVerifyMode</span><a class="plink" href="#PeerVerifyMode-enum" title="Direct link to this headline"></a></h3>
<p>Describes the peer verification modes for <a href="./qsslsocket.htm" translate="no">QSslSocket</a>. The default mode is AutoVerifyPeer, which selects an appropriate mode depending on the socket's QSocket::SslMode.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSslSocket::VerifyNone</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign"><a href="./qsslsocket.htm" translate="no">QSslSocket</a> will not request a certificate from the peer. You can set this mode if you are not interested in the identity of the other side of the connection. The connection will still be encrypted, and your socket will still send its local certificate to the peer if it's requested.</td></tr>
<tr><td class="topAlign"><code translate="no">QSslSocket::QueryPeer</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign"><a href="./qsslsocket.htm" translate="no">QSslSocket</a> will request a certificate from the peer, but does not require this certificate to be valid. This is useful when you want to display peer certificate details to the user without affecting the actual SSL handshake. This mode is the default for servers. Note: In Schannel this value acts the same as VerifyNone.</td></tr>
<tr><td class="topAlign"><code translate="no">QSslSocket::VerifyPeer</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign"><a href="./qsslsocket.htm" translate="no">QSslSocket</a> will request a certificate from the peer during the SSL handshake phase, and requires that this certificate is valid. On failure, <a href="./qsslsocket.htm" translate="no">QSslSocket</a> will emit the QSslSocket::sslErrors() signal. This mode is the default for clients.</td></tr>
<tr><td class="topAlign"><code translate="no">QSslSocket::AutoVerifyPeer</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign"><a href="./qsslsocket.htm" translate="no">QSslSocket</a> will automatically use QueryPeer for server sockets and VerifyPeer for client sockets.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#peerVerifyMode" translate="no">QSslSocket::peerVerifyMode</a>().</p>
<!-- @@@PeerVerifyMode -->
<!-- $$$SslMode$$$UnencryptedMode$$$SslClientMode$$$SslServerMode -->
<h3 class="fn" id="SslMode-enum" translate="no"><a name="SslMode-enum"></a>enum QSslSocket::<span class="name">SslMode</span><a class="plink" href="#SslMode-enum" title="Direct link to this headline"></a></h3>
<p>Describes the connection modes available for <a href="./qsslsocket.htm" translate="no">QSslSocket</a>.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSslSocket::UnencryptedMode</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The socket is unencrypted. Its behavior is identical to <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QSslSocket::SslClientMode</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The socket is a client-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see <a href="./qsslsocket.htm#isEncrypted" translate="no">QSslSocket::isEncrypted</a>()).</td></tr>
<tr><td class="topAlign"><code translate="no">QSslSocket::SslServerMode</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The socket is a server-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see <a href="./qsslsocket.htm#isEncrypted" translate="no">QSslSocket::isEncrypted</a>()).</td></tr>
</tbody></table></div>
<!-- @@@SslMode -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSslSocket[overload1]$$$QSslSocketQObject* -->
<h3 class="fn" id="QSslSocket" translate="no"><a name="QSslSocket"></a>QSslSocket::<span class="name">QSslSocket</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QSslSocket" title="Direct link to this headline"></a></h3>
<p>Constructs a QSslSocket object. <i translate="no">parent</i> is passed to <a href="./qobject.htm" translate="no">QObject</a>'s constructor. The new socket's <a href="./qsslcipher.htm" translate="no">cipher</a> suite is set to the one returned by the static method defaultCiphers().</p>
<!-- @@@QSslSocket -->
<!-- $$$encrypted[overload1]$$$encrypted -->
<h3 class="fn" id="encrypted" translate="no"><a name="encrypted"></a><code translate="no">[signal] </code><span class="type">void</span> QSslSocket::<span class="name">encrypted</span>()<a class="plink" href="#encrypted" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when <a href="./qsslsocket.htm" translate="no">QSslSocket</a> enters encrypted mode. After this signal has been emitted, <a href="./qsslsocket.htm#isEncrypted" translate="no">QSslSocket::isEncrypted</a>() will return true, and all further transmissions on the socket will be encrypted.</p>
<p><b>See also </b><a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">QSslSocket::connectToHostEncrypted</a>() and <a href="./qsslsocket.htm#isEncrypted" translate="no">QSslSocket::isEncrypted</a>().</p>
<!-- @@@encrypted -->
<!-- $$$encryptedBytesWritten[overload1]$$$encryptedBytesWrittenqint64 -->
<h3 class="fn" id="encryptedBytesWritten" translate="no"><a name="encryptedBytesWritten"></a><code translate="no">[signal] </code><span class="type">void</span> QSslSocket::<span class="name">encryptedBytesWritten</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>written</i>)<a class="plink" href="#encryptedBytesWritten" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when <a href="./qsslsocket.htm" translate="no">QSslSocket</a> writes its encrypted data to the network. The <i translate="no">written</i> parameter contains the number of bytes that were successfully written.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qiodevice.htm#bytesWritten" translate="no">QIODevice::bytesWritten</a>().</p>
<!-- @@@encryptedBytesWritten -->
<!-- $$$ignoreSslErrors[overload1]$$$ignoreSslErrors -->
<h3 class="fn" id="ignoreSslErrors" translate="no"><a name="ignoreSslErrors"></a><code translate="no">[slot] </code><span class="type">void</span> QSslSocket::<span class="name">ignoreSslErrors</span>()<a class="plink" href="#ignoreSslErrors" title="Direct link to this headline"></a></h3>
<p>This slot tells <a href="./qsslsocket.htm" translate="no">QSslSocket</a> to ignore errors during <a href="./qsslsocket.htm" translate="no">QSslSocket</a>'s handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to sslErrors(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the sslErrors() signal has been emitted.</p>
<p>If there are no errors during the SSL handshake phase (i.e., the identity of the peer is established with no problems), <a href="./qsslsocket.htm" translate="no">QSslSocket</a> will not emit the sslErrors() signal, and it is unnecessary to call this function.</p>
<div class="admonition warning">
<p><b>Warning: </b>Be sure to always let the user inspect the errors reported by the sslErrors() signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the connection should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</p>
</div>
<p><b>See also </b><a href="./qsslsocket-obsolete.htm#sslErrors" translate="no">sslErrors</a>().</p>
<!-- @@@ignoreSslErrors -->
<!-- $$$modeChanged[overload1]$$$modeChangedQSslSocket::SslMode -->
<h3 class="fn" id="modeChanged" translate="no"><a name="modeChanged"></a><code translate="no">[signal] </code><span class="type">void</span> QSslSocket::<span class="name">modeChanged</span>(<span class="type"><a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslMode</a></span> <i>mode</i>)<a class="plink" href="#modeChanged" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when <a href="./qsslsocket.htm" translate="no">QSslSocket</a> changes from <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::UnencryptedMode</a> to either <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslClientMode</a> or <a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslServerMode</a>. <i translate="no">mode</i> is the new mode.</p>
<p><b>See also </b><a href="./qsslsocket.htm#mode" translate="no">QSslSocket::mode</a>().</p>
<!-- @@@modeChanged -->
<!-- $$$newSessionTicketReceived[overload1]$$$newSessionTicketReceived -->
<h3 class="fn" id="newSessionTicketReceived" translate="no"><a name="newSessionTicketReceived"></a><code translate="no">[signal] </code><span class="type">void</span> QSslSocket::<span class="name">newSessionTicketReceived</span>()<a class="plink" href="#newSessionTicketReceived" title="Direct link to this headline"></a></h3>
<p>If TLS 1.3 protocol was negotiated during a handshake, <a href="./qsslsocket.htm" translate="no">QSslSocket</a> emits this signal after receiving NewSessionTicket message. Session and session ticket's lifetime hint are updated in the socket's configuration. The session can be used for session resumption (and a shortened handshake) in future TLS connections.</p>
<div class="admonition note">
<p><b>Note: </b>This functionality enabled only with OpenSSL backend and requires OpenSSL v 1.1.1 or above.</p>
</div>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qsslsocket.htm#sslConfiguration" translate="no">QSslSocket::sslConfiguration</a>(), <a href="./qsslconfiguration.htm#sessionTicket" translate="no">QSslConfiguration::sessionTicket</a>(), and <a href="./qsslconfiguration.htm#sessionTicketLifeTimeHint" translate="no">QSslConfiguration::sessionTicketLifeTimeHint</a>().</p>
<!-- @@@newSessionTicketReceived -->
<!-- $$$peerVerifyError[overload1]$$$peerVerifyErrorconstQSslError& -->
<h3 class="fn" id="peerVerifyError" translate="no"><a name="peerVerifyError"></a><code translate="no">[signal] </code><span class="type">void</span> QSslSocket::<span class="name">peerVerifyError</span>(const <span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span> &amp;<i>error</i>)<a class="plink" href="#peerVerifyError" title="Direct link to this headline"></a></h3>
<p><a href="./qsslsocket.htm" translate="no">QSslSocket</a> can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The <i translate="no">error</i> is usually an indication that <a href="./qsslsocket.htm" translate="no">QSslSocket</a> is unable to securely identify the peer.</p>
<p>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, <a href="./qsslsocket.htm" translate="no">QSslSocket</a> will proceed to emitting QSslSocket::sslErrors().</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket-obsolete.htm#sslErrors" translate="no">sslErrors</a>().</p>
<!-- @@@peerVerifyError -->
<!-- $$$preSharedKeyAuthenticationRequired[overload1]$$$preSharedKeyAuthenticationRequiredQSslPreSharedKeyAuthenticator* -->
<h3 class="fn" id="preSharedKeyAuthenticationRequired" translate="no"><a name="preSharedKeyAuthenticationRequired"></a><code translate="no">[signal] </code><span class="type">void</span> QSslSocket::<span class="name">preSharedKeyAuthenticationRequired</span>(<span class="type"><a href="./qsslpresharedkeyauthenticator.htm" translate="no">QSslPreSharedKeyAuthenticator</a></span> *<i>authenticator</i>)<a class="plink" href="#preSharedKeyAuthenticationRequired" title="Direct link to this headline"></a></h3>
<p><a href="./qsslsocket.htm" translate="no">QSslSocket</a> emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</p>
<p>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed <i translate="no">authenticator</i> object according to their needs.</p>
<div class="admonition note">
<p><b>Note: </b>Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The <i translate="no">authenticator</i> object is owned by the socket and must not be deleted by the application.</p>
</div>
<p>This function was introduced in Qt 5.5.</p>
<p><b>See also </b><a href="./qsslpresharedkeyauthenticator.htm" translate="no">QSslPreSharedKeyAuthenticator</a>.</p>
<!-- @@@preSharedKeyAuthenticationRequired -->
<!-- $$$sslErrors$$$sslErrorsconstQList<QSslError>& -->
<h3 class="fn" id="sslErrors-1" translate="no"><a name="sslErrors-1"></a><code translate="no">[signal] </code><span class="type">void</span> QSslSocket::<span class="name">sslErrors</span>(const <span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span>&gt; &amp;<i>errors</i>)<a class="plink" href="#sslErrors-1" title="Direct link to this headline"></a></h3>
<p><a href="./qsslsocket.htm" translate="no">QSslSocket</a> emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that <a href="./qsslsocket.htm" translate="no">QSslSocket</a> is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted.</p>
<p>If you want to continue connecting despite the errors that have occurred, you must call <a href="./qsslsocket.htm#ignoreSslErrors" translate="no">QSslSocket::ignoreSslErrors</a>() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call <a href="./qsslsocket.htm#sslHandshakeErrors" translate="no">sslHandshakeErrors</a>().</p>
<p><i translate="no">errors</i> contains one or more errors that prevent <a href="./qsslsocket.htm" translate="no">QSslSocket</a> from verifying the identity of the peer.</p>
<div class="admonition note">
<p><b>Note: </b>You cannot use <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::QueuedConnection</a> when connecting to this signal, or calling <a href="./qsslsocket.htm#ignoreSslErrors" translate="no">QSslSocket::ignoreSslErrors</a>() will have no effect.</p>
</div>
<p><b>Note:</b> Signal <i>sslErrors</i> is overloaded in this class. To connect to this signal by using the function pointer syntax, Qt provides a convenient helper for obtaining the function pointer as shown in this example:</p><div class="pre"><pre class="cpp prettyprint" translate="no">connect(sslSocket<span class="operator">,</span> <span class="type">QOverload</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span><span class="operator">&gt;</span> <span class="operator">&amp;</span><span class="operator">&gt;</span><span class="operator">::</span>of(<span class="operator">&amp;</span><span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span><span class="operator">::</span>sslErrors)<span class="operator">,</span>
    <span class="operator">[</span><span class="operator">=</span><span class="operator">]</span>(<span class="keyword">const</span> <span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span><span class="operator">&gt;</span> <span class="operator">&amp;</span>errors){ <span class="comment">/* ... */</span> });</pre></div>
<p><b>See also </b><a href="./qsslsocket.htm#peerVerifyError" translate="no">peerVerifyError</a>().</p>
<!-- @@@sslErrors -->
<!-- $$$startClientEncryption[overload1]$$$startClientEncryption -->
<h3 class="fn" id="startClientEncryption" translate="no"><a name="startClientEncryption"></a><code translate="no">[slot] </code><span class="type">void</span> QSslSocket::<span class="name">startClientEncryption</span>()<a class="plink" href="#startClientEncryption" title="Direct link to this headline"></a></h3>
<p>Starts a delayed SSL handshake for a client connection. This function can be called when the socket is in the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">ConnectedState</a> but still in the <a href="./qsslsocket.htm#SslMode-enum" translate="no">UnencryptedMode</a>. If it is not yet connected, or if it is already encrypted, this function has no effect.</p>
<p>Clients that implement STARTTLS functionality often make use of delayed SSL handshakes. Most other clients can avoid calling this function directly by using <a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>() instead, which automatically performs the handshake.</p>
<p><b>See also </b><a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>() and <a href="./qsslsocket.htm#startServerEncryption" translate="no">startServerEncryption</a>().</p>
<!-- @@@startClientEncryption -->
<!-- $$$startServerEncryption[overload1]$$$startServerEncryption -->
<h3 class="fn" id="startServerEncryption" translate="no"><a name="startServerEncryption"></a><code translate="no">[slot] </code><span class="type">void</span> QSslSocket::<span class="name">startServerEncryption</span>()<a class="plink" href="#startServerEncryption" title="Direct link to this headline"></a></h3>
<p>Starts a delayed SSL handshake for a server connection. This function can be called when the socket is in the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">ConnectedState</a> but still in <a href="./qsslsocket.htm#SslMode-enum" translate="no">UnencryptedMode</a>. If it is not connected or it is already encrypted, the function has no effect.</p>
<p>For server sockets, calling this function is the only way to initiate the SSL handshake. Most servers will call this function immediately upon receiving a connection, or as a result of having received a protocol-specific command to enter SSL mode (e.g, the server may respond to receiving the string "STARTTLS\r\n" by calling this function).</p>
<p>The most common way to implement an SSL server is to create a subclass of <a href="./qtcpserver.htm" translate="no">QTcpServer</a> and reimplement <a href="./qtcpserver.htm#incomingConnection" translate="no">QTcpServer::incomingConnection</a>(). The returned socket descriptor is then passed to <a href="./qsslsocket.htm#setSocketDescriptor" translate="no">QSslSocket::setSocketDescriptor</a>().</p>
<p><b>See also </b><a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>() and <a href="./qsslsocket.htm#startClientEncryption" translate="no">startClientEncryption</a>().</p>
<!-- @@@startServerEncryption -->
<!-- $$$~QSslSocket[overload1]$$$~QSslSocket -->
<h3 class="fn" id="dtor.QSslSocket" translate="no"><a name="dtor.QSslSocket"></a><code translate="no">[virtual] </code>QSslSocket::<span class="name">~QSslSocket</span>()<a class="plink" href="#dtor.QSslSocket" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qsslsocket.htm" translate="no">QSslSocket</a>.</p>
<!-- @@@~QSslSocket -->
<!-- $$$abort[overload1]$$$abort -->
<h3 class="fn" id="abort" translate="no"><a name="abort"></a><span class="type">void</span> QSslSocket::<span class="name">abort</span>()<a class="plink" href="#abort" title="Direct link to this headline"></a></h3>
<p>Aborts the current connection and resets the socket. Unlike <a href="./qabstractsocket.htm#disconnectFromHost" translate="no">disconnectFromHost</a>(), this function immediately closes the socket, clearing any pending data in the write buffer.</p>
<p><b>See also </b><a href="./qabstractsocket.htm#disconnectFromHost" translate="no">disconnectFromHost</a>() and <a href="./qsslsocket.htm#close" translate="no">close</a>().</p>
<!-- @@@abort -->
<!-- $$$atEnd[overload1]$$$atEnd -->
<h3 class="fn" id="atEnd" translate="no"><a name="atEnd"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QSslSocket::<span class="name">atEnd</span>() const<a class="plink" href="#atEnd" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#atEnd" translate="no">QAbstractSocket::atEnd</a>() const.</p>
<!-- @@@atEnd -->
<!-- $$$bytesAvailable[overload1]$$$bytesAvailable -->
<h3 class="fn" id="bytesAvailable" translate="no"><a name="bytesAvailable"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QSslSocket::<span class="name">bytesAvailable</span>() const<a class="plink" href="#bytesAvailable" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#bytesAvailable" translate="no">QAbstractSocket::bytesAvailable</a>() const.</p>
<p>Returns the number of decrypted bytes that are immediately available for reading.</p>
<!-- @@@bytesAvailable -->
<!-- $$$bytesToWrite[overload1]$$$bytesToWrite -->
<h3 class="fn" id="bytesToWrite" translate="no"><a name="bytesToWrite"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QSslSocket::<span class="name">bytesToWrite</span>() const<a class="plink" href="#bytesToWrite" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#bytesToWrite" translate="no">QAbstractSocket::bytesToWrite</a>() const.</p>
<p>Returns the number of unencrypted bytes that are waiting to be encrypted and written to the network.</p>
<!-- @@@bytesToWrite -->
<!-- $$$canReadLine[overload1]$$$canReadLine -->
<h3 class="fn" id="canReadLine" translate="no"><a name="canReadLine"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QSslSocket::<span class="name">canReadLine</span>() const<a class="plink" href="#canReadLine" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#canReadLine" translate="no">QAbstractSocket::canReadLine</a>() const.</p>
<p>Returns <code translate="no">true</code> if you can read one while line (terminated by a single ASCII '\n' character) of decrypted characters; otherwise, false is returned.</p>
<!-- @@@canReadLine -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" id="close" translate="no"><a name="close"></a><code translate="no">[override virtual] </code><span class="type">void</span> QSslSocket::<span class="name">close</span>()<a class="plink" href="#close" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#close" translate="no">QAbstractSocket::close</a>().</p>
<!-- @@@close -->
<!-- $$$connectToHostEncrypted[overload1]$$$connectToHostEncryptedconstQString&quint16QIODevice::OpenModeQAbstractSocket::NetworkLayerProtocol -->
<h3 class="fn" id="connectToHostEncrypted" translate="no"><a name="connectToHostEncrypted"></a><span class="type">void</span> QSslSocket::<span class="name">connectToHostEncrypted</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>hostName</i>, <span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, <span class="type"><a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">QIODevice::OpenMode</a></span> <i>mode</i> = ReadWrite, <span class="type"><a href="./qabstractsocket.htm#NetworkLayerProtocol-enum" translate="no">QAbstractSocket::NetworkLayerProtocol</a></span> <i>protocol</i> = AnyIPProtocol)<a class="plink" href="#connectToHostEncrypted" title="Direct link to this headline"></a></h3>
<p>Starts an encrypted connection to the device <i translate="no">hostName</i> on <i translate="no">port</i>, using <i translate="no">mode</i> as the <a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">OpenMode</a>. This is equivalent to calling <a href="./qabstractsocket.htm#connectToHost" translate="no">connectToHost</a>() to establish the connection, followed by a call to <a href="./qsslsocket.htm#startClientEncryption" translate="no">startClientEncryption</a>(). The <i translate="no">protocol</i> parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</p>
<p><a href="./qsslsocket.htm" translate="no">QSslSocket</a> first enters the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">HostLookupState</a>. Then, after entering either the event loop or one of the waitFor...() functions, it enters the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">ConnectingState</a>, emits <a href="./qabstractsocket.htm#connected" translate="no">connected</a>(), and then initiates the SSL client handshake. At each state change, <a href="./qsslsocket.htm" translate="no">QSslSocket</a> emits signal <a href="./qabstractsocket.htm#stateChanged" translate="no">stateChanged</a>().</p>
<p>After initiating the SSL client handshake, if the identity of the peer can't be established, signal sslErrors() is emitted. If you want to ignore the errors and continue connecting, you must call <a href="./qsslsocket.htm#ignoreSslErrors" translate="no">ignoreSslErrors</a>(), either from inside a slot function connected to the sslErrors() signal, or prior to entering encrypted mode. If <a href="./qsslsocket.htm#ignoreSslErrors" translate="no">ignoreSslErrors</a>() is not called, the connection is dropped, signal <a href="./qabstractsocket.htm#disconnected" translate="no">disconnected</a>() is emitted, and <a href="./qsslsocket.htm" translate="no">QSslSocket</a> returns to the <a href="./qabstractsocket.htm#SocketState-enum" translate="no">UnconnectedState</a>.</p>
<p>If the SSL handshake is successful, <a href="./qsslsocket.htm" translate="no">QSslSocket</a> emits <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>().</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span> socket;
connect(<span class="operator">&amp;</span>socket<span class="operator">,</span> SIGNAL(encrypted())<span class="operator">,</span> receiver<span class="operator">,</span> SLOT(socketEncrypted()));

socket<span class="operator">.</span>connectToHostEncrypted(<span class="string">"imap"</span><span class="operator">,</span> <span class="number">993</span>);
socket<span class="operator">-</span><span class="operator">&gt;</span>write(<span class="string">"1 CAPABILITY\r\n"</span>);</pre></div>
<div class="admonition note">
<p><b>Note: </b>The example above shows that text can be written to the socket immediately after requesting the encrypted connection, before the <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() signal has been emitted. In such cases, the text is queued in the object and written to the socket <i>after</i> the connection is established and the <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() signal has been emitted.</p>
</div>
<p>The default for <i translate="no">mode</i> is <a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">ReadWrite</a>.</p>
<p>If you want to create a <a href="./qsslsocket.htm" translate="no">QSslSocket</a> on the server side of a connection, you should instead call <a href="./qsslsocket.htm#startServerEncryption" translate="no">startServerEncryption</a>() upon receiving the incoming connection through <a href="./qtcpserver.htm" translate="no">QTcpServer</a>.</p>
<p><b>See also </b><a href="./qabstractsocket.htm#connectToHost" translate="no">connectToHost</a>(), <a href="./qsslsocket.htm#startClientEncryption" translate="no">startClientEncryption</a>(), <a href="./qsslsocket.htm#waitForConnected" translate="no">waitForConnected</a>(), and <a href="./qsslsocket.htm#waitForEncrypted" translate="no">waitForEncrypted</a>().</p>
<!-- @@@connectToHostEncrypted -->
<!-- $$$connectToHostEncrypted$$$connectToHostEncryptedconstQString&quint16constQString&QIODevice::OpenModeQAbstractSocket::NetworkLayerProtocol -->
<h3 class="fn" id="connectToHostEncrypted-1" translate="no"><a name="connectToHostEncrypted-1"></a><span class="type">void</span> QSslSocket::<span class="name">connectToHostEncrypted</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>hostName</i>, <span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <i>port</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>sslPeerName</i>, <span class="type"><a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">QIODevice::OpenMode</a></span> <i>mode</i> = ReadWrite, <span class="type"><a href="./qabstractsocket.htm#NetworkLayerProtocol-enum" translate="no">QAbstractSocket::NetworkLayerProtocol</a></span> <i>protocol</i> = AnyIPProtocol)<a class="plink" href="#connectToHostEncrypted-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>In addition to the original behaviour of connectToHostEncrypted, this overloaded method enables the usage of a different hostname (<i translate="no">sslPeerName</i>) for the certificate validation instead of the one used for the TCP connection (<i translate="no">hostName</i>).</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>().</p>
<!-- @@@connectToHostEncrypted -->
<!-- $$$encryptedBytesAvailable[overload1]$$$encryptedBytesAvailable -->
<h3 class="fn" id="encryptedBytesAvailable" translate="no"><a name="encryptedBytesAvailable"></a><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QSslSocket::<span class="name">encryptedBytesAvailable</span>() const<a class="plink" href="#encryptedBytesAvailable" title="Direct link to this headline"></a></h3>
<p>Returns the number of encrypted bytes that are awaiting decryption. Normally, this function will return 0 because <a href="./qsslsocket.htm" translate="no">QSslSocket</a> decrypts its incoming data as soon as it can.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@encryptedBytesAvailable -->
<!-- $$$encryptedBytesToWrite[overload1]$$$encryptedBytesToWrite -->
<h3 class="fn" id="encryptedBytesToWrite" translate="no"><a name="encryptedBytesToWrite"></a><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QSslSocket::<span class="name">encryptedBytesToWrite</span>() const<a class="plink" href="#encryptedBytesToWrite" title="Direct link to this headline"></a></h3>
<p>Returns the number of encrypted bytes that are waiting to be written to the network.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@encryptedBytesToWrite -->
<!-- $$$flush[overload1]$$$flush -->
<h3 class="fn" id="flush" translate="no"><a name="flush"></a><span class="type">bool</span> QSslSocket::<span class="name">flush</span>()<a class="plink" href="#flush" title="Direct link to this headline"></a></h3>
<p>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns <code translate="no">true</code>; otherwise false is returned.</p>
<p>Call this function if you need <a href="./qsslsocket.htm" translate="no">QSslSocket</a> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <a href="./qabstractsocket.htm" translate="no">QAbstractSocket</a> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <a href="./qsslsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a>() instead.</p>
<p><b>See also </b><a href="./qiodevice.htm#write" translate="no">write</a>() and <a href="./qsslsocket.htm#waitForBytesWritten" translate="no">waitForBytesWritten</a>().</p>
<!-- @@@flush -->
<!-- $$$ignoreSslErrors$$$ignoreSslErrorsconstQList<QSslError>& -->
<h3 class="fn" id="ignoreSslErrors-1" translate="no"><a name="ignoreSslErrors-1"></a><span class="type">void</span> QSslSocket::<span class="name">ignoreSslErrors</span>(const <span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span>&gt; &amp;<i>errors</i>)<a class="plink" href="#ignoreSslErrors-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This method tells <a href="./qsslsocket.htm" translate="no">QSslSocket</a> to ignore only the errors given in <i translate="no">errors</i>.</p>
<div class="admonition note">
<p><b>Note: </b>Because most SSL errors are associated with a certificate, for most of them you must set the expected certificate this SSL error is related to. If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:</p>
</div>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span><span class="operator">&gt;</span> cert <span class="operator">=</span> <span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span><span class="operator">::</span>fromPath(QLatin1String(<span class="string">"server-certificate.pem"</span>));
<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span> error(<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span><span class="operator">::</span>SelfSignedCertificate<span class="operator">,</span> cert<span class="operator">.</span>at(<span class="number">0</span>));
<span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span><span class="operator">&gt;</span> expectedSslErrors;
expectedSslErrors<span class="operator">.</span>append(error);

<span class="type"><a href="./qsslsocket.htm#QSslSocket" translate="no">QSslSocket</a></span> socket;
socket<span class="operator">.</span>ignoreSslErrors(expectedSslErrors);
socket<span class="operator">.</span>connectToHostEncrypted(<span class="string">"server.tld"</span><span class="operator">,</span> <span class="number">443</span>);</pre></div>
<p>Multiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="./qsslsocket-obsolete.htm#sslErrors" translate="no">sslErrors</a>() and <a href="./qsslsocket.htm#sslHandshakeErrors" translate="no">sslHandshakeErrors</a>().</p>
<!-- @@@ignoreSslErrors -->
<!-- $$$isEncrypted[overload1]$$$isEncrypted -->
<h3 class="fn" id="isEncrypted" translate="no"><a name="isEncrypted"></a><span class="type">bool</span> QSslSocket::<span class="name">isEncrypted</span>() const<a class="plink" href="#isEncrypted" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the socket is encrypted; otherwise, false is returned.</p>
<p>An encrypted socket encrypts all data that is written by calling <a href="./qiodevice.htm#write" translate="no">write</a>() or <a href="./qiodevice.htm#putChar" translate="no">putChar</a>() before the data is written to the network, and decrypts all incoming data as the data is received from the network, before you call <a href="./qiodevice.htm#read" translate="no">read</a>(), <a href="./qiodevice.htm#readLine" translate="no">readLine</a>() or <a href="./qiodevice.htm#getChar" translate="no">getChar</a>().</p>
<p><a href="./qsslsocket.htm" translate="no">QSslSocket</a> emits <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() when it enters encrypted mode.</p>
<p>You can call <a href="./qsslsocket.htm#sessionCipher" translate="no">sessionCipher</a>() to find which cryptographic cipher is used to encrypt and decrypt your data.</p>
<p><b>See also </b><a href="./qsslsocket.htm#mode" translate="no">mode</a>().</p>
<!-- @@@isEncrypted -->
<!-- $$$localCertificate[overload1]$$$localCertificate -->
<h3 class="fn" id="localCertificate" translate="no"><a name="localCertificate"></a><span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span> QSslSocket::<span class="name">localCertificate</span>() const<a class="plink" href="#localCertificate" title="Direct link to this headline"></a></h3>
<p>Returns the socket's local <a href="./qsslcertificate.htm" translate="no">certificate</a>, or an empty certificate if no local certificate has been assigned.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setLocalCertificate" translate="no">setLocalCertificate</a>() and <a href="./qsslsocket.htm#privateKey" translate="no">privateKey</a>().</p>
<!-- @@@localCertificate -->
<!-- $$$localCertificateChain[overload1]$$$localCertificateChain -->
<h3 class="fn" id="localCertificateChain" translate="no"><a name="localCertificateChain"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span>&gt; QSslSocket::<span class="name">localCertificateChain</span>() const<a class="plink" href="#localCertificateChain" title="Direct link to this headline"></a></h3>
<p>Returns the socket's local <a href="./qsslcertificate.htm" translate="no">certificate</a> chain, or an empty list if no local certificates have been assigned.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setLocalCertificateChain" translate="no">setLocalCertificateChain</a>().</p>
<!-- @@@localCertificateChain -->
<!-- $$$mode[overload1]$$$mode -->
<h3 class="fn" id="mode" translate="no"><a name="mode"></a><span class="type"><a href="./qsslsocket.htm#SslMode-enum" translate="no">QSslSocket::SslMode</a></span> QSslSocket::<span class="name">mode</span>() const<a class="plink" href="#mode" title="Direct link to this headline"></a></h3>
<p>Returns the current mode for the socket; either <a href="./qsslsocket.htm#SslMode-enum" translate="no">UnencryptedMode</a>, where <a href="./qsslsocket.htm" translate="no">QSslSocket</a> behaves identially to <a href="./qtcpsocket.htm" translate="no">QTcpSocket</a>, or one of <a href="./qsslsocket.htm#SslMode-enum" translate="no">SslClientMode</a> or <a href="./qsslsocket.htm#SslMode-enum" translate="no">SslServerMode</a>, where the client is either negotiating or in encrypted mode.</p>
<p>When the mode changes, <a href="./qsslsocket.htm" translate="no">QSslSocket</a> emits <a href="./qsslsocket.htm#modeChanged" translate="no">modeChanged</a>()</p>
<p><b>See also </b><a href="./qsslsocket.htm#SslMode-enum" translate="no">SslMode</a>.</p>
<!-- @@@mode -->
<!-- $$$ocspResponses[overload1]$$$ocspResponses -->
<h3 class="fn" id="ocspResponses" translate="no"><a name="ocspResponses"></a><span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type"><a href="./qocspresponse.htm" translate="no">QOcspResponse</a></span>&gt; QSslSocket::<span class="name">ocspResponses</span>() const<a class="plink" href="#ocspResponses" title="Direct link to this headline"></a></h3>
<p>This function returns Online Certificate Status Protocol responses that a server may send during a TLS handshake using OCSP stapling. The vector is empty if no definitive response or no response at all was received.</p>
<p>This function was introduced in Qt 5.13.</p>
<p><b>See also </b><a href="./qsslconfiguration.htm#setOcspStaplingEnabled" translate="no">QSslConfiguration::setOcspStaplingEnabled</a>().</p>
<!-- @@@ocspResponses -->
<!-- $$$peerCertificate[overload1]$$$peerCertificate -->
<h3 class="fn" id="peerCertificate" translate="no"><a name="peerCertificate"></a><span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span> QSslSocket::<span class="name">peerCertificate</span>() const<a class="plink" href="#peerCertificate" title="Direct link to this headline"></a></h3>
<p>Returns the peer's digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</p>
<p>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</p>
<p>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the sslErrors() signal or the <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() signal.</p>
<p>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</p>
<p>If you want to check the peer's complete chain of certificates, use <a href="./qsslsocket.htm#peerCertificateChain" translate="no">peerCertificateChain</a>() to get them all at once.</p>
<p><b>See also </b><a href="./qsslsocket.htm#peerCertificateChain" translate="no">peerCertificateChain</a>().</p>
<!-- @@@peerCertificate -->
<!-- $$$peerCertificateChain[overload1]$$$peerCertificateChain -->
<h3 class="fn" id="peerCertificateChain" translate="no"><a name="peerCertificateChain"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span>&gt; QSslSocket::<span class="name">peerCertificateChain</span>() const<a class="plink" href="#peerCertificateChain" title="Direct link to this headline"></a></h3>
<p>Returns the peer's chain of digital certificates, or an empty list of certificates.</p>
<p>Peer certificates are checked automatically during the handshake phase. This function is normally used to fetch certificates for display, or for performing connection diagnostics. Certificates contain information about the peer and the certificate issuers, including host name, issuer names, and issuer public keys.</p>
<p>The peer certificates are set in <a href="./qsslsocket.htm" translate="no">QSslSocket</a> during the handshake phase, so it is safe to call this function from a slot connected to the sslErrors() signal or the <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() signal.</p>
<p>If an empty list is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</p>
<p>If you want to get only the peer's immediate certificate, use <a href="./qsslsocket.htm#peerCertificate" translate="no">peerCertificate</a>().</p>
<p><b>See also </b><a href="./qsslsocket.htm#peerCertificate" translate="no">peerCertificate</a>().</p>
<!-- @@@peerCertificateChain -->
<!-- $$$peerVerifyDepth[overload1]$$$peerVerifyDepth -->
<h3 class="fn" id="peerVerifyDepth" translate="no"><a name="peerVerifyDepth"></a><span class="type">int</span> QSslSocket::<span class="name">peerVerifyDepth</span>() const<a class="plink" href="#peerVerifyDepth" title="Direct link to this headline"></a></h3>
<p>Returns the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</p>
<p>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setPeerVerifyDepth" translate="no">setPeerVerifyDepth</a>() and <a href="./qsslsocket.htm#peerVerifyMode" translate="no">peerVerifyMode</a>().</p>
<!-- @@@peerVerifyDepth -->
<!-- $$$peerVerifyMode[overload1]$$$peerVerifyMode -->
<h3 class="fn" id="peerVerifyMode" translate="no"><a name="peerVerifyMode"></a><span class="type"><a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">QSslSocket::PeerVerifyMode</a></span> QSslSocket::<span class="name">peerVerifyMode</span>() const<a class="plink" href="#peerVerifyMode" title="Direct link to this headline"></a></h3>
<p>Returns the socket's verify mode. This mode decides whether <a href="./qsslsocket.htm" translate="no">QSslSocket</a> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</p>
<p>The default mode is <a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">AutoVerifyPeer</a>, which tells <a href="./qsslsocket.htm" translate="no">QSslSocket</a> to use <a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">VerifyPeer</a> for clients and <a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">QueryPeer</a> for servers.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setPeerVerifyMode" translate="no">setPeerVerifyMode</a>(), <a href="./qsslsocket.htm#peerVerifyDepth" translate="no">peerVerifyDepth</a>(), and <a href="./qsslsocket.htm#mode" translate="no">mode</a>().</p>
<!-- @@@peerVerifyMode -->
<!-- $$$peerVerifyName[overload1]$$$peerVerifyName -->
<h3 class="fn" id="peerVerifyName" translate="no"><a name="peerVerifyName"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QSslSocket::<span class="name">peerVerifyName</span>() const<a class="plink" href="#peerVerifyName" title="Direct link to this headline"></a></h3>
<p>Returns the different hostname for the certificate validation, as set by <a href="./qsslsocket.htm#setPeerVerifyName" translate="no">setPeerVerifyName</a> or by <a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setPeerVerifyName" translate="no">setPeerVerifyName</a>() and <a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>().</p>
<!-- @@@peerVerifyName -->
<!-- $$$privateKey[overload1]$$$privateKey -->
<h3 class="fn" id="privateKey" translate="no"><a name="privateKey"></a><span class="type"><a href="./qsslkey.htm" translate="no">QSslKey</a></span> QSslSocket::<span class="name">privateKey</span>() const<a class="plink" href="#privateKey" title="Direct link to this headline"></a></h3>
<p>Returns this socket's private key.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setPrivateKey" translate="no">setPrivateKey</a>() and <a href="./qsslsocket.htm#localCertificate" translate="no">localCertificate</a>().</p>
<!-- @@@privateKey -->
<!-- $$$protocol[overload1]$$$protocol -->
<h3 class="fn" id="protocol" translate="no"><a name="protocol"></a><span class="type"><a href="./qssl.htm#SslProtocol-enum" translate="no">QSsl::SslProtocol</a></span> QSslSocket::<span class="name">protocol</span>() const<a class="plink" href="#protocol" title="Direct link to this headline"></a></h3>
<p>Returns the socket's SSL protocol. By default, <a href="./qssl.htm#SslProtocol-enum" translate="no">QSsl::SecureProtocols</a> is used.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setProtocol" translate="no">setProtocol</a>().</p>
<!-- @@@protocol -->
<!-- $$$readData[overload1]$$$readDatachar*qint64 -->
<h3 class="fn" id="readData" translate="no"><a name="readData"></a><code translate="no">[override virtual protected] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QSslSocket::<span class="name">readData</span>(<span class="type">char</span> *<i>data</i>, <span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>maxlen</i>)<a class="plink" href="#readData" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#readData" translate="no">QAbstractSocket::readData</a>(char *data, qint64 maxSize).</p>
<!-- @@@readData -->
<!-- $$$resume[overload1]$$$resume -->
<h3 class="fn" id="resume" translate="no"><a name="resume"></a><code translate="no">[override virtual] </code><span class="type">void</span> QSslSocket::<span class="name">resume</span>()<a class="plink" href="#resume" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#resume" translate="no">QAbstractSocket::resume</a>().</p>
<p>Continues data transfer on the socket after it has been paused. If "<a href="./qabstractsocket.htm#setPauseMode" translate="no">setPauseMode</a>(<a href="./qabstractsocket.htm#PauseMode-enum" translate="no">QAbstractSocket::PauseOnSslErrors</a>);" has been called on this socket and a sslErrors() signal is received, calling this method is necessary for the socket to continue.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qabstractsocket.htm#pauseMode" translate="no">QAbstractSocket::pauseMode</a>() and <a href="./qabstractsocket.htm#setPauseMode" translate="no">QAbstractSocket::setPauseMode</a>().</p>
<!-- @@@resume -->
<!-- $$$sessionCipher[overload1]$$$sessionCipher -->
<h3 class="fn" id="sessionCipher" translate="no"><a name="sessionCipher"></a><span class="type"><a href="./qsslcipher.htm" translate="no">QSslCipher</a></span> QSslSocket::<span class="name">sessionCipher</span>() const<a class="plink" href="#sessionCipher" title="Direct link to this headline"></a></h3>
<p>Returns the socket's cryptographic <a href="./qsslcipher.htm" translate="no">cipher</a>, or a null cipher if the connection isn't encrypted. The socket's cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</p>
<p><a href="./qsslsocket.htm" translate="no">QSslSocket</a> also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</p>
<p><b>See also </b><a href="./qsslconfiguration.htm#ciphers" translate="no">QSslConfiguration::ciphers</a>(), <a href="./qsslconfiguration.htm#setCiphers" translate="no">QSslConfiguration::setCiphers</a>(), <a href="./qsslconfiguration.htm#setCiphers" translate="no">QSslConfiguration::setCiphers</a>(), <a href="./qsslconfiguration.htm#ciphers" translate="no">QSslConfiguration::ciphers</a>(), and <a href="./qsslconfiguration.htm#supportedCiphers" translate="no">QSslConfiguration::supportedCiphers</a>().</p>
<!-- @@@sessionCipher -->
<!-- $$$sessionProtocol[overload1]$$$sessionProtocol -->
<h3 class="fn" id="sessionProtocol" translate="no"><a name="sessionProtocol"></a><span class="type"><a href="./qssl.htm#SslProtocol-enum" translate="no">QSsl::SslProtocol</a></span> QSslSocket::<span class="name">sessionProtocol</span>() const<a class="plink" href="#sessionProtocol" title="Direct link to this headline"></a></h3>
<p>Returns the socket's SSL/TLS protocol or UnknownProtocol if the connection isn't encrypted. The socket's protocol for the session is set during the handshake phase.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#protocol" translate="no">protocol</a>() and <a href="./qsslsocket.htm#setProtocol" translate="no">setProtocol</a>().</p>
<!-- @@@sessionProtocol -->
<!-- $$$setLocalCertificate[overload1]$$$setLocalCertificateconstQSslCertificate& -->
<h3 class="fn" id="setLocalCertificate" translate="no"><a name="setLocalCertificate"></a><span class="type">void</span> QSslSocket::<span class="name">setLocalCertificate</span>(const <span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span> &amp;<i>certificate</i>)<a class="plink" href="#setLocalCertificate" title="Direct link to this headline"></a></h3>
<p>Sets the socket's local certificate to <i translate="no">certificate</i>. The local certificate is necessary if you need to confirm your identity to the peer. It is used together with the private key; if you set the local certificate, you must also set the private key.</p>
<p>The local certificate and private key are always necessary for server sockets, but are also rarely used by client sockets if the server requires the client to authenticate.</p>
<div class="admonition note">
<p><b>Note: </b>Secure Transport SSL backend on macOS may update the default keychain (the default is probably your login keychain) by importing your local certificates and keys. This can also result in system dialogs showing up and asking for permission when your application is using these private keys. If such behavior is undesired, set the QT_SSL_USE_TEMPORARY_KEYCHAIN environment variable to a non-zero value; this will prompt <a href="./qsslsocket.htm" translate="no">QSslSocket</a> to use its own temporary keychain.</p>
</div>
<p><b>See also </b><a href="./qsslsocket.htm#localCertificate" translate="no">localCertificate</a>() and <a href="./qsslsocket.htm#setPrivateKey" translate="no">setPrivateKey</a>().</p>
<!-- @@@setLocalCertificate -->
<!-- $$$setLocalCertificate$$$setLocalCertificateconstQString&QSsl::EncodingFormat -->
<h3 class="fn" id="setLocalCertificate-1" translate="no"><a name="setLocalCertificate-1"></a><span class="type">void</span> QSslSocket::<span class="name">setLocalCertificate</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>path</i>, <span class="type"><a href="./qssl.htm#EncodingFormat-enum" translate="no">QSsl::EncodingFormat</a></span> <i>format</i> = QSsl::Pem)<a class="plink" href="#setLocalCertificate-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Sets the socket's local <a href="./qsslcertificate.htm" translate="no">certificate</a> to the first one found in file <i translate="no">path</i>, which is parsed according to the specified <i translate="no">format</i>.</p>
<!-- @@@setLocalCertificate -->
<!-- $$$setLocalCertificateChain[overload1]$$$setLocalCertificateChainconstQList<QSslCertificate>& -->
<h3 class="fn" id="setLocalCertificateChain" translate="no"><a name="setLocalCertificateChain"></a><span class="type">void</span> QSslSocket::<span class="name">setLocalCertificateChain</span>(const <span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qsslcertificate.htm" translate="no">QSslCertificate</a></span>&gt; &amp;<i>localChain</i>)<a class="plink" href="#setLocalCertificateChain" title="Direct link to this headline"></a></h3>
<p>Sets the certificate chain to be presented to the peer during the SSL handshake to be <i translate="no">localChain</i>.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qsslsocket.htm#localCertificateChain" translate="no">localCertificateChain</a>() and <a href="./qsslconfiguration.htm#setLocalCertificateChain" translate="no">QSslConfiguration::setLocalCertificateChain</a>().</p>
<!-- @@@setLocalCertificateChain -->
<!-- $$$setPeerVerifyDepth[overload1]$$$setPeerVerifyDepthint -->
<h3 class="fn" id="setPeerVerifyDepth" translate="no"><a name="setPeerVerifyDepth"></a><span class="type">void</span> QSslSocket::<span class="name">setPeerVerifyDepth</span>(<span class="type">int</span> <i>depth</i>)<a class="plink" href="#setPeerVerifyDepth" title="Direct link to this headline"></a></h3>
<p>Sets the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, to <i translate="no">depth</i>. Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</p>
<p>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#peerVerifyDepth" translate="no">peerVerifyDepth</a>() and <a href="./qsslsocket.htm#setPeerVerifyMode" translate="no">setPeerVerifyMode</a>().</p>
<!-- @@@setPeerVerifyDepth -->
<!-- $$$setPeerVerifyMode[overload1]$$$setPeerVerifyModeQSslSocket::PeerVerifyMode -->
<h3 class="fn" id="setPeerVerifyMode" translate="no"><a name="setPeerVerifyMode"></a><span class="type">void</span> QSslSocket::<span class="name">setPeerVerifyMode</span>(<span class="type"><a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">QSslSocket::PeerVerifyMode</a></span> <i>mode</i>)<a class="plink" href="#setPeerVerifyMode" title="Direct link to this headline"></a></h3>
<p>Sets the socket's verify mode to <i translate="no">mode</i>. This mode decides whether <a href="./qsslsocket.htm" translate="no">QSslSocket</a> should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</p>
<p>The default mode is <a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">AutoVerifyPeer</a>, which tells <a href="./qsslsocket.htm" translate="no">QSslSocket</a> to use <a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">VerifyPeer</a> for clients and <a href="./qsslsocket.htm#PeerVerifyMode-enum" translate="no">QueryPeer</a> for servers.</p>
<p>Setting this mode after encryption has started has no effect on the current connection.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#peerVerifyMode" translate="no">peerVerifyMode</a>(), <a href="./qsslsocket.htm#setPeerVerifyDepth" translate="no">setPeerVerifyDepth</a>(), and <a href="./qsslsocket.htm#mode" translate="no">mode</a>().</p>
<!-- @@@setPeerVerifyMode -->
<!-- $$$setPeerVerifyName[overload1]$$$setPeerVerifyNameconstQString& -->
<h3 class="fn" id="setPeerVerifyName" translate="no"><a name="setPeerVerifyName"></a><span class="type">void</span> QSslSocket::<span class="name">setPeerVerifyName</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>hostName</i>)<a class="plink" href="#setPeerVerifyName" title="Direct link to this headline"></a></h3>
<p>Sets a different host name, given by <i translate="no">hostName</i>, for the certificate validation instead of the one used for the TCP connection.</p>
<p>This function was introduced in Qt 4.8.</p>
<p><b>See also </b><a href="./qsslsocket.htm#peerVerifyName" translate="no">peerVerifyName</a>() and <a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>().</p>
<!-- @@@setPeerVerifyName -->
<!-- $$$setPrivateKey[overload1]$$$setPrivateKeyconstQSslKey& -->
<h3 class="fn" id="setPrivateKey" translate="no"><a name="setPrivateKey"></a><span class="type">void</span> QSslSocket::<span class="name">setPrivateKey</span>(const <span class="type"><a href="./qsslkey.htm" translate="no">QSslKey</a></span> &amp;<i>key</i>)<a class="plink" href="#setPrivateKey" title="Direct link to this headline"></a></h3>
<p>Sets the socket's private <a href="./qsslkey.htm" translate="no">key</a> to <i translate="no">key</i>. The private key and the local <a href="./qsslcertificate.htm" translate="no">certificate</a> are used by clients and servers that must prove their identity to SSL peers.</p>
<p>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</p>
<p><b>See also </b><a href="./qsslsocket.htm#privateKey" translate="no">privateKey</a>() and <a href="./qsslsocket.htm#setLocalCertificate" translate="no">setLocalCertificate</a>().</p>
<!-- @@@setPrivateKey -->
<!-- $$$setPrivateKey$$$setPrivateKeyconstQString&QSsl::KeyAlgorithmQSsl::EncodingFormatconstQByteArray& -->
<h3 class="fn" id="setPrivateKey-1" translate="no"><a name="setPrivateKey-1"></a><span class="type">void</span> QSslSocket::<span class="name">setPrivateKey</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>fileName</i>, <span class="type"><a href="./qssl.htm#KeyAlgorithm-enum" translate="no">QSsl::KeyAlgorithm</a></span> <i>algorithm</i> = QSsl::Rsa, <span class="type"><a href="./qssl.htm#EncodingFormat-enum" translate="no">QSsl::EncodingFormat</a></span> <i>format</i> = QSsl::Pem, const <span class="type"><a href="./qbytearray.htm" translate="no">QByteArray</a></span> &amp;<i>passPhrase</i> = QByteArray())<a class="plink" href="#setPrivateKey-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Reads the string in file <i translate="no">fileName</i> and decodes it using a specified <i translate="no">algorithm</i> and encoding <i translate="no">format</i> to construct an <a href="./qsslkey.htm" translate="no">SSL key</a>. If the encoded key is encrypted, <i translate="no">passPhrase</i> is used to decrypt it.</p>
<p>The socket's private key is set to the constructed key. The private key and the local <a href="./qsslcertificate.htm" translate="no">certificate</a> are used by clients and servers that must prove their identity to SSL peers.</p>
<p>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</p>
<p><b>See also </b><a href="./qsslsocket.htm#privateKey" translate="no">privateKey</a>() and <a href="./qsslsocket.htm#setLocalCertificate" translate="no">setLocalCertificate</a>().</p>
<!-- @@@setPrivateKey -->
<!-- $$$setProtocol[overload1]$$$setProtocolQSsl::SslProtocol -->
<h3 class="fn" id="setProtocol" translate="no"><a name="setProtocol"></a><span class="type">void</span> QSslSocket::<span class="name">setProtocol</span>(<span class="type"><a href="./qssl.htm#SslProtocol-enum" translate="no">QSsl::SslProtocol</a></span> <i>protocol</i>)<a class="plink" href="#setProtocol" title="Direct link to this headline"></a></h3>
<p>Sets the socket's SSL protocol to <i translate="no">protocol</i>. This will affect the next initiated handshake; calling this function on an already-encrypted socket will not affect the socket's protocol.</p>
<p><b>See also </b><a href="./qsslsocket.htm#protocol" translate="no">protocol</a>().</p>
<!-- @@@setProtocol -->
<!-- $$$setReadBufferSize[overload1]$$$setReadBufferSizeqint64 -->
<h3 class="fn" id="setReadBufferSize" translate="no"><a name="setReadBufferSize"></a><code translate="no">[override virtual] </code><span class="type">void</span> QSslSocket::<span class="name">setReadBufferSize</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>size</i>)<a class="plink" href="#setReadBufferSize" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#setReadBufferSize" translate="no">QAbstractSocket::setReadBufferSize</a>(qint64 size).</p>
<p>Sets the size of <a href="./qsslsocket.htm" translate="no">QSslSocket</a>'s internal read buffer to be <i translate="no">size</i> bytes.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@setReadBufferSize -->
<!-- $$$setSocketDescriptor[overload1]$$$setSocketDescriptorqintptrQAbstractSocket::SocketStateQIODevice::OpenMode -->
<h3 class="fn" id="setSocketDescriptor" translate="no"><a name="setSocketDescriptor"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QSslSocket::<span class="name">setSocketDescriptor</span>(<span class="type"><a href="./qtglobal.htm#qintptr-typedef" translate="no">qintptr</a></span> <i>socketDescriptor</i>, <span class="type"><a href="./qabstractsocket.htm#SocketState-enum" translate="no">QAbstractSocket::SocketState</a></span> <i>state</i> = ConnectedState, <span class="type"><a href="./qiodevice.htm#OpenModeFlag-enum" translate="no">QIODevice::OpenMode</a></span> <i>openMode</i> = ReadWrite)<a class="plink" href="#setSocketDescriptor" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#setSocketDescriptor" translate="no">QAbstractSocket::setSocketDescriptor</a>(qintptr socketDescriptor, QAbstractSocket::SocketState socketState, QIODevice::OpenMode openMode).</p>
<p>Initializes <a href="./qsslsocket.htm" translate="no">QSslSocket</a> with the native socket descriptor <i translate="no">socketDescriptor</i>. Returns <code translate="no">true</code> if <i translate="no">socketDescriptor</i> is accepted as a valid socket descriptor; otherwise returns <code translate="no">false</code>. The socket is opened in the mode specified by <i translate="no">openMode</i>, and enters the socket state specified by <i translate="no">state</i>.</p>
<div class="admonition note">
<p><b>Note: </b>It is not possible to initialize two sockets with the same native socket descriptor.</p>
</div>
<p><b>See also </b><a href="./qabstractsocket.htm#socketDescriptor" translate="no">socketDescriptor</a>().</p>
<!-- @@@setSocketDescriptor -->
<!-- $$$setSocketOption[overload1]$$$setSocketOptionQAbstractSocket::SocketOptionconstQVariant& -->
<h3 class="fn" id="setSocketOption" translate="no"><a name="setSocketOption"></a><code translate="no">[override virtual] </code><span class="type">void</span> QSslSocket::<span class="name">setSocketOption</span>(<span class="type"><a href="./qabstractsocket.htm#SocketOption-enum" translate="no">QAbstractSocket::SocketOption</a></span> <i>option</i>, const <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> &amp;<i>value</i>)<a class="plink" href="#setSocketOption" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#setSocketOption" translate="no">QAbstractSocket::setSocketOption</a>(QAbstractSocket::SocketOption option, const QVariant &amp;value).</p>
<p>Sets the given <i translate="no">option</i> to the value described by <i translate="no">value</i>.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="./qsslsocket.htm#socketOption" translate="no">socketOption</a>().</p>
<!-- @@@setSocketOption -->
<!-- $$$setSslConfiguration[overload1]$$$setSslConfigurationconstQSslConfiguration& -->
<h3 class="fn" id="setSslConfiguration" translate="no"><a name="setSslConfiguration"></a><span class="type">void</span> QSslSocket::<span class="name">setSslConfiguration</span>(const <span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span> &amp;<i>configuration</i>)<a class="plink" href="#setSslConfiguration" title="Direct link to this headline"></a></h3>
<p>Sets the socket's SSL configuration to be the contents of <i translate="no">configuration</i>. This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in <i translate="no">configuration</i>.</p>
<p>It is not possible to set the SSL-state related fields.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#sslConfiguration" translate="no">sslConfiguration</a>(), <a href="./qsslsocket.htm#setLocalCertificate" translate="no">setLocalCertificate</a>(), <a href="./qsslsocket.htm#setPrivateKey" translate="no">setPrivateKey</a>(), <a href="./qsslconfiguration.htm#setCaCertificates" translate="no">QSslConfiguration::setCaCertificates</a>(), and <a href="./qsslconfiguration.htm#setCiphers" translate="no">QSslConfiguration::setCiphers</a>().</p>
<!-- @@@setSslConfiguration -->
<!-- $$$socketOption[overload1]$$$socketOptionQAbstractSocket::SocketOption -->
<h3 class="fn" id="socketOption" translate="no"><a name="socketOption"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> QSslSocket::<span class="name">socketOption</span>(<span class="type"><a href="./qabstractsocket.htm#SocketOption-enum" translate="no">QAbstractSocket::SocketOption</a></span> <i>option</i>)<a class="plink" href="#socketOption" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#socketOption" translate="no">QAbstractSocket::socketOption</a>(QAbstractSocket::SocketOption option).</p>
<p>Returns the value of the <i translate="no">option</i> option.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setSocketOption" translate="no">setSocketOption</a>().</p>
<!-- @@@socketOption -->
<!-- $$$sslConfiguration[overload1]$$$sslConfiguration -->
<h3 class="fn" id="sslConfiguration" translate="no"><a name="sslConfiguration"></a><span class="type"><a href="./qsslconfiguration.htm" translate="no">QSslConfiguration</a></span> QSslSocket::<span class="name">sslConfiguration</span>() const<a class="plink" href="#sslConfiguration" title="Direct link to this headline"></a></h3>
<p>Returns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate.</p>
<p>The SSL configuration also contains fields that can change with time without notice.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#setSslConfiguration" translate="no">setSslConfiguration</a>(), <a href="./qsslsocket.htm#localCertificate" translate="no">localCertificate</a>(), <a href="./qsslsocket.htm#peerCertificate" translate="no">peerCertificate</a>(), <a href="./qsslsocket.htm#peerCertificateChain" translate="no">peerCertificateChain</a>(), <a href="./qsslsocket.htm#sessionCipher" translate="no">sessionCipher</a>(), <a href="./qsslsocket.htm#privateKey" translate="no">privateKey</a>(), <a href="./qsslconfiguration.htm#ciphers" translate="no">QSslConfiguration::ciphers</a>(), and <a href="./qsslconfiguration.htm#caCertificates" translate="no">QSslConfiguration::caCertificates</a>().</p>
<!-- @@@sslConfiguration -->
<!-- $$$sslHandshakeErrors[overload1]$$$sslHandshakeErrors -->
<h3 class="fn" id="sslHandshakeErrors" translate="no"><a name="sslHandshakeErrors"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qsslerror.htm" translate="no">QSslError</a></span>&gt; QSslSocket::<span class="name">sslHandshakeErrors</span>() const<a class="plink" href="#sslHandshakeErrors" title="Direct link to this headline"></a></h3>
<p>Returns a list of the last SSL errors that occurred. This is the same list as <a href="./qsslsocket.htm" translate="no">QSslSocket</a> passes via the sslErrors() signal. If the connection has been encrypted with no errors, this function will return an empty list.</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qsslsocket.htm#connectToHostEncrypted" translate="no">connectToHostEncrypted</a>().</p>
<!-- @@@sslHandshakeErrors -->
<!-- $$$sslLibraryBuildVersionNumber[overload1]$$$sslLibraryBuildVersionNumber -->
<h3 class="fn" id="sslLibraryBuildVersionNumber" translate="no"><a name="sslLibraryBuildVersionNumber"></a><code translate="no">[static] </code><span class="type">long</span> QSslSocket::<span class="name">sslLibraryBuildVersionNumber</span>()<a class="plink" href="#sslLibraryBuildVersionNumber" title="Direct link to this headline"></a></h3>
<p>Returns the version number of the SSL library in use at compile time. If no SSL support is available then this will return an undefined value.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#sslLibraryVersionNumber" translate="no">sslLibraryVersionNumber</a>().</p>
<!-- @@@sslLibraryBuildVersionNumber -->
<!-- $$$sslLibraryBuildVersionString[overload1]$$$sslLibraryBuildVersionString -->
<h3 class="fn" id="sslLibraryBuildVersionString" translate="no"><a name="sslLibraryBuildVersionString"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QSslSocket::<span class="name">sslLibraryBuildVersionString</span>()<a class="plink" href="#sslLibraryBuildVersionString" title="Direct link to this headline"></a></h3>
<p>Returns the version string of the SSL library in use at compile time. If no SSL support is available then this will return an empty value.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qsslsocket.htm#sslLibraryVersionString" translate="no">sslLibraryVersionString</a>().</p>
<!-- @@@sslLibraryBuildVersionString -->
<!-- $$$sslLibraryVersionNumber[overload1]$$$sslLibraryVersionNumber -->
<h3 class="fn" id="sslLibraryVersionNumber" translate="no"><a name="sslLibraryVersionNumber"></a><code translate="no">[static] </code><span class="type">long</span> QSslSocket::<span class="name">sslLibraryVersionNumber</span>()<a class="plink" href="#sslLibraryVersionNumber" title="Direct link to this headline"></a></h3>
<p>Returns the version number of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return an undefined value.</p>
<p>This function was introduced in Qt 5.0.</p>
<!-- @@@sslLibraryVersionNumber -->
<!-- $$$sslLibraryVersionString[overload1]$$$sslLibraryVersionString -->
<h3 class="fn" id="sslLibraryVersionString" translate="no"><a name="sslLibraryVersionString"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QSslSocket::<span class="name">sslLibraryVersionString</span>()<a class="plink" href="#sslLibraryVersionString" title="Direct link to this headline"></a></h3>
<p>Returns the version string of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return an empty value.</p>
<p>This function was introduced in Qt 5.0.</p>
<!-- @@@sslLibraryVersionString -->
<!-- $$$supportsSsl[overload1]$$$supportsSsl -->
<h3 class="fn" id="supportsSsl" translate="no"><a name="supportsSsl"></a><code translate="no">[static] </code><span class="type">bool</span> QSslSocket::<span class="name">supportsSsl</span>()<a class="plink" href="#supportsSsl" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this platform supports SSL; otherwise, returns false. If the platform doesn't support SSL, the socket will fail in the connection phase.</p>
<!-- @@@supportsSsl -->
<!-- $$$waitForBytesWritten[overload1]$$$waitForBytesWrittenint -->
<h3 class="fn" id="waitForBytesWritten" translate="no"><a name="waitForBytesWritten"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QSslSocket::<span class="name">waitForBytesWritten</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForBytesWritten" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#waitForBytesWritten" translate="no">QAbstractSocket::waitForBytesWritten</a>(int msecs).</p>
<!-- @@@waitForBytesWritten -->
<!-- $$$waitForConnected[overload1]$$$waitForConnectedint -->
<h3 class="fn" id="waitForConnected" translate="no"><a name="waitForConnected"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QSslSocket::<span class="name">waitForConnected</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForConnected" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#waitForConnected" translate="no">QAbstractSocket::waitForConnected</a>(int msecs).</p>
<p>Waits until the socket is connected, or <i translate="no">msecs</i> milliseconds, whichever happens first. If the connection has been established, this function returns <code translate="no">true</code>; otherwise it returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qabstractsocket.htm#waitForConnected" translate="no">QAbstractSocket::waitForConnected</a>().</p>
<!-- @@@waitForConnected -->
<!-- $$$waitForDisconnected[overload1]$$$waitForDisconnectedint -->
<h3 class="fn" id="waitForDisconnected" translate="no"><a name="waitForDisconnected"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QSslSocket::<span class="name">waitForDisconnected</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForDisconnected" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#waitForDisconnected" translate="no">QAbstractSocket::waitForDisconnected</a>(int msecs).</p>
<p>Waits until the socket has disconnected or <i translate="no">msecs</i> milliseconds, whichever comes first. If the connection has been disconnected, this function returns <code translate="no">true</code>; otherwise it returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qabstractsocket.htm#waitForDisconnected" translate="no">QAbstractSocket::waitForDisconnected</a>().</p>
<!-- @@@waitForDisconnected -->
<!-- $$$waitForEncrypted[overload1]$$$waitForEncryptedint -->
<h3 class="fn" id="waitForEncrypted" translate="no"><a name="waitForEncrypted"></a><span class="type">bool</span> QSslSocket::<span class="name">waitForEncrypted</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForEncrypted" title="Direct link to this headline"></a></h3>
<p>Waits until the socket has completed the SSL handshake and has emitted <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>(), or <i translate="no">msecs</i> milliseconds, whichever comes first. If <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>() has been emitted, this function returns true; otherwise (e.g., the socket is disconnected, or the SSL handshake fails), false is returned.</p>
<p>The following example waits up to one second for the socket to be encrypted:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">socket<span class="operator">-</span><span class="operator">&gt;</span>connectToHostEncrypted(<span class="string">"imap"</span><span class="operator">,</span> <span class="number">993</span>);
<span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>waitForEncrypted(<span class="number">1000</span>))
    <a href="./qtglobal.htm#qDebug" translate="no">qDebug</a>(<span class="string">"Encrypted!"</span>);</pre></div>
<p>If msecs is -1, this function will not time out.</p>
<p><b>See also </b><a href="./qsslsocket.htm#startClientEncryption" translate="no">startClientEncryption</a>(), <a href="./qsslsocket.htm#startServerEncryption" translate="no">startServerEncryption</a>(), <a href="./qsslsocket.htm#encrypted" translate="no">encrypted</a>(), and <a href="./qsslsocket.htm#isEncrypted" translate="no">isEncrypted</a>().</p>
<!-- @@@waitForEncrypted -->
<!-- $$$waitForReadyRead[overload1]$$$waitForReadyReadint -->
<h3 class="fn" id="waitForReadyRead" translate="no"><a name="waitForReadyRead"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QSslSocket::<span class="name">waitForReadyRead</span>(<span class="type">int</span> <i>msecs</i> = 30000)<a class="plink" href="#waitForReadyRead" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#waitForReadyRead" translate="no">QAbstractSocket::waitForReadyRead</a>(int msecs).</p>
<!-- @@@waitForReadyRead -->
<!-- $$$writeData[overload1]$$$writeDataconstchar*qint64 -->
<h3 class="fn" id="writeData" translate="no"><a name="writeData"></a><code translate="no">[override virtual protected] </code><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QSslSocket::<span class="name">writeData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>len</i>)<a class="plink" href="#writeData" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qabstractsocket.htm#writeData" translate="no">QAbstractSocket::writeData</a>(const char *data, qint64 size).</p>
<!-- @@@writeData -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>