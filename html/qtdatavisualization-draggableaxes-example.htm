<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Axis Range Dragging With Labels Example | Qt Data Visualization</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtdatavisualization-index.htm" translate="no">Qt Data Visualization</a></li>
                            <li class="last"><a>Axis Range Dragging With Labels Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Axis Range Dragging With Labels Example</h1>
<span class="subtitle"></span>
<!-- $$$draggableaxes-brief -->
<p>Implementing a custom input handler to support axis dragging.</p>
<!-- @@@draggableaxes -->
<!-- $$$draggableaxes-description -->
<div class="descr"> <a name="details"></a>
<p>The Axis Range Dragging example shows how to customize the 3D graph controls in a widget application to allow changing axis ranges by clicking on an axis label and dragging. This is done by implementing a custom input handler to react to selection signals emitted from the graph.</p>
<p class="centerAlign"><img alt="" src="./images/draggableaxes-example.png"></p><a name="running-the-example"></a>
<h4 id="running-the-example">Running the Example<a class="plink" href="#running-the-example" title="Direct link to this headline"></a></h4>
<p>To run the example from <a href="http://doc.qt.io/qtcreator/index.html" translate="no">Qt Creator</a>, open the <b>Welcome</b> mode and select the example from <b>Examples</b>. For more information, visit <a href="https://doc.qt.io/qtcreator/creator-build-example-application.html" translate="no">Building and Running an Example</a>.</p>
<a name="replacing-default-input-handling"></a>
<h4 id="replacing-default-input-handling">Replacing Default Input Handling<a class="plink" href="#replacing-default-input-handling" title="Direct link to this headline"></a></h4>
<p>The default input handling mechanism is replaced by setting the active input handler of <a href="./q3dscatter.htm" translate="no">Q3DScatter</a> to <code translate="no">AxesInputHandler</code> that implements the custom behavior:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Give ownership of the handler to the graph and make it the active handler</span>
m_graph<span class="operator">-</span><span class="operator">&gt;</span>setActiveInputHandler(m_inputHandler);</pre></div>
<p><code translate="no">m_inputHandler</code> was initialized in the constructor:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">m_inputHandler(<span class="keyword">new</span> AxesInputHandler(scatter))<span class="operator">,</span></pre></div>
<p>We will also need the pointers to the axes, so we will pass them to our input handler too:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Give our axes to the input handler</span>
m_inputHandler<span class="operator">-</span><span class="operator">&gt;</span>setAxes(m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisX()<span class="operator">,</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisZ()<span class="operator">,</span> m_graph<span class="operator">-</span><span class="operator">&gt;</span>axisY());</pre></div>
<a name="extending-mouse-event-handling"></a>
<h4 id="extending-mouse-event-handling">Extending Mouse Event Handling<a class="plink" href="#extending-mouse-event-handling" title="Direct link to this headline"></a></h4>
<p>First of all, we inherited our input handler from <a href="./q3dinputhandler.htm" translate="no">Q3DInputHandler</a> instead of <a href="./qabstract3dinputhandler.htm" translate="no">QAbstract3DInputHandler</a>. The reason for doing this is to keep all the functionality of the default input handling, and to add our own functionality on top of it:</p>
<div class="pre"><pre class="cpp" translate="no"><span class="keyword">class</span> AxesInputHandler : <span class="keyword">public</span> <span class="type"><a href="./q3dinputhandler.htm" translate="no">Q3DInputHandler</a></span></pre></div>
<p>We start extending the default functionality by re-implementing some of the mouse events. Let's start with <code translate="no">mousePressEvent</code>. We'll just add button pressed flag for left mouse button into it, and keep the rest of the default functionality:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> AxesInputHandler<span class="operator">::</span>mousePressEvent(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> <span class="operator">*</span>event<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> <span class="operator">&amp;</span>mousePos)
{
    <span class="type"><a href="./q3dinputhandler.htm" translate="no">Q3DInputHandler</a></span><span class="operator">::</span>mousePressEvent(event<span class="operator">,</span> mousePos);
    <span class="keyword">if</span> (<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>LeftButton <span class="operator">=</span><span class="operator">=</span> event<span class="operator">-</span><span class="operator">&gt;</span>button())
        m_mousePressed <span class="operator">=</span> <span class="keyword">true</span>;
}</pre></div>
<p>We'll need to modify <code translate="no">mouseReleaseEvent</code> too to clear the flag and reset the internal state:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> AxesInputHandler<span class="operator">::</span>mouseReleaseEvent(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> <span class="operator">*</span>event<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> <span class="operator">&amp;</span>mousePos)
{
    <span class="type"><a href="./q3dinputhandler.htm" translate="no">Q3DInputHandler</a></span><span class="operator">::</span>mouseReleaseEvent(event<span class="operator">,</span> mousePos);
    m_mousePressed <span class="operator">=</span> <span class="keyword">false</span>;
    m_state <span class="operator">=</span> StateNormal;
}</pre></div>
<p>Then we'll modify <code translate="no">mouseMoveEvent</code>. Here we check if the <code translate="no">m_mousePressed</code> is <code translate="no">true</code> and our internal state is something other than <code translate="no">StateNormal</code>. If so, we'll set the input positions for mouse move distance calculations and call the axis dragging function (see <a href="./qtdatavisualization-draggableaxes-example.htm#implementing-axis-dragging" translate="no">Implementing axis dragging</a> for details):</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> AxesInputHandler<span class="operator">::</span>mouseMoveEvent(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> <span class="operator">*</span>event<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> <span class="operator">&amp;</span>mousePos)
{
    <span class="comment">// Check if we're trying to drag axis label</span>
    <span class="keyword">if</span> (m_mousePressed <span class="operator">&amp;</span><span class="operator">&amp;</span> m_state <span class="operator">!</span><span class="operator">=</span> StateNormal) {
        setPreviousInputPos(inputPosition());
        setInputPosition(mousePos);
        handleAxisDragging();
    } <span class="keyword">else</span> {
        <span class="type"><a href="./q3dinputhandler.htm" translate="no">Q3DInputHandler</a></span><span class="operator">::</span>mouseMoveEvent(event<span class="operator">,</span> mousePos);
    }
}</pre></div>
<p>We don't need to change the functionality of mouse wheel, so we will not re-implement that.</p>
<a name="implementing-axis-dragging"></a>
<h4 id="implementing-axis-dragging">Implementing Axis Dragging<a class="plink" href="#implementing-axis-dragging" title="Direct link to this headline"></a></h4>
<p>First we need to start listening to the selection signal from the graph. We do that in the constructor, and connect it to <code translate="no">handleElementSelected</code> method:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Connect to the item selection signal from graph</span>
connect(graph<span class="operator">,</span> <span class="operator">&amp;</span>QAbstract3DGraph<span class="operator">::</span>selectedElementChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span>
        <span class="operator">&amp;</span>AxesInputHandler<span class="operator">::</span>handleElementSelected);</pre></div>
<p>In <code translate="no">handleElementSelected</code> we check the type of the selection and set our internal state based on it:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">switch</span> (type) {
<span class="keyword">case</span> QAbstract3DGraph<span class="operator">::</span>ElementAxisXLabel:
    m_state <span class="operator">=</span> StateDraggingX;
    <span class="keyword">break</span>;
<span class="keyword">case</span> QAbstract3DGraph<span class="operator">::</span>ElementAxisYLabel:
    m_state <span class="operator">=</span> StateDraggingY;
    <span class="keyword">break</span>;
<span class="keyword">case</span> QAbstract3DGraph<span class="operator">::</span>ElementAxisZLabel:
    m_state <span class="operator">=</span> StateDraggingZ;
    <span class="keyword">break</span>;
<span class="keyword">default</span>:
    m_state <span class="operator">=</span> StateNormal;
    <span class="keyword">break</span>;
}</pre></div>
<p>The actual dragging logic is implemented in <code translate="no">handleAxisDragging</code> method, which we call from <code translate="no">mouseMoveEvent</code> in case the required conditions are met:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Check if we're trying to drag axis label</span>
<span class="keyword">if</span> (m_mousePressed <span class="operator">&amp;</span><span class="operator">&amp;</span> m_state <span class="operator">!</span><span class="operator">=</span> StateNormal) {</pre></div>
<p>In <code translate="no">handleAxisDragging</code> we first get the scene orientation from our active camera:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Get scene orientation from active camera</span>
<span class="type">float</span> xRotation <span class="operator">=</span> scene()<span class="operator">-</span><span class="operator">&gt;</span>activeCamera()<span class="operator">-</span><span class="operator">&gt;</span>xRotation();
<span class="type">float</span> yRotation <span class="operator">=</span> scene()<span class="operator">-</span><span class="operator">&gt;</span>activeCamera()<span class="operator">-</span><span class="operator">&gt;</span>yRotation();</pre></div>
<p>Then we calculate the modifiers to mouse move direction based on the orientation:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Calculate directional drag multipliers based on rotation</span>
<span class="type">float</span> xMulX <span class="operator">=</span> <a href="./qtmath.htm#qCos" translate="no">qCos</a>(<a href="./qtmath.htm#qDegreesToRadians" translate="no">qDegreesToRadians</a>(xRotation));
<span class="type">float</span> xMulY <span class="operator">=</span> <a href="./qtmath.htm#qSin" translate="no">qSin</a>(<a href="./qtmath.htm#qDegreesToRadians" translate="no">qDegreesToRadians</a>(xRotation));
<span class="type">float</span> zMulX <span class="operator">=</span> <a href="./qtmath.htm#qSin" translate="no">qSin</a>(<a href="./qtmath.htm#qDegreesToRadians" translate="no">qDegreesToRadians</a>(xRotation));
<span class="type">float</span> zMulY <span class="operator">=</span> <a href="./qtmath.htm#qCos" translate="no">qCos</a>(<a href="./qtmath.htm#qDegreesToRadians" translate="no">qDegreesToRadians</a>(xRotation));</pre></div>
<p>After that, we calculate the mouse movement, and modify it based on the y rotation of the camera:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Get the drag amount</span>
<span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> move <span class="operator">=</span> inputPosition() <span class="operator">-</span> previousInputPos();

<span class="comment">// Flip the effect of y movement if we're viewing from below</span>
<span class="type">float</span> yMove <span class="operator">=</span> (yRotation <span class="operator">&lt;</span> <span class="number">0</span>) <span class="operator">?</span> <span class="operator">-</span>move<span class="operator">.</span>y() : move<span class="operator">.</span>y();</pre></div>
<p>And finally apply the moved distance to the correct axis:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Adjust axes</span>
<span class="keyword">switch</span> (m_state) {
<span class="keyword">case</span> StateDraggingX:
    distance <span class="operator">=</span> (move<span class="operator">.</span>x() <span class="operator">*</span> xMulX <span class="operator">-</span> yMove <span class="operator">*</span> xMulY) <span class="operator">/</span> m_speedModifier;
    m_axisX<span class="operator">-</span><span class="operator">&gt;</span>setRange(m_axisX<span class="operator">-</span><span class="operator">&gt;</span>min() <span class="operator">-</span> distance<span class="operator">,</span> m_axisX<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">-</span> distance);
    <span class="keyword">break</span>;
<span class="keyword">case</span> StateDraggingZ:
    distance <span class="operator">=</span> (move<span class="operator">.</span>x() <span class="operator">*</span> zMulX <span class="operator">+</span> yMove <span class="operator">*</span> zMulY) <span class="operator">/</span> m_speedModifier;
    m_axisZ<span class="operator">-</span><span class="operator">&gt;</span>setRange(m_axisZ<span class="operator">-</span><span class="operator">&gt;</span>min() <span class="operator">+</span> distance<span class="operator">,</span> m_axisZ<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> distance);
    <span class="keyword">break</span>;
<span class="keyword">case</span> StateDraggingY:
    distance <span class="operator">=</span> move<span class="operator">.</span>y() <span class="operator">/</span> m_speedModifier; <span class="comment">// No need to use adjusted y move here</span>
    m_axisY<span class="operator">-</span><span class="operator">&gt;</span>setRange(m_axisY<span class="operator">-</span><span class="operator">&gt;</span>min() <span class="operator">+</span> distance<span class="operator">,</span> m_axisY<span class="operator">-</span><span class="operator">&gt;</span>max() <span class="operator">+</span> distance);
    <span class="keyword">break</span>;
<span class="keyword">default</span>:
    <span class="keyword">break</span>;
}</pre></div>
<p>We also have a function for setting the dragging speed:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">inline</span> <span class="type">void</span> setDragSpeedModifier(<span class="type">float</span> modifier) { m_speedModifier <span class="operator">=</span> modifier; }</pre></div>
<p>This is needed, as the mouse movement distance is absolute (in screen coordinates) and we need to adjust it to the axis range. The larger the value, the slower the dragging will be. Note that on this example we do not take scene zoom level into account when determining the drag speed, so you'll notice changes in the range adjustment as you change the zoom level.</p>
<p>The modifier could be adjusted automatically based on the axis range and camera zoom level, but we'll leave implementing that as an excercise for the reader.</p>
<a name="example-contents"></a>
<h4 id="example-contents">Example Contents<a class="plink" href="#example-contents" title="Direct link to this headline"></a></h4>
<p><a href="https://code.qt.io/cgit/qt/qtdatavis3d.git/tree/examples/datavisualization/draggableaxes?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@draggableaxes -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>