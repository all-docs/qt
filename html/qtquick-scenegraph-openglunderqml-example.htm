<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Scene Graph - OpenGL Under QML | Qt Quick</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtquick-scenegraph-openglunderqml-example.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a>Scene Graph - OpenGL Under QML</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Scene Graph - OpenGL Under QML</h1>
<span class="subtitle"></span>
<!-- $$$scenegraph/openglunderqml-brief -->
<p>Shows how to render OpenGL under a Qt Quick scene.</p>
<!-- @@@scenegraph/openglunderqml -->
<!-- $$$scenegraph/openglunderqml-description -->
<div class="descr"> <a name="details"></a>
<p class="centerAlign"><img alt="" src="./images/openglunderqml-example.jpg"></p><p>The OpenGL under QML example shows how an application can make use of the <a href="./qquickwindow.htm#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>() signal to draw custom OpenGL content under a Qt Quick scene. This signal is emitted at the start of every frame, before the scene graph starts its rendering, thus any OpenGL draw calls that are made as a response to this signal, will stack under the Qt Quick items.</p>
<p>As an alternative, applications that wish to render OpenGL content on top of the Qt Quick scene, can do so by connecting to the <a href="./qquickwindow.htm#afterRendering" translate="no">QQuickWindow::afterRendering</a>() signal.</p>
<p>In this example, we will also see how it is possible to have values that are exposed to QML which affect the OpenGL rendering. We animate the threshold value using a <a href="./qml-qtquick-numberanimation.htm" translate="no">NumberAnimation</a> in the QML file and this value is used by the OpenGL shader program that draws the squircles.</p>
<p>The example is equivalent in most ways to the <a href="./qtquick-scenegraph-d3d11underqml-example.htm" translate="no">Direct3D 11 Under QML</a>, <a href="./qtquick-scenegraph-metalunderqml-example.htm" translate="no">Metal Under QML</a>, and <a href="./qtquick-scenegraph-vulkanunderqml-example.htm" translate="no">Vulkan Under QML</a> examples, they all render the same custom content, just via different native APIs.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> Squircle : <span class="keyword">public</span> <span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span>
{
    Q_OBJECT
    Q_PROPERTY(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t READ t WRITE setT NOTIFY tChanged)
    QML_ELEMENT

<span class="keyword">public</span>:
    Squircle();

    <span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t() <span class="keyword">const</span> { <span class="keyword">return</span> m_t; }
    <span class="type">void</span> setT(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t);

<span class="keyword">signals</span>:
    <span class="type">void</span> tChanged();

<span class="keyword">public</span> <span class="keyword">slots</span>:
    <span class="type">void</span> sync();
    <span class="type">void</span> cleanup();

<span class="keyword">private</span> <span class="keyword">slots</span>:
    <span class="type">void</span> handleWindowChanged(<span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span> <span class="operator">*</span>win);

<span class="keyword">private</span>:
    <span class="type">void</span> releaseResources() override;

    <span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> m_t;
    SquircleRenderer <span class="operator">*</span>m_renderer;
};</pre></div>
<p>First of all, we need an object we can expose to QML. This is a subclass of <a href="./qquickitem.htm" translate="no">QQuickItem</a> so we can easily access <a href="./qquickitem.htm#window" translate="no">QQuickItem::window</a>(). We expose it to QML using the <a href="./qqmlengine.htm#QML_ELEMENT" translate="no">QML_ELEMENT</a> macro.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> SquircleRenderer : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span><span class="operator">,</span> <span class="keyword">protected</span> <span class="type"><a href="./qopenglfunctions.htm" translate="no">QOpenGLFunctions</a></span>
{
    Q_OBJECT
<span class="keyword">public</span>:
    SquircleRenderer() : m_t(<span class="number">0</span>)<span class="operator">,</span> m_program(<span class="number">0</span>) { }
    <span class="operator">~</span>SquircleRenderer();

    <span class="type">void</span> setT(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t) { m_t <span class="operator">=</span> t; }
    <span class="type">void</span> setViewportSize(<span class="keyword">const</span> <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> <span class="operator">&amp;</span>size) { m_viewportSize <span class="operator">=</span> size; }
    <span class="type">void</span> setWindow(<span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span> <span class="operator">*</span>window) { m_window <span class="operator">=</span> window; }

<span class="keyword">public</span> <span class="keyword">slots</span>:
    <span class="type">void</span> init();
    <span class="type">void</span> paint();

<span class="keyword">private</span>:
    <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> m_viewportSize;
    <span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> m_t;
    <span class="type"><a href="./qopenglshaderprogram.htm" translate="no">QOpenGLShaderProgram</a></span> <span class="operator">*</span>m_program;
    <span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span> <span class="operator">*</span>m_window;
};</pre></div>
<p>Then we need an object to take care of the rendering. This instance needs to be separated from the <a href="./qquickitem.htm" translate="no">QQuickItem</a> because the item lives in the GUI thread and the rendering potentially happens on the render thread. Since we want to connect to <a href="./qquickwindow.htm#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>(), we make the renderer a <a href="./qobject.htm" translate="no">QObject</a>. The renderer contains a copy of all the state it needs, independent of the GUI thread.</p>
<div class="admonition note">
<p><b>Note: </b>Don't be tempted to merge the two objects into one. QQuickItems may be deleted on the GUI thread while the render thread is rendering.</p>
</div>
<p>Lets move on to the implementation.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">Squircle<span class="operator">::</span>Squircle()
    : m_t(<span class="number">0</span>)
    <span class="operator">,</span> m_renderer(nullptr)
{
    connect(<span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span><span class="operator">::</span>windowChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>Squircle<span class="operator">::</span>handleWindowChanged);
}</pre></div>
<p>The constructor of the <code translate="no">Squircle</code> class simply initializes the values and connects to the window changed signal which we will use to prepare our renderer.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> Squircle<span class="operator">::</span>handleWindowChanged(<span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span> <span class="operator">*</span>win)
{
    <span class="keyword">if</span> (win) {
        connect(win<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span><span class="operator">::</span>beforeSynchronizing<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>Squircle<span class="operator">::</span>sync<span class="operator">,</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>DirectConnection);
        connect(win<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span><span class="operator">::</span>sceneGraphInvalidated<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>Squircle<span class="operator">::</span>cleanup<span class="operator">,</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>DirectConnection);</pre></div>
<p>Once we have a window, we attach to the <a href="./qquickwindow.htm#beforeSynchronizing" translate="no">QQuickWindow::beforeSynchronizing</a>() signal which we will use to create the renderer and to copy state into it safely. We also connect to the <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">QQuickWindow::sceneGraphInvalidated</a>() signal to handle the cleanup of the renderer.</p>
<div class="admonition note">
<p><b>Note: </b>Since the Squircle object has affinity to the GUI thread and the signals are emitted from the rendering thread, it is crucial that the connections are made with <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::DirectConnection</a>. Failing to do so, will result in that the slots are invoked on the wrong thread with no OpenGL context present.</p>
</div>
<div class="pre"><pre class="cpp prettyprint" translate="no">        <span class="comment">// Ensure we start with cleared to black. The squircle's blend mode relies on this.</span>
        win<span class="operator">-</span><span class="operator">&gt;</span>setColor(<span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>black);
    }
}</pre></div>
<p>The default behavior of the scene graph is to clear the framebuffer before rendering. This is fine since we will insert our own rendering code after this clear is enqueued. Make sure however that we clear to the desired color (black).</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> Squircle<span class="operator">::</span>sync()
{
    <span class="keyword">if</span> (<span class="operator">!</span>m_renderer) {
        m_renderer <span class="operator">=</span> <span class="keyword">new</span> SquircleRenderer();
        connect(window()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span><span class="operator">::</span>beforeRendering<span class="operator">,</span> m_renderer<span class="operator">,</span> <span class="operator">&amp;</span>SquircleRenderer<span class="operator">::</span>init<span class="operator">,</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>DirectConnection);
        connect(window()<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span><span class="operator">::</span>beforeRenderPassRecording<span class="operator">,</span> m_renderer<span class="operator">,</span> <span class="operator">&amp;</span>SquircleRenderer<span class="operator">::</span>paint<span class="operator">,</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>DirectConnection);
    }
    m_renderer<span class="operator">-</span><span class="operator">&gt;</span>setViewportSize(window()<span class="operator">-</span><span class="operator">&gt;</span>size() <span class="operator">*</span> window()<span class="operator">-</span><span class="operator">&gt;</span>devicePixelRatio());
    m_renderer<span class="operator">-</span><span class="operator">&gt;</span>setT(m_t);
    m_renderer<span class="operator">-</span><span class="operator">&gt;</span>setWindow(window());
}</pre></div>
<p>We use the <code translate="no">sync()</code> function to initialize the renderer and to copy the state in our item into the renderer. When the renderer is created, we also connect the <a href="./qquickwindow.htm#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>() and <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">QQuickWindow::beforeRenderPassRecording</a>() to the renderer's <code translate="no">init()</code> and <code translate="no">paint()</code> slots.</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="./qquickwindow.htm#beforeSynchronizing" translate="no">QQuickWindow::beforeSynchronizing</a>() signal is emitted on the rendering thread while the GUI thread is blocked, so it is safe to simply copy the value without any additional protection.</p>
</div>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> Squircle<span class="operator">::</span>cleanup()
{
    <span class="keyword">delete</span> m_renderer;
    m_renderer <span class="operator">=</span> nullptr;
}

<span class="keyword">class</span> CleanupJob : <span class="keyword">public</span> <span class="type"><a href="./qrunnable.htm" translate="no">QRunnable</a></span>
{
<span class="keyword">public</span>:
    CleanupJob(SquircleRenderer <span class="operator">*</span>renderer) : m_renderer(renderer) { }
    <span class="type">void</span> run() override { <span class="keyword">delete</span> m_renderer; }
<span class="keyword">private</span>:
    SquircleRenderer <span class="operator">*</span>m_renderer;
};

<span class="type">void</span> Squircle<span class="operator">::</span>releaseResources()
{
    window()<span class="operator">-</span><span class="operator">&gt;</span>scheduleRenderJob(<span class="keyword">new</span> CleanupJob(m_renderer)<span class="operator">,</span> <span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span><span class="operator">::</span>BeforeSynchronizingStage);
    m_renderer <span class="operator">=</span> nullptr;
}

SquircleRenderer<span class="operator">::</span><span class="operator">~</span>SquircleRenderer()
{
    <span class="keyword">delete</span> m_program;
}</pre></div>
<p>In the <code translate="no">cleanup()</code> function we delete the renderer which in turn cleans up its own resources. This is complemented by reimplementing <a href="./qquickwindow.htm#releaseResources" translate="no">QQuickWindow::releaseResources</a>() since just connecting to the sceneGraphInvalidated() signal is not sufficient on its own to handle all cases.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> Squircle<span class="operator">::</span>setT(<span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> t)
{
    <span class="keyword">if</span> (t <span class="operator">=</span><span class="operator">=</span> m_t)
        <span class="keyword">return</span>;
    m_t <span class="operator">=</span> t;
    <span class="keyword">emit</span> tChanged();
    <span class="keyword">if</span> (window())
        window()<span class="operator">-</span><span class="operator">&gt;</span>update();
}</pre></div>
<p>When the value of <code translate="no">t</code> changes, we call <a href="./qquickwindow.htm#update" translate="no">QQuickWindow::update</a>() rather than <a href="./qquickitem.htm#update" translate="no">QQuickItem::update</a>() because the former will force the entire window to be redrawn, even when the scene graph has not changed since the last frame.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> SquircleRenderer<span class="operator">::</span>init()
{
    <span class="keyword">if</span> (<span class="operator">!</span>m_program) {
        <span class="type"><a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a></span> <span class="operator">*</span>rif <span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>rendererInterface();
        Q_ASSERT(rif<span class="operator">-</span><span class="operator">&gt;</span>graphicsApi() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a></span><span class="operator">::</span>OpenGL <span class="operator">|</span><span class="operator">|</span> rif<span class="operator">-</span><span class="operator">&gt;</span>graphicsApi() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a></span><span class="operator">::</span>OpenGLRhi);

        initializeOpenGLFunctions();

        m_program <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qopenglshaderprogram.htm" translate="no">QOpenGLShaderProgram</a></span>();
        m_program<span class="operator">-</span><span class="operator">&gt;</span>addCacheableShaderFromSourceCode(<span class="type"><a href="./qopenglshader.htm" translate="no">QOpenGLShader</a></span><span class="operator">::</span>Vertex<span class="operator">,</span>
                                                    <span class="string">"attribute highp vec4 vertices;"</span>
                                                    <span class="string">"varying highp vec2 coords;"</span>
                                                    <span class="string">"void main() {"</span>
                                                    <span class="string">"    gl_Position = vertices;"</span>
                                                    <span class="string">"    coords = vertices.xy;"</span>
                                                    <span class="string">"}"</span>);
        m_program<span class="operator">-</span><span class="operator">&gt;</span>addCacheableShaderFromSourceCode(<span class="type"><a href="./qopenglshader.htm" translate="no">QOpenGLShader</a></span><span class="operator">::</span>Fragment<span class="operator">,</span>
                                                    <span class="string">"uniform lowp float t;"</span>
                                                    <span class="string">"varying highp vec2 coords;"</span>
                                                    <span class="string">"void main() {"</span>
                                                    <span class="string">"    lowp float i = 1. - (pow(abs(coords.x), 4.) + pow(abs(coords.y), 4.));"</span>
                                                    <span class="string">"    i = smoothstep(t - 0.8, t + 0.8, i);"</span>
                                                    <span class="string">"    i = floor(i * 20.) / 20.;"</span>
                                                    <span class="string">"    gl_FragColor = vec4(coords * .5 + .5, i, i);"</span>
                                                    <span class="string">"}"</span>);

        m_program<span class="operator">-</span><span class="operator">&gt;</span>bindAttributeLocation(<span class="string">"vertices"</span><span class="operator">,</span> <span class="number">0</span>);
        m_program<span class="operator">-</span><span class="operator">&gt;</span>link();

    }
}</pre></div>
<p>In the SquircleRenderer's <code translate="no">init()</code> function we start by initializing the shader program if not yet done. The OpenGL context is current on the thread when the slot is invoked.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> SquircleRenderer<span class="operator">::</span>paint()
{
    <span class="comment">// Play nice with the RHI. Not strictly needed when the scenegraph uses</span>
    <span class="comment">// OpenGL directly.</span>
    m_window<span class="operator">-</span><span class="operator">&gt;</span>beginExternalCommands();

    m_program<span class="operator">-</span><span class="operator">&gt;</span>bind();

    m_program<span class="operator">-</span><span class="operator">&gt;</span>enableAttributeArray(<span class="number">0</span>);

    <span class="type">float</span> values<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
        <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span>
        <span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="operator">,</span>
        <span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span>
        <span class="number">1</span><span class="operator">,</span> <span class="number">1</span>
    };

    <span class="comment">// This example relies on (deprecated) client-side pointers for the vertex</span>
    <span class="comment">// input. Therefore, we have to make sure no vertex buffer is bound.</span>
    glBindBuffer(GL_ARRAY_BUFFER<span class="operator">,</span> <span class="number">0</span>);

    m_program<span class="operator">-</span><span class="operator">&gt;</span>setAttributeArray(<span class="number">0</span><span class="operator">,</span> GL_FLOAT<span class="operator">,</span> values<span class="operator">,</span> <span class="number">2</span>);
    m_program<span class="operator">-</span><span class="operator">&gt;</span>setUniformValue(<span class="string">"t"</span><span class="operator">,</span> (<span class="type">float</span>) m_t);

    glViewport(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> m_viewportSize<span class="operator">.</span>width()<span class="operator">,</span> m_viewportSize<span class="operator">.</span>height());

    glDisable(GL_DEPTH_TEST);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA<span class="operator">,</span> GL_ONE);

    glDrawArrays(GL_TRIANGLE_STRIP<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">4</span>);

    m_program<span class="operator">-</span><span class="operator">&gt;</span>disableAttributeArray(<span class="number">0</span>);
    m_program<span class="operator">-</span><span class="operator">&gt;</span>release();

    <span class="comment">// Not strictly needed for this example, but generally useful for when</span>
    <span class="comment">// mixing with raw OpenGL.</span>
    m_window<span class="operator">-</span><span class="operator">&gt;</span>resetOpenGLState();

    m_window<span class="operator">-</span><span class="operator">&gt;</span>endExternalCommands();
}</pre></div>
<p>We use the shader program to draw the squircle in <code translate="no">paint()</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span><span class="operator">*</span>argv)
{
    <span class="type"><a href="./qguiapplication.htm" translate="no">QGuiApplication</a></span> app(argc<span class="operator">,</span> argv);

    <span class="type"><a href="./qquickview.htm" translate="no">QQuickView</a></span> view;
    view<span class="operator">.</span>setResizeMode(<span class="type"><a href="./qquickview.htm" translate="no">QQuickView</a></span><span class="operator">::</span>SizeRootObjectToView);
    view<span class="operator">.</span>setSource(<span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span>(<span class="string">"qrc:///scenegraph/openglunderqml/main.qml"</span>));
    view<span class="operator">.</span>show();

    <span class="keyword">return</span> app<span class="operator">.</span>exec();
}</pre></div>
<p>The application's <code translate="no">main()</code> function instantiates a <a href="./qquickview.htm" translate="no">QQuickView</a> and launches the <code translate="no">main.qml</code> file.</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick 2.0
import OpenGLUnderQML 1.0

<span class="type"><a href="./qml-qtquick-item.htm" translate="no">Item</a></span> {

    <span class="name">width</span>: <span class="number">320</span>
    <span class="name">height</span>: <span class="number">480</span>

    <span class="type">Squircle</span> {
        SequentialAnimation on <span class="name">t</span> {
            <span class="type"><a href="./qml-qtquick-numberanimation.htm" translate="no">NumberAnimation</a></span> { <span class="name">to</span>: <span class="number">1</span>; <span class="name">duration</span>: <span class="number">2500</span>; <span class="name">easing</span>.type: <span class="name">Easing</span>.<span class="name">InQuad</span> }
            <span class="type"><a href="./qml-qtquick-numberanimation.htm" translate="no">NumberAnimation</a></span> { <span class="name">to</span>: <span class="number">0</span>; <span class="name">duration</span>: <span class="number">2500</span>; <span class="name">easing</span>.type: <span class="name">Easing</span>.<span class="name">OutQuad</span> }
            <span class="name">loops</span>: <span class="name">Animation</span>.<span class="name">Infinite</span>
            <span class="name">running</span>: <span class="number">true</span>
        }
    }</pre></div>
<p>We import the Squircle QML type with the name we registered in the <code translate="no">main()</code> function. We then instantiate it and create a running <a href="./qml-qtquick-numberanimation.htm" translate="no">NumberAnimation</a> on its <code translate="no">t</code> property.</p>
<div class="pre"><pre class="qml prettyprint" translate="no">    <span class="type"><a href="./qml-qtquick-rectangle.htm" translate="no">Rectangle</a></span> {
        <span class="name">color</span>: <span class="name">Qt</span>.<span class="name">rgba</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.7</span>)
        <span class="name">radius</span>: <span class="number">10</span>
        <span class="name">border</span>.width: <span class="number">1</span>
        <span class="name">border</span>.color: <span class="string">"white"</span>
        <span class="name">anchors</span>.fill: <span class="name">label</span>
        <span class="name">anchors</span>.margins: -<span class="number">10</span>
    }

    <span class="type"><a href="./qml-qtquick-text.htm" translate="no">Text</a></span> {
        <span class="name">id</span>: <span class="name">label</span>
        <span class="name">color</span>: <span class="string">"black"</span>
        <span class="name">wrapMode</span>: <span class="name">Text</span>.<span class="name">WordWrap</span>
        <span class="name">text</span>: <span class="string">"The background here is a squircle rendered with raw OpenGL using the 'beforeRender()' signal in QQuickWindow. This text label and its border is rendered using QML"</span>
        <span class="name">anchors</span>.right: <span class="name">parent</span>.<span class="name">right</span>
        <span class="name">anchors</span>.left: <span class="name">parent</span>.<span class="name">left</span>
        <span class="name">anchors</span>.bottom: <span class="name">parent</span>.<span class="name">bottom</span>
        <span class="name">anchors</span>.margins: <span class="number">20</span>
    }
}</pre></div>
<p>Then we overlay a short descriptive text, so that it is clearly visible that we are in fact rendering OpenGL under our Qt Quick scene.</p>
<p><a href="https://code.qt.io/cgit/qt/qtdeclarative.git/tree/examples/quick/scenegraph/openglunderqml?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@scenegraph/openglunderqml -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>