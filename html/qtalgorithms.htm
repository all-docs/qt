<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>&lt;QtAlgorithms&gt; - Generic Algorithms | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtalgorithms.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a>&lt;QtAlgorithms&gt; - Generic Algorithms</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">&lt;QtAlgorithms&gt; - Generic Algorithms</h1>
<!-- $$$<QtAlgorithms>-brief -->
<p>The &lt;QtAlgorithms&gt; header includes the generic, template-based algorithms. <a href="#details">More...</a></p>
<!-- @@@<QtAlgorithms> -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QtAlgorithms&gt;</span>
</td></tr></tbody></table></div><ul>
<li><a href="./qtalgorithms-obsolete.htm">Obsolete members</a></li>
</ul>
<a name="functions"></a>
<h2 id="functions">Functions<a class="plink" href="#functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountLeadingZeroBits" translate="no">qCountLeadingZeroBits</a></b>(quint32 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountLeadingZeroBits" translate="no">qCountLeadingZeroBits</a></b>(quint8 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountLeadingZeroBits-1" translate="no">qCountLeadingZeroBits</a></b>(quint16 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountLeadingZeroBits-2" translate="no">qCountLeadingZeroBits</a></b>(quint64 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountTrailingZeroBits" translate="no">qCountTrailingZeroBits</a></b>(quint8 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountTrailingZeroBits-1" translate="no">qCountTrailingZeroBits</a></b>(quint32 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountTrailingZeroBits-2" translate="no">qCountTrailingZeroBits</a></b>(quint16 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qCountTrailingZeroBits-3" translate="no">qCountTrailingZeroBits</a></b>(quint64 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qDeleteAll" translate="no">qDeleteAll</a></b>(ForwardIterator <i>begin</i>, ForwardIterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qDeleteAll-1" translate="no">qDeleteAll</a></b>(const Container &amp;<i>c</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qPopulationCount" translate="no">qPopulationCount</a></b>(quint8 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qPopulationCount-1" translate="no">qPopulationCount</a></b>(quint32 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qPopulationCount-2" translate="no">qPopulationCount</a></b>(quint16 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qPopulationCount-3" translate="no">qPopulationCount</a></b>(quint64 <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qtalgorithms.htm#qSwap" translate="no">qSwap</a></b>(T &amp;<i>var1</i>, T &amp;<i>var2</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$<QtAlgorithms>-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>Qt provides a number of global template functions in <code translate="no">&lt;QtAlgorithms&gt;</code> that work on containers and perform small tasks to make life easier, such as <a href="./qtalgorithms.htm#qDeleteAll" translate="no">qDeleteAll</a>(), which invokes <code translate="no">operator delete</code> on all items in a given container or in a given range. You can use these algorithms with any <a href="./containers.htm" translate="no">container class</a> that provides STL-style iterators, including Qt's <a href="./qlist.htm" translate="no">QList</a>, QLinkedList, <a href="./qvector.htm" translate="no">QVector</a>, <a href="./qmap.htm" translate="no">QMap</a>, and <a href="./qhash.htm#qhash" translate="no">QHash</a> classes.</p>
<p>Most algorithms take <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterators</a> as parameters. The algorithms are generic in the sense that they aren't bound to a specific iterator class; you can use them with any iterators that meet a certain set of requirements.</p>
<p>Different algorithms can have different requirements for the iterators they accept. For example, qFill() accepts two <a href="./qtalgorithms.htm#forward-iterators" translate="no">forward iterators</a>. The iterator types required are specified for each algorithm. If an iterator of the wrong type is passed (for example, if <a href="./qlist.htm#ConstIterator-typedef" translate="no">QList::ConstIterator</a> is passed as an <a href="./qtalgorithms.htm#output-iterators" translate="no">output iterator</a>), you will always get a compiler error, although not necessarily a very informative one.</p>
<p>Some algorithms have special requirements on the value type stored in the containers. For example, <a href="./qtalgorithms.htm#qDeleteAll" translate="no">qDeleteAll</a>() requires that the value type is a non-const pointer type (for example, <a href="./qwidget.htm" translate="no">QWidget</a> *). The value type requirements are specified for each algorithm, and the compiler will produce an error if a requirement isn't met.</p>
<p>The generic algorithms can be used on other container classes than those provided by Qt and STL. The syntax of STL-style iterators is modeled after C++ pointers, so it's possible to use plain arrays as containers and plain pointers as iterators. A common idiom is to use qBinaryFind() together with two static arrays: one that contains a list of keys, and another that contains a list of associated values. For example, the following code will look up an HTML entity (e.g., <code translate="no">&amp;amp</code>;) in the <code translate="no">name_table</code> array and return the corresponding Unicode value from the <code translate="no">value_table</code> if the entity is recognized:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qchar.htm" translate="no">QChar</a></span> resolveEntity(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>entity)
{
    <span class="keyword">static</span> <span class="keyword">const</span> QLatin1String name_table<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
        <span class="string">"AElig"</span><span class="operator">,</span> <span class="string">"Aacute"</span><span class="operator">,</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">,</span> <span class="string">"zwnj"</span>
    };
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="./qtglobal.htm#ushort-typedef" translate="no">ushort</a></span> value_table<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
        <span class="number">0x0061</span><span class="operator">,</span> <span class="number">0x00c1</span><span class="operator">,</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">,</span> <span class="number">0x200c</span>
    };
    <span class="type">int</span> N <span class="operator">=</span> <span class="keyword">sizeof</span>(name_table) <span class="operator">/</span> <span class="keyword">sizeof</span>(name_table<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>);

    <span class="keyword">const</span> QLatin1String <span class="operator">*</span>name <span class="operator">=</span> <a href="./qtalgorithms-obsolete.htm#qBinaryFind" translate="no">qBinaryFind</a>(name_table<span class="operator">,</span> name_table <span class="operator">+</span> N<span class="operator">,</span>
                                            entity);
    <span class="type">int</span> index <span class="operator">=</span> name <span class="operator">-</span> name_table;
    <span class="keyword">if</span> (index <span class="operator">=</span><span class="operator">=</span> N)
        <span class="keyword">return</span> <span class="type"><a href="./qchar.htm" translate="no">QChar</a></span>();

    <span class="keyword">return</span> <span class="type"><a href="./qchar.htm" translate="no">QChar</a></span>(value_table<span class="operator">[</span>index<span class="operator">]</span>);
}</pre></div>
<p>This kind of code is for advanced users only; for most applications, a <a href="./qmap.htm" translate="no">QMap</a>- or <a href="./qhash.htm#qhash" translate="no">QHash</a>-based approach would work just as well:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qchar.htm" translate="no">QChar</a></span> resolveEntity(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>entity)
{
    <span class="keyword">static</span> <span class="type"><a href="./qmap.htm" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> entityMap;

    <span class="keyword">if</span> (<span class="operator">!</span>entityMap) {
        entityMap<span class="operator">.</span>insert(<span class="string">"AElig"</span><span class="operator">,</span> <span class="number">0x0061</span>);
        entityMap<span class="operator">.</span>insert(<span class="string">"Aacute"</span><span class="operator">,</span> <span class="number">0x00c1</span>);
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        entityMap<span class="operator">.</span>insert(<span class="string">"zwnj"</span><span class="operator">,</span> <span class="number">0x200c</span>);
    }
    <span class="keyword">return</span> <span class="type"><a href="./qchar.htm" translate="no">QChar</a></span>(entityMap<span class="operator">.</span>value(entity));
}</pre></div>
<a name="types-of-iterators"></a>
<h4 id="types-of-iterators">Types of Iterators<a class="plink" href="#types-of-iterators" title="Direct link to this headline"></a></h4>
<p>The algorithms have certain requirements on the iterator types they accept, and these are specified individually for each function. The compiler will produce an error if a requirement isn't met.</p>
<a name="input-iterators"></a>
<h5 id="input-iterators">Input Iterators<a class="plink" href="#input-iterators" title="Direct link to this headline"></a></h5>
<p>An <i>input iterator</i> is an iterator that can be used for reading data sequentially from a container. It must provide the following operators: <code translate="no">==</code> and <code translate="no">!=</code> for comparing two iterators, unary <code translate="no">*</code> for retrieving the value stored in the item, and prefix <code translate="no">++</code> for advancing to the next item.</p>
<p>The Qt containers' iterator types (const and non-const) are all input iterators.</p>
<a name="output-iterators"></a>
<h5 id="output-iterators">Output Iterators<a class="plink" href="#output-iterators" title="Direct link to this headline"></a></h5>
<p>An output iterator is an iterator that can be used for writing data sequentially to a container or to some output stream. It must provide the following operators: unary <code translate="no">*</code> for writing a value (i.e., <code translate="no">*it = val</code>) and prefix <code translate="no">++</code> for advancing to the next item.</p>
<p>The Qt containers' non-const iterator types are all output iterators.</p>
<a name="forward-iterators"></a>
<h5 id="forward-iterators">Forward Iterators<a class="plink" href="#forward-iterators" title="Direct link to this headline"></a></h5>
<p>A <i>forward iterator</i> is an iterator that meets the requirements of both input iterators and output iterators.</p>
<p>The Qt containers' non-const iterator types are all forward iterators.</p>
<a name="bidirectional-iterators"></a>
<h5 id="bidirectional-iterators">Bidirectional Iterators<a class="plink" href="#bidirectional-iterators" title="Direct link to this headline"></a></h5>
<p>A <i>bidirectional iterator</i> is an iterator that meets the requirements of forward iterators but that in addition supports prefix <code translate="no">--</code> for iterating backward.</p>
<p>The Qt containers' non-const iterator types are all bidirectional iterators.</p>
<a name="random-access-iterators"></a>
<h5 id="random-access-iterators">Random Access Iterators<a class="plink" href="#random-access-iterators" title="Direct link to this headline"></a></h5>
<p>The last category, <i>random access iterators</i>, is the most powerful type of iterator. It supports all the requirements of a bidirectional iterator, and supports the following operations:</p>
<div class="table"><table class="generic">
<tbody><tr class="odd" valign="top"><td><code translate="no">i += n</code></td><td>advances iterator <code translate="no">i</code> by <code translate="no">n</code> positions</td></tr>
<tr class="even" valign="top"><td><code translate="no">i -= n</code></td><td>moves iterator <code translate="no">i</code> back by <code translate="no">n</code> positions</td></tr>
<tr class="odd" valign="top"><td><code translate="no">i + n</code> or <code translate="no">n + i</code></td><td>returns the iterator for the item <code translate="no">n</code> positions ahead of iterator <code translate="no">i</code></td></tr>
<tr class="even" valign="top"><td><code translate="no">i - n</code></td><td>returns the iterator for the item <code translate="no">n</code> positions behind of iterator <code translate="no">i</code></td></tr>
<tr class="odd" valign="top"><td><code translate="no">i - j</code></td><td>returns the number of items between iterators <code translate="no">i</code> and <code translate="no">j</code></td></tr>
<tr class="even" valign="top"><td><code translate="no">i[n]</code></td><td>same as <code translate="no">*(i + n)</code></td></tr>
<tr class="odd" valign="top"><td><code translate="no">i &lt; j</code></td><td>returns <code translate="no">true</code> if iterator <code translate="no">j</code> comes after iterator <code translate="no">i</code></td></tr>
</tbody></table></div>
<p><a href="./qlist.htm" translate="no">QList</a> and <a href="./qvector.htm" translate="no">QVector</a>'s non-const iterator types are random access iterators.</p>
<a name="qt-and-the-stl-algorithms"></a>
<h4 id="qt-and-the-stl-algorithms">Qt and the STL Algorithms<a class="plink" href="#qt-and-the-stl-algorithms" title="Direct link to this headline"></a></h4>
<p>Historically, Qt used to provide functions which were direct equivalents of many STL algorithmic functions. Starting with Qt 5.0, you are instead encouraged to use directly the implementations available in the STL; most of the Qt ones have been deprecated (although they are still available to keep the old code compiling).</p>
<a name="porting-guidelines"></a>
<h5 id="porting-guidelines">Porting guidelines<a class="plink" href="#porting-guidelines" title="Direct link to this headline"></a></h5>
<p>Most of the time, an application using the deprecated Qt algorithmic functions can be easily ported to use the equivalent STL functions. You need to:</p>
<ol class="1" type="1"><li>add the <code translate="no">#include &lt;algorithm&gt;</code> preprocessor directive;</li>
<li>replace the Qt functions with the STL counterparts, according to the table below.</li>
</ol>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Qt function</th><th>STL function</th></tr></thead>
<tbody><tr class="odd" valign="top"><td>qBinaryFind</td><td><code translate="no">std::binary_search</code> or <code translate="no">std::lower_bound</code></td></tr>
<tr class="even" valign="top"><td>qCopy</td><td><code translate="no">std::copy</code></td></tr>
<tr class="odd" valign="top"><td>qCopyBackward</td><td><code translate="no">std::copy_backward</code></td></tr>
<tr class="even" valign="top"><td>qEqual</td><td><code translate="no">std::equal</code></td></tr>
<tr class="odd" valign="top"><td>qFill</td><td><code translate="no">std::fill</code></td></tr>
<tr class="even" valign="top"><td>qFind</td><td><code translate="no">std::find</code></td></tr>
<tr class="odd" valign="top"><td>qCount</td><td><code translate="no">std::count</code></td></tr>
<tr class="even" valign="top"><td>qSort</td><td><code translate="no">std::sort</code></td></tr>
<tr class="odd" valign="top"><td>qStableSort</td><td><code translate="no">std::stable_sort</code></td></tr>
<tr class="even" valign="top"><td>qLowerBound</td><td><code translate="no">std::lower_bound</code></td></tr>
<tr class="odd" valign="top"><td>qUpperBound</td><td><code translate="no">std::upper_bound</code></td></tr>
<tr class="even" valign="top"><td>qLess</td><td><code translate="no">std::less</code></td></tr>
<tr class="odd" valign="top"><td>qGreater</td><td><code translate="no">std::greater</code></td></tr>
</tbody></table></div>
<p>The only cases in which the port may not be straightforward is if the old code relied on template specializations of the qLess() and/or the <a href="./qtalgorithms.htm#qSwap" translate="no">qSwap</a>() functions, which were used internally by the implementations of the Qt algorithmic functions, but are instead ignored by the STL ones.</p>
<p>In case the old code relied on the specialization of the qLess() functor, then a workaround is explicitly passing an instance of the qLess() class to the STL function, for instance like this:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">std<span class="operator">::</span>sort(container<span class="operator">.</span>begin()<span class="operator">,</span> container<span class="operator">.</span>end()<span class="operator">,</span> <a href="./qtalgorithms-obsolete.htm#qLess" translate="no">qLess</a><span class="operator">&lt;</span>T<span class="operator">&gt;</span>());</pre></div>
<p>Instead, since it's not possible to pass a custom swapper functor to STL functions, the only workaround for a template specialization for <a href="./qtalgorithms.htm#qSwap" translate="no">qSwap</a>() is providing the same specialization for <code translate="no">std::swap()</code>.</p>
</div>
<p><b>See also </b><a href="./containers.htm" translate="no">container classes</a> and <a href="./qtglobal.htm" translate="no">&lt;QtGlobal&gt;</a>.</p>
<!-- @@@<QtAlgorithms> -->
<div class="func">
<h2>Function Documentation</h2>
<!-- $$$qCountLeadingZeroBits[overload1]$$$qCountLeadingZeroBitsquint32 -->
<h3 class="fn" id="qCountLeadingZeroBits" translate="no"><a name="qCountLeadingZeroBits"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint32-typedef" translate="no">quint32</a></span> <i>v</i>)<a class="plink" href="#qCountLeadingZeroBits" title="Direct link to this headline"></a></h3>
<p>Returns the number of consecutive zero bits in <i translate="no">v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint32(1)) returns 31 and qCountLeadingZeroBits(quint32(8)) returns 28.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountLeadingZeroBits -->
<!-- $$$qCountLeadingZeroBits[overload1]$$$qCountLeadingZeroBitsquint8 -->
<h3 class="fn" id="qCountLeadingZeroBits" translate="no"><a name="qCountLeadingZeroBits"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint8-typedef" translate="no">quint8</a></span> <i>v</i>)<a class="plink" href="#qCountLeadingZeroBits" title="Direct link to this headline"></a></h3>
<p>Returns the number of consecutive zero bits in <i translate="no">v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint8(1)) returns 7 and qCountLeadingZeroBits(quint8(8)) returns 4.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountLeadingZeroBits -->
<!-- $$$qCountLeadingZeroBits$$$qCountLeadingZeroBitsquint16 -->
<h3 class="fn" id="qCountLeadingZeroBits-1" translate="no"><a name="qCountLeadingZeroBits-1"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <i>v</i>)<a class="plink" href="#qCountLeadingZeroBits-1" title="Direct link to this headline"></a></h3>
<p>Returns the number of consecutive zero bits in <i translate="no">v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint16(1)) returns 15 and qCountLeadingZeroBits(quint16(8)) returns 12.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountLeadingZeroBits -->
<!-- $$$qCountLeadingZeroBits$$$qCountLeadingZeroBitsquint64 -->
<h3 class="fn" id="qCountLeadingZeroBits-2" translate="no"><a name="qCountLeadingZeroBits-2"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountLeadingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint64-typedef" translate="no">quint64</a></span> <i>v</i>)<a class="plink" href="#qCountLeadingZeroBits-2" title="Direct link to this headline"></a></h3>
<p>Returns the number of consecutive zero bits in <i translate="no">v</i>, when searching from the MSB. For example, qCountLeadingZeroBits(quint64(1)) returns 63 and qCountLeadingZeroBits(quint64(8)) returns 60.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountLeadingZeroBits -->
<!-- $$$qCountTrailingZeroBits[overload1]$$$qCountTrailingZeroBitsquint8 -->
<h3 class="fn" id="qCountTrailingZeroBits" translate="no"><a name="qCountTrailingZeroBits"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint8-typedef" translate="no">quint8</a></span> <i>v</i>)<a class="plink" href="#qCountTrailingZeroBits" title="Direct link to this headline"></a></h3>
<p>Returns the number of consecutive zero bits in <i translate="no">v</i>, when searching from the LSB. For example, qCountTrailingZeroBits(1) returns 0 and qCountTrailingZeroBits(8) returns 3.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountTrailingZeroBits -->
<!-- $$$qCountTrailingZeroBits$$$qCountTrailingZeroBitsquint32 -->
<h3 class="fn" id="qCountTrailingZeroBits-1" translate="no"><a name="qCountTrailingZeroBits-1"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint32-typedef" translate="no">quint32</a></span> <i>v</i>)<a class="plink" href="#qCountTrailingZeroBits-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountTrailingZeroBits -->
<!-- $$$qCountTrailingZeroBits$$$qCountTrailingZeroBitsquint16 -->
<h3 class="fn" id="qCountTrailingZeroBits-2" translate="no"><a name="qCountTrailingZeroBits-2"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <i>v</i>)<a class="plink" href="#qCountTrailingZeroBits-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountTrailingZeroBits -->
<!-- $$$qCountTrailingZeroBits$$$qCountTrailingZeroBitsquint64 -->
<h3 class="fn" id="qCountTrailingZeroBits-3" translate="no"><a name="qCountTrailingZeroBits-3"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qCountTrailingZeroBits</span>(<span class="type"><a href="./qtglobal.htm#quint64-typedef" translate="no">quint64</a></span> <i>v</i>)<a class="plink" href="#qCountTrailingZeroBits-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qCountTrailingZeroBits -->
<!-- $$$qDeleteAll[overload1]$$$qDeleteAllForwardIteratorForwardIterator -->
<h3 class="fn" id="qDeleteAll" translate="no"><a name="qDeleteAll"></a>template &lt;typename ForwardIterator&gt; <span class="type">void</span> <span class="name">qDeleteAll</span>(<span class="type">ForwardIterator</span> <i>begin</i>, <span class="type">ForwardIterator</span> <i>end</i>)<a class="plink" href="#qDeleteAll" title="Direct link to this headline"></a></h3>
<p>Deletes all the items in the range [<i translate="no">begin</i>, <i translate="no">end</i>) using the C++ <code translate="no">delete</code> operator. The item type must be a pointer type (for example, <code translate="no">QWidget *</code>).</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span>Employee <span class="operator">*</span><span class="operator">&gt;</span> list;
list<span class="operator">.</span>append(<span class="keyword">new</span> Employee(<span class="string">"Blackpool"</span><span class="operator">,</span> <span class="string">"Stephen"</span>));
list<span class="operator">.</span>append(<span class="keyword">new</span> Employee(<span class="string">"Twist"</span><span class="operator">,</span> <span class="string">"Oliver"</span>));

qDeleteAll(list<span class="operator">.</span>begin()<span class="operator">,</span> list<span class="operator">.</span>end());
list<span class="operator">.</span>clear();</pre></div>
<p>Notice that qDeleteAll() doesn't remove the items from the container; it merely calls <code translate="no">delete</code> on them. In the example above, we call clear() on the container to remove the items.</p>
<p>This function can also be used to delete items stored in associative containers, such as <a href="./qmap.htm" translate="no">QMap</a> and <a href="./qhash.htm#qhash" translate="no">QHash</a>. Only the objects stored in each container will be deleted by this function; objects used as keys will not be deleted.</p>
<p><b>See also </b><a href="./qtalgorithms.htm#forward-iterators" translate="no">forward iterators</a>.</p>
<!-- @@@qDeleteAll -->
<!-- $$$qDeleteAll$$$qDeleteAllconstContainer& -->
<h3 class="fn" id="qDeleteAll-1" translate="no"><a name="qDeleteAll-1"></a>template &lt;typename Container&gt; <span class="type">void</span> <span class="name">qDeleteAll</span>(const <span class="type">Container</span> &amp;<i>c</i>)<a class="plink" href="#qDeleteAll-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This is the same as qDeleteAll(<i translate="no">c</i>.begin(), <i translate="no">c</i>.end()).</p>
<!-- @@@qDeleteAll -->
<!-- $$$qPopulationCount[overload1]$$$qPopulationCountquint8 -->
<h3 class="fn" id="qPopulationCount" translate="no"><a name="qPopulationCount"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="./qtglobal.htm#quint8-typedef" translate="no">quint8</a></span> <i>v</i>)<a class="plink" href="#qPopulationCount" title="Direct link to this headline"></a></h3>
<p>Returns the number of bits set in <i translate="no">v</i>. This number is also called the Hamming Weight of <i translate="no">v</i>.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@qPopulationCount -->
<!-- $$$qPopulationCount$$$qPopulationCountquint32 -->
<h3 class="fn" id="qPopulationCount-1" translate="no"><a name="qPopulationCount-1"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="./qtglobal.htm#quint32-typedef" translate="no">quint32</a></span> <i>v</i>)<a class="plink" href="#qPopulationCount-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@qPopulationCount -->
<!-- $$$qPopulationCount$$$qPopulationCountquint16 -->
<h3 class="fn" id="qPopulationCount-2" translate="no"><a name="qPopulationCount-2"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <i>v</i>)<a class="plink" href="#qPopulationCount-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@qPopulationCount -->
<!-- $$$qPopulationCount$$$qPopulationCountquint64 -->
<h3 class="fn" id="qPopulationCount-3" translate="no"><a name="qPopulationCount-3"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qPopulationCount</span>(<span class="type"><a href="./qtglobal.htm#quint64-typedef" translate="no">quint64</a></span> <i>v</i>)<a class="plink" href="#qPopulationCount-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@qPopulationCount -->
<!-- $$$qSwap[overload1]$$$qSwapT&T& -->
<h3 class="fn" id="qSwap" translate="no"><a name="qSwap"></a>template &lt;typename T&gt; <span class="type">void</span> <span class="name">qSwap</span>(<span class="type">T</span> &amp;<i>var1</i>, <span class="type">T</span> &amp;<i>var2</i>)<a class="plink" href="#qSwap" title="Direct link to this headline"></a></h3>
<p>Exchanges the values of variables <i translate="no">lhs</i> and <i translate="no">rhs</i>, taking type-specific <code translate="no">swap()</code> overloads into account.</p>
<p>This function is Qt's version of <a href="https://www.boost.org/doc/libs/release/libs/core/doc/html/core/swap.html" translate="no"><code translate="no">boost::swap()</code></a>, and is equivalent to</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">using</span> std<span class="operator">::</span>swap;   <span class="comment">// bring std::swap into scope (for built-in types)</span>
swap(lhs<span class="operator">,</span> rhs);    <span class="comment">// unqualified call (picks up type-specific overloads</span>
                   <span class="comment">// via Argument-Dependent Lookup, or falls back to std::swap)</span></pre></div>
<p>Use this function primarily in generic code, where you would traditionally have written the above two lines, because you don't know anything about <code translate="no">T</code>.</p>
<p>If you already know what <code translate="no">T</code> is, then use one of the following options, in order of preference:</p>
<ul>
<li><code translate="no">lhs.swap(rhs);</code> if such a member-swap exists</li>
<li><code translate="no">std::swap(lhs, rhs);</code> if no type-specific <code translate="no">swap()</code> exists</li>
</ul>
<p>See <a href="https://www.boost.org/doc/libs/release/libs/core/doc/html/core/swap.html" translate="no"><code translate="no">boost::swap()</code> on boost.org</a> for more details.</p>
<p>See also <a href="https://en.cppreference.com/w/cpp/algorithm/swap" translate="no"><code translate="no">std::swap</code> on cppreference.com</a>, <a href="https://en.cppreference.com/w/cpp/named_req/Swappable" translate="no"><code translate="no">Swappable</code> on cppreference.com</a>.</p>
<!-- @@@qSwap -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>