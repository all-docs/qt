<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Plug &amp; Paint Example | Qt Widgets</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtwidgets-index.htm" translate="no">Qt Widgets</a></li>
                            <li><a>Plug &amp; Paint Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Plug &amp; Paint Example</h1>
<span class="subtitle"></span>
<!-- $$$tools/plugandpaint/app-brief -->
<p>Demonstrates how to extend Qt applications using plugins.</p>
<!-- @@@tools/plugandpaint/app -->
<!-- $$$tools/plugandpaint/app-description -->
<div class="descr"> <a name="details"></a>
<p class="centerAlign"><img alt="Screenshot of the Plug &amp; Paint example" src="./images/plugandpaint.png"></p><p>A plugin is a dynamic library that can be loaded at run-time to extend an application. Qt makes it possible to create custom plugins and to load them using <a href="./qpluginloader.htm" translate="no">QPluginLoader</a>. To ensure that plugins don't get lost, it is also possible to link them statically to the executable. The Plug &amp; Paint example uses plugins to support custom brushes, shapes, and image filters. A single plugin can provide multiple brushes, shapes, and/or filters.</p>
<p>If you want to learn how to make your own application extensible through plugins, we recommend that you start by reading this overview, which explains how to make an application use plugins. Afterwards, you can read the <a href="./qtwidgets-tools-plugandpaint-plugins-basictools-example.htm" translate="no">Basic Tools</a> and <a href="./qtwidgets-tools-plugandpaint-plugins-extrafilters-example.htm" translate="no">Extra Filters</a> overviews, which show how to implement static and dynamic plugins, respectively.</p>
<p>Plug &amp; Paint consists of the following classes:</p>
<ul>
<li><code translate="no">MainWindow</code> is a <a href="./qmainwindow.htm" translate="no">QMainWindow</a> subclass that provides the menu system and that contains a <code translate="no">PaintArea</code> as the central widget.</li>
<li><code translate="no">PaintArea</code> is a <a href="./qwidget.htm" translate="no">QWidget</a> that allows the user to draw using a brush and to insert shapes.</li>
<li><code translate="no">PluginDialog</code> is a dialog that shows information about the plugins detected by the application.</li>
<li><code translate="no">BrushInterface</code>, <code translate="no">ShapeInterface</code>, and <code translate="no">FilterInterface</code> are abstract base classes that can be implemented by plugins to provide custom brushes, shapes, and image filters.</li>
</ul>
<a name="the-plugin-interfaces"></a>
<h4 id="the-plugin-interfaces">The Plugin Interfaces<a class="plink" href="#the-plugin-interfaces" title="Direct link to this headline"></a></h4>
<p>We will start by reviewing the interfaces defined in <code translate="no">interfaces.h</code>. These interfaces are used by the Plug &amp; Paint application to access extra functionality. They are implemented in the plugins.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> BrushInterface
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="operator">~</span>BrushInterface() <span class="operator">=</span> <span class="keyword">default</span>;

    <span class="keyword">virtual</span> <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> brushes() <span class="keyword">const</span> <span class="operator">=</span> <span class="number">0</span>;
    <span class="keyword">virtual</span> <span class="type"><a href="./qrect.htm" translate="no">QRect</a></span> mousePress(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>brush<span class="operator">,</span> <span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">&amp;</span>painter<span class="operator">,</span>
                             <span class="keyword">const</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> <span class="operator">&amp;</span>pos) <span class="operator">=</span> <span class="number">0</span>;
    <span class="keyword">virtual</span> <span class="type"><a href="./qrect.htm" translate="no">QRect</a></span> mouseMove(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>brush<span class="operator">,</span> <span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">&amp;</span>painter<span class="operator">,</span>
                            <span class="keyword">const</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> <span class="operator">&amp;</span>oldPos<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> <span class="operator">&amp;</span>newPos) <span class="operator">=</span> <span class="number">0</span>;
    <span class="keyword">virtual</span> <span class="type"><a href="./qrect.htm" translate="no">QRect</a></span> mouseRelease(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>brush<span class="operator">,</span> <span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> <span class="operator">&amp;</span>painter<span class="operator">,</span>
                               <span class="keyword">const</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> <span class="operator">&amp;</span>pos) <span class="operator">=</span> <span class="number">0</span>;
};</pre></div>
<p>The <code translate="no">BrushInterface</code> class declares four pure virtual functions. The first pure virtual function, <code translate="no">brushes()</code>, returns a list of strings that identify the brushes provided by the plugin. By returning a <a href="./qstringlist.htm" translate="no">QStringList</a> instead of a <a href="./qstring.htm" translate="no">QString</a>, we make it possible for a single plugin to provide multiple brushes. The other functions have a <code translate="no">brush</code> parameter to identify which brush (among those returned by <code translate="no">brushes()</code>) is used.</p>
<p><code translate="no">mousePress()</code>, <code translate="no">mouseMove()</code>, and <code translate="no">mouseRelease()</code> take a <a href="./qpainter.htm" translate="no">QPainter</a> and one or two <a href="./qpoint.htm" translate="no">QPoint</a>s, and return a <a href="./qrect.htm" translate="no">QRect</a> identifying which portion of the image was altered by the brush.</p>
<p>The class also has a virtual destructor. Interface classes usually don't need such a destructor (because it would make little sense to <code translate="no">delete</code> the object that implements the interface through a pointer to the interface), but some compilers emit a warning for classes that declare virtual functions but no virtual destructor. We provide the destructor to keep these compilers happy.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> ShapeInterface
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="operator">~</span>ShapeInterface() <span class="operator">=</span> <span class="keyword">default</span>;

    <span class="keyword">virtual</span> <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> shapes() <span class="keyword">const</span> <span class="operator">=</span> <span class="number">0</span>;
    <span class="keyword">virtual</span> <span class="type"><a href="./qpainterpath.htm" translate="no">QPainterPath</a></span> generateShape(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>shape<span class="operator">,</span>
                                       <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>parent) <span class="operator">=</span> <span class="number">0</span>;
};</pre></div>
<p>The <code translate="no">ShapeInterface</code> class declares a <code translate="no">shapes()</code> function that works the same as <code translate="no">BrushInterface</code>'s <code translate="no">brushes()</code> function, and a <code translate="no">generateShape()</code> function that has a <code translate="no">shape</code> parameter. Shapes are represented by a <a href="./qpainterpath.htm" translate="no">QPainterPath</a>, a data type that can represent arbitrary 2D shapes or combinations of shapes. The <code translate="no">parent</code> parameter can be used by the plugin to pop up a dialog asking the user to specify more information.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> FilterInterface
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> <span class="operator">~</span>FilterInterface() <span class="operator">=</span> <span class="keyword">default</span>;

    <span class="keyword">virtual</span> <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> filters() <span class="keyword">const</span> <span class="operator">=</span> <span class="number">0</span>;
    <span class="keyword">virtual</span> <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> filterImage(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>filter<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> <span class="operator">&amp;</span>image<span class="operator">,</span>
                               <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span>parent) <span class="operator">=</span> <span class="number">0</span>;
};</pre></div>
<p>The <code translate="no">FilterInterface</code> class declares a <code translate="no">filters()</code> function that returns a list of filter names, and a <code translate="no">filterImage()</code> function that applies a filter to an image.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor">#define BrushInterface_iid "org.qt-project.Qt.Examples.PlugAndPaint.BrushInterface/1.0"</span>

Q_DECLARE_INTERFACE(BrushInterface<span class="operator">,</span> BrushInterface_iid)

<span class="preprocessor">#define ShapeInterface_iid  "org.qt-project.Qt.Examples.PlugAndPaint.ShapeInterface/1.0"</span>

Q_DECLARE_INTERFACE(ShapeInterface<span class="operator">,</span> ShapeInterface_iid)
<span class="preprocessor">#define FilterInterface_iid "org.qt-project.Qt.Examples.PlugAndPaint.FilterInterface/1.0"</span>

Q_DECLARE_INTERFACE(FilterInterface<span class="operator">,</span> FilterInterface_iid)</pre></div>
<p>To make it possible to query at run-time whether a plugin implements a given interface, we must use the <code translate="no">Q_DECLARE_INTERFACE()</code> macro. The first argument is the name of the interface. The second argument is a string identifying the interface in a unique way. By convention, we use a "Java package name" syntax to identify interfaces. If we later change the interfaces, we must use a different string to identify the new interface; otherwise, the application might crash. It is therefore a good idea to include a version number in the string, as we did above.</p>
<p>The <a href="./qtwidgets-tools-plugandpaint-plugins-basictools-example.htm" translate="no">Basic Tools</a> plugin and the <a href="./qtwidgets-tools-plugandpaint-plugins-extrafilters-example.htm" translate="no">Extra Filters</a> plugin shows how to derive from <code translate="no">BrushInterface</code>, <code translate="no">ShapeInterface</code>, and <code translate="no">FilterInterface</code>.</p>
<p>A note on naming: It might have been tempting to give the <code translate="no">brushes()</code>, <code translate="no">shapes()</code>, and <code translate="no">filters()</code> functions a more generic name, such as <code translate="no">keys()</code> or <code translate="no">features()</code>. However, that would have made multiple inheritance impractical. When creating interfaces, we should always try to give unique names to the pure virtual functions.</p>
<a name="the-mainwindow-class"></a>
<h4 id="the-mainwindow-class">The MainWindow Class<a class="plink" href="#the-mainwindow-class" title="Direct link to this headline"></a></h4>
<p>The <code translate="no">MainWindow</code> class is a standard <a href="./qmainwindow.htm" translate="no">QMainWindow</a> subclass, as found in many of the other examples (e.g., <a href="./qtwidgets-mainwindows-application-example.htm" translate="no">Application</a>). Here, we'll concentrate on the parts of the code that are related to plugins.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> MainWindow<span class="operator">::</span>loadPlugins()
{
    <span class="keyword">const</span> <span class="keyword">auto</span> staticInstances <span class="operator">=</span> <span class="type"><a href="./qpluginloader.htm" translate="no">QPluginLoader</a></span><span class="operator">::</span>staticInstances();
    <span class="keyword">for</span> (<span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>plugin : staticInstances)
        populateMenus(plugin);</pre></div>
<p>The <code translate="no">loadPlugins()</code> function is called from the <code translate="no">MainWindow</code> constructor to detect plugins and update the <b translate="no">Brush</b>, <b translate="no">Shapes</b>, and <b translate="no">Filters</b> menus. We start by handling static plugins (available through <a href="./qpluginloader.htm#staticInstances" translate="no">QPluginLoader::staticInstances</a>())</p>
<p>To the application that uses the plugin, a Qt plugin is simply a <a href="./qobject.htm" translate="no">QObject</a>. That <a href="./qobject.htm" translate="no">QObject</a> implements plugin interfaces using multiple inheritance.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    pluginsDir <span class="operator">=</span> <span class="type"><a href="./qdir.htm" translate="no">QDir</a></span>(<span class="type"><a href="./qcoreapplication.htm" translate="no">QCoreApplication</a></span><span class="operator">::</span>applicationDirPath());

<span class="preprocessor">#if defined(Q_OS_WIN)</span>
    <span class="keyword">if</span> (pluginsDir<span class="operator">.</span>dirName()<span class="operator">.</span>toLower() <span class="operator">=</span><span class="operator">=</span> <span class="string">"debug"</span> <span class="operator">|</span><span class="operator">|</span> pluginsDir<span class="operator">.</span>dirName()<span class="operator">.</span>toLower() <span class="operator">=</span><span class="operator">=</span> <span class="string">"release"</span>)
        pluginsDir<span class="operator">.</span>cdUp();
<span class="preprocessor">#elif defined(Q_OS_MAC)</span>
    <span class="keyword">if</span> (pluginsDir<span class="operator">.</span>dirName() <span class="operator">=</span><span class="operator">=</span> <span class="string">"MacOS"</span>) {
        pluginsDir<span class="operator">.</span>cdUp();
        pluginsDir<span class="operator">.</span>cdUp();
        pluginsDir<span class="operator">.</span>cdUp();
    }
<span class="preprocessor">#endif</span>
    pluginsDir<span class="operator">.</span>cd(<span class="string">"plugins"</span>);</pre></div>
<p>The next step is to load dynamic plugins. We initialize the <code translate="no">pluginsDir</code> member variable to refer to the <code translate="no">plugins</code> subdirectory of the Plug &amp; Paint example. On Unix, this is just a matter of initializing the <a href="./qdir.htm" translate="no">QDir</a> variable with <a href="./qcoreapplication.htm#applicationDirPath" translate="no">QApplication::applicationDirPath</a>(), the path of the executable file, and to do a <a href="./qdir.htm#cd" translate="no">cd()</a>. On Windows and macOS, this file is usually located in a subdirectory, so we need to take this into account.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="keyword">const</span> <span class="keyword">auto</span> entryList <span class="operator">=</span> pluginsDir<span class="operator">.</span>entryList(<span class="type"><a href="./qdir.htm" translate="no">QDir</a></span><span class="operator">::</span>Files);
    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>fileName : entryList) {
        <span class="type"><a href="./qpluginloader.htm" translate="no">QPluginLoader</a></span> loader(pluginsDir<span class="operator">.</span>absoluteFilePath(fileName));
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>plugin <span class="operator">=</span> loader<span class="operator">.</span>instance();
        <span class="keyword">if</span> (plugin) {
            populateMenus(plugin);
            pluginFileNames <span class="operator">+</span><span class="operator">=</span> fileName;
        }
    }</pre></div>
<p>We use <a href="./qdir.htm#entryList" translate="no">QDir::entryList</a>() to get a list of all files in that directory. Then we iterate over the result using a range-based for loop and try to load the plugin using <a href="./qpluginloader.htm" translate="no">QPluginLoader</a>.</p>
<p>The <a href="./qobject.htm" translate="no">QObject</a> provided by the plugin is accessible through <a href="./qpluginloader.htm#instance" translate="no">QPluginLoader::instance</a>(). If the dynamic library isn't a Qt plugin, or if it was compiled against an incompatible version of the Qt library, <a href="./qpluginloader.htm#instance" translate="no">QPluginLoader::instance</a>() returns a null pointer.</p>
<p>If <a href="./qpluginloader.htm#instance" translate="no">QPluginLoader::instance</a>() is non-null, we add it to the menus.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    brushMenu<span class="operator">-</span><span class="operator">&gt;</span>setEnabled(<span class="operator">!</span>brushActionGroup<span class="operator">-</span><span class="operator">&gt;</span>actions()<span class="operator">.</span>isEmpty());
    shapesMenu<span class="operator">-</span><span class="operator">&gt;</span>setEnabled(<span class="operator">!</span>shapesMenu<span class="operator">-</span><span class="operator">&gt;</span>actions()<span class="operator">.</span>isEmpty());
    filterMenu<span class="operator">-</span><span class="operator">&gt;</span>setEnabled(<span class="operator">!</span>filterMenu<span class="operator">-</span><span class="operator">&gt;</span>actions()<span class="operator">.</span>isEmpty());
}</pre></div>
<p>At the end, we enable or disable the <b translate="no">Brush</b>, <b translate="no">Shapes</b>, and <b translate="no">Filters</b> menus based on whether they contain any items.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> MainWindow<span class="operator">::</span>populateMenus(<span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>plugin)
{
    <span class="keyword">auto</span> iBrush <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>BrushInterface <span class="operator">*</span><span class="operator">&gt;</span>(plugin);
    <span class="keyword">if</span> (iBrush)
        addToMenu(plugin<span class="operator">,</span> iBrush<span class="operator">-</span><span class="operator">&gt;</span>brushes()<span class="operator">,</span> brushMenu<span class="operator">,</span> <span class="operator">&amp;</span>MainWindow<span class="operator">::</span>changeBrush<span class="operator">,</span>
                  brushActionGroup);

    <span class="keyword">auto</span> iShape <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>ShapeInterface <span class="operator">*</span><span class="operator">&gt;</span>(plugin);
    <span class="keyword">if</span> (iShape)
        addToMenu(plugin<span class="operator">,</span> iShape<span class="operator">-</span><span class="operator">&gt;</span>shapes()<span class="operator">,</span> shapesMenu<span class="operator">,</span> <span class="operator">&amp;</span>MainWindow<span class="operator">::</span>insertShape);

    <span class="keyword">auto</span> iFilter <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>FilterInterface <span class="operator">*</span><span class="operator">&gt;</span>(plugin);
    <span class="keyword">if</span> (iFilter)
        addToMenu(plugin<span class="operator">,</span> iFilter<span class="operator">-</span><span class="operator">&gt;</span>filters()<span class="operator">,</span> filterMenu<span class="operator">,</span> <span class="operator">&amp;</span>MainWindow<span class="operator">::</span>applyFilter);
}</pre></div>
<p>For each plugin (static or dynamic), we check which interfaces it implements using <a href="./qobject.htm#qobject_cast" translate="no">qobject_cast</a>(). First, we try to cast the plugin instance to a <code translate="no">BrushInterface</code>; if it works, we call the private function <code translate="no">addToMenu()</code> with the list of brushes returned by <code translate="no">brushes()</code>. Then we do the same with the <code translate="no">ShapeInterface</code> and the <code translate="no">FilterInterface</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> MainWindow<span class="operator">::</span>aboutPlugins()
{
    PluginDialog dialog(pluginsDir<span class="operator">.</span>path()<span class="operator">,</span> pluginFileNames<span class="operator">,</span> <span class="keyword">this</span>);
    dialog<span class="operator">.</span>exec();
}</pre></div>
<p>The <code translate="no">aboutPlugins()</code> slot is called on startup and can be invoked at any time through the <b translate="no">About Plugins</b> action. It pops up a <code translate="no">PluginDialog</code>, providing information about the loaded plugins.</p>
<p class="centerAlign"><img alt="Screenshot of the Plugin dialog" src="./images/plugandpaint-plugindialog.png"></p><p>The <code translate="no">addToMenu()</code> function is called from <code translate="no">loadPlugin()</code> to create <a href="./qaction.htm" translate="no">QAction</a>s for custom brushes, shapes, or filters and add them to the relevant menu. The <a href="./qaction.htm" translate="no">QAction</a> is created with the plugin from which it comes from as the parent; this makes it convenient to get access to the plugin later.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> MainWindow<span class="operator">::</span>changeBrush()
{
    <span class="keyword">auto</span> action <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qaction.htm" translate="no">QAction</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(sender());
    <span class="keyword">if</span> (<span class="operator">!</span>action)
      <span class="keyword">return</span>;
    <span class="keyword">auto</span> iBrush <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>BrushInterface <span class="operator">*</span><span class="operator">&gt;</span>(action<span class="operator">-</span><span class="operator">&gt;</span>parent());
    <span class="keyword">if</span> (<span class="operator">!</span>iBrush)
      <span class="keyword">return</span>;
    <span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> brush <span class="operator">=</span> action<span class="operator">-</span><span class="operator">&gt;</span>text();

    paintArea<span class="operator">-</span><span class="operator">&gt;</span>setBrush(iBrush<span class="operator">,</span> brush);
}</pre></div>
<p>The <code translate="no">changeBrush()</code> slot is invoked when the user chooses one of the brushes from the <b translate="no">Brush</b> menu. We start by finding out which action invoked the slot using <a href="./qobject.htm#sender" translate="no">QObject::sender</a>(). Then we get the <code translate="no">BrushInterface</code> out of the plugin (which we conveniently passed as the <a href="./qaction.htm" translate="no">QAction</a>'s parent) and we call <code translate="no">PaintArea::setBrush()</code> with the <code translate="no">BrushInterface</code> and the string identifying the brush. Next time the user draws on the paint area, <code translate="no">PaintArea</code> will use this brush.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> MainWindow<span class="operator">::</span>insertShape()
{
    <span class="keyword">auto</span> action <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qaction.htm" translate="no">QAction</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(sender());
    <span class="keyword">if</span> (<span class="operator">!</span>action)
      <span class="keyword">return</span>;
    <span class="keyword">auto</span> iShape <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>ShapeInterface <span class="operator">*</span><span class="operator">&gt;</span>(action<span class="operator">-</span><span class="operator">&gt;</span>parent());
    <span class="keyword">if</span> (<span class="operator">!</span>iShape)
      <span class="keyword">return</span>;

    <span class="keyword">const</span> <span class="type"><a href="./qpainterpath.htm" translate="no">QPainterPath</a></span> path <span class="operator">=</span> iShape<span class="operator">-</span><span class="operator">&gt;</span>generateShape(action<span class="operator">-</span><span class="operator">&gt;</span>text()<span class="operator">,</span> <span class="keyword">this</span>);
    <span class="keyword">if</span> (<span class="operator">!</span>path<span class="operator">.</span>isEmpty())
        paintArea<span class="operator">-</span><span class="operator">&gt;</span>insertShape(path);
}</pre></div>
<p>The <code translate="no">insertShape()</code> is invoked when the use chooses one of the shapes from the <b translate="no">Shapes</b> menu. We retrieve the <a href="./qaction.htm" translate="no">QAction</a> that invoked the slot, then the <code translate="no">ShapeInterface</code> associated with that <a href="./qaction.htm" translate="no">QAction</a>, and finally we call <code translate="no">ShapeInterface::generateShape()</code> to obtain a <a href="./qpainterpath.htm" translate="no">QPainterPath</a>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> MainWindow<span class="operator">::</span>applyFilter()
{
    <span class="keyword">auto</span> action <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="./qaction.htm" translate="no">QAction</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(sender());
    <span class="keyword">if</span> (<span class="operator">!</span>action)
      <span class="keyword">return</span>;
    <span class="keyword">auto</span> iFilter <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>FilterInterface <span class="operator">*</span><span class="operator">&gt;</span>(action<span class="operator">-</span><span class="operator">&gt;</span>parent());
    <span class="keyword">if</span> (<span class="operator">!</span>iFilter)
      <span class="keyword">return</span>;

    <span class="keyword">const</span> <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> image <span class="operator">=</span> iFilter<span class="operator">-</span><span class="operator">&gt;</span>filterImage(action<span class="operator">-</span><span class="operator">&gt;</span>text()<span class="operator">,</span> paintArea<span class="operator">-</span><span class="operator">&gt;</span>image()<span class="operator">,</span>
                                              <span class="keyword">this</span>);
    paintArea<span class="operator">-</span><span class="operator">&gt;</span>setImage(image);
}</pre></div>
<p>The <code translate="no">applyFilter()</code> slot is similar: We retrieve the <a href="./qaction.htm" translate="no">QAction</a> that invoked the slot, then the <code translate="no">FilterInterface</code> associated to that <a href="./qaction.htm" translate="no">QAction</a>, and finally we call <code translate="no">FilterInterface::filterImage()</code> to apply the filter onto the current image.</p>
<a name="the-paintarea-class"></a>
<h4 id="the-paintarea-class">The PaintArea Class<a class="plink" href="#the-paintarea-class" title="Direct link to this headline"></a></h4>
<p>The <code translate="no">PaintArea</code> class contains some code that deals with <code translate="no">BrushInterface</code>, so we'll review it briefly.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> PaintArea<span class="operator">::</span>setBrush(BrushInterface <span class="operator">*</span>brushInterface<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>brush)
{
    <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>brushInterface <span class="operator">=</span> brushInterface;
    <span class="keyword">this</span><span class="operator">-</span><span class="operator">&gt;</span>brush <span class="operator">=</span> brush;
}</pre></div>
<p>In <code translate="no">setBrush()</code>, we simply store the <code translate="no">BrushInterface</code> and the brush that are given to us by <code translate="no">MainWindow</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> PaintArea<span class="operator">::</span>mouseMoveEvent(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> <span class="operator">*</span>event)
{
    <span class="keyword">if</span> ((event<span class="operator">-</span><span class="operator">&gt;</span>buttons() <span class="operator">&amp;</span> <span class="type"><a href="./qt.htm" translate="no">Qt</a></span><span class="operator">::</span>LeftButton) <span class="operator">&amp;</span><span class="operator">&amp;</span> lastPos <span class="operator">!</span><span class="operator">=</span> <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span>(<span class="operator">-</span><span class="number">1</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span>)) {
        <span class="keyword">if</span> (brushInterface) {
            <span class="type"><a href="./qpainter.htm" translate="no">QPainter</a></span> painter(<span class="operator">&amp;</span>theImage);
            setupPainter(painter);
            <span class="keyword">const</span> <span class="type"><a href="./qrect.htm" translate="no">QRect</a></span> rect <span class="operator">=</span> brushInterface<span class="operator">-</span><span class="operator">&gt;</span>mouseMove(brush<span class="operator">,</span> painter<span class="operator">,</span> lastPos<span class="operator">,</span>
                                                         event<span class="operator">-</span><span class="operator">&gt;</span>pos());
            update(rect);
        }

        lastPos <span class="operator">=</span> event<span class="operator">-</span><span class="operator">&gt;</span>pos();
    }
}</pre></div>
<p>In the <a href="./qwidget.htm#mouseMoveEvent" translate="no">mouse move event handler</a>, we call the <code translate="no">BrushInterface::mouseMove()</code> function on the current <code translate="no">BrushInterface</code>, with the current brush. The mouse press and mouse release handlers are very similar.</p>
<a name="the-plugindialog-class"></a>
<h4 id="the-plugindialog-class">The PluginDialog Class<a class="plink" href="#the-plugindialog-class" title="Direct link to this headline"></a></h4>
<p>The <code translate="no">PluginDialog</code> class provides information about the loaded plugins to the user. Its constructor takes a path to the plugins and a list of plugin file names. It calls <code translate="no">findPlugins()</code> to fill the QTreeWdiget with information about the plugins:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> PluginDialog<span class="operator">::</span>findPlugins(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>path<span class="operator">,</span>
                               <span class="keyword">const</span> <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> <span class="operator">&amp;</span>fileNames)
{
    label<span class="operator">-</span><span class="operator">&gt;</span>setText(tr(<span class="string">"Plug &amp; Paint found the following plugins\n"</span>
                      <span class="string">"(looked in %1):"</span>)
                   <span class="operator">.</span>arg(<span class="type"><a href="./qdir.htm" translate="no">QDir</a></span><span class="operator">::</span>toNativeSeparators(path)));

    <span class="keyword">const</span> <span class="type"><a href="./qdir.htm" translate="no">QDir</a></span> dir(path);

    <span class="keyword">const</span> <span class="keyword">auto</span> staticInstances <span class="operator">=</span> <span class="type"><a href="./qpluginloader.htm" translate="no">QPluginLoader</a></span><span class="operator">::</span>staticInstances();
    <span class="keyword">for</span> (<span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>plugin : staticInstances)
        populateTreeWidget(plugin<span class="operator">,</span> tr(<span class="string">"%1 (Static Plugin)"</span>)
                                   <span class="operator">.</span>arg(plugin<span class="operator">-</span><span class="operator">&gt;</span>metaObject()<span class="operator">-</span><span class="operator">&gt;</span>className()));

    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>fileName : fileNames) {
        <span class="type"><a href="./qpluginloader.htm" translate="no">QPluginLoader</a></span> loader(dir<span class="operator">.</span>absoluteFilePath(fileName));
        <span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>plugin <span class="operator">=</span> loader<span class="operator">.</span>instance();
        <span class="keyword">if</span> (plugin)
            populateTreeWidget(plugin<span class="operator">,</span> fileName);
    }
}</pre></div>
<p>The <code translate="no">findPlugins()</code> is very similar to <code translate="no">MainWindow::loadPlugins()</code>. It uses <a href="./qpluginloader.htm" translate="no">QPluginLoader</a> to access the static and dynamic plugins. Its helper function <code translate="no">populateTreeWidget()</code> uses <a href="./qobject.htm#qobject_cast" translate="no">qobject_cast</a>() to find out which interfaces are implemented by the plugins:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> PluginDialog<span class="operator">::</span>populateTreeWidget(<span class="type"><a href="./qobject.htm" translate="no">QObject</a></span> <span class="operator">*</span>plugin<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>text)
{
    <span class="keyword">auto</span> pluginItem <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qtreewidgetitem.htm" translate="no">QTreeWidgetItem</a></span>(treeWidget);
    pluginItem<span class="operator">-</span><span class="operator">&gt;</span>setText(<span class="number">0</span><span class="operator">,</span> text);
    pluginItem<span class="operator">-</span><span class="operator">&gt;</span>setExpanded(<span class="keyword">true</span>);

    <span class="type"><a href="./qfont.htm" translate="no">QFont</a></span> boldFont <span class="operator">=</span> pluginItem<span class="operator">-</span><span class="operator">&gt;</span>font(<span class="number">0</span>);
    boldFont<span class="operator">.</span>setBold(<span class="keyword">true</span>);
    pluginItem<span class="operator">-</span><span class="operator">&gt;</span>setFont(<span class="number">0</span><span class="operator">,</span> boldFont);

    <span class="keyword">if</span> (plugin) {
        <span class="keyword">auto</span> iBrush <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>BrushInterface <span class="operator">*</span><span class="operator">&gt;</span>(plugin);
        <span class="keyword">if</span> (iBrush)
            addItems(pluginItem<span class="operator">,</span> <span class="string">"BrushInterface"</span><span class="operator">,</span> iBrush<span class="operator">-</span><span class="operator">&gt;</span>brushes());

        <span class="keyword">auto</span> iShape <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>ShapeInterface <span class="operator">*</span><span class="operator">&gt;</span>(plugin);
        <span class="keyword">if</span> (iShape)
            addItems(pluginItem<span class="operator">,</span> <span class="string">"ShapeInterface"</span><span class="operator">,</span> iShape<span class="operator">-</span><span class="operator">&gt;</span>shapes());

        <span class="keyword">auto</span> iFilter <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span>FilterInterface <span class="operator">*</span><span class="operator">&gt;</span>(plugin);
        <span class="keyword">if</span> (iFilter)
            addItems(pluginItem<span class="operator">,</span> <span class="string">"FilterInterface"</span><span class="operator">,</span> iFilter<span class="operator">-</span><span class="operator">&gt;</span>filters());
    }
}</pre></div>
<a name="importing-static-plugins"></a>
<h4 id="importing-static-plugins">Importing Static Plugins<a class="plink" href="#importing-static-plugins" title="Direct link to this headline"></a></h4>
<p>The <a href="./qtwidgets-tools-plugandpaint-plugins-basictools-example.htm" translate="no">Basic Tools</a> plugin is built as a static plugin, to ensure that it is always available to the application. This requires using the <a href="./qtplugin.htm#Q_IMPORT_PLUGIN" translate="no">Q_IMPORT_PLUGIN</a>() macro somewhere in the application (in a <code translate="no">.cpp</code> file) and specifying the plugin in the <code translate="no">.pro</code> file.</p>
<p>For Plug &amp; Paint, we have chosen to put <a href="./qtplugin.htm#Q_IMPORT_PLUGIN" translate="no">Q_IMPORT_PLUGIN</a>() in <code translate="no">main.cpp</code>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor">#include "mainwindow.h"</span>

<span class="preprocessor">#include &lt;QApplication&gt;</span>
<span class="preprocessor">#include &lt;QtPlugin&gt;</span>

Q_IMPORT_PLUGIN(BasicToolsPlugin)

<span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
{
    <span class="type"><a href="./qapplication.htm" translate="no">QApplication</a></span> app(argc<span class="operator">,</span> argv);
    MainWindow window;
    window<span class="operator">.</span>show();
    <span class="keyword">return</span> app<span class="operator">.</span>exec();
}</pre></div>
<p>The argument to <a href="./qtplugin.htm#Q_IMPORT_PLUGIN" translate="no">Q_IMPORT_PLUGIN</a>() is the plugin name, which corresponds with the name of the class that declares metadata for the plugin with <a href="./qtplugin.htm#Q_PLUGIN_METADATA" translate="no">Q_PLUGIN_METADATA</a>().</p>
<p>In the <code translate="no">.pro</code> file, we need to specify the static library. Here's the project file for building Plug &amp; Paint:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">TARGET = plugandpaint
DESTDIR = ..

QT += widgets

HEADERS        = interfaces.h \
                 mainwindow.h \
                 paintarea.h \
                 plugindialog.h
SOURCES        = main.cpp \
                 mainwindow.cpp \
                 paintarea.cpp \
                 plugindialog.cpp

LIBS           = -L../plugins

macx-xcode {
    LIBS += -lpnp_basictools$($${QMAKE_XCODE_LIBRARY_SUFFIX_SETTING})
} else {
    android {
        LIBS += -lpnp_basictools_$${QT_ARCH}
    } else {
        LIBS += -lpnp_basictools
    }
    if(!debug_and_release|build_pass):CONFIG(debug, debug|release) {
        mac:LIBS = $$member(LIBS, 0) $$member(LIBS, 1)_debug
        win32:LIBS = $$member(LIBS, 0) $$member(LIBS, 1)d
    }
}</pre></div>
<p>The <code translate="no">LIBS</code> line variable specifies the library <code translate="no">pnp_basictools</code> located in the <code translate="no">../plugandpaint/plugins/basictools</code> directory. (Although the <code translate="no">LIBS</code> syntax has a distinct Unix flavor, <code translate="no">qmake</code> supports it on all platforms.)</p>
<p>The <code translate="no">CONFIG()</code> code at the end is necessary for this example because the example is part of the Qt distribution and Qt can be configured to be built simultaneously in debug and in release modes. You don't need to for your own plugin applications.</p>
<p>This completes our review of the Plug &amp; Paint application. At this point, you might want to take a look at the <a href="./qtwidgets-tools-plugandpaint-plugins-basictools-example.htm" translate="no">Basic Tools</a> example plugin.</p>
<p><a href="https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/tools/plugandpaint/app?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@tools/plugandpaint/app -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>