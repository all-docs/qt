<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Qt Quick 3D Custom Material Reference | Qt Quick 3D</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick3d-index.htm" translate="no">Qt Quick 3D</a></li>
                            <li class="last"><a>Qt Quick 3D Custom Material Reference</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Qt Quick 3D Custom Material Reference</h1>
<span class="subtitle"></span>
<!-- $$$custom-material-reference.html-description -->
<div class="descr"> <a name="details"></a>
<p>This page explains how to write custom material using the <a href="./qtquick3d-qmlmodule.htm" translate="no">QtQuick3D</a>.Materials material library interface.</p>
<a name="overview"></a>
<h2 id="overview">Overview<a class="plink" href="#overview" title="Direct link to this headline"></a></h2>
<p>The material specification lets you write custom materials and connect those to the lighting system. Each material must have a fragment shader that implements all the functions the library needs to calculate the shaded color. The material system also offers ready-made functions to help implementing the material. These functions can be accessed by the shader using <code translate="no">#include</code> directive with the name of the function.</p>
<p>The material system supports dielectric and transparent materials, point lights, area lights, ambient occlusion, shadowing, two-sided polygons, index-of-refraction, and fragment cutoff (masking).</p>
<p>It is also possible to write custom material without using the boilerplate code, in which case the main function must be implemented in the shader.</p>
<a name="required-functions"></a>
<h2 id="required-functions">Required Functions<a class="plink" href="#required-functions" title="Direct link to this headline"></a></h2>
<p>These are the functions each fragment shader must implement.</p>
<div class="pre"><pre class="cpp plain" translate="no">bool evalTwoSided()</pre></div>
<p>This function controls two-sided lighting. Return <code translate="no">true</code> to enable two-sided lighting and <code translate="no">false</code> to disable it. When two-sided lighting is disabled, only the front-facing material functions are called.</p>
<div class="pre"><pre class="cpp plain" translate="no">float computeIOR()</pre></div>
<p>This function is called to compute the index of refraction for the material. Return material index of refraction.</p>
<div class="pre"><pre class="cpp plain" translate="no">float evalCutout()</pre></div>
<p>This function is called when evaluating fragment cutoff (masking) value. The fragment is discarded if the value returned by this function is less than or equal to zero.</p>
<div class="pre"><pre class="cpp plain" translate="no">vec3 computeNormal()</pre></div>
<p>This function is used to calculate the normal for the fragment. Return the normal of the fragment.</p>
<div class="pre"><pre class="cpp plain" translate="no">void computeTemporaries()</pre></div>
<p>This function is called to calculate any temporary values needed by the material and it is called before any other function.</p>
<div class="pre"><pre class="cpp plain" translate="no">void initializeLayerVariables()</pre></div>
<p>This function is called to initialize layer parameters for the material. User should initialize variables to store the lighting values to be computed in the <code translate="no">computeFrontLayerColor</code>, <code translate="no">computeFrontAreaColor</code>, <code translate="no">computeFrontLayerEnvironment</code>, <code translate="no">computeBackLayerColor</code>, <code translate="no">computeBackAreaColor</code>, and <code translate="no">computeBackLayerEnvironment</code>.</p>
<div class="pre"><pre class="cpp plain" translate="no">void initializeLayerVariablesWithLightmap()</pre></div>
<p>This function is called to allow the material to initialize layer parameters.</p>
<div class="admonition note">
<p><b>Note: </b>This function is optional and gets called only if the material uses lightmaps.</p>
</div>
<div class="pre"><pre class="cpp plain" translate="no">vec3 computeFrontMaterialEmissive()</pre></div>
<p>This function is called when the material calculates the Emissive component of the material for the front-facing polygon. Return vec3 RGB emissive value.</p>
<div class="pre"><pre class="cpp plain" translate="no">vec3 computeBackMaterialEmissive()</pre></div>
<p>This function is called when the material calculates the Emissive component of the material for the back-facing polygon. Return vec3 RGB emissive value.</p>
<div class="pre"><pre class="cpp plain" translate="no">void computeFrontLayerColor( in vec3 normal, in vec3 lightDir, in vec3 viewDir,
                             in vec3 lightDiffuse, in vec3 lightSpecular,
                             in float materialIOR, in float aoFactor )</pre></div>
<p>This function is called for every light (excluding area lights) for the front-facing polygon. The material can write its own lighting model or use the provided functions. The functions available for use are <code translate="no">microfacetBSDF</code>, <code translate="no">physGlossyBSDF</code>, and <code translate="no">simpleGlossyBSDF</code>. The <code translate="no">normal</code> is the fragment normal. The <code translate="no">lightDir</code> is the normalized vector from fragment to light in world space.</p>
<div class="pre"><pre class="cpp plain" translate="no">void computeFrontAreaColor( in int lightIdx, in vec4 lightDiffuse, in vec4 lightSpecular )</pre></div>
<p>This function is called for every area light for the front-facing polygon.</p>
<div class="pre"><pre class="cpp plain" translate="no">void computeFrontLayerEnvironment( in vec3 normal, in vec3 viewDir, in float aoFactor )</pre></div>
<p>This function is called once to calculate the environmental light for the front-facing polygon.</p>
<div class="pre"><pre class="cpp plain" translate="no">void computeBackLayerColor( in vec3 normal, in vec3 lightDir, in vec3 viewDir,
                            in vec3 lightDiffuse, in vec3 lightSpecular,
                            in float materialIOR, in float aoFactor )</pre></div>
<p>This function is called for every light (excluding area lights) for the back-facing polygon. The material can write its own lighting model or use the provided functions. The functions available for use are <code translate="no">microfacetBSDF</code>, <code translate="no">physGlossyBSDF</code> and <code translate="no">simpleGlossyBSDF</code>. The <code translate="no">normal</code> is the fragment normal. The <code translate="no">lightDir</code> is the normalized vector from fragment to light in world space.</p>
<div class="pre"><pre class="cpp plain" translate="no">void computeBackAreaColor( in int lightIdx, in vec4 lightDiffuse, in vec4 lightSpecular )</pre></div>
<p>This function is called for every area light for the back-facing polygon.</p>
<div class="pre"><pre class="cpp plain" translate="no">void computeBackLayerEnvironment( in vec3 normal, in vec3 viewDir, in float aoFactor )</pre></div>
<p>This function is called once to calculate the environmental light for the back-facing polygon.</p>
<div class="pre"><pre class="cpp plain" translate="no">vec4 computeLayerWeights( in float alpha )</pre></div>
<p>This function is called after all lighting have been processed to calculate the final lighting value for the fragment.</p>
<div class="pre"><pre class="cpp plain" translate="no">vec4 computeGlass( in vec3 normal, in float materialIOR, in float alpha, in vec4 color )</pre></div>
<p>This function is called only if the material is transparent and non-transmissive after <code translate="no">computeLayerWeights</code> has been called.</p>
<div class="pre"><pre class="cpp plain" translate="no">vec4 computeOpacity( in vec4 color )</pre></div>
<p>This function is called only if the material is transmissive after <code translate="no">computeLayerWeights</code> has been called.</p>
<a name="mandatory-includes"></a>
<h2 id="mandatory-includes">Mandatory Includes<a class="plink" href="#mandatory-includes" title="Direct link to this headline"></a></h2>
<div class="pre"><pre class="cpp plain" translate="no">#include "vertexFragmentBase.glsllib"
#include "SSAOCustomMaterial.glsllib"
#include "sampleLight.glsllib"
#include "sampleProbe.glsllib"
#include "sampleArea.glsllib"</pre></div>
<p>These includes are required for all materials.</p>
<a name="global-variables"></a>
<h2 id="global-variables">Global Variables<a class="plink" href="#global-variables" title="Direct link to this headline"></a></h2>
<p>These variables are available to the material, but should not be modified:</p>
<div class="pre"><pre class="cpp plain" translate="no">vec3 normal;
vec3 surfNormal;
vec3 texCoord0;
vec3 tangent;
vec3 binormal;
vec3 viewDir;</pre></div>
<p>These are read-only the fragment shader input variables.</p>
<div class="pre"><pre class="cpp plain" translate="no">vec3 varTexCoord0;
vec3 varTexCoord1;
vec3 varNormal;
vec3 varTangent;
vec3 varBinormal;
vec3 varObjTangent;
vec3 varObjBinormal;
vec3 varWorldPos;
vec3 varObjPos;</pre></div>
<a name="configuration-flags"></a>
<h2 id="configuration-flags">Configuration Flags<a class="plink" href="#configuration-flags" title="Direct link to this headline"></a></h2>
<p>These configuration flags can be used to enable certain features for the material.</p>
<div class="pre"><pre class="cpp plain" translate="no">#define QSSG_ENABLE_UV0 1/0
#define QSSG_ENABLE_WORLD_POSITION 1/0
#define QSSG_ENABLE_TEXTAN 1/0
#define QSSG_ENABLE_BINORMAL 1/0</pre></div>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Flag</th><th>Desctiption</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">QSSG_ENABLE_UV0</code></td><td>Enables texture coordinate 0 variable.</td></tr>
<tr class="even" valign="top"><td><code translate="no">QSSG_ENABLE_WORLD_POSITION</code></td><td>Enables world position variable.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">QSSG_ENABLE_TEXTAN</code></td><td>Enables tangent variable.</td></tr>
<tr class="even" valign="top"><td><code translate="no">QSSG_ENABLE_BINORMAL</code></td><td>Enables binormal variable.</td></tr>
</tbody></table></div>
<a name="configured-features"></a>
<h2 id="configured-features">Configured Features<a class="plink" href="#configured-features" title="Direct link to this headline"></a></h2>
<p>These flags are conditionally enabled by the material system when the material is being compiled. The custom shader can use them to enable different code paths for compilation.</p>
<div class="pre"><pre class="cpp plain" translate="no">#define QSSG_ENABLE_CG_LIGHTING
#define QSSG_ENABLE_LIGHT_PROBE
#define QSSG_ENABLE_SSAO
#define QSSG_ENABLE_SSDO
#define QSSG_ENABLE_SSM
#define QSSG_ENABLE_RNM</pre></div>
<div class="table"><div class="admonition note">
<p><b>Note: </b>Normal-mapped radiosity is not currently supported. </p></div><table class="generic">
<thead><tr class="qt-style"><th>Flag</th><th>Desctiption</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">QSSG_ENABLE_CG_LIGHTING</code></td><td>Enabled when lighting is enabled.</td></tr>
<tr class="even" valign="top"><td><code translate="no">QSSG_ENABLE_LIGHT_PROBE</code></td><td>Enabled when light probe is enabled.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">QSSG_ENABLE_SSAO</code></td><td>Enabled when screen space ambient occlusion is enabled.</td></tr>
<tr class="even" valign="top"><td><code translate="no">QSSG_ENABLE_SSDO</code></td><td>Enabled when screen space direct occlusion is enabled.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">QSSG_ENABLE_SSM</code></td><td>Enabled when shadow mapping is enabled.</td></tr>
<tr class="even" valign="top"><td><code translate="no">QSSG_ENABLE_RNM</code></td><td>Enabled when normal-mapped radiosity is enabled.</td></tr>
<tr class="odd" valign="top"></tr>
</tbody></table></div>
</div>
<a name="including-functionality-from-a-library"></a>
<h2 id="including-functionality-from-a-library">Including functionality from a library<a class="plink" href="#including-functionality-from-a-library" title="Direct link to this headline"></a></h2>
<p>The material can import functions from the shader library using the <code translate="no">#include</code> directive. Some functionality requires the user to define the constant and structures of the functionality. For example, to use the <code translate="no">blendColorLayers</code> function the user must specify the <code translate="no">mono_xxx</code> constants and the <code translate="no">texture_return</code> and <code translate="no">color_layer</code> structure (at least once) before including them in their material.</p>
<div class="pre"><pre class="cpp plain" translate="no">#define mono_alpha 0
#define mono_average 1
#define mono_luminance 2
#define mono_maximum 3

struct texture_return
{
    vec3 tint;
    float mono;
};

struct color_layer
{
    vec3 layer_color;
    float weight;
    int mode;
};

#include "blendColorLayers.glsllib"

texture_return blendColorLayers( in color_layer colorLayer[1], in vec3 base, in int monoSource );</pre></div>
<p>Some includes require additional functionality to work correctly. For example <code translate="no">fileBumpTexture</code> requires these additional includes and defines:</p>
<div class="pre"><pre class="cpp plain" translate="no">#include "luminance.glsllib"
#include "monoChannel.glsllib"
#define wrap_clamp 0
#define wrap_repeat 1
#define wrap_mirrored_repeat 2
#include "rotationTranslationScale.glsllib"
#include "transformCoordinate.glsllib"</pre></div>
<a name="includable-functions"></a>
<h2 id="includable-functions">Includable Functions<a class="plink" href="#includable-functions" title="Direct link to this headline"></a></h2>
<a name="microfacetbsdf"></a>
<h3 id="microfacetbsdf">microfacetBSDF<a class="plink" href="#microfacetbsdf" title="Direct link to this headline"></a></h3>
<div class="pre"><pre class="cpp plain" translate="no">#define scatter_reflect 0
#define scatter_transmit 1
#define scatter_reflect_transmit 2

#include "calculateRoughness.glsllib"
#include "microfacetBSDF.glsllib"

vec4 microfacetBSDF( in mat3 tanFrame, in vec3 L, in vec3 V, in vec3 lightSpecular, in float ior,
                     in float roughnessU, in float roughnessV, in int mode )</pre></div>
<p>This function calculates light value for rough surface using microfacet BSDF lighting model. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">L</code></td><td>Light vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">V</code></td><td>View vector.</td></tr>
<tr class="even" valign="top"><td><code translate="no">ior</code></td><td>Index-of-refraction.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
<tr class="even" valign="top"><td><code translate="no">mode</code></td><td>The mode of scattering calculations.</td></tr>
</tbody></table></div>
<div class="pre"><pre class="cpp plain" translate="no">vec4 microfacetSampledBSDF( in mat3 tanFrame, in vec3 viewDir, in float roughnessU,
                            in float roughnessV, in int mode )</pre></div>
<p>This function calculates light value for rough surface using microfacet BSDF lighting model based on environment map. The environment map is specified with the <code translate="no">uEnvironmentMap</code> property. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">viewDir</code></td><td>View direction vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
<tr class="even" valign="top"><td><code translate="no">mode</code></td><td>The mode of scattering calculations.</td></tr>
</tbody></table></div>
<a name="physglossybsdf"></a>
<h3 id="physglossybsdf">physGlossyBSDF<a class="plink" href="#physglossybsdf" title="Direct link to this headline"></a></h3>
<div class="pre"><pre class="cpp plain" translate="no">#define scatter_reflect 0
#define scatter_transmit 1
#define scatter_reflect_transmit 2

#include "physGlossyBSDF.glsllib"

vec4 kggxGlossyBSDF( in mat3 tanFrame, in vec3 L, in vec3 V, in vec3 lightSpecular, in float ior,
                     in float roughnessU, in float roughnessV, in int mode )</pre></div>
<p>This function calculates light value for glossy surface using the GGX BSDF. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">L</code></td><td>Light vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">V</code></td><td>View vector.</td></tr>
<tr class="even" valign="top"><td><code translate="no">lightSpecular</code></td><td>Light specular value.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">ior</code></td><td>Index-of-refraction.</td></tr>
<tr class="even" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">mode</code></td><td>The mode of scattering calculations.</td></tr>
</tbody></table></div>
<div class="pre"><pre class="cpp plain" translate="no">vec4 wardGlossyBSDF( in mat3 tanFrame, in vec3 L, in vec3 V, in vec3 lightSpecular, in float ior,
                     in float roughnessU, in float roughnessV, in int mode )</pre></div>
<p>This function calculates light value for glossy surface using the Ward BSDF. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">L</code></td><td>Light vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">V</code></td><td>View vector.</td></tr>
<tr class="even" valign="top"><td><code translate="no">lightSpecular</code></td><td>Light specular value.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">ior</code></td><td>Index-of-refraction.</td></tr>
<tr class="even" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">mode</code></td><td>The mode of scattering calculations.</td></tr>
</tbody></table></div>
<a name="simpleglossybsdf"></a>
<h3 id="simpleglossybsdf">simpleGlossyBSDF<a class="plink" href="#simpleglossybsdf" title="Direct link to this headline"></a></h3>
<div class="pre"><pre class="cpp plain" translate="no">#define scatter_reflect 0
#define scatter_transmit 1
#define scatter_reflect_transmit 2

#include "calculateRoughness.glsllib"
#include "simpleGlossyBSDF.glsllib"

vec4 simpleGlossyBSDF( in mat3 tanFrame, in vec3 L, vec3 V, in vec3 lightSpecular, in float ior,
                       in float roughnessU, in float roughnessV, in int mode )</pre></div>
<p>This function calculates light value for glossy surface using the simple BSDF. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">L</code></td><td>Light vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">V</code></td><td>View vector.</td></tr>
<tr class="even" valign="top"><td><code translate="no">lightSpecular</code></td><td>Light specular value.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">ior</code></td><td>Index-of-refraction.</td></tr>
<tr class="even" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">mode</code></td><td>The mode of scattering calculations.</td></tr>
</tbody></table></div>
<div class="pre"><pre class="cpp plain" translate="no">vec4 simpleGlossyBSDFEnvironment( in mat3 tanFrame, in vec3 viewDir, in float roughnessU,
                                  in float roughnessV, in int mode )</pre></div>
<p>This function calculates light value for glossy surface using simple BSDF lighting model based on environment map. The environment map is specified with the <code translate="no">uEnvironmentMap</code> property. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">viewDir</code></td><td>View vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
<tr class="even" valign="top"><td><code translate="no">mode</code></td><td>The mode of scattering calculations.</td></tr>
</tbody></table></div>
<a name="sampleprobe"></a>
<h3 id="sampleprobe">sampleProbe<a class="plink" href="#sampleprobe" title="Direct link to this headline"></a></h3>
<div class="pre"><pre class="cpp plain" translate="no">#include "sampleProbe.glsllib"

vec4 sampleGlossy( mat3 tanFrame, vec3 viewDir, float roughness )</pre></div>
<p>Calculates specular sample for the light probe. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">viewDir</code></td><td>View direction vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
</tbody></table></div>
<div class="admonition note">
<p><b>Note: </b>QT3DS_ENABLE_LIGHT_PROBE must be enabled to use this function.</p>
</div>
<div class="pre"><pre class="cpp plain" translate="no">vec4 sampleDiffuse( mat3 tanFrame )</pre></div>
<p>Calculates diffuse sample for the light probe. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
</tbody></table></div>
<div class="admonition note">
<p><b>Note: </b>QT3DS_ENABLE_LIGHT_PROBE must be enabled to use this function.</p>
</div>
<a name="samplearea"></a>
<h3 id="samplearea">sampleArea<a class="plink" href="#samplearea" title="Direct link to this headline"></a></h3>
<div class="pre"><pre class="cpp plain" translate="no">#include "sampleArea.glsllib"

vec4 sampleAreaGlossy( in mat3 tanFrame, in vec3 pos, in int lightIdx, in vec3 viewDir,
                       in float roughnessU, in float roughnessV )</pre></div>
<p>Computes specular sample for an area light. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">pos</code></td><td>Fragment world position.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">lightIdx</code></td><td>Index of the light to sample.</td></tr>
<tr class="even" valign="top"><td><code translate="no">viewDir</code></td><td>View direction vector.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">roughtnessU</code> <code translate="no">roughnessV</code></td><td>Roughness factors relative to the texture U- and V-coordinates.</td></tr>
</tbody></table></div>
<div class="pre"><pre class="cpp plain" translate="no">vec4 sampleAreaDiffuse( in mat3 tanFrame, in vec3 pos, in int lightIdx )</pre></div>
<p>Computes diffuse sample for an area light. The return value is 4-component rgba vector.</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Parameter</th><th>Description</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">tanFrame</code></td><td>Tangent-space matrix of the fragment.</td></tr>
<tr class="even" valign="top"><td><code translate="no">pos</code></td><td>Fragment world position.</td></tr>
<tr class="odd" valign="top"><td><code translate="no">lightIdx</code></td><td>Index of the light to sample.</td></tr>
</tbody></table></div>
<a name="custom-material-with-main-function"></a>
<h2 id="custom-material-with-main-function">Custom Material with Main Function<a class="plink" href="#custom-material-with-main-function" title="Direct link to this headline"></a></h2>
<p>It is also possible to write the custom material without the rest of the material system. In this case it is not necessary to write all the functions described above. Each pass needs a main function only.</p>
<div class="pre"><pre class="cpp plain" translate="no">out vec4 fragColor;
void main()
{
    fragColor = ...
}</pre></div>
<a name="simple-custom-material-example"></a>
<h3 id="simple-custom-material-example">Simple Custom Material Example<a class="plink" href="#simple-custom-material-example" title="Direct link to this headline"></a></h3>
<div class="pre"><pre class="cpp plain" translate="no">#define QSSG_ENABLE_UV0 1
#define QSSG_ENABLE_WORLD_POSITION 1
#define QSSG_ENABLE_TEXTAN 0
#define QSSG_ENABLE_BINORMAL 0

#include "vertexFragmentBase.glsllib"
#include "SSAOCustomMaterial.glsllib"
#include "sampleLight.glsllib"
#include "sampleProbe.glsllib"
#include "sampleArea.glsllib"

// Set shader output.
out vec4 fragColor;

void main()
{
    vec4 c = texture(basecolor, varTexCoord0.xy);
    c.rgb *= vec3(red_weight, green_weight, blue_weight);
    fragColor = c;
}</pre></div>
<a name="custom-material-vertex-shaders"></a>
<h2 id="custom-material-vertex-shaders">Custom Material Vertex Shaders<a class="plink" href="#custom-material-vertex-shaders" title="Direct link to this headline"></a></h2>
<p>Default vertex shader generation can be overridden with a custom vertex shader.</p>
<a name="custom-vertex-shader-example"></a>
<h3 id="custom-vertex-shader-example">Custom Vertex Shader Example<a class="plink" href="#custom-vertex-shader-example" title="Direct link to this headline"></a></h3>
<div class="pre"><pre class="cpp plain" translate="no">in vec3 attr_pos;

uniform mat4 modelViewProjection;

out vec3 pos;

void main() {
    pos = attr_pos;
    pos.x += sin(time * 4.0 + pos.y) * amplitude;
    gl_Position = modelViewProjection * vec4(pos, 1.0);
}</pre></div>
<a name="default-vertex-shader-inputs"></a>
<h3 id="default-vertex-shader-inputs">Default Vertex Shader Inputs<a class="plink" href="#default-vertex-shader-inputs" title="Direct link to this headline"></a></h3>
<p>The vertex attributes provided as inputs to the vertex shaders are defined by the mesh files. The following vertex attributes are used by default.</p>
<div class="pre"><pre class="cpp plain" translate="no">in vec3 attr_pos;
in vec3 attr_norm;
in vec2 attr_uv0;
in vec3 attr_textan;
in vec3 attr_binormal;</pre></div>
<p>The following uniforms are provided to shaders.</p>
<div class="pre"><pre class="cpp plain" translate="no">uniform mat4 modelMatrix;
uniform mat4 modelViewProjection;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform mat4 viewProjectionMatrix;
uniform mat4 viewportMatrix;

uniform vec3 cameraPosition;
uniform vec2 cameraProperties;

uniform sampler2D depthTexture;
uniform sampler2D aoTexture;

uniform sampler2D lightProbe;
uniform vec4 lightProbeProperties;
uniform vec4 lightProbeOptions;
uniform vec4 lightProbeRotation;
uniform vec4 lightProbeOffset;

uniform sampler2D lightProbe2;
uniform vec4 lightProbe2Properties;

uniform int lightCount;
uniform int areaLightCount;
uniform int shadowMapCount;
uniform int shadowCubeCount;

uniform float objectOpacity;

uniform sampler2D shadowMaps[8];
uniform samplerCube shadowCubes[8];</pre></div>
</div>
<!-- @@@custom-material-reference.html -->

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>