<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QVector | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qvector.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QVector</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QVector Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QVector</span>
<!-- $$$QVector-brief -->
<p>The QVector class is a template class that provides a dynamic array. <a href="#details">More...</a></p>
<!-- @@@QVector -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QVector&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qstack.htm" translate="no">QStack</a> and <a href="./qvulkaninfovector.htm" translate="no">QVulkanInfoVector</a></p>
</td></tr></tbody></table></div><ul>
<li><a href="./qvector-members.htm">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#Iterator-typedef" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#iterator-typedefx" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#reverse_iterator-typedef" translate="no">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#value_type-typedef" translate="no">value_type</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#QVector-5" translate="no">QVector</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#QVector-4" translate="no">QVector</a></b>(QVector&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#QVector-3" translate="no">QVector</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#QVector-2" translate="no">QVector</a></b>(int <i>size</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#QVector-1" translate="no">QVector</a></b>(int <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#QVector" translate="no">QVector</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-eq-1" translate="no">operator=</a></b>(QVector&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-eq" translate="no">operator=</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#dtor.QVector" translate="no">~QVector</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#append" translate="no">append</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#append-1" translate="no">append</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#append-2" translate="no">append</a></b>(const QVector&lt;T&gt; &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#at" translate="no">at</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::reference </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#back" translate="no">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reference </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#back-1" translate="no">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#capacity" translate="no">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T *</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#constData" translate="no">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#constFirst" translate="no">constFirst</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#constLast" translate="no">constLast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#contains" translate="no">contains</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#count" translate="no">count</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#count-1" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#crbegin" translate="no">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#crend" translate="no">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T *</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#data" translate="no">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T *</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#data-1" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#endsWith" translate="no">endsWith</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#erase" translate="no">erase</a></b>(QVector::iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#erase-1" translate="no">erase</a></b>(QVector::iterator <i>begin</i>, QVector::iterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#fill" translate="no">fill</a></b>(const T &amp;<i>value</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#first" translate="no">first</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#first-1" translate="no">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#front" translate="no">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reference </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#front-1" translate="no">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#indexOf" translate="no">indexOf</a></b>(const T &amp;<i>value</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#insert" translate="no">insert</a></b>(int <i>i</i>, T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#insert-1" translate="no">insert</a></b>(int <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#insert-2" translate="no">insert</a></b>(int <i>i</i>, int <i>count</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#insert-3" translate="no">insert</a></b>(QVector::iterator <i>before</i>, int <i>count</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#insert-4" translate="no">insert</a></b>(QVector::iterator <i>before</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#insert-5" translate="no">insert</a></b>(QVector::iterator <i>before</i>, T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#last" translate="no">last</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#last-1" translate="no">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#lastIndexOf" translate="no">lastIndexOf</a></b>(const T &amp;<i>value</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#length" translate="no">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#mid" translate="no">mid</a></b>(int <i>pos</i>, int <i>length</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#move" translate="no">move</a></b>(int <i>from</i>, int <i>to</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#pop_back" translate="no">pop_back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#pop_front" translate="no">pop_front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#prepend" translate="no">prepend</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#prepend-1" translate="no">prepend</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#push_back" translate="no">push_back</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#push_back-1" translate="no">push_back</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#push_front" translate="no">push_front</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#push_front-1" translate="no">push_front</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#rbegin" translate="no">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#rbegin-1" translate="no">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#remove" translate="no">remove</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#remove-1" translate="no">remove</a></b>(int <i>i</i>, int <i>count</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#removeAll" translate="no">removeAll</a></b>(const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#removeAt" translate="no">removeAt</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#removeFirst" translate="no">removeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#removeLast" translate="no">removeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#removeOne" translate="no">removeOne</a></b>(const T &amp;<i>t</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#rend" translate="no">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#rend-1" translate="no">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#replace" translate="no">replace</a></b>(int <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#reserve" translate="no">reserve</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#resize" translate="no">resize</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#shrink_to_fit" translate="no">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#squeeze" translate="no">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#startsWith" translate="no">startsWith</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#swap" translate="no">swap</a></b>(QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#swapItemsAt" translate="no">swapItemsAt</a></b>(int <i>i</i>, int <i>j</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#takeAt" translate="no">takeAt</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#takeFirst" translate="no">takeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#takeLast" translate="no">takeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#toList" translate="no">toList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#toStdVector" translate="no">toStdVector</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#value" translate="no">value</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#value-1" translate="no">value</a></b>(int <i>i</i>, const T &amp;<i>defaultValue</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-not-eq" translate="no">operator!=</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-2b" translate="no">operator+</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-2b-eq" translate="no">operator+=</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-2b-eq-1" translate="no">operator+=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-2b-eq-2" translate="no">operator+=</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-lt-lt-1" translate="no">operator&lt;&lt;</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-lt-lt-2" translate="no">operator&lt;&lt;</a></b>(T &amp;&amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-eq-2" translate="no">operator=</a></b>(int <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-eq-eq" translate="no">operator==</a></b>(const QVector&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-5b-5d" translate="no">operator[]</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-5b-5d-1" translate="no">operator[]</a></b>(int <i>i</i>) const</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#fromList" translate="no">fromList</a></b>(const QList&lt;T&gt; &amp;<i>list</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#fromStdVector" translate="no">fromStdVector</a></b>(const int &amp;<i>vector</i>)</td></tr>
</tbody></table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members<a class="plink" href="#related-non-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#qHash" translate="no">qHash</a></b>(const QVector&lt;T&gt; &amp;<i>key</i>, uint <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-lt" translate="no">operator&lt;</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-lt-eq" translate="no">operator&lt;=</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-gt" translate="no">operator&gt;</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvector.htm#operator-gt-eq" translate="no">operator&gt;=</a></b>(const QVector&lt;T&gt; &amp;<i>lhs</i>, const QVector&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QVector-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QVector&lt;T&gt; is one of Qt's generic <a href="./containers.htm" translate="no">container classes</a>. It stores its items in adjacent memory locations and provides fast index-based access.</p>
<p><a href="./qlist.htm" translate="no">QList</a>&lt;T&gt;, QLinkedList&lt;T&gt;, QVector&lt;T&gt;, and <a href="./qvarlengtharray.htm" translate="no">QVarLengthArray</a>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</p>
<ul>
<li>QVector should be your default first choice. QVector&lt;T&gt; will usually give better performance than <a href="./qlist.htm" translate="no">QList</a>&lt;T&gt;, because QVector&lt;T&gt; always stores its items sequentially in memory, where <a href="./qlist.htm" translate="no">QList</a>&lt;T&gt; will allocate its items on the heap unless <code translate="no">sizeof(T) &lt;= sizeof(void*)</code> and T has been declared to be either a <code translate="no">Q_MOVABLE_TYPE</code> or a <code translate="no">Q_PRIMITIVE_TYPE</code> using <a href="./qtglobal.htm#Q_DECLARE_TYPEINFO" translate="no">Q_DECLARE_TYPEINFO</a>. See the <a href="http://marcmutz.wordpress.com/effective-qt/containers/#containers-qlist" translate="no">Pros and Cons of Using QList</a> for an explanation.</li>
<li>However, <a href="./qlist.htm" translate="no">QList</a> is used throughout the Qt APIs for passing parameters and for returning values. Use <a href="./qlist.htm" translate="no">QList</a> to interface with those APIs.</li>
<li>If you need a real linked list, which guarantees <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a> insertions mid-list and uses iterators to items rather than indexes, use QLinkedList.</li>
</ul>
<div class="admonition note">
<p><b>Note: </b>QVector and <a href="./qvarlengtharray.htm" translate="no">QVarLengthArray</a> both guarantee C-compatible array layout. <a href="./qlist.htm" translate="no">QList</a> does not. This might be important if your application must interface with a C API.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Iterators into a QLinkedList and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a QVector and non-heap-allocating QLists.</p>
</div>
<p>Here's an example of a QVector that stores integers and a QVector that stores <a href="./qstring.htm" translate="no">QString</a> values:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> integerVector;
<span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> stringVector;</pre></div>
<p>QVector stores its items in a vector (array). Typically, vectors are created with an initial size. For example, the following code constructs a QVector with 200 elements:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector(<span class="number">200</span>);</pre></div>
<p>The elements are automatically initialized with a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a>. If you want to initialize the vector with a different value, pass that value as the second argument to the constructor:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector(<span class="number">200</span><span class="operator">,</span> <span class="string">"Pass"</span>);</pre></div>
<p>You can also call <a href="./qvector.htm#fill" translate="no">fill</a>() at any time to fill the vector with a value.</p>
<p>QVector uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const vectors, operator[]() returns a reference to the item that can be used on the left side of an assignment:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">if</span> (vector<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="string">"Liz"</span>)
    vector<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">"Elizabeth"</span>;</pre></div>
<p>For read-only access, an alternative syntax is to use <a href="./qvector.htm#at" translate="no">at</a>():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> vector<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
    <span class="keyword">if</span> (vector<span class="operator">.</span>at(i) <span class="operator">=</span><span class="operator">=</span> <span class="string">"Alfonso"</span>)
        cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Found Alfonso at position "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
}</pre></div>
<p><a href="./qvector.htm#at" translate="no">at</a>() can be faster than operator[](), because it never causes a <a href="./implicit-sharing.htm#deep-copy" translate="no">deep copy</a> to occur.</p>
<p>Another way to access the data stored in a QVector is to call <a href="./qvector.htm#data" translate="no">data</a>(). The function returns a pointer to the first item in the vector. You can use the pointer to directly access and modify the elements stored in the vector. The pointer is also useful if you need to pass a QVector to a function that accepts a plain C++ array.</p>
<p>If you want to find all occurrences of a particular value in a vector, use <a href="./qvector.htm#indexOf" translate="no">indexOf</a>() or <a href="./qvector.htm#lastIndexOf" translate="no">lastIndexOf</a>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of the matching item if they found one; otherwise, they return -1. For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> i <span class="operator">=</span> vector<span class="operator">.</span>indexOf(<span class="string">"Harumi"</span>);
<span class="keyword">if</span> (i <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>)
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"First occurrence of Harumi is at position "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;</pre></div>
<p>If you simply want to check whether a vector contains a particular value, use <a href="./qvector.htm#contains" translate="no">contains</a>(). If you want to find out how many times a particular value occurs in the vector, use <a href="./qvector.htm#count-1" translate="no">count</a>().</p>
<p>QVector provides these basic functions to add, move, and remove items: <a href="./qvector.htm#insert" translate="no">insert</a>(), <a href="./qvector.htm#replace" translate="no">replace</a>(), <a href="./qvector.htm#remove" translate="no">remove</a>(), <a href="./qvector.htm#prepend" translate="no">prepend</a>(), <a href="./qvector.htm#append" translate="no">append</a>(). With the exception of <a href="./qvector.htm#append" translate="no">append</a>() and <a href="./qvector.htm#replace" translate="no">replace</a>(), these functions can be slow (<a href="./containers.htm#linear-time" translate="no">linear time</a>) for large vectors, because they require moving many items in the vector by one position in memory. If you want a container class that provides fast insertion/removal in the middle, use <a href="./qlist.htm" translate="no">QList</a> or QLinkedList instead.</p>
<p>Unlike plain C++ arrays, QVectors can be resized at any time by calling <a href="./qvector.htm#resize" translate="no">resize</a>(). If the new size is larger than the old size, QVector might need to reallocate the whole vector. QVector tries to reduce the number of reallocations by preallocating up to twice as much memory as the actual data needs.</p>
<p>If you know in advance approximately how many items the QVector will contain, you can call <a href="./qvector.htm#reserve" translate="no">reserve</a>(), asking QVector to preallocate a certain amount of memory. You can also call <a href="./qvector.htm#capacity" translate="no">capacity</a>() to find out how much memory QVector actually allocated.</p>
<p>Note that using non-const operators and functions can cause QVector to do a deep copy of the data. This is due to <a href="./implicit-sharing.htm" translate="no">implicit sharing</a>.</p>
<p>QVector's value type must be an <a href="./containers.htm#assignable-data-type" translate="no">assignable data type</a>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <a href="./qwidget.htm" translate="no">QWidget</a> as a value; instead, store a <a href="./qwidget.htm" translate="no">QWidget</a> *. A few functions have additional requirements; for example, <a href="./qvector.htm#indexOf" translate="no">indexOf</a>() and <a href="./qvector.htm#lastIndexOf" translate="no">lastIndexOf</a>() expect the value type to support <code translate="no">operator==()</code>. These requirements are documented on a per-function basis.</p>
<p>Like the other container classes, QVector provides <a href="./containers.htm#java-style-iterators" translate="no">Java-style iterators</a> (<a href="./qvectoriterator.htm" translate="no">QVectorIterator</a> and <a href="./qmutablevectoriterator.htm" translate="no">QMutableVectorIterator</a>) and <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterators</a> (<a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a> and <a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a>). In practice, these are rarely used, because you can use indexes into the QVector.</p>
<p>In addition to QVector, Qt also provides <a href="./qvarlengtharray.htm" translate="no">QVarLengthArray</a>, a very low-level class with little functionality that is optimized for speed.</p>
<p>QVector does <i>not</i> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</p>
<a name="more-information-on-using-qt-containers"></a>
<h4 id="more-information-on-using-qt-containers">More Information on Using Qt Containers<a class="plink" href="#more-information-on-using-qt-containers" title="Direct link to this headline"></a></h4>
<p>For a detailed discussion comparing Qt containers with each other and with STL containers, see <a href="http://marcmutz.wordpress.com/effective-qt/containers/" translate="no">Understand the Qt Containers</a>.</p>
<a name="maximum-size-and-out-of-memory-conditions"></a>
<h3 id="maximum-size-and-out-of-memory-conditions">Maximum size and out-of-memory conditions<a class="plink" href="#maximum-size-and-out-of-memory-conditions" title="Direct link to this headline"></a></h3>
<p>The current version of QVector is limited to just under 2 GB (2^31 bytes) in size. The exact value is architecture-dependent, since it depends on the overhead required for managing the data block, but is no more than 32 bytes. The number of elements that can be stored in a QVector is that size divided by the size of each element.</p>
<p>In case memory allocation fails, QVector will use the <a href="./qtglobal.htm#Q_CHECK_PTR" translate="no">Q_CHECK_PTR</a> macro, which will throw a <code translate="no">std::bad_alloc</code> exception if the application is being compiled with exception support. If exceptions are disabled, then running out of memory is undefined behavior.</p>
<p>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the Qt API.</p>
</div>
<p><b>See also </b><a href="./qvectoriterator.htm" translate="no">QVectorIterator</a>, <a href="./qmutablevectoriterator.htm" translate="no">QMutableVectorIterator</a>, <a href="./qlist.htm" translate="no">QList</a>, and <a href="./qlinkedlist.htm" translate="no">QLinkedList</a>.</p>
<!-- @@@QVector -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" id="ConstIterator-typedef" translate="no"><a name="ConstIterator-typedef"></a>typedef QVector::<span class="name">ConstIterator</span><a class="plink" href="#ConstIterator-typedef" title="Direct link to this headline"></a></h3>
<p>Qt-style synonym for <a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" id="Iterator-typedef" translate="no"><a name="Iterator-typedef"></a>typedef QVector::<span class="name">Iterator</span><a class="plink" href="#Iterator-typedef" title="Direct link to this headline"></a></h3>
<p>Qt-style synonym for <a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef" translate="no"><a name="const_iterator-typedef"></a>typedef QVector::<span class="name">const_iterator</span><a class="plink" href="#const_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>The QVector::const_iterator typedef provides an STL-style const iterator for <a href="./qvector.htm" translate="no">QVector</a> and <a href="./qstack.htm" translate="no">QStack</a>.</p>
<p><a href="./qvector.htm" translate="no">QVector</a> provides both <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterators</a> and <a href="./containers.htm#java-style-iterators" translate="no">Java-style iterators</a>. The STL-style const iterator is simply a typedef for "const T *" (pointer to const T).</p>
<div class="admonition warning">
<p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="./containers.htm#implicit-sharing-iterator-problem" translate="no">Implicit sharing iterator problem</a>.</p>
</div>
<p><b>See also </b><a href="./qvector.htm#constBegin" translate="no">QVector::constBegin</a>(), <a href="./qvector.htm#constEnd" translate="no">QVector::constEnd</a>(), <a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a>, and <a href="./qvectoriterator.htm" translate="no">QVectorIterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" id="const_pointer-typedef" translate="no"><a name="const_pointer-typedef"></a>typedef QVector::<span class="name">const_pointer</span><a class="plink" href="#const_pointer-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for const T *. Provided for STL compatibility.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" id="const_reference-typedef" translate="no"><a name="const_reference-typedef"></a>typedef QVector::<span class="name">const_reference</span><a class="plink" href="#const_reference-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T &amp;. Provided for STL compatibility.</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef" translate="no"><a name="const_reverse_iterator-typedef"></a>typedef QVector::<span class="name">const_reverse_iterator</span><a class="plink" href="#const_reverse_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>The QVector::const_reverse_iterator typedef provides an STL-style const reverse iterator for <a href="./qvector.htm" translate="no">QVector</a>.</p>
<p>It is simply a typedef for <code translate="no">std::reverse_iterator&lt;const T*&gt;</code>.</p>
<div class="admonition warning">
<p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="./containers.htm#implicit-sharing-iterator-problem" translate="no">Implicit sharing iterator problem</a>.</p>
</div>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#rbegin" translate="no">QVector::rbegin</a>(), <a href="./qvector.htm#rend" translate="no">QVector::rend</a>(), <a href="./qvector.htm#reverse_iterator-typedef" translate="no">QVector::reverse_iterator</a>, and <a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" id="difference_type-typedef" translate="no"><a name="difference_type-typedef"></a>typedef QVector::<span class="name">difference_type</span><a class="plink" href="#difference_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedefx" translate="no"><a name="iterator-typedefx"></a>typedef QVector::<span class="name">iterator</span><a class="plink" href="#iterator-typedefx" title="Direct link to this headline"></a></h3>
<p>The QVector::iterator typedef provides an STL-style non-const iterator for <a href="./qvector.htm" translate="no">QVector</a> and <a href="./qstack.htm" translate="no">QStack</a>.</p>
<p><a href="./qvector.htm" translate="no">QVector</a> provides both <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterators</a> and <a href="./containers.htm#java-style-iterators" translate="no">Java-style iterators</a>. The STL-style non-const iterator is simply a typedef for "T *" (pointer to T).</p>
<div class="admonition warning">
<p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="./containers.htm#implicit-sharing-iterator-problem" translate="no">Implicit sharing iterator problem</a>.</p>
</div>
<p><b>See also </b><a href="./qvector.htm#begin" translate="no">QVector::begin</a>(), <a href="./qvector.htm#end" translate="no">QVector::end</a>(), <a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a>, and <a href="./qmutablevectoriterator.htm" translate="no">QMutableVectorIterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$pointer -->
<h3 class="fn" id="pointer-typedef" translate="no"><a name="pointer-typedef"></a>typedef QVector::<span class="name">pointer</span><a class="plink" href="#pointer-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T *. Provided for STL compatibility.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" id="reference-typedef" translate="no"><a name="reference-typedef"></a>typedef QVector::<span class="name">reference</span><a class="plink" href="#reference-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T &amp;. Provided for STL compatibility.</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef" translate="no"><a name="reverse_iterator-typedef"></a>typedef QVector::<span class="name">reverse_iterator</span><a class="plink" href="#reverse_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>The QVector::reverse_iterator typedef provides an STL-style non-const reverse iterator for <a href="./qvector.htm" translate="no">QVector</a>.</p>
<p>It is simply a typedef for <code translate="no">std::reverse_iterator&lt;T*&gt;</code>.</p>
<div class="admonition warning">
<p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="./containers.htm#implicit-sharing-iterator-problem" translate="no">Implicit sharing iterator problem</a>.</p>
</div>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#rbegin" translate="no">QVector::rbegin</a>(), <a href="./qvector.htm#rend" translate="no">QVector::rend</a>(), <a href="./qvector.htm#const_reverse_iterator-typedef" translate="no">QVector::const_reverse_iterator</a>, and <a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef" translate="no"><a name="size_type-typedef"></a>typedef QVector::<span class="name">size_type</span><a class="plink" href="#size_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" id="value_type-typedef" translate="no"><a name="value_type-typedef"></a>typedef QVector::<span class="name">value_type</span><a class="plink" href="#value_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="push_front" translate="no"><a name="push_front"></a><span class="type">void</span> QVector::<span class="name">push_front</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#push_front" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="push_front-1" translate="no"><a name="push_front-1"></a><span class="type">void</span> QVector::<span class="name">push_front</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#push_front-1" title="Direct link to this headline"></a></h3></div>
<p>This function is provided for STL compatibility. It is equivalent to prepend(<i translate="no">value</i>).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="insert-5" translate="no"><a name="insert-5"></a><span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> QVector::<span class="name">insert</span>(<span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> <i>before</i>, <span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#insert-5" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="insert-4" translate="no"><a name="insert-4"></a><span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> QVector::<span class="name">insert</span>(<span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> <i>before</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert-4" title="Direct link to this headline"></a></h3></div>
<p>This is an overloaded function.</p>
<p>Inserts <i translate="no">value</i> in front of the item pointed to by the iterator <i translate="no">before</i>. Returns an iterator pointing at the inserted item.</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="insert" translate="no"><a name="insert"></a><span class="type">void</span> QVector::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#insert" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="insert-1" translate="no"><a name="insert-1"></a><span class="type">void</span> QVector::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert-1" title="Direct link to this headline"></a></h3></div>
<p>Inserts <i translate="no">value</i> at index position <i translate="no">i</i> in the vector. If <i translate="no">i</i> is 0, the value is prepended to the vector. If <i translate="no">i</i> is <a href="./qvector.htm#size" translate="no">size</a>(), the value is appended to the vector.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector;
vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"alpha"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"beta"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"delta"</span>;
vector<span class="operator">.</span>insert(<span class="number">2</span><span class="operator">,</span> <span class="string">"gamma"</span>);
<span class="comment">// vector: ["alpha", "beta", "gamma", "delta"]</span></pre></div>
<p>For large vectors, this operation can be slow (<a href="./containers.htm#linear-time" translate="no">linear time</a>), because it requires moving all the items at indexes <i translate="no">i</i> and above by one position further in memory. If you want a container class that provides a fast <a href="./qvector.htm#insert" translate="no">insert</a>() function, use QLinkedList instead.</p>
<p><b>See also </b><a href="./qvector.htm#append" translate="no">append</a>(), <a href="./qvector.htm#prepend" translate="no">prepend</a>(), and <a href="./qvector.htm#remove" translate="no">remove</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="prepend" translate="no"><a name="prepend"></a><span class="type">void</span> QVector::<span class="name">prepend</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#prepend" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="prepend-1" translate="no"><a name="prepend-1"></a><span class="type">void</span> QVector::<span class="name">prepend</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#prepend-1" title="Direct link to this headline"></a></h3></div>
<p>Inserts <i translate="no">value</i> at the beginning of the vector.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector;
vector<span class="operator">.</span>prepend(<span class="string">"one"</span>);
vector<span class="operator">.</span>prepend(<span class="string">"two"</span>);
vector<span class="operator">.</span>prepend(<span class="string">"three"</span>);
<span class="comment">// vector: ["three", "two", "one"]</span></pre></div>
<p>This is the same as vector.insert(0, <i translate="no">value</i>).</p>
<p>For large vectors, this operation can be slow (<a href="./containers.htm#linear-time" translate="no">linear time</a>), because it requires moving all the items in the vector by one position further in memory. If you want a container class that provides a fast <a href="./qvector.htm#prepend" translate="no">prepend</a>() function, use <a href="./qlist.htm" translate="no">QList</a> or QLinkedList instead.</p>
<p><b>See also </b><a href="./qvector.htm#append" translate="no">append</a>() and <a href="./qvector.htm#insert" translate="no">insert</a>().</p>
<!-- @@@ -->
<!-- $$$QVector$$$QVectorInputIteratorInputIterator -->
<h3 class="fn" id="QVector-5" translate="no"><a name="QVector-5"></a>template &lt;typename InputIterator, int&gt; QVector::<span class="name">QVector</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)<a class="plink" href="#QVector-5" title="Direct link to this headline"></a></h3>
<p>Constructs a vector with the contents in the iterator range [<i translate="no">first</i>, <i translate="no">last</i>).</p>
<p>The value type of <code translate="no">InputIterator</code> must be convertible to <code translate="no">T</code>.</p>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorQVector<T>&& -->
<h3 class="fn" id="QVector-4" translate="no"><a name="QVector-4"></a>QVector::<span class="name">QVector</span>(<span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)<a class="plink" href="#QVector-4" title="Direct link to this headline"></a></h3>
<p>Move-constructs a QVector instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorconstQVector<T>& -->
<h3 class="fn" id="QVector-3" translate="no"><a name="QVector-3"></a>QVector::<span class="name">QVector</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#QVector-3" title="Direct link to this headline"></a></h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p>This operation takes <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>, because QVector is <a href="./implicit-sharing.htm" translate="no">implicitly shared</a>. This makes returning a QVector from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="./containers.htm#algorithmic-complexity" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="./qvector.htm#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorintconstT& -->
<h3 class="fn" id="QVector-2" translate="no"><a name="QVector-2"></a>QVector::<span class="name">QVector</span>(<span class="type">int</span> <i>size</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#QVector-2" title="Direct link to this headline"></a></h3>
<p>Constructs a vector with an initial size of <i translate="no">size</i> elements. Each element is initialized with <i translate="no">value</i>.</p>
<p><b>See also </b><a href="./qvector.htm#resize" translate="no">resize</a>() and <a href="./qvector.htm#fill" translate="no">fill</a>().</p>
<!-- @@@QVector -->
<!-- $$$QVector$$$QVectorint -->
<h3 class="fn" id="QVector-1" translate="no"><a name="QVector-1"></a>QVector::<span class="name">QVector</span>(<span class="type">int</span> <i>args</i>)<a class="plink" href="#QVector-1" title="Direct link to this headline"></a></h3>
<p>Constructs a vector from the std::initializer_list given by <i translate="no">args</i>.</p>
<p>This constructor is only enabled if the compiler supports C++11 initializer lists.</p>
<p>This function was introduced in Qt 4.8.</p>
<!-- @@@QVector -->
<!-- $$$QVector[overload1]$$$QVector -->
<h3 class="fn" id="QVector" translate="no"><a name="QVector"></a>QVector::<span class="name">QVector</span>()<a class="plink" href="#QVector" title="Direct link to this headline"></a></h3>
<p>Constructs an empty vector.</p>
<p><b>See also </b><a href="./qvector.htm#resize" translate="no">resize</a>().</p>
<!-- @@@QVector -->
<!-- $$$operator=$$$operator=QVector<T>&& -->
<h3 class="fn" id="operator-eq-1" translate="no"><a name="operator-eq-1"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator=</span>(<span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)<a class="plink" href="#operator-eq-1" title="Direct link to this headline"></a></h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="./qvector.htm" translate="no">QVector</a> instance.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@operator= -->
<!-- $$$operator=[overload1]$$$operator=constQVector<T>& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator=</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns <i translate="no">other</i> to this vector and returns a reference to this vector.</p>
<!-- @@@operator= -->
<!-- $$$~QVector[overload1]$$$~QVector -->
<h3 class="fn" id="dtor.QVector" translate="no"><a name="dtor.QVector"></a>QVector::<span class="name">~QVector</span>()<a class="plink" href="#dtor.QVector" title="Direct link to this headline"></a></h3>
<p>Destroys the vector.</p>
<!-- @@@~QVector -->
<!-- $$$append[overload1]$$$appendconstT& -->
<h3 class="fn" id="append" translate="no"><a name="append"></a><span class="type">void</span> QVector::<span class="name">append</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#append" title="Direct link to this headline"></a></h3>
<p>Inserts <i translate="no">value</i> at the end of the vector.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector;
vector<span class="operator">.</span>append(<span class="string">"one"</span>);
vector<span class="operator">.</span>append(<span class="string">"two"</span>);
<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> three <span class="operator">=</span> <span class="string">"three"</span>;
vector<span class="operator">.</span>append(three);
<span class="comment">// vector: ["one", "two", "three"]</span>
<span class="comment">// three: "three"</span></pre></div>
<p>This is the same as calling resize(<a href="./qvector.htm#size" translate="no">size</a>() + 1) and assigning <i translate="no">value</i> to the new last element in the vector.</p>
<p>This operation is relatively fast, because <a href="./qvector.htm" translate="no">QVector</a> typically allocates more memory than necessary, so it can grow without reallocating the entire vector each time.</p>
<p><b>See also </b><a href="./qvector.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>(), <a href="./qvector.htm#prepend" translate="no">prepend</a>(), and <a href="./qvector.htm#insert" translate="no">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendT&& -->
<h3 class="fn" id="append-1" translate="no"><a name="append-1"></a><span class="type">void</span> QVector::<span class="name">append</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#append-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector;
vector<span class="operator">.</span>append(<span class="string">"one"</span>);
vector<span class="operator">.</span>append(<span class="string">"two"</span>);
<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> three <span class="operator">=</span> <span class="string">"three"</span>;
vector<span class="operator">.</span>append(std<span class="operator">::</span>move(three));
<span class="comment">// vector: ["one", "two", "three"]</span>
<span class="comment">// three: ""</span></pre></div>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQVector<T>& -->
<h3 class="fn" id="append-2" translate="no"><a name="append-2"></a><span class="type">void</span> QVector::<span class="name">append</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>value</i>)<a class="plink" href="#append-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends the items of the <i translate="no">value</i> vector to this vector.</p>
<p>This function was introduced in Qt 5.5.</p>
<p><b>See also </b><a href="./qvector.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>() and <a href="./qvector.htm#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@append -->
<!-- $$$at[overload1]$$$atint -->
<h3 class="fn" id="at" translate="no"><a name="at"></a>const <span class="type">T</span> &amp;QVector::<span class="name">at</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#at" title="Direct link to this headline"></a></h3>
<p>Returns the item at index position <i translate="no">i</i> in the vector.</p>
<p><i translate="no">i</i> must be a valid index position in the vector (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qvector.htm#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="./qvector.htm#value" translate="no">value</a>() and <a href="./qvector.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" id="back" translate="no"><a name="back"></a><span class="type"><a href="./qvector.htm#reference-typedef" translate="no">QVector::reference</a></span> QVector::<span class="name">back</span>()<a class="plink" href="#back" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qvector.htm#last" translate="no">last</a>().</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" id="back-1" translate="no"><a name="back-1"></a><span class="type"><a href="./qvector.htm#const_reference-typedef" translate="no">QVector::const_reference</a></span> QVector::<span class="name">back</span>() const<a class="plink" href="#back-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin" translate="no"><a name="begin"></a><span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> QVector::<span class="name">begin</span>()<a class="plink" href="#begin" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the vector.</p>
<p><b>See also </b><a href="./qvector.htm#constBegin" translate="no">constBegin</a>() and <a href="./qvector.htm#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1" translate="no"><a name="begin-1"></a><span class="type"><a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a></span> QVector::<span class="name">begin</span>() const<a class="plink" href="#begin-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" id="capacity" translate="no"><a name="capacity"></a><span class="type">int</span> QVector::<span class="name">capacity</span>() const<a class="plink" href="#capacity" title="Direct link to this headline"></a></h3>
<p>Returns the maximum number of items that can be stored in the vector without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="./qvector.htm" translate="no">QVector</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call <a href="./qvector.htm#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="./qvector.htm#reserve" translate="no">reserve</a>() and <a href="./qvector.htm#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin" translate="no"><a name="cbegin"></a><span class="type"><a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a></span> QVector::<span class="name">cbegin</span>() const<a class="plink" href="#cbegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the vector.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qvector.htm#begin" translate="no">begin</a>() and <a href="./qvector.htm#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend" translate="no"><a name="cend"></a><span class="type"><a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a></span> QVector::<span class="name">cend</span>() const<a class="plink" href="#cend" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the vector.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qvector.htm#cbegin" translate="no">cbegin</a>() and <a href="./qvector.htm#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear" translate="no"><a name="clear"></a><span class="type">void</span> QVector::<span class="name">clear</span>()<a class="plink" href="#clear" title="Direct link to this headline"></a></h3>
<p>Removes all the elements from the vector.</p>
<div class="admonition note">
<p><b>Note: </b>Until Qt 5.6, this also released the memory used by the vector. From Qt 5.7, the capacity is preserved. To shed all capacity, swap with a default-constructed vector:</p>
</div>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span> v <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>;
<span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span>T<span class="operator">&gt;</span>()<span class="operator">.</span>swap(v);
Q_ASSERT(v<span class="operator">.</span>capacity() <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>);</pre></div>
<p>or call <a href="./qvector.htm#squeeze" translate="no">squeeze</a>().</p>
<p><b>See also </b><a href="./qvector.htm#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin" translate="no"><a name="constBegin"></a><span class="type"><a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a></span> QVector::<span class="name">constBegin</span>() const<a class="plink" href="#constBegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the vector.</p>
<p><b>See also </b><a href="./qvector.htm#begin" translate="no">begin</a>() and <a href="./qvector.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" id="constData" translate="no"><a name="constData"></a>const <span class="type">T</span> *QVector::<span class="name">constData</span>() const<a class="plink" href="#constData" title="Direct link to this headline"></a></h3>
<p>Returns a const pointer to the data stored in the vector. The pointer can be used to access the items in the vector. The pointer remains valid as long as the vector isn't reallocated.</p>
<p>This function is mostly useful to pass a vector to a function that accepts a plain C++ array.</p>
<p><b>See also </b><a href="./qvector.htm#data" translate="no">data</a>() and <a href="./qvector.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd" translate="no"><a name="constEnd"></a><span class="type"><a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a></span> QVector::<span class="name">constEnd</span>() const<a class="plink" href="#constEnd" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the vector.</p>
<p><b>See also </b><a href="./qvector.htm#constBegin" translate="no">constBegin</a>() and <a href="./qvector.htm#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFirst[overload1]$$$constFirst -->
<h3 class="fn" id="constFirst" translate="no"><a name="constFirst"></a>const <span class="type">T</span> &amp;QVector::<span class="name">constFirst</span>() const<a class="plink" href="#constFirst" title="Direct link to this headline"></a></h3>
<p>Returns a const reference to the first item in the vector. This function assumes that the vector isn't empty.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#constLast" translate="no">constLast</a>(), <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>(), and <a href="./qvector.htm#first" translate="no">first</a>().</p>
<!-- @@@constFirst -->
<!-- $$$constLast[overload1]$$$constLast -->
<h3 class="fn" id="constLast" translate="no"><a name="constLast"></a>const <span class="type">T</span> &amp;QVector::<span class="name">constLast</span>() const<a class="plink" href="#constLast" title="Direct link to this headline"></a></h3>
<p>Returns a const reference to the last item in the vector. This function assumes that the vector isn't empty.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#constFirst" translate="no">constFirst</a>(), <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>(), and <a href="./qvector.htm#last" translate="no">last</a>().</p>
<!-- @@@constLast -->
<!-- $$$contains[overload1]$$$containsconstT& -->
<h3 class="fn" id="contains" translate="no"><a name="contains"></a><span class="type">bool</span> QVector::<span class="name">contains</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#contains" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the vector contains an occurrence of <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qvector.htm#indexOf" translate="no">indexOf</a>() and <a href="./qvector.htm#count-1" translate="no">count</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstT& -->
<h3 class="fn" id="count" translate="no"><a name="count"></a><span class="type">int</span> QVector::<span class="name">count</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#count" title="Direct link to this headline"></a></h3>
<p>Returns the number of occurrences of <i translate="no">value</i> in the vector.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qvector.htm#contains" translate="no">contains</a>() and <a href="./qvector.htm#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-1" translate="no"><a name="count-1"></a><span class="type">int</span> QVector::<span class="name">count</span>() const<a class="plink" href="#count-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="./qvector.htm#size" translate="no">size</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin" translate="no"><a name="crbegin"></a><span class="type"><a href="./qvector.htm#const_reverse_iterator-typedef" translate="no">QVector::const_reverse_iterator</a></span> QVector::<span class="name">crbegin</span>() const<a class="plink" href="#crbegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first item in the vector, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#begin" translate="no">begin</a>(), <a href="./qvector.htm#rbegin" translate="no">rbegin</a>(), and <a href="./qvector.htm#rend" translate="no">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend" translate="no"><a name="crend"></a><span class="type"><a href="./qvector.htm#const_reverse_iterator-typedef" translate="no">QVector::const_reverse_iterator</a></span> QVector::<span class="name">crend</span>() const<a class="plink" href="#crend" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last item in the vector, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#end" translate="no">end</a>(), <a href="./qvector.htm#rend" translate="no">rend</a>(), and <a href="./qvector.htm#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" id="data" translate="no"><a name="data"></a><span class="type">T</span> *QVector::<span class="name">data</span>()<a class="plink" href="#data" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the data stored in the vector. The pointer can be used to access and modify the items in the vector.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> vector(<span class="number">10</span>);
<span class="type">int</span> <span class="operator">*</span>data <span class="operator">=</span> vector<span class="operator">.</span>data();
<span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">10</span>; <span class="operator">+</span><span class="operator">+</span>i)
    data<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> i;</pre></div>
<p>The pointer remains valid as long as the vector isn't reallocated.</p>
<p>This function is mostly useful to pass a vector to a function that accepts a plain C++ array.</p>
<p><b>See also </b><a href="./qvector.htm#constData" translate="no">constData</a>() and <a href="./qvector.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" id="data-1" translate="no"><a name="data-1"></a>const <span class="type">T</span> *QVector::<span class="name">data</span>() const<a class="plink" href="#data-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@data -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" id="empty" translate="no"><a name="empty"></a><span class="type">bool</span> QVector::<span class="name">empty</span>() const<a class="plink" href="#empty" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>(), returning <code translate="no">true</code> if the vector is empty; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end" translate="no"><a name="end"></a><span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> QVector::<span class="name">end</span>()<a class="plink" href="#end" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the vector.</p>
<p><b>See also </b><a href="./qvector.htm#begin" translate="no">begin</a>() and <a href="./qvector.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1" translate="no"><a name="end-1"></a><span class="type"><a href="./qvector.htm#const_iterator-typedef" translate="no">QVector::const_iterator</a></span> QVector::<span class="name">end</span>() const<a class="plink" href="#end-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithconstT& -->
<h3 class="fn" id="endsWith" translate="no"><a name="endsWith"></a><span class="type">bool</span> QVector::<span class="name">endsWith</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#endsWith" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this vector is not empty and its last item is equal to <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qvector.htm#last" translate="no">last</a>().</p>
<!-- @@@endsWith -->
<!-- $$$erase[overload1]$$$eraseQVector::iterator -->
<h3 class="fn" id="erase" translate="no"><a name="erase"></a><span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> QVector::<span class="name">erase</span>(<span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> <i>pos</i>)<a class="plink" href="#erase" title="Direct link to this headline"></a></h3>
<p>Removes the item pointed to by the iterator <i translate="no">pos</i> from the vector, and returns an iterator to the next item in the vector (which may be <a href="./qvector.htm#end" translate="no">end</a>()).</p>
<p><b>See also </b><a href="./qvector.htm#insert" translate="no">insert</a>() and <a href="./qvector.htm#remove" translate="no">remove</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQVector::iteratorQVector::iterator -->
<h3 class="fn" id="erase-1" translate="no"><a name="erase-1"></a><span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> QVector::<span class="name">erase</span>(<span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> <i>begin</i>, <span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> <i>end</i>)<a class="plink" href="#erase-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Removes all the items from <i translate="no">begin</i> up to (but not including) <i translate="no">end</i>. Returns an iterator to the same item that <i translate="no">end</i> referred to before the call.</p>
<!-- @@@erase -->
<!-- $$$fill[overload1]$$$fillconstT&int -->
<h3 class="fn" id="fill" translate="no"><a name="fill"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">fill</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>size</i> = -1)<a class="plink" href="#fill" title="Direct link to this headline"></a></h3>
<p>Assigns <i translate="no">value</i> to all items in the vector. If <i translate="no">size</i> is different from -1 (the default), the vector is resized to size <i translate="no">size</i> beforehand.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector(<span class="number">3</span>);
vector<span class="operator">.</span>fill(<span class="string">"Yes"</span>);
<span class="comment">// vector: ["Yes", "Yes", "Yes"]</span>

vector<span class="operator">.</span>fill(<span class="string">"oh"</span><span class="operator">,</span> <span class="number">5</span>);
<span class="comment">// vector: ["oh", "oh", "oh", "oh", "oh"]</span></pre></div>
<p><b>See also </b><a href="./qvector.htm#resize" translate="no">resize</a>().</p>
<!-- @@@fill -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" id="first" translate="no"><a name="first"></a><span class="type">T</span> &amp;QVector::<span class="name">first</span>()<a class="plink" href="#first" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the first item in the vector. This function assumes that the vector isn't empty.</p>
<p><b>See also </b><a href="./qvector.htm#last" translate="no">last</a>(), <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>(), and <a href="./qvector.htm#constFirst" translate="no">constFirst</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn" id="first-1" translate="no"><a name="first-1"></a>const <span class="type">T</span> &amp;QVector::<span class="name">first</span>() const<a class="plink" href="#first-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@first -->
<!-- $$$fromList[overload1]$$$fromListconstQList<T>& -->
<h3 class="fn" id="fromList" translate="no"><a name="fromList"></a><code translate="no">[static] </code><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">fromList</span>(const <span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>list</i>)<a class="plink" href="#fromList" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./qvector.htm" translate="no">QVector</a> object with the data contained in <i translate="no">list</i>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Sven"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Kim"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Ola"</span>;

<span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vect <span class="operator">=</span> <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span><span class="operator">::</span>fromList(list);
<span class="comment">// vect: ["Sven", "Kim", "Ola"]</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>Since Qt 5.14, range constructors are available for Qt's generic <a href="./containers.htm" translate="no">container classes</a> and should be used in place of this method.</p>
</div>
<p><b>See also </b><a href="./qvector.htm#toList" translate="no">toList</a>() and <a href="./qlist.htm#toVector" translate="no">QList::toVector</a>().</p>
<!-- @@@fromList -->
<!-- $$$fromStdVector[overload1]$$$fromStdVectorconstint& -->
<h3 class="fn" id="fromStdVector" translate="no"><a name="fromStdVector"></a><code translate="no">[static] </code><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">fromStdVector</span>(const <span class="type">int</span> &amp;<i>vector</i>)<a class="plink" href="#fromStdVector" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./qvector.htm" translate="no">QVector</a> object with the data contained in <i translate="no">vector</i>. The order of the elements in the <a href="./qvector.htm" translate="no">QVector</a> is the same as in <i translate="no">vector</i>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">std<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> stdvector;
vector<span class="operator">.</span>push_back(<span class="number">1.2</span>);
vector<span class="operator">.</span>push_back(<span class="number">0.5</span>);
vector<span class="operator">.</span>push_back(<span class="number">3.14</span>);

<span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vector <span class="operator">=</span> <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span><span class="operator">::</span>fromStdVector(stdvector);</pre></div>
<div class="admonition note">
<p><b>Note: </b>Since Qt 5.14, range constructors are available for Qt's generic <a href="./containers.htm" translate="no">container classes</a> and should be used in place of this method.</p>
</div>
<p><b>See also </b><a href="./qvector.htm#toStdVector" translate="no">toStdVector</a>() and <a href="./qlist-obsolete.htm#fromStdList" translate="no">QList::fromStdList</a>().</p>
<!-- @@@fromStdVector -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" id="front" translate="no"><a name="front"></a><span class="type">T</span> &amp;QVector::<span class="name">front</span>()<a class="plink" href="#front" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qvector.htm#first" translate="no">first</a>().</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" id="front-1" translate="no"><a name="front-1"></a><span class="type"><a href="./qvector.htm#const_reference-typedef" translate="no">QVector::const_reference</a></span> QVector::<span class="name">front</span>() const<a class="plink" href="#front-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfconstT&int -->
<h3 class="fn" id="indexOf" translate="no"><a name="indexOf"></a><span class="type">int</span> QVector::<span class="name">indexOf</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>from</i> = 0) const<a class="plink" href="#indexOf" title="Direct link to this headline"></a></h3>
<p>Returns the index position of the first occurrence of <i translate="no">value</i> in the vector, searching forward from index position <i translate="no">from</i>. Returns -1 if no item matched.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector;
vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"C"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span>;
vector<span class="operator">.</span>indexOf(<span class="string">"B"</span>);            <span class="comment">// returns 1</span>
vector<span class="operator">.</span>indexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">1</span>);         <span class="comment">// returns 1</span>
vector<span class="operator">.</span>indexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">2</span>);         <span class="comment">// returns 3</span>
vector<span class="operator">.</span>indexOf(<span class="string">"X"</span>);            <span class="comment">// returns -1</span></pre></div>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qvector.htm#lastIndexOf" translate="no">lastIndexOf</a>() and <a href="./qvector.htm#contains" translate="no">contains</a>().</p>
<!-- @@@indexOf -->
<!-- $$$insert$$$insertintintconstT& -->
<h3 class="fn" id="insert-2" translate="no"><a name="insert-2"></a><span class="type">void</span> QVector::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>count</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts <i translate="no">count</i> copies of <i translate="no">value</i> at index position <i translate="no">i</i> in the vector.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vector;
vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">2.718</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1.442</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0.4342</span>;
vector<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">9.9</span>);
<span class="comment">// vector: [2.718, 9.9, 9.9, 9.9, 1.442, 0.4342]</span></pre></div>
<!-- @@@insert -->
<!-- $$$insert$$$insertQVector::iteratorintconstT& -->
<h3 class="fn" id="insert-3" translate="no"><a name="insert-3"></a><span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> QVector::<span class="name">insert</span>(<span class="type"><a href="./qvector.htm#iterator-typedefx" translate="no">QVector::iterator</a></span> <i>before</i>, <span class="type">int</span> <i>count</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert-3" title="Direct link to this headline"></a></h3>
<p>Inserts <i translate="no">count</i> copies of <i translate="no">value</i> in front of the item pointed to by the iterator <i translate="no">before</i>. Returns an iterator pointing at the first of the inserted items.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty" translate="no"><a name="isEmpty"></a><span class="type">bool</span> QVector::<span class="name">isEmpty</span>() const<a class="plink" href="#isEmpty" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the vector has size 0; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qvector.htm#size" translate="no">size</a>() and <a href="./qvector.htm#resize" translate="no">resize</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" id="last" translate="no"><a name="last"></a><span class="type">T</span> &amp;QVector::<span class="name">last</span>()<a class="plink" href="#last" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the last item in the vector. This function assumes that the vector isn't empty.</p>
<p><b>See also </b><a href="./qvector.htm#first" translate="no">first</a>(), <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>(), and <a href="./qvector.htm#constLast" translate="no">constLast</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn" id="last-1" translate="no"><a name="last-1"></a>const <span class="type">T</span> &amp;QVector::<span class="name">last</span>() const<a class="plink" href="#last-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@last -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstT&int -->
<h3 class="fn" id="lastIndexOf" translate="no"><a name="lastIndexOf"></a><span class="type">int</span> QVector::<span class="name">lastIndexOf</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>from</i> = -1) const<a class="plink" href="#lastIndexOf" title="Direct link to this headline"></a></h3>
<p>Returns the index position of the last occurrence of the value <i translate="no">value</i> in the vector, searching backward from index position <i translate="no">from</i>. If <i translate="no">from</i> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vector;
vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"C"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span>;
vector<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span>);        <span class="comment">// returns 3</span>
vector<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">3</span>);     <span class="comment">// returns 3</span>
vector<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">2</span>);     <span class="comment">// returns 1</span>
vector<span class="operator">.</span>lastIndexOf(<span class="string">"X"</span>);        <span class="comment">// returns -1</span></pre></div>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qvector.htm#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" id="length" translate="no"><a name="length"></a><span class="type">int</span> QVector::<span class="name">length</span>() const<a class="plink" href="#length" title="Direct link to this headline"></a></h3>
<p>Same as <a href="./qvector.htm#size" translate="no">size</a>() and <a href="./qvector.htm#count-1" translate="no">count</a>().</p>
<p>Provided for compatibility with <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qvector.htm#size" translate="no">size</a>(), <a href="./qvector.htm#count-1" translate="no">count</a>(), and <a href="./qlist.htm#length" translate="no">QList::length</a>().</p>
<!-- @@@length -->
<!-- $$$mid[overload1]$$$midintint -->
<h3 class="fn" id="mid" translate="no"><a name="mid"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">mid</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>length</i> = -1) const<a class="plink" href="#mid" title="Direct link to this headline"></a></h3>
<p>Returns a sub-vector which contains elements from this vector, starting at position <i translate="no">pos</i>. If <i translate="no">length</i> is -1 (the default), all elements after <i translate="no">pos</i> are included; otherwise <i translate="no">length</i> elements (or all remaining elements if there are less than <i translate="no">length</i> elements) are included.</p>
<!-- @@@mid -->
<!-- $$$move[overload1]$$$moveintint -->
<h3 class="fn" id="move" translate="no"><a name="move"></a><span class="type">void</span> QVector::<span class="name">move</span>(<span class="type">int</span> <i>from</i>, <span class="type">int</span> <i>to</i>)<a class="plink" href="#move" title="Direct link to this headline"></a></h3>
<p>Moves the item at index position <i translate="no">from</i> to index position <i translate="no">to</i>.</p>
<p>Provided for compatibility with <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#move" translate="no">QList::move</a>().</p>
<!-- @@@move -->
<!-- $$$pop_back[overload1]$$$pop_back -->
<h3 class="fn" id="pop_back" translate="no"><a name="pop_back"></a><span class="type">void</span> QVector::<span class="name">pop_back</span>()<a class="plink" href="#pop_back" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qvector.htm#removeLast" translate="no">removeLast</a>().</p>
<!-- @@@pop_back -->
<!-- $$$pop_front[overload1]$$$pop_front -->
<h3 class="fn" id="pop_front" translate="no"><a name="pop_front"></a><span class="type">void</span> QVector::<span class="name">pop_front</span>()<a class="plink" href="#pop_front" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qvector.htm#removeFirst" translate="no">removeFirst</a>().</p>
<!-- @@@pop_front -->
<!-- $$$push_back[overload1]$$$push_backconstT& -->
<h3 class="fn" id="push_back" translate="no"><a name="push_back"></a><span class="type">void</span> QVector::<span class="name">push_back</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#push_back" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to append(<i translate="no">value</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backT&& -->
<h3 class="fn" id="push_back-1" translate="no"><a name="push_back-1"></a><span class="type">void</span> QVector::<span class="name">push_back</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#push_back-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@push_back -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin" translate="no"><a name="rbegin"></a><span class="type"><a href="./qvector.htm#reverse_iterator-typedef" translate="no">QVector::reverse_iterator</a></span> QVector::<span class="name">rbegin</span>()<a class="plink" href="#rbegin" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first item in the vector, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#begin" translate="no">begin</a>(), <a href="./qvector.htm#crbegin" translate="no">crbegin</a>(), and <a href="./qvector.htm#rend" translate="no">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1" translate="no"><a name="rbegin-1"></a><span class="type"><a href="./qvector.htm#const_reverse_iterator-typedef" translate="no">QVector::const_reverse_iterator</a></span> QVector::<span class="name">rbegin</span>() const<a class="plink" href="#rbegin-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeint -->
<h3 class="fn" id="remove" translate="no"><a name="remove"></a><span class="type">void</span> QVector::<span class="name">remove</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#remove" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Removes the element at index position <i translate="no">i</i>.</p>
<p><b>See also </b><a href="./qvector.htm#insert" translate="no">insert</a>(), <a href="./qvector.htm#replace" translate="no">replace</a>(), and <a href="./qvector.htm#fill" translate="no">fill</a>().</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeintint -->
<h3 class="fn" id="remove-1" translate="no"><a name="remove-1"></a><span class="type">void</span> QVector::<span class="name">remove</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>count</i>)<a class="plink" href="#remove-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Removes <i translate="no">count</i> elements from the middle of the vector, starting at index position <i translate="no">i</i>.</p>
<p><b>See also </b><a href="./qvector.htm#insert" translate="no">insert</a>(), <a href="./qvector.htm#replace" translate="no">replace</a>(), and <a href="./qvector.htm#fill" translate="no">fill</a>().</p>
<!-- @@@remove -->
<!-- $$$removeAll[overload1]$$$removeAllconstT& -->
<h3 class="fn" id="removeAll" translate="no"><a name="removeAll"></a><span class="type">int</span> QVector::<span class="name">removeAll</span>(const <span class="type">T</span> &amp;<i>t</i>)<a class="plink" href="#removeAll" title="Direct link to this headline"></a></h3>
<p>Removes all elements that compare equal to <i translate="no">t</i> from the vector. Returns the number of elements removed, if any.</p>
<p>Provided for compatibility with <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qvector.htm#removeOne" translate="no">removeOne</a>() and <a href="./qlist.htm#removeAll" translate="no">QList::removeAll</a>().</p>
<!-- @@@removeAll -->
<!-- $$$removeAt[overload1]$$$removeAtint -->
<h3 class="fn" id="removeAt" translate="no"><a name="removeAt"></a><span class="type">void</span> QVector::<span class="name">removeAt</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#removeAt" title="Direct link to this headline"></a></h3>
<p>Removes the element at index position <i translate="no">i</i>. Equivalent to</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">remove(i);</pre></div>
<p>Provided for compatibility with <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qvector.htm#remove" translate="no">remove</a>() and <a href="./qlist.htm#removeAt" translate="no">QList::removeAt</a>().</p>
<!-- @@@removeAt -->
<!-- $$$removeFirst[overload1]$$$removeFirst -->
<h3 class="fn" id="removeFirst" translate="no"><a name="removeFirst"></a><span class="type">void</span> QVector::<span class="name">removeFirst</span>()<a class="plink" href="#removeFirst" title="Direct link to this headline"></a></h3>
<p>Removes the first item in the vector. Calling this function is equivalent to calling remove(0). The vector must not be empty. If the vector can be empty, call <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qvector.htm#remove" translate="no">remove</a>(), <a href="./qvector.htm#takeFirst" translate="no">takeFirst</a>(), and <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@removeFirst -->
<!-- $$$removeLast[overload1]$$$removeLast -->
<h3 class="fn" id="removeLast" translate="no"><a name="removeLast"></a><span class="type">void</span> QVector::<span class="name">removeLast</span>()<a class="plink" href="#removeLast" title="Direct link to this headline"></a></h3>
<p>Removes the last item in the vector. Calling this function is equivalent to calling remove(<a href="./qvector.htm#size" translate="no">size</a>() - 1). The vector must not be empty. If the vector can be empty, call <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qvector.htm#remove" translate="no">remove</a>(), <a href="./qvector.htm#takeLast" translate="no">takeLast</a>(), <a href="./qvector.htm#removeFirst" translate="no">removeFirst</a>(), and <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@removeLast -->
<!-- $$$removeOne[overload1]$$$removeOneconstT& -->
<h3 class="fn" id="removeOne" translate="no"><a name="removeOne"></a><span class="type">bool</span> QVector::<span class="name">removeOne</span>(const <span class="type">T</span> &amp;<i>t</i>)<a class="plink" href="#removeOne" title="Direct link to this headline"></a></h3>
<p>Removes the first element that compares equal to <i translate="no">t</i> from the vector. Returns whether an element was, in fact, removed.</p>
<p>Provided for compatibility with <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qvector.htm#removeAll" translate="no">removeAll</a>() and <a href="./qlist.htm#removeOne" translate="no">QList::removeOne</a>().</p>
<!-- @@@removeOne -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend" translate="no"><a name="rend"></a><span class="type"><a href="./qvector.htm#reverse_iterator-typedef" translate="no">QVector::reverse_iterator</a></span> QVector::<span class="name">rend</span>()<a class="plink" href="#rend" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last item in the vector, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qvector.htm#end" translate="no">end</a>(), <a href="./qvector.htm#crend" translate="no">crend</a>(), and <a href="./qvector.htm#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1" translate="no"><a name="rend-1"></a><span class="type"><a href="./qvector.htm#const_reverse_iterator-typedef" translate="no">QVector::const_reverse_iterator</a></span> QVector::<span class="name">rend</span>() const<a class="plink" href="#rend-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rend -->
<!-- $$$replace[overload1]$$$replaceintconstT& -->
<h3 class="fn" id="replace" translate="no"><a name="replace"></a><span class="type">void</span> QVector::<span class="name">replace</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#replace" title="Direct link to this headline"></a></h3>
<p>Replaces the item at index position <i translate="no">i</i> with <i translate="no">value</i>.</p>
<p><i translate="no">i</i> must be a valid index position in the vector (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qvector.htm#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="./qvector.htm#operator-5b-5d" translate="no">operator[]</a>() and <a href="./qvector.htm#remove" translate="no">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn" id="reserve" translate="no"><a name="reserve"></a><span class="type">void</span> QVector::<span class="name">reserve</span>(<span class="type">int</span> <i>size</i>)<a class="plink" href="#reserve" title="Direct link to this headline"></a></h3>
<p>Attempts to allocate memory for at least <i translate="no">size</i> elements. If you know in advance how large the vector will be, you should call this function to prevent reallocations and memory fragmentation.</p>
<p>If <i translate="no">size</i> is an underestimate, the worst that will happen is that the <a href="./qvector.htm" translate="no">QVector</a> will be a bit slower. If <i translate="no">size</i> is an overestimate, you may have used more memory than the normal <a href="./qvector.htm" translate="no">QVector</a> growth strategy would have allocatedor you may have used less.</p>
<p>An alternative to reserve() is calling <a href="./qvector.htm#resize" translate="no">resize</a>(). Whether or not that is faster than reserve() depends on the element type, because <a href="./qvector.htm#resize" translate="no">resize</a>() default-constructs all elements, and requires assignment to existing entries rather than calling <a href="./qvector.htm#append" translate="no">append</a>(), which copy- or move-constructs. For simple types, like <code translate="no">int</code> or <code translate="no">double</code>, <a href="./qvector.htm#resize" translate="no">resize</a>() is typically faster, but for anything more complex, you should prefer reserve().</p>
<div class="admonition warning">
<p><b>Warning: </b>If the size passed to <a href="./qvector.htm#resize" translate="no">resize</a>() was underestimated, you run out of allocated space and into undefined behavior. This problem does not exist with reserve(), because it treats the size as just a hint.</p>
</div>
<p><b>See also </b><a href="./qvector.htm#squeeze" translate="no">squeeze</a>() and <a href="./qvector.htm#capacity" translate="no">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeint -->
<h3 class="fn" id="resize" translate="no"><a name="resize"></a><span class="type">void</span> QVector::<span class="name">resize</span>(<span class="type">int</span> <i>size</i>)<a class="plink" href="#resize" title="Direct link to this headline"></a></h3>
<p>Sets the size of the vector to <i translate="no">size</i>. If <i translate="no">size</i> is greater than the current size, elements are added to the end; the new elements are initialized with a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a>. If <i translate="no">size</i> is less than the current size, elements are removed from the end.</p>
<p>Since Qt 5.6, resize() doesn't shrink the capacity anymore. To shed excess capacity, use <a href="./qvector.htm#squeeze" translate="no">squeeze</a>().</p>
<p><b>See also </b><a href="./qvector.htm#size" translate="no">size</a>().</p>
<!-- @@@resize -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" id="shrink_to_fit" translate="no"><a name="shrink_to_fit"></a><span class="type">void</span> QVector::<span class="name">shrink_to_fit</span>()<a class="plink" href="#shrink_to_fit" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qvector.htm#squeeze" translate="no">squeeze</a>().</p>
<p>This function was introduced in Qt 5.10.</p>
<!-- @@@shrink_to_fit -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type">int</span> QVector::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the number of items in the vector.</p>
<p><b>See also </b><a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qvector.htm#resize" translate="no">resize</a>().</p>
<!-- @@@size -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" id="squeeze" translate="no"><a name="squeeze"></a><span class="type">void</span> QVector::<span class="name">squeeze</span>()<a class="plink" href="#squeeze" title="Direct link to this headline"></a></h3>
<p>Releases any memory not required to store the items.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="./qvector.htm" translate="no">QVector</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>See also </b><a href="./qvector.htm#reserve" translate="no">reserve</a>() and <a href="./qvector.htm#capacity" translate="no">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$startsWith[overload1]$$$startsWithconstT& -->
<h3 class="fn" id="startsWith" translate="no"><a name="startsWith"></a><span class="type">bool</span> QVector::<span class="name">startsWith</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#startsWith" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this vector is not empty and its first item is equal to <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qvector.htm#first" translate="no">first</a>().</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQVector<T>& -->
<h3 class="fn" id="swap" translate="no"><a name="swap"></a><span class="type">void</span> QVector::<span class="name">swap</span>(<span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#swap" title="Direct link to this headline"></a></h3>
<p>Swaps vector <i translate="no">other</i> with this vector. This operation is very fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>
<!-- @@@swap -->
<!-- $$$swapItemsAt[overload1]$$$swapItemsAtintint -->
<h3 class="fn" id="swapItemsAt" translate="no"><a name="swapItemsAt"></a><span class="type">void</span> QVector::<span class="name">swapItemsAt</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>j</i>)<a class="plink" href="#swapItemsAt" title="Direct link to this headline"></a></h3>
<p>Exchange the item at index position <i translate="no">i</i> with the item at index position <i translate="no">j</i>. This function assumes that both <i translate="no">i</i> and <i translate="no">j</i> are at least 0 but less than <a href="./qvector.htm#size" translate="no">size</a>(). To avoid failure, test that both <i translate="no">i</i> and <i translate="no">j</i> are at least 0 and less than <a href="./qvector.htm#size" translate="no">size</a>().</p>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@swapItemsAt -->
<!-- $$$takeAt[overload1]$$$takeAtint -->
<h3 class="fn" id="takeAt" translate="no"><a name="takeAt"></a><span class="type">T</span> QVector::<span class="name">takeAt</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#takeAt" title="Direct link to this headline"></a></h3>
<p>Removes the element at index position <i translate="no">i</i> and returns it.</p>
<p>Equivalent to</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">T t <span class="operator">=</span> at(i);
remove(i);
<span class="keyword">return</span> t;</pre></div>
<p>Provided for compatibility with <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qvector.htm#takeFirst" translate="no">takeFirst</a>(), <a href="./qvector.htm#takeLast" translate="no">takeLast</a>(), and <a href="./qlist.htm#takeAt" translate="no">QList::takeAt</a>().</p>
<!-- @@@takeAt -->
<!-- $$$takeFirst[overload1]$$$takeFirst -->
<h3 class="fn" id="takeFirst" translate="no"><a name="takeFirst"></a><span class="type">T</span> QVector::<span class="name">takeFirst</span>()<a class="plink" href="#takeFirst" title="Direct link to this headline"></a></h3>
<p>Removes the first item in the vector and returns it. This function assumes the vector is not empty. To avoid failure, call <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qvector.htm#takeLast" translate="no">takeLast</a>() and <a href="./qvector.htm#removeFirst" translate="no">removeFirst</a>().</p>
<!-- @@@takeFirst -->
<!-- $$$takeLast[overload1]$$$takeLast -->
<h3 class="fn" id="takeLast" translate="no"><a name="takeLast"></a><span class="type">T</span> QVector::<span class="name">takeLast</span>()<a class="plink" href="#takeLast" title="Direct link to this headline"></a></h3>
<p>Removes the last item in the list and returns it. This function assumes the vector is not empty. To avoid failure, call <a href="./qvector.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>If you don't use the return value, <a href="./qvector.htm#removeLast" translate="no">removeLast</a>() is more efficient.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qvector.htm#takeFirst" translate="no">takeFirst</a>() and <a href="./qvector.htm#removeLast" translate="no">removeLast</a>().</p>
<!-- @@@takeLast -->
<!-- $$$toList[overload1]$$$toList -->
<h3 class="fn" id="toList" translate="no"><a name="toList"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">toList</span>() const<a class="plink" href="#toList" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./qlist.htm" translate="no">QList</a> object with the data contained in this <a href="./qvector.htm" translate="no">QVector</a>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vect;
vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"red"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"green"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"blue"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"black"</span>;

<span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list <span class="operator">=</span> vect<span class="operator">.</span>toList();
<span class="comment">// list: ["red", "green", "blue", "black"]</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>Since Qt 5.14, range constructors are available for Qt's generic <a href="./containers.htm" translate="no">container classes</a> and should be used in place of this method.</p>
</div>
<p><b>See also </b><a href="./qvector.htm#fromList" translate="no">fromList</a>() and <a href="./qlist.htm#fromVector" translate="no">QList::fromVector</a>().</p>
<!-- @@@toList -->
<!-- $$$toStdVector[overload1]$$$toStdVector -->
<h3 class="fn" id="toStdVector" translate="no"><a name="toStdVector"></a><span class="type">int</span> QVector::<span class="name">toStdVector</span>() const<a class="plink" href="#toStdVector" title="Direct link to this headline"></a></h3>
<p>Returns a std::vector object with the data contained in this <a href="./qvector.htm" translate="no">QVector</a>. Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vector;
vector <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">1.2</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">0.5</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">3.14</span>;

std<span class="operator">::</span>vector<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> stdvector <span class="operator">=</span> vector<span class="operator">.</span>toStdVector();</pre></div>
<div class="admonition note">
<p><b>Note: </b>Since Qt 5.14, range constructors are available for Qt's generic <a href="./containers.htm" translate="no">container classes</a> and should be used in place of this method.</p>
</div>
<p><b>See also </b><a href="./qvector.htm#fromStdVector" translate="no">fromStdVector</a>() and <a href="./qlist-obsolete.htm#toStdList" translate="no">QList::toStdList</a>().</p>
<!-- @@@toStdVector -->
<!-- $$$value[overload1]$$$valueint -->
<h3 class="fn" id="value" translate="no"><a name="value"></a><span class="type">T</span> QVector::<span class="name">value</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#value" title="Direct link to this headline"></a></h3>
<p>Returns the value at index position <i translate="no">i</i> in the vector.</p>
<p>If the index <i translate="no">i</i> is out of bounds, the function returns a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a>. If you are certain that <i translate="no">i</i> is within bounds, you can use <a href="./qvector.htm#at" translate="no">at</a>() instead, which is slightly faster.</p>
<p><b>See also </b><a href="./qvector.htm#at" translate="no">at</a>() and <a href="./qvector.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@value -->
<!-- $$$value$$$valueintconstT& -->
<h3 class="fn" id="value-1" translate="no"><a name="value-1"></a><span class="type">T</span> QVector::<span class="name">value</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>defaultValue</i>) const<a class="plink" href="#value-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>If the index <i translate="no">i</i> is out of bounds, the function returns <i translate="no">defaultValue</i>.</p>
<!-- @@@value -->
<!-- $$$operator!=[overload1]$$$operator!=constQVector<T>& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QVector::<span class="name">operator!=</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is not equal to this vector; otherwise returns <code translate="no">false</code>.</p>
<p>Two vectors are considered equal if they contain the same values in the same order.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qvector.htm#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator+[overload1]$$$operator+constQVector<T>& -->
<h3 class="fn" id="operator-2b" translate="no"><a name="operator-2b"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; QVector::<span class="name">operator+</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-2b" title="Direct link to this headline"></a></h3>
<p>Returns a vector that contains all the items in this vector followed by all the items in the <i translate="no">other</i> vector.</p>
<p><b>See also </b><a href="./qvector.htm#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+=[overload1]$$$operator+=constQVector<T>& -->
<h3 class="fn" id="operator-2b-eq" translate="no"><a name="operator-2b-eq"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator+=</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-2b-eq" title="Direct link to this headline"></a></h3>
<p>Appends the items of the <i translate="no">other</i> vector to this vector and returns a reference to this vector.</p>
<p><b>See also </b><a href="./qvector.htm#operator-2b" translate="no">operator+</a>() and <a href="./qvector.htm#append" translate="no">append</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constT& -->
<h3 class="fn" id="operator-2b-eq-1" translate="no"><a name="operator-2b-eq-1"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator+=</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#operator-2b-eq-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends <i translate="no">value</i> to the vector.</p>
<p><b>See also </b><a href="./qvector.htm#append" translate="no">append</a>() and <a href="./qvector.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=T&& -->
<h3 class="fn" id="operator-2b-eq-2" translate="no"><a name="operator-2b-eq-2"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator+=</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#operator-2b-eq-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.11.</p>
<p><b>See also </b><a href="./qvector.htm#append" translate="no">append</a>() and <a href="./qvector.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator<<[overload1]$$$operator<<constT& -->
<h3 class="fn" id="operator-lt-lt" translate="no"><a name="operator-lt-lt"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator&lt;&lt;</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#operator-lt-lt" title="Direct link to this headline"></a></h3>
<p>Appends <i translate="no">value</i> to the vector and returns a reference to this vector.</p>
<p><b>See also </b><a href="./qvector.htm#append" translate="no">append</a>() and <a href="./qvector.htm#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<constQVector<T>& -->
<h3 class="fn" id="operator-lt-lt-1" translate="no"><a name="operator-lt-lt-1"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator&lt;&lt;</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-lt-lt-1" title="Direct link to this headline"></a></h3>
<p>Appends <i translate="no">other</i> to the vector and returns a reference to the vector.</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<T&& -->
<h3 class="fn" id="operator-lt-lt-2" translate="no"><a name="operator-lt-lt-2"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator&lt;&lt;</span>(<span class="type">T</span> &amp;&amp;<i>value</i>)<a class="plink" href="#operator-lt-lt-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.11.</p>
<p><b>See also </b><a href="./qvector.htm#append" translate="no">append</a>() and <a href="./qvector.htm#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator=$$$operator=int -->
<h3 class="fn" id="operator-eq-2" translate="no"><a name="operator-eq-2"></a><span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;QVector::<span class="name">operator=</span>(<span class="type">int</span> <i>args</i>)<a class="plink" href="#operator-eq-2" title="Direct link to this headline"></a></h3>
<p>Assigns the collection of values in <i translate="no">args</i> to this <a href="./qvector.htm" translate="no">QVector</a> instance.</p>
<p>This operator is only enabled if the compiler supports C++11 initializer lists.</p>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQVector<T>& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QVector::<span class="name">operator==</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is equal to this vector; otherwise returns <code translate="no">false</code>.</p>
<p>Two vectors are considered equal if they contain the same values in the same order.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qvector.htm#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d" translate="no"><a name="operator-5b-5d"></a><span class="type">T</span> &amp;QVector::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#operator-5b-5d" title="Direct link to this headline"></a></h3>
<p>Returns the item at index position <i translate="no">i</i> as a modifiable reference.</p>
<p><i translate="no">i</i> must be a valid index position in the vector (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qvector.htm#size" translate="no">size</a>()).</p>
<p>Note that using non-const operators can cause <a href="./qvector.htm" translate="no">QVector</a> to do a deep copy.</p>
<p><b>See also </b><a href="./qvector.htm#at" translate="no">at</a>() and <a href="./qvector.htm#value" translate="no">value</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d-1" translate="no"><a name="operator-5b-5d-1"></a>const <span class="type">T</span> &amp;QVector::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#operator-5b-5d-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as at(<i translate="no">i</i>).</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash[overload1]$$$qHashconstQVector<T>&uint -->
<h3 class="fn" id="qHash" translate="no"><a name="qHash"></a>template &lt;typename T&gt; <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qHash</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>key</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>seed</i> = 0)<a class="plink" href="#qHash" title="Direct link to this headline"></a></h3>
<p>Returns the hash value for <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<p>This function requires qHash() to be overloaded for the value type <code translate="no">T</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qHash -->
<!-- $$$operator<[overload1]$$$operator<constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-lt" translate="no"><a name="operator-lt"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-lt" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if vector <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically less than</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator< -->
<!-- $$$operator<=[overload1]$$$operator<=constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-lt-eq" translate="no"><a name="operator-lt-eq"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-lt-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if vector <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically less than or equal to</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator<= -->
<!-- $$$operator>[overload1]$$$operator>constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-gt" translate="no"><a name="operator-gt"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-gt" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if vector <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically greater than</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=constQVector<T>&constQVector<T>& -->
<h3 class="fn" id="operator-gt-eq" translate="no"><a name="operator-gt-eq"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qvector.htm#QVector" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-gt-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if vector <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically greater than or equal to</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator>= -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>