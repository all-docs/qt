<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QSGMaterialRhiShader | Qt Quick</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a href="./qtquick-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QSGMaterialRhiShader</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QSGMaterialRhiShader Class</h1>
<!-- $$$QSGMaterialRhiShader-brief -->
<p>The QSGMaterialRhiShader class represents a graphics API independent shader program. <a href="#details">More...</a></p>
<!-- @@@QSGMaterialRhiShader -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSGMaterialRhiShader&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.14</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qsgmaterialshader.htm" translate="no">QSGMaterialShader</a></td></tr></tbody></table></div><p>This class was introduced in Qt 5.14.</p>
<ul>
<li><a href="./qsgmaterialrhishader-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader-graphicspipelinestate.htm" translate="no">GraphicsPipelineState</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader-renderstate.htm" translate="no">RenderState</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#Flag-enum" translate="no">Flag</a></b> { UpdatesGraphicsPipelineState }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#Flag-enum" translate="no">Flags</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#QSGMaterialRhiShader" translate="no">QSGMaterialRhiShader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGMaterialRhiShader::Flags </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#setFlag" translate="no">setFlag</a></b>(QSGMaterialRhiShader::Flags <i>flags</i>, bool <i>on</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#updateGraphicsPipelineState" translate="no">updateGraphicsPipelineState</a></b>(QSGMaterialRhiShader::RenderState &amp;<i>state</i>, QSGMaterialRhiShader::GraphicsPipelineState *<i>ps</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#updateSampledImage" translate="no">updateSampledImage</a></b>(QSGMaterialRhiShader::RenderState &amp;<i>state</i>, int <i>binding</i>, QSGTexture **<i>texture</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#updateUniformData" translate="no">updateUniformData</a></b>(QSGMaterialRhiShader::RenderState &amp;<i>state</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td></tr>
</tbody></table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions<a class="plink" href="#protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#setShader" translate="no">setShader</a></b>(QSGMaterialRhiShader::Stage <i>stage</i>, const QShader &amp;<i>shader</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialrhishader.htm#setShaderFileName" translate="no">setShaderFileName</a></b>(QSGMaterialRhiShader::Stage <i>stage</i>, const QString &amp;<i>filename</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QSGMaterialRhiShader-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QSGMaterialRhiShader is a modern, cross-platform alternative to <a href="./qsgmaterialshader.htm" translate="no">QSGMaterialShader</a>. The latter is tied to OpenGL and GLSL by design, whereas QSGMaterialRhiShader is based on QShader, a container for multiple versions of a graphics shader together with reflection information.</p>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="./qtquick-visualcanvas-scenegraph.htm#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
</div>
<!-- @@@QSGMaterialRhiShader -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$UpdatesGraphicsPipelineState -->
<h3 class="flags" id="Flag-enum"><a name="Flag-enum"></a>enum QSGMaterialRhiShader::<span class="name">Flag</span><br>flags QSGMaterialRhiShader::<span class="name">Flags</span><a class="plink" href="#Flag-enum" title="Direct link to this headline"></a></h3>
<p>Flag values to indicate special material properties.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QSGMaterialRhiShader::UpdatesGraphicsPipelineState</code></td><td class="topAlign tblval"><code translate="no">0x0001</code></td><td class="topAlign">Setting this flag enables calling <a href="./qsgmaterialrhishader.htm#updateGraphicsPipelineState" translate="no">updateGraphicsPipelineState</a>().</td></tr>
</tbody></table></div>
<p>The Flags type is a typedef for <a href="./qflags.htm">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSGMaterialRhiShader[overload1]$$$QSGMaterialRhiShader -->
<h3 class="fn" id="QSGMaterialRhiShader" translate="no"><a name="QSGMaterialRhiShader"></a>QSGMaterialRhiShader::<span class="name">QSGMaterialRhiShader</span>()<a class="plink" href="#QSGMaterialRhiShader" title="Direct link to this headline"></a></h3>
<p>Constructs a new QSGMaterialRhiShader.</p>
<!-- @@@QSGMaterialRhiShader -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" id="flags" translate="no"><a name="flags"></a><span class="type"><a href="./qsgmaterialrhishader.htm#Flag-enum" translate="no">QSGMaterialRhiShader::Flags</a></span> QSGMaterialRhiShader::<span class="name">flags</span>() const<a class="plink" href="#flags" title="Direct link to this headline"></a></h3>
<p>Returns the currently set flags for this material shader.</p>
<!-- @@@flags -->
<!-- $$$setFlag[overload1]$$$setFlagQSGMaterialRhiShader::Flagsbool -->
<h3 class="fn" id="setFlag" translate="no"><a name="setFlag"></a><span class="type">void</span> QSGMaterialRhiShader::<span class="name">setFlag</span>(<span class="type"><a href="./qsgmaterialrhishader.htm#Flag-enum" translate="no">QSGMaterialRhiShader::Flags</a></span> <i>flags</i>, <span class="type">bool</span> <i>on</i> = true)<a class="plink" href="#setFlag" title="Direct link to this headline"></a></h3>
<p>Sets the <i translate="no">flags</i> on this material shader if <i translate="no">on</i> is true; otherwise clears the specified flags.</p>
<!-- @@@setFlag -->
<!-- $$$setShader[overload1]$$$setShaderQSGMaterialRhiShader::StageconstQShader& -->
<h3 class="fn" id="setShader" translate="no"><a name="setShader"></a><code translate="no">[protected] </code><span class="type">void</span> QSGMaterialRhiShader::<span class="name">setShader</span>(<span class="type">QSGMaterialRhiShader::Stage</span> <i>stage</i>, const <span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qshader.html" translate="no">QShader</a></span> &amp;<i>shader</i>)<a class="plink" href="#setShader" title="Direct link to this headline"></a></h3>
<p>Sets the <i translate="no">shader</i> for the specified <i translate="no">stage</i>.</p>
<!-- @@@setShader -->
<!-- $$$setShaderFileName[overload1]$$$setShaderFileNameQSGMaterialRhiShader::StageconstQString& -->
<h3 class="fn" id="setShaderFileName" translate="no"><a name="setShaderFileName"></a><code translate="no">[protected] </code><span class="type">void</span> QSGMaterialRhiShader::<span class="name">setShaderFileName</span>(<span class="type">QSGMaterialRhiShader::Stage</span> <i>stage</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>filename</i>)<a class="plink" href="#setShaderFileName" title="Direct link to this headline"></a></h3>
<p>Sets the <i translate="no">filename</i> for the shader for the specified <i translate="no">stage</i>.</p>
<p>The file is expected to contain a serialized QRhiShader.</p>
<!-- @@@setShaderFileName -->
<!-- $$$updateGraphicsPipelineState[overload1]$$$updateGraphicsPipelineStateQSGMaterialRhiShader::RenderState&QSGMaterialRhiShader::GraphicsPipelineState*QSGMaterial*QSGMaterial* -->
<h3 class="fn" id="updateGraphicsPipelineState" translate="no"><a name="updateGraphicsPipelineState"></a><code translate="no">[virtual] </code><span class="type">bool</span> QSGMaterialRhiShader::<span class="name">updateGraphicsPipelineState</span>(<span class="type"><a href="./qsgmaterialrhishader-renderstate.htm" translate="no">QSGMaterialRhiShader::RenderState</a></span> &amp;<i>state</i>, <span class="type"><a href="./qsgmaterialrhishader-graphicspipelinestate.htm" translate="no">QSGMaterialRhiShader::GraphicsPipelineState</a></span> *<i>ps</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>oldMaterial</i>)<a class="plink" href="#updateGraphicsPipelineState" title="Direct link to this headline"></a></h3>
<p>This function is called by the scene graph to enable the material to provide a custom set of graphics state. The set of states that are customizable by material is limited to blending and related settings.</p>
<div class="admonition note">
<p><b>Note: </b>This function is only called when the <a href="./qsgmaterialrhishader.htm#Flag-enum" translate="no">UpdatesGraphicsPipelineState</a> flag was enabled via setFlags(). By default it is not set, and so this function is never called.</p>
</div>
<p>The return value must be <code translate="no">true</code> whenever a change was made to any of the members in <i translate="no">ps</i>.</p>
<div class="admonition note">
<p><b>Note: </b>The contents of <i translate="no">ps</i> is not persistent between invocations of this function.</p>
</div>
<p>The current rendering <i translate="no">state</i> is passed from the scene graph.</p>
<p>The subclass specific state can be extracted from <i translate="no">newMaterial</i>. When <i translate="no">oldMaterial</i> is null, this shader was just activated.</p>
<!-- @@@updateGraphicsPipelineState -->
<!-- $$$updateSampledImage[overload1]$$$updateSampledImageQSGMaterialRhiShader::RenderState&intQSGTexture**QSGMaterial*QSGMaterial* -->
<h3 class="fn" id="updateSampledImage" translate="no"><a name="updateSampledImage"></a><code translate="no">[virtual] </code><span class="type">void</span> QSGMaterialRhiShader::<span class="name">updateSampledImage</span>(<span class="type"><a href="./qsgmaterialrhishader-renderstate.htm" translate="no">QSGMaterialRhiShader::RenderState</a></span> &amp;<i>state</i>, <span class="type">int</span> <i>binding</i>, <span class="type"><a href="./qsgtexture.htm" translate="no">QSGTexture</a></span> **<i>texture</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>oldMaterial</i>)<a class="plink" href="#updateSampledImage" title="Direct link to this headline"></a></h3>
<p>This function is called by the scene graph to prepare using a sampled image in the shader, typically in form of a combined image sampler.</p>
<p><i translate="no">binding</i> is the binding number of the sampler. The function is called for each variable in the material's shaders' <a href="https://doc.qt.io/archives/qt-5.15/qshaderdescription.html#combinedImageSamplers" translate="no">QShaderDescription::combinedImageSamplers</a>().</p>
<p>When *<i translate="no">texture</i> is null, it must be set to a <a href="./qsgtexture.htm" translate="no">QSGTexture</a> pointer before returning. When non-null, it is up to the material to decide if a new <code translate="no">QSGTexture *</code> is stored to it, or if it updates some parameters on the already known <a href="./qsgtexture.htm" translate="no">QSGTexture</a>. The ownership of the <a href="./qsgtexture.htm" translate="no">QSGTexture</a> is not transferred.</p>
<p>The current rendering <i translate="no">state</i> is passed from the scene graph. It is up to the material to enqueue the texture data uploads to the QRhiResourceUpdateBatch retriveable via <a href="./qsgmaterialrhishader-renderstate.htm#resourceUpdateBatch" translate="no">RenderState::resourceUpdateBatch</a>().</p>
<p>The subclass specific state can be extracted from <i translate="no">newMaterial</i>.</p>
<p><i translate="no">oldMaterial</i> can be used to minimize changes. When <i translate="no">oldMaterial</i> is null, this shader was just activated.</p>
<!-- @@@updateSampledImage -->
<!-- $$$updateUniformData[overload1]$$$updateUniformDataQSGMaterialRhiShader::RenderState&QSGMaterial*QSGMaterial* -->
<h3 class="fn" id="updateUniformData" translate="no"><a name="updateUniformData"></a><code translate="no">[virtual] </code><span class="type">bool</span> QSGMaterialRhiShader::<span class="name">updateUniformData</span>(<span class="type"><a href="./qsgmaterialrhishader-renderstate.htm" translate="no">QSGMaterialRhiShader::RenderState</a></span> &amp;<i>state</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>oldMaterial</i>)<a class="plink" href="#updateUniformData" title="Direct link to this headline"></a></h3>
<p>This function is called by the scene graph to get the contents of the shader program's uniform buffer updated. The implementation is not expected to perform any real graphics operations, it is merely responsible for copying data to the <a href="./qbytearray.htm" translate="no">QByteArray</a> returned from <a href="./qsgmaterialrhishader-renderstate.htm#uniformData" translate="no">RenderState::uniformData</a>(). The scene graph takes care of making that buffer visible in the shaders.</p>
<p>The current rendering <i translate="no">state</i> is passed from the scene graph. If the state indicates that any relevant state is dirty, the implementation must update the appropriate region in the buffer data that is accessible via <a href="./qsgmaterialrhishader-renderstate.htm#uniformData" translate="no">RenderState::uniformData</a>(). When a state, such as, matrix or opacity, is not dirty, there is no need to touch the corresponding region since the data is persistent.</p>
<p>The return value must be <code translate="no">true</code> whenever any change was made to the uniform data.</p>
<p>The subclass specific state, such as the color of a flat color material, should be extracted from <i translate="no">newMaterial</i> to update the relevant regions in the buffer accordingly.</p>
<p><i translate="no">oldMaterial</i> can be used to minimize buffer changes (which are typically memcpy calls) when updating material states. When <i translate="no">oldMaterial</i> is null, this shader was just activated.</p>
<!-- @@@updateUniformData -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>