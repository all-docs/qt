<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QMap | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qmap.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QMap</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QMap Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename Key, typename T&gt; class QMap</span>
<!-- $$$QMap-brief -->
<p>The QMap class is a template class that provides a red-black-tree-based dictionary. <a href="#details">More...</a></p>
<!-- @@@QMap -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QMap&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qmultimap.htm" translate="no">QMultiMap</a></p>
</td></tr></tbody></table></div><ul>
<li><a href="./qmap-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qmap-obsolete.htm">Obsolete members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qmap-const-iterator.htm" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qmap-iterator.htm" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qmap-key-iterator.htm" translate="no">key_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#Iterator-typedef" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#const_key_value_iterator-typedef" translate="no">const_key_value_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#key_type-typedef" translate="no">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#key_value_iterator-typedef" translate="no">key_value_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#mapped_type-typedef" translate="no">mapped_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#size_type-typedef" translate="no">size_type</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#QMap-4" translate="no">QMap</a></b>(<i>const int</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#QMap-3" translate="no">QMap</a></b>(QMap&lt;Key, T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#QMap-2" translate="no">QMap</a></b>(const QMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#QMap-1" translate="no">QMap</a></b>(<i>int</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#QMap" translate="no">QMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#operator-eq-1" translate="no">operator=</a></b>(QMap&lt;Key, T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap&lt;Key, T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#operator-eq" translate="no">operator=</a></b>(const QMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#dtor.QMap" translate="no">~QMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#constFind" translate="no">constFind</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#constKeyValueBegin" translate="no">constKeyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#constKeyValueEnd" translate="no">constKeyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#contains" translate="no">contains</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#count" translate="no">count</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#count-1" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPair&lt;QMap::iterator, QMap::iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#equal_range" translate="no">equal_range</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPair&lt;QMap::const_iterator, QMap::const_iterator&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#equal_range-1" translate="no">equal_range</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#erase" translate="no">erase</a></b>(QMap::iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#find" translate="no">find</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#find-1" translate="no">find</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#first" translate="no">first</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#first-1" translate="no">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const Key &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#firstKey" translate="no">firstKey</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#insert" translate="no">insert</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#insert-1" translate="no">insert</a></b>(QMap::const_iterator <i>pos</i>, const Key &amp;<i>key</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#insert-2" translate="no">insert</a></b>(const QMap&lt;Key, T&gt; &amp;<i>map</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const Key </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#key" translate="no">key</a></b>(const T &amp;<i>value</i>, const Key &amp;<i>defaultKey</i> = Key()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keyBegin" translate="no">keyBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::key_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keyEnd" translate="no">keyEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keyValueBegin" translate="no">keyValueBegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keyValueBegin-1" translate="no">keyValueBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keyValueEnd" translate="no">keyValueEnd</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_key_value_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keyValueEnd-1" translate="no">keyValueEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keys" translate="no">keys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;Key&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#keys-1" translate="no">keys</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#last" translate="no">last</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#last-1" translate="no">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const Key &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#lastKey" translate="no">lastKey</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#lowerBound" translate="no">lowerBound</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#lowerBound-1" translate="no">lowerBound</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#remove" translate="no">remove</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#swap" translate="no">swap</a></b>(QMap&lt;Key, T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#take" translate="no">take</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#toStdMap" translate="no">toStdMap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#upperBound" translate="no">upperBound</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#upperBound-1" translate="no">upperBound</a></b>(const Key &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#value" translate="no">value</a></b>(const Key &amp;<i>key</i>, const T &amp;<i>defaultValue</i> = T()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#values" translate="no">values</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#operator-not-eq" translate="no">operator!=</a></b>(const QMap&lt;Key, T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#operator-eq-eq" translate="no">operator==</a></b>(const QMap&lt;Key, T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#operator-5b-5d" translate="no">operator[]</a></b>(const Key &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T </td><td class="memItemRight bottomAlign"><b><a href="./qmap.htm#operator-5b-5d-1" translate="no">operator[]</a></b>(const Key &amp;<i>key</i>) const</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QMap-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QMap&lt;Key, T&gt; is one of Qt's generic <a href="./containers.htm" translate="no">container classes</a>. It stores (key, value) pairs and provides fast lookup of the value associated with a key.</p>
<p>QMap and <a href="./qhash.htm#qhash" translate="no">QHash</a> provide very similar functionality. The differences are:</p>
<ul>
<li><a href="./qhash.htm#qhash" translate="no">QHash</a> provides average faster lookups than QMap. (See <a href="./containers.htm#algorithmic-complexity" translate="no">Algorithmic Complexity</a> for details.)</li>
<li>When iterating over a <a href="./qhash.htm#qhash" translate="no">QHash</a>, the items are arbitrarily ordered. With QMap, the items are always sorted by key.</li>
<li>The key type of a <a href="./qhash.htm#qhash" translate="no">QHash</a> must provide operator==() and a global <a href="./qhash.htm#qhash" translate="no">qHash</a>(Key) function. The key type of a QMap must provide operator&lt;() specifying a total order. Since Qt 5.8.1 it is also safe to use a pointer type as key, even if the underlying operator&lt;() does not provide a total order.</li>
</ul>
<p>Here's an example QMap with <a href="./qstring.htm" translate="no">QString</a> keys and <code translate="no">int</code> values:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> map;</pre></div>
<p>To insert a (key, value) pair into the map, you can use operator[]():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">map<span class="operator">[</span><span class="string">"one"</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">1</span>;
map<span class="operator">[</span><span class="string">"three"</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">3</span>;
map<span class="operator">[</span><span class="string">"seven"</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">7</span>;</pre></div>
<p>This inserts the following three (key, value) pairs into the QMap: ("one", 1), ("three", 3), and ("seven", 7). Another way to insert items into the map is to use <a href="./qmap.htm#insert" translate="no">insert</a>():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">map<span class="operator">.</span>insert(<span class="string">"twelve"</span><span class="operator">,</span> <span class="number">12</span>);</pre></div>
<p>To look up a value, use operator[]() or <a href="./qmap.htm#value" translate="no">value</a>():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> num1 <span class="operator">=</span> map<span class="operator">[</span><span class="string">"thirteen"</span><span class="operator">]</span>;
<span class="type">int</span> num2 <span class="operator">=</span> map<span class="operator">.</span>value(<span class="string">"thirteen"</span>);</pre></div>
<p>If there is no item with the specified key in the map, these functions return a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a>.</p>
<p>If you want to check whether the map contains a certain key, use <a href="./qmap.htm#contains" translate="no">contains</a>():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> timeout <span class="operator">=</span> <span class="number">30</span>;
<span class="keyword">if</span> (map<span class="operator">.</span>contains(<span class="string">"TIMEOUT"</span>))
    timeout <span class="operator">=</span> map<span class="operator">.</span>value(<span class="string">"TIMEOUT"</span>);</pre></div>
<p>There is also a <a href="./qmap.htm#value" translate="no">value</a>() overload that uses its second argument as a default value if there is no item with the specified key:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> timeout <span class="operator">=</span> map<span class="operator">.</span>value(<span class="string">"TIMEOUT"</span><span class="operator">,</span> <span class="number">30</span>);</pre></div>
<p>In general, we recommend that you use <a href="./qmap.htm#contains" translate="no">contains</a>() and <a href="./qmap.htm#value" translate="no">value</a>() rather than operator[]() for looking up a key in a map. The reason is that operator[]() silently inserts an item into the map if no item exists with the same key (unless the map is const). For example, the following code snippet will create 1000 items in memory:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// WRONG</span>
<span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span> map;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
<span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000</span>; <span class="operator">+</span><span class="operator">+</span>i) {
    <span class="keyword">if</span> (map<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> okButton)
        cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Found button at index "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
}</pre></div>
<p>To avoid this problem, replace <code translate="no">map[i]</code> with <code translate="no">map.value(i)</code> in the code above.</p>
<p>If you want to navigate through all the (key, value) pairs stored in a QMap, you can use an iterator. QMap provides both <a href="./containers.htm#java-style-iterators" translate="no">Java-style iterators</a> (<a href="./qmapiterator.htm" translate="no">QMapIterator</a> and <a href="./qmutablemapiterator.htm" translate="no">QMutableMapIterator</a>) and <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterators</a> (<a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a> and <a href="./qmap-iterator.htm" translate="no">QMap::iterator</a>). Here's how to iterate over a QMap&lt;<a href="./qstring.htm" translate="no">QString</a>, int&gt; using a Java-style iterator:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmapiterator.htm" translate="no">QMapIterator</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> i(map);
<span class="keyword">while</span> (i<span class="operator">.</span>hasNext()) {
    i<span class="operator">.</span>next();
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>key() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">": "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
}</pre></div>
<p>Here's the same code, but using an STL-style iterator this time:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>const_iterator i <span class="operator">=</span> map<span class="operator">.</span>constBegin();
<span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> map<span class="operator">.</span>constEnd()) {
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>key() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">": "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
    <span class="operator">+</span><span class="operator">+</span>i;
}</pre></div>
<p>The items are traversed in ascending key order.</p>
<p>Normally, a QMap allows only one value per key. If you call <a href="./qmap.htm#insert" translate="no">insert</a>() with a key that already exists in the QMap, the previous value will be erased. For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">map<span class="operator">.</span>insert(<span class="string">"plenty"</span><span class="operator">,</span> <span class="number">100</span>);
map<span class="operator">.</span>insert(<span class="string">"plenty"</span><span class="operator">,</span> <span class="number">2000</span>);
<span class="comment">// map.value("plenty") == 2000</span></pre></div>
<p>However, you can store multiple values per key by using using the subclass <a href="./qmultimap.htm" translate="no">QMultiMap</a>. If you want to retrieve all the values for a single key, you can use values(const Key &amp;key), which returns a <a href="./qlist.htm" translate="no">QList</a>&lt;T&gt;:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> values <span class="operator">=</span> map<span class="operator">.</span>values(<span class="string">"plenty"</span>);
<span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> values<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i)
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> values<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;</pre></div>
<p>The items that share the same key are available from most recently to least recently inserted. Another approach is to call <a href="./qmap.htm#find" translate="no">find</a>() to get the STL-style iterator for the first item with a key and iterate from there:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>iterator i <span class="operator">=</span> map<span class="operator">.</span>find(<span class="string">"plenty"</span>);
<span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> map<span class="operator">.</span>end() <span class="operator">&amp;</span><span class="operator">&amp;</span> i<span class="operator">.</span>key() <span class="operator">=</span><span class="operator">=</span> <span class="string">"plenty"</span>) {
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
    <span class="operator">+</span><span class="operator">+</span>i;
}</pre></div>
<p>If you only need to extract the values from a map (not the keys), you can also use <a href="./containers.htm#foreach" translate="no">foreach</a>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> map;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
foreach (<span class="type">int</span> value<span class="operator">,</span> map)
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> value <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;</pre></div>
<p>Items can be removed from the map in several ways. One way is to call <a href="./qmap.htm#remove" translate="no">remove</a>(); this will remove any item with the given key. Another way is to use <a href="./qmutablemapiterator.htm#remove" translate="no">QMutableMapIterator::remove</a>(). In addition, you can clear the entire map using <a href="./qmap.htm#clear" translate="no">clear</a>().</p>
<p>QMap's key and value data types must be <a href="./containers.htm#assignable-data-types" translate="no">assignable data types</a>. This covers most data types you are likely to encounter, but the compiler won't let you, for example, store a <a href="./qwidget.htm" translate="no">QWidget</a> as a value; instead, store a <a href="./qwidget.htm" translate="no">QWidget</a> *. In addition, QMap's key type must provide operator&lt;(). QMap uses it to keep its items sorted, and assumes that two keys <code translate="no">x</code> and <code translate="no">y</code> are equal if neither <code translate="no">x &lt; y</code> nor <code translate="no">y &lt; x</code> is true.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor">#ifndef EMPLOYEE_H</span>
<span class="preprocessor">#define EMPLOYEE_H</span>

<span class="keyword">class</span> Employee
{
<span class="keyword">public</span>:
    Employee() {}
    Employee(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>name<span class="operator">,</span> <span class="type"><a href="./qdate.htm" translate="no">QDate</a></span> dateOfBirth);
    <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

<span class="keyword">private</span>:
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> myName;
    <span class="type"><a href="./qdate.htm" translate="no">QDate</a></span> myDateOfBirth;
};

<span class="keyword">inline</span> bool <span class="keyword">operator</span><span class="operator">&lt;</span>(<span class="keyword">const</span> Employee <span class="operator">&amp;</span>e1<span class="operator">,</span> <span class="keyword">const</span> Employee <span class="operator">&amp;</span>e2)
{
    <span class="keyword">if</span> (e1<span class="operator">.</span>name() <span class="operator">!</span><span class="operator">=</span> e2<span class="operator">.</span>name())
        <span class="keyword">return</span> e1<span class="operator">.</span>name() <span class="operator">&lt;</span> e2<span class="operator">.</span>name();
    <span class="keyword">return</span> e1<span class="operator">.</span>dateOfBirth() <span class="operator">&lt;</span> e2<span class="operator">.</span>dateOfBirth();
}

<span class="preprocessor">#endif // EMPLOYEE_H</span></pre></div>
<p>In the example, we start by comparing the employees' names. If they're equal, we compare their dates of birth to break the tie.</p>
</div>
<p><b>See also </b><a href="./qmapiterator.htm" translate="no">QMapIterator</a>, <a href="./qmutablemapiterator.htm" translate="no">QMutableMapIterator</a>, <a href="./qhash.htm#qhash" translate="no">QHash</a>, and <a href="./qset.htm" translate="no">QSet</a>.</p>
<!-- @@@QMap -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" id="ConstIterator-typedef" translate="no"><a name="ConstIterator-typedef"></a>typedef QMap::<span class="name">ConstIterator</span><a class="plink" href="#ConstIterator-typedef" title="Direct link to this headline"></a></h3>
<p>Qt-style synonym for <a href="./qmap.htm" translate="no">QMap</a>&lt;Key, T&gt;::const_iterator.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" id="Iterator-typedef" translate="no"><a name="Iterator-typedef"></a>typedef QMap::<span class="name">Iterator</span><a class="plink" href="#Iterator-typedef" title="Direct link to this headline"></a></h3>
<p>Qt-style synonym for <a href="./qmap.htm" translate="no">QMap</a>&lt;Key, T&gt;::iterator.</p>
<!-- @@@Iterator -->
<!-- $$$const_key_value_iterator -->
<h3 class="fn" id="const_key_value_iterator-typedef" translate="no"><a name="const_key_value_iterator-typedef"></a>typedef QMap::<span class="name">const_key_value_iterator</span><a class="plink" href="#const_key_value_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>The QMap::const_key_value_iterator typedef provides an STL-style iterator for <a href="./qmap.htm" translate="no">QMap</a> and <a href="./qmultimap.htm" translate="no">QMultiMap</a>.</p>
<p>QMap::const_key_value_iterator is essentially the same as <a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p>This typedef was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qkeyvalueiterator.htm" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@const_key_value_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" id="difference_type-typedef" translate="no"><a name="difference_type-typedef"></a>typedef QMap::<span class="name">difference_type</span><a class="plink" href="#difference_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$key_type -->
<h3 class="fn" id="key_type-typedef" translate="no"><a name="key_type-typedef"></a>typedef QMap::<span class="name">key_type</span><a class="plink" href="#key_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for Key. Provided for STL compatibility.</p>
<!-- @@@key_type -->
<!-- $$$key_value_iterator -->
<h3 class="fn" id="key_value_iterator-typedef" translate="no"><a name="key_value_iterator-typedef"></a>typedef QMap::<span class="name">key_value_iterator</span><a class="plink" href="#key_value_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>The QMap::key_value_iterator typedef provides an STL-style iterator for <a href="./qmap.htm" translate="no">QMap</a> and <a href="./qmultimap.htm" translate="no">QMultiMap</a>.</p>
<p>QMap::key_value_iterator is essentially the same as <a href="./qmap-iterator.htm" translate="no">QMap::iterator</a> with the difference that operator*() returns a key/value pair instead of a value.</p>
<p>This typedef was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qkeyvalueiterator.htm" translate="no">QKeyValueIterator</a>.</p>
<!-- @@@key_value_iterator -->
<!-- $$$mapped_type -->
<h3 class="fn" id="mapped_type-typedef" translate="no"><a name="mapped_type-typedef"></a>typedef QMap::<span class="name">mapped_type</span><a class="plink" href="#mapped_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@mapped_type -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef" translate="no"><a name="size_type-typedef"></a>typedef QMap::<span class="name">size_type</span><a class="plink" href="#size_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QMap$$$QMapconstint -->
<h3 class="fn" id="QMap-4" translate="no"><a name="QMap-4"></a>QMap::<span class="name">QMap</span>(<i>const int</i>)<a class="plink" href="#QMap-4" title="Direct link to this headline"></a></h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p><b>See also </b><a href="./qmap.htm#toStdMap" translate="no">toStdMap</a>().</p>
<!-- @@@QMap -->
<!-- $$$QMap$$$QMapQMap<Key,T>&& -->
<h3 class="fn" id="QMap-3" translate="no"><a name="QMap-3"></a>QMap::<span class="name">QMap</span>(<span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;&amp;<i>other</i>)<a class="plink" href="#QMap-3" title="Direct link to this headline"></a></h3>
<p>Move-constructs a QMap instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@QMap -->
<!-- $$$QMap$$$QMapconstQMap<Key,T>& -->
<h3 class="fn" id="QMap-2" translate="no"><a name="QMap-2"></a>QMap::<span class="name">QMap</span>(const <span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#QMap-2" title="Direct link to this headline"></a></h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p>This operation occurs in <a href="./containers.htm#constant-time" translate="no">constant time</a>, because QMap is <a href="./implicit-sharing.htm" translate="no">implicitly shared</a>. This makes returning a QMap from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="./qmap.htm#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QMap -->
<!-- $$$QMap$$$QMapint -->
<h3 class="fn" id="QMap-1" translate="no"><a name="QMap-1"></a>QMap::<span class="name">QMap</span>(<i>int</i>)<a class="plink" href="#QMap-1" title="Direct link to this headline"></a></h3>
<p>Constructs a map with a copy of each of the elements in the initializer list <i translate="no">list</i>.</p>
<p>This function is only available if the program is being compiled in C++11 mode.</p>
<p>This function was introduced in Qt 5.1.</p>
<!-- @@@QMap -->
<!-- $$$QMap[overload1]$$$QMap -->
<h3 class="fn" id="QMap" translate="no"><a name="QMap"></a>QMap::<span class="name">QMap</span>()<a class="plink" href="#QMap" title="Direct link to this headline"></a></h3>
<p>Constructs an empty map.</p>
<p><b>See also </b><a href="./qmap.htm#clear" translate="no">clear</a>().</p>
<!-- @@@QMap -->
<!-- $$$operator=$$$operator=QMap<Key,T>&& -->
<h3 class="fn" id="operator-eq-1" translate="no"><a name="operator-eq-1"></a><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMap::<span class="name">operator=</span>(<span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;&amp;<i>other</i>)<a class="plink" href="#operator-eq-1" title="Direct link to this headline"></a></h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="./qmap.htm" translate="no">QMap</a> instance.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@operator= -->
<!-- $$$operator=[overload1]$$$operator=constQMap<Key,T>& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;QMap::<span class="name">operator=</span>(const <span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns <i translate="no">other</i> to this map and returns a reference to this map.</p>
<!-- @@@operator= -->
<!-- $$$~QMap[overload1]$$$~QMap -->
<h3 class="fn" id="dtor.QMap" translate="no"><a name="dtor.QMap"></a>QMap::<span class="name">~QMap</span>()<a class="plink" href="#dtor.QMap" title="Direct link to this headline"></a></h3>
<p>Destroys the map. References to the values in the map, and all iterators over this map, become invalid.</p>
<!-- @@@~QMap -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin" translate="no"><a name="begin"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">begin</span>()<a class="plink" href="#begin" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the map.</p>
<p><b>See also </b><a href="./qmap.htm#constBegin" translate="no">constBegin</a>() and <a href="./qmap.htm#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1" translate="no"><a name="begin-1"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">begin</span>() const<a class="plink" href="#begin-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin" translate="no"><a name="cbegin"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">cbegin</span>() const<a class="plink" href="#cbegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the map.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qmap.htm#begin" translate="no">begin</a>() and <a href="./qmap.htm#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend" translate="no"><a name="cend"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">cend</span>() const<a class="plink" href="#cend" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the map.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qmap.htm#cbegin" translate="no">cbegin</a>() and <a href="./qmap.htm#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear" translate="no"><a name="clear"></a><span class="type">void</span> QMap::<span class="name">clear</span>()<a class="plink" href="#clear" title="Direct link to this headline"></a></h3>
<p>Removes all items from the map.</p>
<p><b>See also </b><a href="./qmap.htm#remove" translate="no">remove</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin" translate="no"><a name="constBegin"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">constBegin</span>() const<a class="plink" href="#constBegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the map.</p>
<p><b>See also </b><a href="./qmap.htm#begin" translate="no">begin</a>() and <a href="./qmap.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd" translate="no"><a name="constEnd"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">constEnd</span>() const<a class="plink" href="#constEnd" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the map.</p>
<p><b>See also </b><a href="./qmap.htm#constBegin" translate="no">constBegin</a>() and <a href="./qmap.htm#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindconstKey& -->
<h3 class="fn" id="constFind" translate="no"><a name="constFind"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">constFind</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#constFind" title="Direct link to this headline"></a></h3>
<p>Returns an const iterator pointing to the item with key <i translate="no">key</i> in the map.</p>
<p>If the map contains no item with key <i translate="no">key</i>, the function returns <a href="./qmap.htm#constEnd" translate="no">constEnd</a>().</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also </b><a href="./qmap.htm#find" translate="no">find</a>() and <a href="./qmultimap.htm#constFind" translate="no">QMultiMap::constFind</a>().</p>
<!-- @@@constFind -->
<!-- $$$constKeyValueBegin[overload1]$$$constKeyValueBegin -->
<h3 class="fn" id="constKeyValueBegin" translate="no"><a name="constKeyValueBegin"></a><span class="type"><a href="./qmap.htm#const_key_value_iterator-typedef" translate="no">QMap::const_key_value_iterator</a></span> QMap::<span class="name">constKeyValueBegin</span>() const<a class="plink" href="#constKeyValueBegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the map.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qmap.htm#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@constKeyValueBegin -->
<!-- $$$constKeyValueEnd[overload1]$$$constKeyValueEnd -->
<h3 class="fn" id="constKeyValueEnd" translate="no"><a name="constKeyValueEnd"></a><span class="type"><a href="./qmap.htm#const_key_value_iterator-typedef" translate="no">QMap::const_key_value_iterator</a></span> QMap::<span class="name">constKeyValueEnd</span>() const<a class="plink" href="#constKeyValueEnd" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the map.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qmap.htm#constKeyValueBegin" translate="no">constKeyValueBegin</a>().</p>
<!-- @@@constKeyValueEnd -->
<!-- $$$contains[overload1]$$$containsconstKey& -->
<h3 class="fn" id="contains" translate="no"><a name="contains"></a><span class="type">bool</span> QMap::<span class="name">contains</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#contains" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the map contains an item with key <i translate="no">key</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qmap.htm#count-1" translate="no">count</a>() and <a href="./qmultimap.htm#contains" translate="no">QMultiMap::contains</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstKey& -->
<h3 class="fn" id="count" translate="no"><a name="count"></a><span class="type">int</span> QMap::<span class="name">count</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#count" title="Direct link to this headline"></a></h3>
<p>Returns the number of items associated with key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="./qmap.htm#contains" translate="no">contains</a>() and <a href="./qmultimap.htm#count" translate="no">QMultiMap::count</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-1" translate="no"><a name="count-1"></a><span class="type">int</span> QMap::<span class="name">count</span>() const<a class="plink" href="#count-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="./qmap.htm#size" translate="no">size</a>().</p>
<!-- @@@count -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" id="empty" translate="no"><a name="empty"></a><span class="type">bool</span> QMap::<span class="name">empty</span>() const<a class="plink" href="#empty" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qmap.htm#isEmpty" translate="no">isEmpty</a>(), returning true if the map is empty; otherwise returning false.</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end" translate="no"><a name="end"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">end</span>()<a class="plink" href="#end" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the map.</p>
<p><b>See also </b><a href="./qmap.htm#begin" translate="no">begin</a>() and <a href="./qmap.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1" translate="no"><a name="end-1"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">end</span>() const<a class="plink" href="#end-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$equal_range[overload1]$$$equal_rangeconstKey& -->
<h3 class="fn" id="equal_range" translate="no"><a name="equal_range"></a><span class="type"><a href="./qpair.htm" translate="no">QPair</a></span>&lt;<span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span>, <span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span>&gt; QMap::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>)<a class="plink" href="#equal_range" title="Direct link to this headline"></a></h3>
<p>Returns a pair of iterators delimiting the range of values <code translate="no">[first, second)</code>, that are stored under <i translate="no">key</i>.</p>
<!-- @@@equal_range -->
<!-- $$$equal_range$$$equal_rangeconstKey& -->
<h3 class="fn" id="equal_range-1" translate="no"><a name="equal_range-1"></a><span class="type"><a href="./qpair.htm" translate="no">QPair</a></span>&lt;<span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span>, <span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span>&gt; QMap::<span class="name">equal_range</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#equal_range-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@equal_range -->
<!-- $$$erase[overload1]$$$eraseQMap::iterator -->
<h3 class="fn" id="erase" translate="no"><a name="erase"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">erase</span>(<span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> <i>pos</i>)<a class="plink" href="#erase" title="Direct link to this headline"></a></h3>
<p>Removes the (key, value) pair pointed to by the iterator <i translate="no">pos</i> from the map, and returns an iterator to the next item in the map.</p>
<p><b>See also </b><a href="./qmap.htm#remove" translate="no">remove</a>().</p>
<!-- @@@erase -->
<!-- $$$find[overload1]$$$findconstKey& -->
<h3 class="fn" id="find" translate="no"><a name="find"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>)<a class="plink" href="#find" title="Direct link to this headline"></a></h3>
<p>Returns an iterator pointing to the item with key <i translate="no">key</i> in the map.</p>
<p>If the map contains no item with key <i translate="no">key</i>, the function returns <a href="./qmap.htm#end" translate="no">end</a>().</p>
<p>If the map contains multiple items with key <i translate="no">key</i>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> map;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
<span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>const_iterator i <span class="operator">=</span> map<span class="operator">.</span>find(<span class="string">"HDR"</span>);
<span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> map<span class="operator">.</span>end() <span class="operator">&amp;</span><span class="operator">&amp;</span> i<span class="operator">.</span>key() <span class="operator">=</span><span class="operator">=</span> <span class="string">"HDR"</span>) {
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
    <span class="operator">+</span><span class="operator">+</span>i;
}</pre></div>
<p><b>See also </b><a href="./qmap.htm#constFind" translate="no">constFind</a>(), <a href="./qmap.htm#value" translate="no">value</a>(), <a href="./qmap.htm#values" translate="no">values</a>(), <a href="./qmap.htm#lowerBound" translate="no">lowerBound</a>(), <a href="./qmap.htm#upperBound" translate="no">upperBound</a>(), and <a href="./qmultimap.htm#find" translate="no">QMultiMap::find</a>().</p>
<!-- @@@find -->
<!-- $$$find$$$findconstKey& -->
<h3 class="fn" id="find-1" translate="no"><a name="find-1"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">find</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#find-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@find -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" id="first" translate="no"><a name="first"></a><span class="type">T</span> &amp;QMap::<span class="name">first</span>()<a class="plink" href="#first" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the first value in the map, that is the value mapped to the smallest key. This function assumes that the map is not empty.</p>
<p>When unshared (or const version is called), this executes in <a href="./containers.htm#constant-time" translate="no">constant time</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qmap.htm#last" translate="no">last</a>(), <a href="./qmap.htm#firstKey" translate="no">firstKey</a>(), and <a href="./qmap.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn" id="first-1" translate="no"><a name="first-1"></a>const <span class="type">T</span> &amp;QMap::<span class="name">first</span>() const<a class="plink" href="#first-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@first -->
<!-- $$$firstKey[overload1]$$$firstKey -->
<h3 class="fn" id="firstKey" translate="no"><a name="firstKey"></a>const <span class="type">Key</span> &amp;QMap::<span class="name">firstKey</span>() const<a class="plink" href="#firstKey" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the smallest key in the map. This function assumes that the map is not empty.</p>
<p>This executes in <a href="./containers.htm#constant-time" translate="no">constant time</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qmap.htm#lastKey" translate="no">lastKey</a>(), <a href="./qmap.htm#first" translate="no">first</a>(), <a href="./qmap.htm#keyBegin" translate="no">keyBegin</a>(), and <a href="./qmap.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@firstKey -->
<!-- $$$insert[overload1]$$$insertconstKey&constT& -->
<h3 class="fn" id="insert" translate="no"><a name="insert"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">insert</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert" title="Direct link to this headline"></a></h3>
<p>Inserts a new item with the key <i translate="no">key</i> and a value of <i translate="no">value</i>.</p>
<p>If there is already an item with the key <i translate="no">key</i>, that item's value is replaced with <i translate="no">value</i>.</p>
<p>If there are multiple items with the key <i translate="no">key</i>, the most recently inserted item's value is replaced with <i translate="no">value</i>.</p>
<p><b>See also </b><a href="./qmultimap.htm#insert" translate="no">QMultiMap::insert</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQMap::const_iteratorconstKey&constT& -->
<h3 class="fn" id="insert-1" translate="no"><a name="insert-1"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">insert</span>(<span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> <i>pos</i>, const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts a new item with the key <i translate="no">key</i> and value <i translate="no">value</i> and with hint <i translate="no">pos</i> suggesting where to do the insert.</p>
<p>If <a href="./qmap.htm#constBegin" translate="no">constBegin</a>() is used as hint it indicates that the <i translate="no">key</i> is less than any key in the map while <a href="./qmap.htm#constEnd" translate="no">constEnd</a>() suggests that the <i translate="no">key</i> is (strictly) larger than any key in the map. Otherwise the hint should meet the condition (<i translate="no">pos</i> - 1).<a href="./qmap.htm#key" translate="no">key</a>() &lt; <i translate="no">key</i> &lt;= pos.<a href="./qmap.htm#key" translate="no">key</a>(). If the hint <i translate="no">pos</i> is wrong it is ignored and a regular insert is done.</p>
<p>If there is already an item with the key <i translate="no">key</i>, that item's value is replaced with <i translate="no">value</i>.</p>
<p>If there are multiple items with the key <i translate="no">key</i>, then exactly one of them is replaced with <i translate="no">value</i>.</p>
<p>If the hint is correct and the map is unshared, the insert executes in amortized <a href="./containers.htm#constant-time" translate="no">constant time</a>.</p>
<p>When creating a map from sorted data inserting the largest key first with <a href="./qmap.htm#constBegin" translate="no">constBegin</a>() is faster than inserting in sorted order with <a href="./qmap.htm#constEnd" translate="no">constEnd</a>(), since <a href="./qmap.htm#constEnd" translate="no">constEnd</a>() - 1 (which is needed to check if the hint is valid) needs <a href="./containers.htm#logarithmic-time" translate="no">logarithmic time</a>.</p>
<p><b>Note:</b> Be careful with the hint. Providing an iterator from an older shared instance might crash but there is also a risk that it will silently corrupt both the map and the <i translate="no">pos</i> map.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qmultimap.htm#insert" translate="no">QMultiMap::insert</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertconstQMap<Key,T>& -->
<h3 class="fn" id="insert-2" translate="no"><a name="insert-2"></a><span class="type">void</span> QMap::<span class="name">insert</span>(const <span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>map</i>)<a class="plink" href="#insert-2" title="Direct link to this headline"></a></h3>
<p>Inserts all the items in <i translate="no">map</i> into this map.</p>
<p>If a key is common to both maps, its value will be replaced with the value stored in <i translate="no">map</i>.</p>
<div class="admonition note">
<p><b>Note: </b>If <i translate="no">map</i> contains multiple entries with the same key then the final value of the key is undefined.</p>
</div>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qmultimap.htm#insert" translate="no">QMultiMap::insert</a>().</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty" translate="no"><a name="isEmpty"></a><span class="type">bool</span> QMap::<span class="name">isEmpty</span>() const<a class="plink" href="#isEmpty" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the map contains no items; otherwise returns false.</p>
<p><b>See also </b><a href="./qmap.htm#size" translate="no">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$key[overload1]$$$keyconstT&constKey& -->
<h3 class="fn" id="key" translate="no"><a name="key"></a>const <span class="type">Key</span> QMap::<span class="name">key</span>(const <span class="type">T</span> &amp;<i>value</i>, const <span class="type">Key</span> &amp;<i>defaultKey</i> = Key()) const<a class="plink" href="#key" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the first key with value <i translate="no">value</i>, or <i translate="no">defaultKey</i> if the map contains no item with value <i translate="no">value</i>. If no <i translate="no">defaultKey</i> is provided the function returns a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed key</a>.</p>
<p>This function can be slow (<a href="./containers.htm#linear-time" translate="no">linear time</a>), because <a href="./qmap.htm" translate="no">QMap</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<p>This function was introduced in Qt 4.3.</p>
<p><b>See also </b><a href="./qmap.htm#value" translate="no">value</a>() and <a href="./qmap.htm#keys" translate="no">keys</a>().</p>
<!-- @@@key -->
<!-- $$$keyBegin[overload1]$$$keyBegin -->
<h3 class="fn" id="keyBegin" translate="no"><a name="keyBegin"></a><span class="type"><a href="./qmap-key-iterator.htm" translate="no">QMap::key_iterator</a></span> QMap::<span class="name">keyBegin</span>() const<a class="plink" href="#keyBegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first key in the map.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qmap.htm#keyEnd" translate="no">keyEnd</a>() and <a href="./qmap.htm#firstKey" translate="no">firstKey</a>().</p>
<!-- @@@keyBegin -->
<!-- $$$keyEnd[overload1]$$$keyEnd -->
<h3 class="fn" id="keyEnd" translate="no"><a name="keyEnd"></a><span class="type"><a href="./qmap-key-iterator.htm" translate="no">QMap::key_iterator</a></span> QMap::<span class="name">keyEnd</span>() const<a class="plink" href="#keyEnd" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last key in the map.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qmap.htm#keyBegin" translate="no">keyBegin</a>() and <a href="./qmap.htm#lastKey" translate="no">lastKey</a>().</p>
<!-- @@@keyEnd -->
<!-- $$$keyValueBegin[overload1]$$$keyValueBegin -->
<h3 class="fn" id="keyValueBegin" translate="no"><a name="keyValueBegin"></a><span class="type"><a href="./qmap.htm#key_value_iterator-typedef" translate="no">QMap::key_value_iterator</a></span> QMap::<span class="name">keyValueBegin</span>()<a class="plink" href="#keyValueBegin" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the map.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qmap.htm#keyValueEnd" translate="no">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueBegin$$$keyValueBegin -->
<h3 class="fn" id="keyValueBegin-1" translate="no"><a name="keyValueBegin-1"></a><span class="type"><a href="./qmap.htm#const_key_value_iterator-typedef" translate="no">QMap::const_key_value_iterator</a></span> QMap::<span class="name">keyValueBegin</span>() const<a class="plink" href="#keyValueBegin-1" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first entry in the map.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qmap.htm#keyValueEnd" translate="no">keyValueEnd</a>().</p>
<!-- @@@keyValueBegin -->
<!-- $$$keyValueEnd[overload1]$$$keyValueEnd -->
<h3 class="fn" id="keyValueEnd" translate="no"><a name="keyValueEnd"></a><span class="type"><a href="./qmap.htm#key_value_iterator-typedef" translate="no">QMap::key_value_iterator</a></span> QMap::<span class="name">keyValueEnd</span>()<a class="plink" href="#keyValueEnd" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the map.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qmap.htm#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keyValueEnd$$$keyValueEnd -->
<h3 class="fn" id="keyValueEnd-1" translate="no"><a name="keyValueEnd-1"></a><span class="type"><a href="./qmap.htm#const_key_value_iterator-typedef" translate="no">QMap::const_key_value_iterator</a></span> QMap::<span class="name">keyValueEnd</span>() const<a class="plink" href="#keyValueEnd-1" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary entry after the last entry in the map.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qmap.htm#keyValueBegin" translate="no">keyValueBegin</a>().</p>
<!-- @@@keyValueEnd -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn" id="keys" translate="no"><a name="keys"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type">Key</span>&gt; QMap::<span class="name">keys</span>() const<a class="plink" href="#keys" title="Direct link to this headline"></a></h3>
<p>Returns a list containing all the keys in the map in ascending order. Keys that occur multiple times in the map (because the method is operating on a <a href="./qmultimap.htm" translate="no">QMultiMap</a>) also occur multiple times in the list.</p>
<p>The order is guaranteed to be the same as that used by <a href="./qmap.htm#values" translate="no">values</a>().</p>
<p><b>See also </b><a href="./qmultimap.htm#uniqueKeys" translate="no">QMultiMap::uniqueKeys</a>(), <a href="./qmap.htm#values" translate="no">values</a>(), and <a href="./qmap.htm#key" translate="no">key</a>().</p>
<!-- @@@keys -->
<!-- $$$keys$$$keysconstT& -->
<h3 class="fn" id="keys-1" translate="no"><a name="keys-1"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type">Key</span>&gt; QMap::<span class="name">keys</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#keys-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a list containing all the keys associated with value <i translate="no">value</i> in ascending order.</p>
<p>This function can be slow (<a href="./containers.htm#linear-time" translate="no">linear time</a>), because <a href="./qmap.htm" translate="no">QMap</a>'s internal data structure is optimized for fast lookup by key, not by value.</p>
<!-- @@@keys -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" id="last" translate="no"><a name="last"></a><span class="type">T</span> &amp;QMap::<span class="name">last</span>()<a class="plink" href="#last" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the last value in the map, that is the value mapped to the largest key. This function assumes that the map is not empty.</p>
<p>When unshared (or const version is called), this executes in <a href="./containers.htm#logarithmic-time" translate="no">logarithmic time</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qmap.htm#first" translate="no">first</a>(), <a href="./qmap.htm#lastKey" translate="no">lastKey</a>(), and <a href="./qmap.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn" id="last-1" translate="no"><a name="last-1"></a>const <span class="type">T</span> &amp;QMap::<span class="name">last</span>() const<a class="plink" href="#last-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@last -->
<!-- $$$lastKey[overload1]$$$lastKey -->
<h3 class="fn" id="lastKey" translate="no"><a name="lastKey"></a>const <span class="type">Key</span> &amp;QMap::<span class="name">lastKey</span>() const<a class="plink" href="#lastKey" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the largest key in the map. This function assumes that the map is not empty.</p>
<p>This executes in <a href="./containers.htm#logarithmic-time" translate="no">logarithmic time</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qmap.htm#firstKey" translate="no">firstKey</a>(), <a href="./qmap.htm#last" translate="no">last</a>(), <a href="./qmap.htm#keyEnd" translate="no">keyEnd</a>(), and <a href="./qmap.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@lastKey -->
<!-- $$$lowerBound[overload1]$$$lowerBoundconstKey& -->
<h3 class="fn" id="lowerBound" translate="no"><a name="lowerBound"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">lowerBound</span>(const <span class="type">Key</span> &amp;<i>key</i>)<a class="plink" href="#lowerBound" title="Direct link to this headline"></a></h3>
<p>Returns an iterator pointing to the first item with key <i translate="no">key</i> in the map. If the map contains no item with key <i translate="no">key</i>, the function returns an iterator to the nearest item with a greater key.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> map;
map<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="string">"one"</span>);
map<span class="operator">.</span>insert(<span class="number">5</span><span class="operator">,</span> <span class="string">"five"</span>);
map<span class="operator">.</span>insert(<span class="number">10</span><span class="operator">,</span> <span class="string">"ten"</span>);

map<span class="operator">.</span>lowerBound(<span class="number">0</span>);      <span class="comment">// returns iterator to (1, "one")</span>
map<span class="operator">.</span>lowerBound(<span class="number">1</span>);      <span class="comment">// returns iterator to (1, "one")</span>
map<span class="operator">.</span>lowerBound(<span class="number">2</span>);      <span class="comment">// returns iterator to (5, "five")</span>
map<span class="operator">.</span>lowerBound(<span class="number">10</span>);     <span class="comment">// returns iterator to (10, "ten")</span>
map<span class="operator">.</span>lowerBound(<span class="number">999</span>);    <span class="comment">// returns end()</span></pre></div>
<p>If the map contains multiple items with key <i translate="no">key</i>, this function returns an iterator that points to the most recently inserted value. The other values are accessible by incrementing the iterator. For example, here's some code that iterates over all the items with the same key:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span> map;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
<span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>const_iterator i <span class="operator">=</span> map<span class="operator">.</span>lowerBound(<span class="string">"HDR"</span>);
<span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">,</span> <span class="type">int</span><span class="operator">&gt;</span><span class="operator">::</span>const_iterator upperBound <span class="operator">=</span> map<span class="operator">.</span>upperBound(<span class="string">"HDR"</span>);
<span class="keyword">while</span> (i <span class="operator">!</span><span class="operator">=</span> upperBound) {
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> i<span class="operator">.</span>value() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
    <span class="operator">+</span><span class="operator">+</span>i;
}</pre></div>
<p><b>See also </b><a href="./qmap.htm#upperBound" translate="no">upperBound</a>() and <a href="./qmap.htm#find" translate="no">find</a>().</p>
<!-- @@@lowerBound -->
<!-- $$$lowerBound$$$lowerBoundconstKey& -->
<h3 class="fn" id="lowerBound-1" translate="no"><a name="lowerBound-1"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">lowerBound</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#lowerBound-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@lowerBound -->
<!-- $$$remove[overload1]$$$removeconstKey& -->
<h3 class="fn" id="remove" translate="no"><a name="remove"></a><span class="type">int</span> QMap::<span class="name">remove</span>(const <span class="type">Key</span> &amp;<i>key</i>)<a class="plink" href="#remove" title="Direct link to this headline"></a></h3>
<p>Removes all the items that have the key <i translate="no">key</i> from the map. Returns the number of items removed which will be 1 if the key exists in the map, and 0 otherwise.</p>
<p><b>See also </b><a href="./qmap.htm#clear" translate="no">clear</a>(), <a href="./qmap.htm#take" translate="no">take</a>(), and <a href="./qmultimap.htm#remove" translate="no">QMultiMap::remove</a>().</p>
<!-- @@@remove -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type">int</span> QMap::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the number of (key, value) pairs in the map.</p>
<p><b>See also </b><a href="./qmap.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qmap.htm#count-1" translate="no">count</a>().</p>
<!-- @@@size -->
<!-- $$$swap[overload1]$$$swapQMap<Key,T>& -->
<h3 class="fn" id="swap" translate="no"><a name="swap"></a><span class="type">void</span> QMap::<span class="name">swap</span>(<span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#swap" title="Direct link to this headline"></a></h3>
<p>Swaps map <i translate="no">other</i> with this map. This operation is very fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>
<!-- @@@swap -->
<!-- $$$take[overload1]$$$takeconstKey& -->
<h3 class="fn" id="take" translate="no"><a name="take"></a><span class="type">T</span> QMap::<span class="name">take</span>(const <span class="type">Key</span> &amp;<i>key</i>)<a class="plink" href="#take" title="Direct link to this headline"></a></h3>
<p>Removes the item with the key <i translate="no">key</i> from the map and returns the value associated with it.</p>
<p>If the item does not exist in the map, the function simply returns a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a>. If there are multiple items for <i translate="no">key</i> in the map, only the most recently inserted one is removed and returned.</p>
<p>If you don't use the return value, <a href="./qmap.htm#remove" translate="no">remove</a>() is more efficient.</p>
<p><b>See also </b><a href="./qmap.htm#remove" translate="no">remove</a>().</p>
<!-- @@@take -->
<!-- $$$toStdMap[overload1]$$$toStdMap -->
<h3 class="fn" id="toStdMap" translate="no"><a name="toStdMap"></a><span class="type">int</span> QMap::<span class="name">toStdMap</span>() const<a class="plink" href="#toStdMap" title="Direct link to this headline"></a></h3>
<p>Returns an STL map equivalent to this <a href="./qmap.htm" translate="no">QMap</a>.</p>
<!-- @@@toStdMap -->
<!-- $$$upperBound[overload1]$$$upperBoundconstKey& -->
<h3 class="fn" id="upperBound" translate="no"><a name="upperBound"></a><span class="type"><a href="./qmap-iterator.htm" translate="no">QMap::iterator</a></span> QMap::<span class="name">upperBound</span>(const <span class="type">Key</span> &amp;<i>key</i>)<a class="plink" href="#upperBound" title="Direct link to this headline"></a></h3>
<p>Returns an iterator pointing to the item that immediately follows the last item with key <i translate="no">key</i> in the map. If the map contains no item with key <i translate="no">key</i>, the function returns an iterator to the nearest item with a greater key.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">,</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> map;
map<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="string">"one"</span>);
map<span class="operator">.</span>insert(<span class="number">5</span><span class="operator">,</span> <span class="string">"five"</span>);
map<span class="operator">.</span>insert(<span class="number">10</span><span class="operator">,</span> <span class="string">"ten"</span>);

map<span class="operator">.</span>upperBound(<span class="number">0</span>);      <span class="comment">// returns iterator to (1, "one")</span>
map<span class="operator">.</span>upperBound(<span class="number">1</span>);      <span class="comment">// returns iterator to (5, "five")</span>
map<span class="operator">.</span>upperBound(<span class="number">2</span>);      <span class="comment">// returns iterator to (5, "five")</span>
map<span class="operator">.</span>upperBound(<span class="number">10</span>);     <span class="comment">// returns end()</span>
map<span class="operator">.</span>upperBound(<span class="number">999</span>);    <span class="comment">// returns end()</span></pre></div>
<p><b>See also </b><a href="./qmap.htm#lowerBound" translate="no">lowerBound</a>() and <a href="./qmap.htm#find" translate="no">find</a>().</p>
<!-- @@@upperBound -->
<!-- $$$upperBound$$$upperBoundconstKey& -->
<h3 class="fn" id="upperBound-1" translate="no"><a name="upperBound-1"></a><span class="type"><a href="./qmap-const-iterator.htm" translate="no">QMap::const_iterator</a></span> QMap::<span class="name">upperBound</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#upperBound-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@upperBound -->
<!-- $$$value[overload1]$$$valueconstKey&constT& -->
<h3 class="fn" id="value" translate="no"><a name="value"></a>const <span class="type">T</span> QMap::<span class="name">value</span>(const <span class="type">Key</span> &amp;<i>key</i>, const <span class="type">T</span> &amp;<i>defaultValue</i> = T()) const<a class="plink" href="#value" title="Direct link to this headline"></a></h3>
<p>Returns the value associated with the key <i translate="no">key</i>.</p>
<p>If the map contains no item with key <i translate="no">key</i>, the function returns <i translate="no">defaultValue</i>. If no <i translate="no">defaultValue</i> is specified, the function returns a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a>. If there are multiple items for <i translate="no">key</i> in the map, the value of the most recently inserted one is returned.</p>
<p><b>See also </b><a href="./qmap.htm#key" translate="no">key</a>(), <a href="./qmap.htm#values" translate="no">values</a>(), <a href="./qmap.htm#contains" translate="no">contains</a>(), and <a href="./qmap.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@value -->
<!-- $$$values[overload1]$$$values -->
<h3 class="fn" id="values" translate="no"><a name="values"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QMap::<span class="name">values</span>() const<a class="plink" href="#values" title="Direct link to this headline"></a></h3>
<p>Returns a list containing all the values in the map, in ascending order of their keys. If a key is associated with multiple values, all of its values will be in the list, and not just the most recently inserted one.</p>
<p><b>See also </b><a href="./qmap.htm#keys" translate="no">keys</a>() and <a href="./qmap.htm#value" translate="no">value</a>().</p>
<!-- @@@values -->
<!-- $$$operator!=[overload1]$$$operator!=constQMap<Key,T>& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QMap::<span class="name">operator!=</span>(const <span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is not equal to this map; otherwise returns <code translate="no">false</code>.</p>
<p>Two maps are considered equal if they contain the same (key, value) pairs.</p>
<p>This function requires the value type to implement <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qmap.htm#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQMap<Key,T>& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QMap::<span class="name">operator==</span>(const <span class="type"><a href="./qmap.htm#QMap" translate="no">QMap</a></span>&lt;<span class="type">Key</span>, <span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is equal to this map; otherwise returns false.</p>
<p>Two maps are considered equal if they contain the same (key, value) pairs.</p>
<p>This function requires the value type to implement <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qmap.htm#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]constKey& -->
<h3 class="fn" id="operator-5b-5d" translate="no"><a name="operator-5b-5d"></a><span class="type">T</span> &amp;QMap::<span class="name">operator[]</span>(const <span class="type">Key</span> &amp;<i>key</i>)<a class="plink" href="#operator-5b-5d" title="Direct link to this headline"></a></h3>
<p>Returns the value associated with the key <i translate="no">key</i> as a modifiable reference.</p>
<p>If the map contains no item with key <i translate="no">key</i>, the function inserts a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a> into the map with key <i translate="no">key</i>, and returns a reference to it. If the map contains multiple items with key <i translate="no">key</i>, this function returns a reference to the most recently inserted value.</p>
<p><b>See also </b><a href="./qmap.htm#insert" translate="no">insert</a>() and <a href="./qmap.htm#value" translate="no">value</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constKey& -->
<h3 class="fn" id="operator-5b-5d-1" translate="no"><a name="operator-5b-5d-1"></a>const <span class="type">T</span> QMap::<span class="name">operator[]</span>(const <span class="type">Key</span> &amp;<i>key</i>) const<a class="plink" href="#operator-5b-5d-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="./qmap.htm#value" translate="no">value</a>().</p>
<!-- @@@operator[] -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>