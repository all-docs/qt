<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QQuickRenderControl | Qt Quick</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qquickrendercontrol.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a href="./qtquick-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QQuickRenderControl</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QQuickRenderControl Class</h1>
<!-- $$$QQuickRenderControl-brief -->
<p>The QQuickRenderControl class provides a mechanism for rendering the Qt Quick scenegraph onto an offscreen render target in a fully application-controlled manner. <a href="#details">More...</a></p>
<!-- @@@QQuickRenderControl -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQuickRenderControl&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.4</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qobject.htm" translate="no">QObject</a></td></tr></tbody></table></div><p>This class was introduced in Qt 5.4.</p>
<ul>
<li><a href="./qquickrendercontrol-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#QQuickRenderControl" translate="no">QQuickRenderControl</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#dtor.QQuickRenderControl" translate="no">~QQuickRenderControl</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#grab" translate="no">grab</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#initialize" translate="no">initialize</a></b>(QOpenGLContext *<i>gl</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#invalidate" translate="no">invalidate</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#polishItems" translate="no">polishItems</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#prepareThread" translate="no">prepareThread</a></b>(QThread *<i>targetThread</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#render" translate="no">render</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QWindow *</td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#renderWindow" translate="no">renderWindow</a></b>(QPoint *<i>offset</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#sync" translate="no">sync</a></b>()</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#renderRequested" translate="no">renderRequested</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#sceneChanged" translate="no">sceneChanged</a></b>()</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QWindow *</td><td class="memItemRight bottomAlign"><b><a href="./qquickrendercontrol.htm#renderWindowFor" translate="no">renderWindowFor</a></b>(QQuickWindow *<i>win</i>, QPoint *<i>offset</i> = nullptr)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QQuickRenderControl-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p><a href="./qquickwindow.htm" translate="no">QQuickWindow</a> and <a href="./qquickview.htm" translate="no">QQuickView</a> and their associated internal render loops render the Qt Quick scene onto a native window. In some cases, for example when integrating with 3rd party OpenGL renderers, it might be beneficial to get the scene into a texture that can then be used in arbitrary ways by the external rendering engine. QQuickRenderControl makes this possible in a hardware accelerated manner, unlike the performance-wise limited alternative of using <a href="./qquickwindow.htm#grabWindow" translate="no">QQuickWindow::grabWindow</a>()</p>
<p>When using a QQuickRenderControl, the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> does not have to be shown or even created at all. This means there will not be an underlying native window for it. Instead, the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> instance is associated with the render control, using the overload of the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> constructor, and an OpenGL framebuffer object by calling <a href="./qquickwindow.htm#setRenderTarget" translate="no">QQuickWindow::setRenderTarget</a>().</p>
<p>Management of the context and framebuffer object is up to the application. The context that will be used by Qt Quick must be created before calling <a href="./qquickrendercontrol.htm#initialize" translate="no">initialize</a>(). The creation of the framebuffer object can be deferred, see below. Qt 5.4 introduces the ability for <a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a> to adopt existing native contexts. Together with QQuickRenderControl this makes it possible to create a <a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a> that shares with an external rendering engine's existing context. This new <a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a> can then be used to render the Qt Quick scene into a texture that is accessible by the other engine's context too.</p>
<p>Loading and instantiation of the QML components happen by using a <a href="./qqmlengine.htm" translate="no">QQmlEngine</a>. Once the root object is created, it will need to be parented to the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a>'s contentItem().</p>
<p>Applications will usually have to connect to 4 important signals:</p>
<ul>
<li><a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">QQuickWindow::sceneGraphInitialized</a>() Emitted at some point after calling <a href="./qquickrendercontrol.htm#initialize" translate="no">QQuickRenderControl::initialize</a>(). Upon this signal, the application is expected to create its framebuffer object and associate it with the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a>.</li>
<li><a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">QQuickWindow::sceneGraphInvalidated</a>() When the scenegraph resources are released, the framebuffer object can be destroyed too.</li>
<li><a href="./qquickrendercontrol.htm#renderRequested" translate="no">QQuickRenderControl::renderRequested</a>() Indicates that the scene has to be rendered by calling <a href="./qquickrendercontrol.htm#render" translate="no">render</a>(). After making the context current, applications are expected to call <a href="./qquickrendercontrol.htm#render" translate="no">render</a>().</li>
<li><a href="./qquickrendercontrol.htm#sceneChanged" translate="no">QQuickRenderControl::sceneChanged</a>() Indicates that the scene has changed meaning that, before rendering, polishing and synchronizing is also necessary.</li>
</ul>
<p>To send events, for example mouse or keyboard events, to the scene, use <a href="./qcoreapplication.htm#sendEvent" translate="no">QCoreApplication::sendEvent</a>() with the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> instance as the receiver.</p>
<div class="admonition note">
<p><b>Note: </b>In general QQuickRenderControl is supported in combination with all Qt Quick backends. However, some functionality, in particular <a href="./qquickrendercontrol.htm#grab" translate="no">grab</a>(), may not be available in all cases.</p>
</div>
</div>
<!-- @@@QQuickRenderControl -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickRenderControl[overload1]$$$QQuickRenderControlQObject* -->
<h3 class="fn" id="QQuickRenderControl" translate="no"><a name="QQuickRenderControl"></a>QQuickRenderControl::<span class="name">QQuickRenderControl</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QQuickRenderControl" title="Direct link to this headline"></a></h3>
<p>Constructs a QQuickRenderControl object, with parent object <i translate="no">parent</i>.</p>
<!-- @@@QQuickRenderControl -->
<!-- $$$renderRequested[overload1]$$$renderRequested -->
<h3 class="fn" id="renderRequested" translate="no"><a name="renderRequested"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickRenderControl::<span class="name">renderRequested</span>()<a class="plink" href="#renderRequested" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the scene graph needs to be rendered. It is not necessary to call <a href="./qquickrendercontrol.htm#sync" translate="no">sync</a>().</p>
<div class="admonition note">
<p><b>Note: </b>Avoid triggering rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</p>
</div>
<!-- @@@renderRequested -->
<!-- $$$sceneChanged[overload1]$$$sceneChanged -->
<h3 class="fn" id="sceneChanged" translate="no"><a name="sceneChanged"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickRenderControl::<span class="name">sceneChanged</span>()<a class="plink" href="#sceneChanged" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the scene graph is updated, meaning that <a href="./qquickrendercontrol.htm#polishItems" translate="no">polishItems</a>() and <a href="./qquickrendercontrol.htm#sync" translate="no">sync</a>() needs to be called. If <a href="./qquickrendercontrol.htm#sync" translate="no">sync</a>() returns true, then <a href="./qquickrendercontrol.htm#render" translate="no">render</a>() needs to be called.</p>
<div class="admonition note">
<p><b>Note: </b>Avoid triggering polishing, synchronization and rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</p>
</div>
<!-- @@@sceneChanged -->
<!-- $$$~QQuickRenderControl[overload1]$$$~QQuickRenderControl -->
<h3 class="fn" id="dtor.QQuickRenderControl" translate="no"><a name="dtor.QQuickRenderControl"></a><code translate="no">[override virtual] </code>QQuickRenderControl::<span class="name">~QQuickRenderControl</span>()<a class="plink" href="#dtor.QQuickRenderControl" title="Direct link to this headline"></a></h3>
<p>Destroys the instance. Releases all scenegraph resources.</p>
<p><b>See also </b><a href="./qquickrendercontrol.htm#invalidate" translate="no">invalidate</a>().</p>
<!-- @@@~QQuickRenderControl -->
<!-- $$$grab[overload1]$$$grab -->
<h3 class="fn" id="grab" translate="no"><a name="grab"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QQuickRenderControl::<span class="name">grab</span>()<a class="plink" href="#grab" title="Direct link to this headline"></a></h3>
<p>Grabs the contents of the scene and returns it as an image.</p>
<div class="admonition note">
<p><b>Note: </b>Requires the context to be current.</p>
</div>
<!-- @@@grab -->
<!-- $$$initialize[overload1]$$$initializeQOpenGLContext* -->
<h3 class="fn" id="initialize" translate="no"><a name="initialize"></a><span class="type">void</span> QQuickRenderControl::<span class="name">initialize</span>(<span class="type"><a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a></span> *<i>gl</i>)<a class="plink" href="#initialize" title="Direct link to this headline"></a></h3>
<p>Initializes the scene graph resources. The context <i translate="no">gl</i> has to be the current OpenGL context or null if it is not relevant because a Qt Quick backend other than OpenGL is in use.</p>
<div class="admonition note">
<p><b>Note: </b>Qt Quick does not take ownership of the context. It is up to the application to destroy it after a call to <a href="./qquickrendercontrol.htm#invalidate" translate="no">invalidate</a>() or after the <a href="./qquickrendercontrol.htm" translate="no">QQuickRenderControl</a> instance is destroyed.</p>
</div>
<!-- @@@initialize -->
<!-- $$$invalidate[overload1]$$$invalidate -->
<h3 class="fn" id="invalidate" translate="no"><a name="invalidate"></a><span class="type">void</span> QQuickRenderControl::<span class="name">invalidate</span>()<a class="plink" href="#invalidate" title="Direct link to this headline"></a></h3>
<p>Stop rendering and release resources. Requires a current context.</p>
<p>This is the equivalent of the cleanup operations that happen with a real <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> when the window becomes hidden.</p>
<p>This function is called from the destructor. Therefore there will typically be no need to call it directly. Pay attention however to the fact that this requires the context, that was passed to <a href="./qquickrendercontrol.htm#initialize" translate="no">initialize</a>(), to be the current one at the time of destroying the <a href="./qquickrendercontrol.htm" translate="no">QQuickRenderControl</a> instance.</p>
<p>Once invalidate() has been called, it is possible to reuse the <a href="./qquickrendercontrol.htm" translate="no">QQuickRenderControl</a> instance by calling <a href="./qquickrendercontrol.htm#initialize" translate="no">initialize</a>() again.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not take QQuickWindow::persistentSceneGraph() or QQuickWindow::persistentOpenGLContext() into account. This means that context-specific resources are always released.</p>
</div>
<!-- @@@invalidate -->
<!-- $$$polishItems[overload1]$$$polishItems -->
<h3 class="fn" id="polishItems" translate="no"><a name="polishItems"></a><span class="type">void</span> QQuickRenderControl::<span class="name">polishItems</span>()<a class="plink" href="#polishItems" title="Direct link to this headline"></a></h3>
<p>This function should be called as late as possible before <a href="./qquickrendercontrol.htm#sync" translate="no">sync</a>(). In a threaded scenario, rendering can happen in parallel with this function.</p>
<!-- @@@polishItems -->
<!-- $$$prepareThread[overload1]$$$prepareThreadQThread* -->
<h3 class="fn" id="prepareThread" translate="no"><a name="prepareThread"></a><span class="type">void</span> QQuickRenderControl::<span class="name">prepareThread</span>(<span class="type"><a href="./qthread.htm" translate="no">QThread</a></span> *<i>targetThread</i>)<a class="plink" href="#prepareThread" title="Direct link to this headline"></a></h3>
<p>Prepares rendering the Qt Quick scene outside the GUI thread.</p>
<p><i translate="no">targetThread</i> specifies the thread on which synchronization and rendering will happen. There is no need to call this function in a single threaded scenario.</p>
<!-- @@@prepareThread -->
<!-- $$$render[overload1]$$$render -->
<h3 class="fn" id="render" translate="no"><a name="render"></a><span class="type">void</span> QQuickRenderControl::<span class="name">render</span>()<a class="plink" href="#render" title="Direct link to this headline"></a></h3>
<p>Renders the scenegraph using the current context.</p>
<!-- @@@render -->
<!-- $$$renderWindow[overload1]$$$renderWindowQPoint* -->
<h3 class="fn" id="renderWindow" translate="no"><a name="renderWindow"></a><code translate="no">[virtual] </code><span class="type"><a href="./qwindow.htm" translate="no">QWindow</a></span> *QQuickRenderControl::<span class="name">renderWindow</span>(<span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> *<i>offset</i>)<a class="plink" href="#renderWindow" title="Direct link to this headline"></a></h3>
<p>Reimplemented in subclasses to return the real window this render control is rendering into.</p>
<p>If <i translate="no">offset</i> in non-null, it is set to the offset of the control inside the window.</p>
<div class="admonition note">
<p><b>Note: </b>While not mandatory, reimplementing this function becomes essential for supporting multiple screens with different device pixel ratios and properly positioning popup windows opened from QML. Therefore providing it in subclasses is highly recommended.</p>
</div>
<!-- @@@renderWindow -->
<!-- $$$renderWindowFor[overload1]$$$renderWindowForQQuickWindow*QPoint* -->
<h3 class="fn" id="renderWindowFor" translate="no"><a name="renderWindowFor"></a><code translate="no">[static] </code><span class="type"><a href="./qwindow.htm" translate="no">QWindow</a></span> *QQuickRenderControl::<span class="name">renderWindowFor</span>(<span class="type"><a href="./qquickwindow.htm" translate="no">QQuickWindow</a></span> *<i>win</i>, <span class="type"><a href="./qpoint.htm" translate="no">QPoint</a></span> *<i>offset</i> = nullptr)<a class="plink" href="#renderWindowFor" title="Direct link to this headline"></a></h3>
<p>Returns the real window that <i translate="no">win</i> is being rendered to, if any.</p>
<p>If <i translate="no">offset</i> in non-null, it is set to the offset of the rendering inside its window.</p>
<!-- @@@renderWindowFor -->
<!-- $$$sync[overload1]$$$sync -->
<h3 class="fn" id="sync" translate="no"><a name="sync"></a><span class="type">bool</span> QQuickRenderControl::<span class="name">sync</span>()<a class="plink" href="#sync" title="Direct link to this headline"></a></h3>
<p>This function is used to synchronize the QML scene with the rendering scene graph.</p>
<p>If a dedicated render thread is used, the GUI thread should be blocked for the duration of this call.</p>
<p>Returns <i>true</i> if the synchronization changed the scene graph.</p>
<!-- @@@sync -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>