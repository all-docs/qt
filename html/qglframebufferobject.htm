<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QGLFramebufferObject | Qt OpenGL</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtopengl-index.htm" translate="no">Qt OpenGL</a></li>
                            <li><a href="./qtopengl-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QGLFramebufferObject</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QGLFramebufferObject Class</h1>
<!-- $$$QGLFramebufferObject-brief -->
<p>The QGLFramebufferObject class encapsulates an OpenGL framebuffer object. <a href="#details">More...</a></p>
<!-- @@@QGLFramebufferObject -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QGLFramebufferObject&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += opengl</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.2</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qpaintdevice.htm" translate="no">QPaintDevice</a></td></tr></tbody></table></div><p><b>This class is obsolete.</b> It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<p>This class was introduced in Qt 4.2.</p>
<ul>
<li><a href="./qglframebufferobject-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#Attachment-enum" translate="no">Attachment</a></b> { NoAttachment, CombinedDepthStencil, Depth }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#QGLFramebufferObject-5" translate="no">QGLFramebufferObject</a></b>(int <i>width</i>, int <i>height</i>, const QGLFramebufferObjectFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#QGLFramebufferObject-4" translate="no">QGLFramebufferObject</a></b>(const QSize &amp;<i>size</i>, const QGLFramebufferObjectFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#QGLFramebufferObject-3" translate="no">QGLFramebufferObject</a></b>(int <i>width</i>, int <i>height</i>, QGLFramebufferObject::Attachment <i>attachment</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLenum <i>internal_format</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#QGLFramebufferObject-2" translate="no">QGLFramebufferObject</a></b>(const QSize &amp;<i>size</i>, QGLFramebufferObject::Attachment <i>attachment</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLenum <i>internal_format</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#QGLFramebufferObject-1" translate="no">QGLFramebufferObject</a></b>(int <i>width</i>, int <i>height</i>, GLenum <i>target</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#QGLFramebufferObject" translate="no">QGLFramebufferObject</a></b>(const QSize &amp;<i>size</i>, GLenum <i>target</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#dtor.QGLFramebufferObject" translate="no">~QGLFramebufferObject</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFramebufferObject::Attachment </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#attachment" translate="no">attachment</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#bind" translate="no">bind</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#drawTexture" translate="no">drawTexture</a></b>(const QRectF &amp;<i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#drawTexture-1" translate="no">drawTexture</a></b>(const QPointF &amp;<i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFramebufferObjectFormat </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#handle" translate="no">handle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#isBound" translate="no">isBound</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#release" translate="no">release</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#texture" translate="no">texture</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#toImage" translate="no">toImage</a></b>() const</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual QPaintEngine *</td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#paintEngine" translate="no">paintEngine</a></b>() const override</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#bindDefault" translate="no">bindDefault</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#blitFramebuffer" translate="no">blitFramebuffer</a></b>(QGLFramebufferObject *<i>target</i>, const QRect &amp;<i>targetRect</i>, QGLFramebufferObject *<i>source</i>, const QRect &amp;<i>sourceRect</i>, GLbitfield <i>buffers</i> = GL_COLOR_BUFFER_BIT, GLenum <i>filter</i> = GL_NEAREST)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#hasOpenGLFramebufferBlit" translate="no">hasOpenGLFramebufferBlit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#hasOpenGLFramebufferObjects" translate="no">hasOpenGLFramebufferObjects</a></b>()</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="./qglframebufferobject.htm#metric" translate="no">metric</a></b>(QPaintDevice::PaintDeviceMetric <i>metric</i>) const override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QGLFramebufferObject-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>The QGLFramebufferObject class encapsulates an OpenGL framebuffer object, defined by the <code translate="no">GL_EXT_framebuffer_object</code> extension. In addition it provides a rendering surface that can be painted on with a <a href="./qpainter.htm" translate="no">QPainter</a>, rendered to using native GL calls, or both. This surface can be bound and used as a regular texture in your own GL drawing code. By default, the QGLFramebufferObject class generates a 2D GL texture (using the <code translate="no">GL_TEXTURE_2D</code> target), which is used as the internal rendering target.</p>
<p><b>It is important to have a current GL context when creating a QGLFramebufferObject, otherwise initialization will fail.</b></p>
<p>OpenGL framebuffer objects and pbuffers (see <a href="./qglpixelbuffer.htm" translate="no">QGLPixelBuffer</a>) can both be used to render to offscreen surfaces, but there are a number of advantages with using framebuffer objects instead of pbuffers:</p>
<ol class="1" type="1"><li>A framebuffer object does not require a separate rendering context, so no context switching will occur when switching rendering targets. There is an overhead involved in switching targets, but in general it is cheaper than a context switch to a pbuffer.</li>
<li>Rendering to dynamic textures (i.e. render-to-texture functionality) works on all platforms. No need to do explicit copy calls from a render buffer into a texture, as was necessary on systems that did not support the <code translate="no">render_texture</code> extension.</li>
<li>It is possible to attach several rendering buffers (or texture objects) to the same framebuffer object, and render to all of them without doing a context switch.</li>
<li>The OpenGL framebuffer extension is a pure GL extension with no system dependant WGL, CGL, or GLX parts. This makes using framebuffer objects more portable.</li>
</ol>
<p>When using a <a href="./qpainter.htm" translate="no">QPainter</a> to paint to a QGLFramebufferObject you should take care that the QGLFramebufferObject is created with the <a href="./qglframebufferobject.htm#Attachment-enum" translate="no">CombinedDepthStencil</a> attachment for <a href="./qpainter.htm" translate="no">QPainter</a> to be able to render correctly. Note that you need to create a QGLFramebufferObject with more than one sample per pixel for primitives to be antialiased when drawing using a <a href="./qpainter.htm" translate="no">QPainter</a>. To create a multisample framebuffer object you should use one of the constructors that take a <a href="./qglframebufferobjectformat.htm" translate="no">QGLFramebufferObjectFormat</a> parameter, and set the <a href="./qglframebufferobjectformat.htm#samples" translate="no">QGLFramebufferObjectFormat::samples</a>() property to a non-zero value.</p>
<p>When painting to a QGLFramebufferObject using <a href="./qpainter.htm" translate="no">QPainter</a>, the state of the current GL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the GL state being reset to its original conditions, particularly the current shader program, GL viewport, texture units, and drawing modes.</p>
<p>For multisample framebuffer objects a color render buffer is created, otherwise a texture with the specified texture target is created. The color render buffer or texture will have the specified internal format, and will be bound to the <code translate="no">GL_COLOR_ATTACHMENT0</code> attachment in the framebuffer object.</p>
<p>If you want to use a framebuffer object with multisampling enabled as a texture, you first need to copy from it to a regular framebuffer object using QGLContext::blitFramebuffer().</p>
<a name="threading"></a>
<h3 id="threading">Threading<a class="plink" href="#threading" title="Direct link to this headline"></a></h3>
<p>As of Qt 4.8, it's possible to draw into a QGLFramebufferObject using a <a href="./qpainter.htm" translate="no">QPainter</a> in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.</p>
<div class="admonition note">
<p><b>Note: </b>This class has been deprecated in favor of <a href="./qopenglframebufferobject.htm" translate="no">QOpenGLFramebufferObject</a>.</p>
</div>
</div>
<!-- @@@QGLFramebufferObject -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Attachment$$$NoAttachment$$$CombinedDepthStencil$$$Depth -->
<h3 class="fn" id="Attachment-enum" translate="no"><a name="Attachment-enum"></a>enum QGLFramebufferObject::<span class="name">Attachment</span><a class="plink" href="#Attachment-enum" title="Direct link to this headline"></a></h3>
<p>This enum type is used to configure the depth and stencil buffers attached to the framebuffer object when it is created.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QGLFramebufferObject::NoAttachment</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</td></tr>
<tr><td class="topAlign"><code translate="no">QGLFramebufferObject::CombinedDepthStencil</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">If the <code translate="no">GL_EXT_packed_depth_stencil</code> extension is present, a combined depth and stencil buffer is attached. If the extension is not present, only a depth buffer is attached.</td></tr>
<tr><td class="topAlign"><code translate="no">QGLFramebufferObject::Depth</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">A depth buffer is attached to the framebuffer object.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 4.3.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#attachment" translate="no">attachment</a>().</p>
<!-- @@@Attachment -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QGLFramebufferObject$$$QGLFramebufferObjectintintconstQGLFramebufferObjectFormat& -->
<h3 class="fn" id="QGLFramebufferObject-5" translate="no"><a name="QGLFramebufferObject-5"></a>QGLFramebufferObject::<span class="name">QGLFramebufferObject</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, const <span class="type"><a href="./qglframebufferobjectformat.htm" translate="no">QGLFramebufferObjectFormat</a></span> &amp;<i>format</i>)<a class="plink" href="#QGLFramebufferObject-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object of the given <i translate="no">width</i> and <i translate="no">height</i> based on the supplied <i translate="no">format</i>.</p>
<!-- @@@QGLFramebufferObject -->
<!-- $$$QGLFramebufferObject$$$QGLFramebufferObjectconstQSize&constQGLFramebufferObjectFormat& -->
<h3 class="fn" id="QGLFramebufferObject-4" translate="no"><a name="QGLFramebufferObject-4"></a>QGLFramebufferObject::<span class="name">QGLFramebufferObject</span>(const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>, const <span class="type"><a href="./qglframebufferobjectformat.htm" translate="no">QGLFramebufferObjectFormat</a></span> &amp;<i>format</i>)<a class="plink" href="#QGLFramebufferObject-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object of the given <i translate="no">size</i> based on the supplied <i translate="no">format</i>.</p>
<!-- @@@QGLFramebufferObject -->
<!-- $$$QGLFramebufferObject$$$QGLFramebufferObjectintintQGLFramebufferObject::AttachmentGLenumGLenum -->
<h3 class="fn" id="QGLFramebufferObject-3" translate="no"><a name="QGLFramebufferObject-3"></a>QGLFramebufferObject::<span class="name">QGLFramebufferObject</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type"><a href="./qglframebufferobject.htm#Attachment-enum" translate="no">QGLFramebufferObject::Attachment</a></span> <i>attachment</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D, <span class="type">GLenum</span> <i>internal_format</i> = 0)<a class="plink" href="#QGLFramebufferObject-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given <i translate="no">width</i> and <i translate="no">height</i>.</p>
<p>The <i translate="no">attachment</i> parameter describes the depth/stencil buffer configuration, <i translate="no">target</i> the texture target and <i translate="no">internal_format</i> the internal texture format. The default texture target is <code translate="no">GL_TEXTURE_2D</code>, while the default internal format is <code translate="no">GL_RGBA8</code> for desktop OpenGL and <code translate="no">GL_RGBA</code> for OpenGL/ES.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#size" translate="no">size</a>(), <a href="./qglframebufferobject.htm#texture" translate="no">texture</a>(), and <a href="./qglframebufferobject.htm#attachment" translate="no">attachment</a>().</p>
<!-- @@@QGLFramebufferObject -->
<!-- $$$QGLFramebufferObject$$$QGLFramebufferObjectconstQSize&QGLFramebufferObject::AttachmentGLenumGLenum -->
<h3 class="fn" id="QGLFramebufferObject-2" translate="no"><a name="QGLFramebufferObject-2"></a>QGLFramebufferObject::<span class="name">QGLFramebufferObject</span>(const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>, <span class="type"><a href="./qglframebufferobject.htm#Attachment-enum" translate="no">QGLFramebufferObject::Attachment</a></span> <i>attachment</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D, <span class="type">GLenum</span> <i>internal_format</i> = 0)<a class="plink" href="#QGLFramebufferObject-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given <i translate="no">size</i>.</p>
<p>The <i translate="no">attachment</i> parameter describes the depth/stencil buffer configuration, <i translate="no">target</i> the texture target and <i translate="no">internal_format</i> the internal texture format. The default texture target is <code translate="no">GL_TEXTURE_2D</code>, while the default internal format is <code translate="no">GL_RGBA8</code> for desktop OpenGL and <code translate="no">GL_RGBA</code> for OpenGL/ES.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#size" translate="no">size</a>(), <a href="./qglframebufferobject.htm#texture" translate="no">texture</a>(), and <a href="./qglframebufferobject.htm#attachment" translate="no">attachment</a>().</p>
<!-- @@@QGLFramebufferObject -->
<!-- $$$QGLFramebufferObject$$$QGLFramebufferObjectintintGLenum -->
<h3 class="fn" id="QGLFramebufferObject-1" translate="no"><a name="QGLFramebufferObject-1"></a>QGLFramebufferObject::<span class="name">QGLFramebufferObject</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D)<a class="plink" href="#QGLFramebufferObject-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the given <i translate="no">width</i> and <i translate="no">height</i>.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#size" translate="no">size</a>() and <a href="./qglframebufferobject.htm#texture" translate="no">texture</a>().</p>
<!-- @@@QGLFramebufferObject -->
<!-- $$$QGLFramebufferObject[overload1]$$$QGLFramebufferObjectconstQSize&GLenum -->
<h3 class="fn" id="QGLFramebufferObject" translate="no"><a name="QGLFramebufferObject"></a>QGLFramebufferObject::<span class="name">QGLFramebufferObject</span>(const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D)<a class="plink" href="#QGLFramebufferObject" title="Direct link to this headline"></a></h3>
<p>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the size <i translate="no">size</i>. The texture is bound to the <code translate="no">GL_COLOR_ATTACHMENT0</code> target in the framebuffer object.</p>
<p>The <i translate="no">target</i> parameter is used to specify the GL texture target. The default target is <code translate="no">GL_TEXTURE_2D</code>. Keep in mind that <code translate="no">GL_TEXTURE_2D</code> textures must have a power of 2 width and height (e.g. 256x512), unless you are using OpenGL 2.0 or higher.</p>
<p>By default, no depth and stencil buffers are attached. This behavior can be toggled using one of the overloaded constructors.</p>
<p>The default internal texture format is <code translate="no">GL_RGBA8</code> for desktop OpenGL, and <code translate="no">GL_RGBA</code> for OpenGL/ES.</p>
<p>It is important that you have a current GL context set when creating the QGLFramebufferObject, otherwise the initialization will fail.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#size" translate="no">size</a>(), <a href="./qglframebufferobject.htm#texture" translate="no">texture</a>(), and <a href="./qglframebufferobject.htm#attachment" translate="no">attachment</a>().</p>
<!-- @@@QGLFramebufferObject -->
<!-- $$$~QGLFramebufferObject[overload1]$$$~QGLFramebufferObject -->
<h3 class="fn" id="dtor.QGLFramebufferObject" translate="no"><a name="dtor.QGLFramebufferObject"></a><code translate="no">[virtual] </code>QGLFramebufferObject::<span class="name">~QGLFramebufferObject</span>()<a class="plink" href="#dtor.QGLFramebufferObject" title="Direct link to this headline"></a></h3>
<p>Destroys the framebuffer object and frees any allocated resources.</p>
<!-- @@@~QGLFramebufferObject -->
<!-- $$$attachment[overload1]$$$attachment -->
<h3 class="fn" id="attachment" translate="no"><a name="attachment"></a><span class="type"><a href="./qglframebufferobject.htm#Attachment-enum" translate="no">QGLFramebufferObject::Attachment</a></span> QGLFramebufferObject::<span class="name">attachment</span>() const<a class="plink" href="#attachment" title="Direct link to this headline"></a></h3>
<p>Returns the status of the depth and stencil buffers attached to this framebuffer object.</p>
<!-- @@@attachment -->
<!-- $$$bind[overload1]$$$bind -->
<h3 class="fn" id="bind" translate="no"><a name="bind"></a><span class="type">bool</span> QGLFramebufferObject::<span class="name">bind</span>()<a class="plink" href="#bind" title="Direct link to this headline"></a></h3>
<p>Switches rendering from the default, windowing system provided framebuffer to this framebuffer object. Returns <code translate="no">true</code> upon success, false otherwise.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#release" translate="no">release</a>().</p>
<!-- @@@bind -->
<!-- $$$bindDefault[overload1]$$$bindDefault -->
<h3 class="fn" id="bindDefault" translate="no"><a name="bindDefault"></a><code translate="no">[static] </code><span class="type">bool</span> QGLFramebufferObject::<span class="name">bindDefault</span>()<a class="plink" href="#bindDefault" title="Direct link to this headline"></a></h3>
<p>Switches rendering back to the default, windowing system provided framebuffer. Returns <code translate="no">true</code> upon success, false otherwise.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#bind" translate="no">bind</a>() and <a href="./qglframebufferobject.htm#release" translate="no">release</a>().</p>
<!-- @@@bindDefault -->
<!-- $$$blitFramebuffer[overload1]$$$blitFramebufferQGLFramebufferObject*constQRect&QGLFramebufferObject*constQRect&GLbitfieldGLenum -->
<h3 class="fn" id="blitFramebuffer" translate="no"><a name="blitFramebuffer"></a><code translate="no">[static] </code><span class="type">void</span> QGLFramebufferObject::<span class="name">blitFramebuffer</span>(<span class="type"><a href="./qglframebufferobject.htm#QGLFramebufferObject" translate="no">QGLFramebufferObject</a></span> *<i>target</i>, const <span class="type"><a href="./qrect.htm" translate="no">QRect</a></span> &amp;<i>targetRect</i>, <span class="type"><a href="./qglframebufferobject.htm#QGLFramebufferObject" translate="no">QGLFramebufferObject</a></span> *<i>source</i>, const <span class="type"><a href="./qrect.htm" translate="no">QRect</a></span> &amp;<i>sourceRect</i>, <span class="type">GLbitfield</span> <i>buffers</i> = GL_COLOR_BUFFER_BIT, <span class="type">GLenum</span> <i>filter</i> = GL_NEAREST)<a class="plink" href="#blitFramebuffer" title="Direct link to this headline"></a></h3>
<p>Blits from the <i translate="no">sourceRect</i> rectangle in the <i translate="no">source</i> framebuffer object to the <i translate="no">targetRect</i> rectangle in the <i translate="no">target</i> framebuffer object.</p>
<p>If <i translate="no">source</i> or <i translate="no">target</i> is <code translate="no">nullptr</code>, the default framebuffer will be used instead of a framebuffer object as source or target respectively.</p>
<p>The <i translate="no">buffers</i> parameter should be a mask consisting of any combination of <code translate="no">GL_COLOR_BUFFER_BIT</code>, <code translate="no">GL_DEPTH_BUFFER_BIT</code>, and <code translate="no">GL_STENCIL_BUFFER_BIT</code>. Any buffer type that is not present both in the source and target buffers is ignored.</p>
<p>The <i translate="no">sourceRect</i> and <i translate="no">targetRect</i> rectangles may have different sizes; in this case <i translate="no">buffers</i> should not contain <code translate="no">GL_DEPTH_BUFFER_BIT</code> or <code translate="no">GL_STENCIL_BUFFER_BIT</code>. The <i translate="no">filter</i> parameter should be set to <code translate="no">GL_LINEAR</code> or <code translate="no">GL_NEAREST</code>, and specifies whether linear or nearest interpolation should be used when scaling is performed.</p>
<p>If <i translate="no">source</i> equals <i translate="no">target</i> a copy is performed within the same buffer. Results are undefined if the source and target rectangles overlap and have different sizes. The sizes must also be the same if any of the framebuffer objects are multisample framebuffers.</p>
<p>Note that the scissor test will restrict the blit area if enabled.</p>
<p>This function will have no effect unless <a href="./qglframebufferobject.htm#hasOpenGLFramebufferBlit" translate="no">hasOpenGLFramebufferBlit</a>() returns true.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#hasOpenGLFramebufferBlit" translate="no">hasOpenGLFramebufferBlit</a>().</p>
<!-- @@@blitFramebuffer -->
<!-- $$$drawTexture[overload1]$$$drawTextureconstQRectF&GLuintGLenum -->
<h3 class="fn" id="drawTexture" translate="no"><a name="drawTexture"></a><span class="type">void</span> QGLFramebufferObject::<span class="name">drawTexture</span>(const <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> &amp;<i>target</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)<a class="plink" href="#drawTexture" title="Direct link to this headline"></a></h3>
<p>Draws the given texture, <i translate="no">textureId</i>, to the given target rectangle, <i translate="no">target</i>, in OpenGL model space. The <i translate="no">textureTarget</i> should be a 2D texture target.</p>
<p>The framebuffer object should be bound when calling this function.</p>
<p>Equivalent to the corresponding <a href="./qglcontext.htm#drawTexture" translate="no">QGLContext::drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$drawTexture$$$drawTextureconstQPointF&GLuintGLenum -->
<h3 class="fn" id="drawTexture-1" translate="no"><a name="drawTexture-1"></a><span class="type">void</span> QGLFramebufferObject::<span class="name">drawTexture</span>(const <span class="type"><a href="./qpointf.htm" translate="no">QPointF</a></span> &amp;<i>point</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)<a class="plink" href="#drawTexture-1" title="Direct link to this headline"></a></h3>
<p>Draws the given texture, <i translate="no">textureId</i>, at the given <i translate="no">point</i> in OpenGL model space. The <i translate="no">textureTarget</i> should be a 2D texture target.</p>
<p>The framebuffer object should be bound when calling this function.</p>
<p>Equivalent to the corresponding <a href="./qglcontext.htm#drawTexture" translate="no">QGLContext::drawTexture</a>().</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format" translate="no"><a name="format"></a><span class="type"><a href="./qglframebufferobjectformat.htm" translate="no">QGLFramebufferObjectFormat</a></span> QGLFramebufferObject::<span class="name">format</span>() const<a class="plink" href="#format" title="Direct link to this headline"></a></h3>
<p>Returns the format of this framebuffer object.</p>
<!-- @@@format -->
<!-- $$$handle[overload1]$$$handle -->
<h3 class="fn" id="handle" translate="no"><a name="handle"></a><span class="type">GLuint</span> QGLFramebufferObject::<span class="name">handle</span>() const<a class="plink" href="#handle" title="Direct link to this headline"></a></h3>
<p>Returns the GL framebuffer object handle for this framebuffer object (returned by the <code translate="no">glGenFrameBuffersEXT()</code> function). This handle can be used to attach new images or buffers to the framebuffer. The user is responsible for cleaning up and destroying these objects.</p>
<!-- @@@handle -->
<!-- $$$hasOpenGLFramebufferBlit[overload1]$$$hasOpenGLFramebufferBlit -->
<h3 class="fn" id="hasOpenGLFramebufferBlit" translate="no"><a name="hasOpenGLFramebufferBlit"></a><code translate="no">[static] </code><span class="type">bool</span> QGLFramebufferObject::<span class="name">hasOpenGLFramebufferBlit</span>()<a class="plink" href="#hasOpenGLFramebufferBlit" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the OpenGL <code translate="no">GL_EXT_framebuffer_blit</code> extension is present on this system; otherwise returns <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#blitFramebuffer" translate="no">blitFramebuffer</a>().</p>
<!-- @@@hasOpenGLFramebufferBlit -->
<!-- $$$hasOpenGLFramebufferObjects[overload1]$$$hasOpenGLFramebufferObjects -->
<h3 class="fn" id="hasOpenGLFramebufferObjects" translate="no"><a name="hasOpenGLFramebufferObjects"></a><code translate="no">[static] </code><span class="type">bool</span> QGLFramebufferObject::<span class="name">hasOpenGLFramebufferObjects</span>()<a class="plink" href="#hasOpenGLFramebufferObjects" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the OpenGL <code translate="no">GL_EXT_framebuffer_object</code> extension is present on this system; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@hasOpenGLFramebufferObjects -->
<!-- $$$isBound[overload1]$$$isBound -->
<h3 class="fn" id="isBound" translate="no"><a name="isBound"></a><span class="type">bool</span> QGLFramebufferObject::<span class="name">isBound</span>() const<a class="plink" href="#isBound" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the framebuffer object is currently bound to a context, otherwise false is returned.</p>
<p>This function was introduced in Qt 4.5.</p>
<!-- @@@isBound -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QGLFramebufferObject::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the framebuffer object is valid.</p>
<p>The framebuffer can become invalid if the initialization process fails, the user attaches an invalid buffer to the framebuffer object, or a non-power of two width/height is specified as the texture size if the texture target is <code translate="no">GL_TEXTURE_2D</code>. The non-power of two limitation does not apply if the OpenGL version is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension is present.</p>
<p>The framebuffer can also become invalid if the QGLContext that the framebuffer was created within is destroyed and there are no other shared contexts that can take over ownership of the framebuffer.</p>
<!-- @@@isValid -->
<!-- $$$metric[overload1]$$$metricQPaintDevice::PaintDeviceMetric -->
<h3 class="fn" id="metric" translate="no"><a name="metric"></a><code translate="no">[override virtual protected] </code><span class="type">int</span> QGLFramebufferObject::<span class="name">metric</span>(<span class="type"><a href="./qpaintdevice.htm#PaintDeviceMetric-enum" translate="no">QPaintDevice::PaintDeviceMetric</a></span> <i>metric</i>) const<a class="plink" href="#metric" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qpaintdevice.htm#metric" translate="no">QPaintDevice::metric</a>(QPaintDevice::PaintDeviceMetric metric) const.</p>
<!-- @@@metric -->
<!-- $$$paintEngine[overload1]$$$paintEngine -->
<h3 class="fn" id="paintEngine" translate="no"><a name="paintEngine"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qpaintengine.htm" translate="no">QPaintEngine</a></span> *QGLFramebufferObject::<span class="name">paintEngine</span>() const<a class="plink" href="#paintEngine" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qpaintdevice.htm#paintEngine" translate="no">QPaintDevice::paintEngine</a>() const.</p>
<!-- @@@paintEngine -->
<!-- $$$release[overload1]$$$release -->
<h3 class="fn" id="release" translate="no"><a name="release"></a><span class="type">bool</span> QGLFramebufferObject::<span class="name">release</span>()<a class="plink" href="#release" title="Direct link to this headline"></a></h3>
<p>Switches rendering back to the default, windowing system provided framebuffer. Returns <code translate="no">true</code> upon success, false otherwise.</p>
<p><b>See also </b><a href="./qglframebufferobject.htm#bind" translate="no">bind</a>().</p>
<!-- @@@release -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> QGLFramebufferObject::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the size of the texture attached to this framebuffer object.</p>
<!-- @@@size -->
<!-- $$$texture[overload1]$$$texture -->
<h3 class="fn" id="texture" translate="no"><a name="texture"></a><span class="type">GLuint</span> QGLFramebufferObject::<span class="name">texture</span>() const<a class="plink" href="#texture" title="Direct link to this headline"></a></h3>
<p>Returns the texture id for the texture attached as the default rendering target in this framebuffer object. This texture id can be bound as a normal texture in your own GL code.</p>
<p>If a multisample framebuffer object is used then the value returned from this function will be invalid.</p>
<!-- @@@texture -->
<!-- $$$toImage[overload1]$$$toImage -->
<h3 class="fn" id="toImage" translate="no"><a name="toImage"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QGLFramebufferObject::<span class="name">toImage</span>() const<a class="plink" href="#toImage" title="Direct link to this headline"></a></h3>
<p>Returns the contents of this framebuffer object as a <a href="./qimage.htm" translate="no">QImage</a>.</p>
<p>The returned image has a format of premultiplied ARGB32 or RGB32. The latter is used only when internalTextureFormat() is set to <code translate="no">GL_RGB</code>.</p>
<p>If the rendering in the framebuffer was not done with premultiplied alpha in mind, create a wrapper <a href="./qimage.htm" translate="no">QImage</a> with a non-premultiplied format. This is necessary before performing operations like <a href="./qimage.htm#save" translate="no">QImage::save</a>() because otherwise the image data would get unpremultiplied, even though it was not premultiplied in the first place. To create such a wrapper without performing a copy of the pixel data, do the following:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> fboImage(fbo<span class="operator">.</span>toImage());
<span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> image(fboImage<span class="operator">.</span>constBits()<span class="operator">,</span> fboImage<span class="operator">.</span>width()<span class="operator">,</span> fboImage<span class="operator">.</span>height()<span class="operator">,</span> <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span><span class="operator">::</span>Format_ARGB32);</pre></div>
<p>On QNX the back buffer is not preserved when a buffer swap occures. So this function might return old content.</p>
<!-- @@@toImage -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>