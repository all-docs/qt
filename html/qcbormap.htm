<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QCborMap | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qcbormap.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QCborMap</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QCborMap Class</h1>
<!-- $$$QCborMap-brief -->
<p>The QCborMap class is used to hold an associative container representable in CBOR. <a href="#details">More...</a></p>
<!-- @@@QCborMap -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QCborMap&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.12</td></tr></tbody></table></div><p>This class was introduced in Qt 5.12.</p>
<ul>
<li><a href="./qcbormap-members.htm">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap-constiterator.htm" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap-iterator.htm" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#iterator-typedef" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#key_type-typedef" translate="no">key_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#mapped_type-typedef" translate="no">mapped_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#value_type-typedef" translate="no">value_type</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#QCborMap-2" translate="no">QCborMap</a></b>(int <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#QCborMap-1" translate="no">QCborMap</a></b>(const QCborMap &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-eq" translate="no">operator=</a></b>(const QCborMap &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#dtor.QCborMap" translate="no">~QCborMap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#compare" translate="no">compare</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#constFind" translate="no">constFind</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#constFind-1" translate="no">constFind</a></b>(QLatin1String <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#constFind-2" translate="no">constFind</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#constFind-3" translate="no">constFind</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#contains" translate="no">contains</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#contains-1" translate="no">contains</a></b>(QLatin1String <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#contains-2" translate="no">contains</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#contains-3" translate="no">contains</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#erase" translate="no">erase</a></b>(QCborMap::const_iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#erase-1" translate="no">erase</a></b>(QCborMap::iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#extract" translate="no">extract</a></b>(QCborMap::iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#extract-1" translate="no">extract</a></b>(QCborMap::const_iterator <i>it</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find" translate="no">find</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find-1" translate="no">find</a></b>(QLatin1String <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find-2" translate="no">find</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find-3" translate="no">find</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find-4" translate="no">find</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find-5" translate="no">find</a></b>(QLatin1String <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find-6" translate="no">find</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#find-7" translate="no">find</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#insert" translate="no">insert</a></b>(qint64 <i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#insert-1" translate="no">insert</a></b>(QLatin1String <i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#insert-2" translate="no">insert</a></b>(const QString &amp;<i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#insert-3" translate="no">insert</a></b>(const QCborValue &amp;<i>key</i>, const QCborValue &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#insert-4" translate="no">insert</a></b>(QCborMap::value_type <i>v</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;QCborValue&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#keys" translate="no">keys</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#remove" translate="no">remove</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#remove-1" translate="no">remove</a></b>(QLatin1String <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#remove-2" translate="no">remove</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#remove-3" translate="no">remove</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#swap" translate="no">swap</a></b>(QCborMap &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#take" translate="no">take</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#take-1" translate="no">take</a></b>(QLatin1String <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#take-2" translate="no">take</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#take-3" translate="no">take</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#toCborValue" translate="no">toCborValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QJsonObject </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#toJsonObject" translate="no">toJsonObject</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariantHash </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#toVariantHash" translate="no">toVariantHash</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariantMap </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#toVariantMap" translate="no">toVariantMap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#value" translate="no">value</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#value-1" translate="no">value</a></b>(QLatin1String <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#value-2" translate="no">value</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#value-3" translate="no">value</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-not-eq" translate="no">operator!=</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-lt" translate="no">operator&lt;</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-eq-eq" translate="no">operator==</a></b>(const QCborMap &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a></b>(qint64 <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a></b>(QLatin1String <i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QCborValue </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a></b>(const QCborValue &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d-5" translate="no">operator[]</a></b>(qint64 <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d-6" translate="no">operator[]</a></b>(QLatin1String <i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d-7" translate="no">operator[]</a></b>(const QString &amp;<i>key</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborValueRef </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#operator-5b-5d-8" translate="no">operator[]</a></b>(const QCborValue &amp;<i>key</i>)</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QCborMap </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#fromJsonObject" translate="no">fromJsonObject</a></b>(const QJsonObject &amp;<i>obj</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#fromVariantHash" translate="no">fromVariantHash</a></b>(const QVariantHash &amp;<i>hash</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCborMap </td><td class="memItemRight bottomAlign"><b><a href="./qcbormap.htm#fromVariantMap" translate="no">fromVariantMap</a></b>(const QVariantMap &amp;<i>map</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QCborMap-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>This class can be used to hold an associative container in CBOR, a map between a key and a value type. CBOR is the Concise Binary Object Representation, a very compact form of binary data encoding that is a superset of JSON. It was created by the IETF Constrained RESTful Environments (CoRE) WG, which has used it in many new RFCs. It is meant to be used alongside the <a href="https://tools.ietf.org/html/rfc7252" translate="no">CoAP protocol</a>.</p>
<p>Unlike JSON and <a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a>, CBOR map keys can be of any type, not just strings. For that reason, QCborMap is effectively a map between <a href="./qcborvalue.htm" translate="no">QCborValue</a> keys to <a href="./qcborvalue.htm" translate="no">QCborValue</a> value elements.</p>
<p>However, for all member functions that take a key parameter, QCborMap provides overloads that will work efficiently with integers and strings. In fact, the use of integer keys is encouraged, since they occupy fewer bytes to transmit and are simpler to encode and decode. Newer protocols designed by the IETF CoRE WG to work specifically with CBOR are known to use them.</p>
<p>QCborMap is not sorted, because of that, searching for keys has linear complexity (O(n)). QCborMap actually keeps the elements in the order that they were inserted, which means that it is possible to make sorted QCborMaps by carefully inserting elements in sorted order. CBOR does not require sorting, but recommends it.</p>
<p>QCborMap can also be converted to and from <a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a> and <a href="./qjsonobject.htm" translate="no">QJsonObject</a>. However, when performing the conversion, any non-string keys will be stringified using a one-way method that the conversion back to QCborMap will not undo.</p>
</div>
<p><b>See also </b><a href="./qcborarray.htm" translate="no">QCborArray</a>, <a href="./qcborvalue.htm" translate="no">QCborValue</a>, <a href="./qjsondocument.htm" translate="no">QJsonDocument</a>, and <a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a>.</p>
<!-- @@@QCborMap -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef" translate="no"><a name="const_iterator-typedef"></a>typedef QCborMap::<span class="name">const_iterator</span><a class="plink" href="#const_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>A synonym for <a href="./qcbormap-constiterator.htm" translate="no">QCborMap::ConstIterator</a></p>
<!-- @@@const_iterator -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedef" translate="no"><a name="iterator-typedef"></a>typedef QCborMap::<span class="name">iterator</span><a class="plink" href="#iterator-typedef" title="Direct link to this headline"></a></h3>
<p>A synonym for <a href="./qcbormap-iterator.htm" translate="no">QCborMap::Iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$key_type -->
<h3 class="fn" id="key_type-typedef" translate="no"><a name="key_type-typedef"></a>typedef QCborMap::<span class="name">key_type</span><a class="plink" href="#key_type-typedef" title="Direct link to this headline"></a></h3>
<p>The key type for this map. Since <a href="./qcbormap.htm" translate="no">QCborMap</a> keys can be any CBOR type, this is a <a href="./qcborvalue.htm" translate="no">QCborValue</a>.</p>
<!-- @@@key_type -->
<!-- $$$mapped_type -->
<h3 class="fn" id="mapped_type-typedef" translate="no"><a name="mapped_type-typedef"></a>typedef QCborMap::<span class="name">mapped_type</span><a class="plink" href="#mapped_type-typedef" title="Direct link to this headline"></a></h3>
<p>The type that is mapped to (the value), that is, a <a href="./qcborvalue.htm" translate="no">QCborValue</a>.</p>
<!-- @@@mapped_type -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef" translate="no"><a name="size_type-typedef"></a>typedef QCborMap::<span class="name">size_type</span><a class="plink" href="#size_type-typedef" title="Direct link to this headline"></a></h3>
<p>The type that <a href="./qcbormap.htm" translate="no">QCborMap</a> uses for sizes.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" id="value_type-typedef" translate="no"><a name="value_type-typedef"></a>typedef QCborMap::<span class="name">value_type</span><a class="plink" href="#value_type-typedef" title="Direct link to this headline"></a></h3>
<p>The value that is stored in this container: a pair of QCborValues</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="extract-1" translate="no"><a name="extract-1"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">extract</span>(<span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> <i>it</i>)<a class="plink" href="#extract-1" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="extract" translate="no"><a name="extract"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">extract</span>(<span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> <i>it</i>)<a class="plink" href="#extract" title="Direct link to this headline"></a></h3></div>
<p>Extracts a value from the map at the position indicated by iterator <i translate="no">it</i> and returns the value so extracted.</p>
<p><b>See also </b><a href="./qcbormap.htm#insert" translate="no">insert</a>(), <a href="./qcbormap.htm#erase" translate="no">erase</a>(), <a href="./qcbormap.htm#take" translate="no">take</a>(), and <a href="./qcbormap.htm#remove" translate="no">remove</a>().</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="find-3" translate="no"><a name="find-3"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>)<a class="plink" href="#find-3" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="find-7" translate="no"><a name="find-7"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>) const<a class="plink" href="#find-7" title="Direct link to this headline"></a></h3></div>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#end" translate="no">end</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="./qcbormap.htm#constFind-3" translate="no">constFind</a>(const QCborValue &amp;), <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="find-2" translate="no"><a name="find-2"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>)<a class="plink" href="#find-2" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="find-6" translate="no"><a name="find-6"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>) const<a class="plink" href="#find-6" title="Direct link to this headline"></a></h3></div>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#end" translate="no">end</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="./qcbormap.htm#constFind-2" translate="no">constFind</a>(const QString &amp;), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="find-1" translate="no"><a name="find-1"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>)<a class="plink" href="#find-1" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="find-5" translate="no"><a name="find-5"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>) const<a class="plink" href="#find-5" title="Direct link to this headline"></a></h3></div>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#end" translate="no">end</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#constFind-1" translate="no">constFind</a>(QLatin1String), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), and <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String).</p>
<!-- @@@ -->
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="find" translate="no"><a name="find"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)<a class="plink" href="#find" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="find-4" translate="no"><a name="find-4"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">find</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const<a class="plink" href="#find-4" title="Direct link to this headline"></a></h3></div>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#end" translate="no">end</a>().</p>
<p>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#constFind" translate="no">constFind</a>(qint64), <a href="./qcbormap.htm#remove" translate="no">remove</a>(qint64), and <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@ -->
<!-- $$$QCborMap$$$QCborMapint -->
<h3 class="fn" id="QCborMap-2" translate="no"><a name="QCborMap-2"></a>QCborMap::<span class="name">QCborMap</span>(<span class="type">int</span> <i>args</i>)<a class="plink" href="#QCborMap-2" title="Direct link to this headline"></a></h3>
<p>Constructs a QCborMap with items from a brace-initialization list found in <i translate="no">args</i>, as in the following example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> map <span class="operator">=</span> {
    {<span class="number">0</span><span class="operator">,</span> <span class="string">"Hello"</span>}<span class="operator">,</span>
    {<span class="number">1</span><span class="operator">,</span> <span class="string">"World"</span>}<span class="operator">,</span>
    {<span class="string">"foo"</span><span class="operator">,</span> nullptr}<span class="operator">,</span>
    {<span class="string">"bar"</span><span class="operator">,</span> <span class="type"><a href="./qcborarray.htm" translate="no">QCborArray</a></span>{<span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span>}}
};</pre></div>
<!-- @@@QCborMap -->
<!-- $$$QCborMap$$$QCborMapconstQCborMap& -->
<h3 class="fn" id="QCborMap-1" translate="no"><a name="QCborMap-1"></a>QCborMap::<span class="name">QCborMap</span>(const <span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>)<a class="plink" href="#QCborMap-1" title="Direct link to this headline"></a></h3>
<p>Creates a QCborMap object that is a copy of <i translate="no">other</i>.</p>
<!-- @@@QCborMap -->
<!-- $$$QCborMap[overload1]$$$QCborMap -->
<h3 class="fn" id="QCborMap" translate="no"><a name="QCborMap"></a>QCborMap::<span class="name">QCborMap</span>()<a class="plink" href="#QCborMap" title="Direct link to this headline"></a></h3>
<p>Constructs an empty CBOR Map object.</p>
<p><b>See also </b><a href="./qcbormap.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@QCborMap -->
<!-- $$$operator=[overload1]$$$operator=constQCborMap& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;QCborMap::<span class="name">operator=</span>(const <span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Replaces the contents of this object with a copy of <i translate="no">other</i>, then returns a reference to this object.</p>
<!-- @@@operator= -->
<!-- $$$~QCborMap[overload1]$$$~QCborMap -->
<h3 class="fn" id="dtor.QCborMap" translate="no"><a name="dtor.QCborMap"></a>QCborMap::<span class="name">~QCborMap</span>()<a class="plink" href="#dtor.QCborMap" title="Direct link to this headline"></a></h3>
<p>Destroys this <a href="./qcbormap.htm" translate="no">QCborMap</a> object and frees any associated resources it owns.</p>
<!-- @@@~QCborMap -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin" translate="no"><a name="begin"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">begin</span>()<a class="plink" href="#begin" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="./qcbormap.htm#end" translate="no">end</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#constBegin" translate="no">constBegin</a>() and <a href="./qcbormap.htm#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1" translate="no"><a name="begin-1"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">begin</span>() const<a class="plink" href="#begin-1" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#begin" translate="no">begin</a>() and <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin" translate="no"><a name="cbegin"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">cbegin</span>() const<a class="plink" href="#cbegin" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#begin" translate="no">begin</a>() and <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend" translate="no"><a name="cend"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">cend</span>() const<a class="plink" href="#cend" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="./qcbormap.htm#begin" translate="no">begin</a>(), <a href="./qcbormap.htm#constBegin" translate="no">constBegin</a>(), <a href="./qcbormap.htm#find" translate="no">find</a>(), and <a href="./qcbormap.htm#constFind" translate="no">constFind</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear" translate="no"><a name="clear"></a><span class="type">void</span> QCborMap::<span class="name">clear</span>()<a class="plink" href="#clear" title="Direct link to this headline"></a></h3>
<p>Empties this map.</p>
<p><b>See also </b><a href="./qcbormap.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareconstQCborMap& -->
<h3 class="fn" id="compare" translate="no"><a name="compare"></a><span class="type">int</span> QCborMap::<span class="name">compare</span>(const <span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const<a class="plink" href="#compare" title="Direct link to this headline"></a></h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns an integer that indicates whether this map should be sorted prior to (if the result is negative) or after <i translate="no">other</i> (if the result is positive). If this function returns 0, the two maps are equal and contain the same elements.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR sorting order, see <a href="./qcborvalue.htm#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="./qcborvalue.htm#compare" translate="no">QCborValue::compare</a>(), <a href="./qcborarray.htm#compare" translate="no">QCborArray::compare</a>(), and <a href="./qcbormap.htm#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@compare -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin" translate="no"><a name="constBegin"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constBegin</span>() const<a class="plink" href="#constBegin" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator pointing to the first key-value pair of this map. If this map is empty, the returned iterator will be the same as <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#begin" translate="no">begin</a>() and <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd" translate="no"><a name="constEnd"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constEnd</span>() const<a class="plink" href="#constEnd" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="./qcbormap.htm#begin" translate="no">begin</a>(), <a href="./qcbormap.htm#constBegin" translate="no">constBegin</a>(), <a href="./qcbormap.htm#find" translate="no">find</a>(), and <a href="./qcbormap.htm#constFind" translate="no">constFind</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFind[overload1]$$$constFindqint64 -->
<h3 class="fn" id="constFind" translate="no"><a name="constFind"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const<a class="plink" href="#constFind" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<p>CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), <a href="./qcbormap.htm#remove" translate="no">remove</a>(qint64), and <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@constFind -->
<!-- $$$constFind$$$constFindQLatin1String -->
<h3 class="fn" id="constFind-1" translate="no"><a name="constFind-1"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>) const<a class="plink" href="#constFind-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), and <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String).</p>
<!-- @@@constFind -->
<!-- $$$constFind$$$constFindconstQString& -->
<h3 class="fn" id="constFind-2" translate="no"><a name="constFind-2"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>) const<a class="plink" href="#constFind-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@constFind -->
<!-- $$$constFind$$$constFindconstQCborValue& -->
<h3 class="fn" id="constFind-3" translate="no"><a name="constFind-3"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">constFind</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>) const<a class="plink" href="#constFind-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a map iterator to the key-value pair whose key is <i translate="no">key</i>, if the map contains such a pair. If it doesn't, this function returns <a href="./qcbormap.htm#constEnd" translate="no">constEnd</a>().</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will find. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), and <a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;).</p>
<!-- @@@constFind -->
<!-- $$$contains[overload1]$$$containsqint64 -->
<h3 class="fn" id="contains" translate="no"><a name="contains"></a><span class="type">bool</span> QCborMap::<span class="name">contains</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const<a class="plink" href="#contains" title="Direct link to this headline"></a></h3>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p><b>See also </b><a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), <a href="./qcbormap.htm#remove" translate="no">remove</a>(qint64), <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;).</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsQLatin1String -->
<h3 class="fn" id="contains-1" translate="no"><a name="contains-1"></a><span class="type">bool</span> QCborMap::<span class="name">contains</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>) const<a class="plink" href="#contains-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;).</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQString& -->
<h3 class="fn" id="contains-2" translate="no"><a name="contains-2"></a><span class="type">bool</span> QCborMap::<span class="name">contains</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>) const<a class="plink" href="#contains-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), and <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;).</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstQCborValue& -->
<h3 class="fn" id="contains-3" translate="no"><a name="contains-3"></a><span class="type">bool</span> QCborMap::<span class="name">contains</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>) const<a class="plink" href="#contains-3" title="Direct link to this headline"></a></h3>
<p>Returns true if this map contains a key-value pair identified by key <i translate="no">key</i>.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), and <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;).</p>
<!-- @@@contains -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" id="empty" translate="no"><a name="empty"></a><span class="type">bool</span> QCborMap::<span class="name">empty</span>() const<a class="plink" href="#empty" title="Direct link to this headline"></a></h3>
<p>Synonym for <a href="./qcbormap.htm#isEmpty" translate="no">isEmpty</a>(). This function is provided for compatibility with generic code that uses the Standard Library API.</p>
<p>Returns true if this map is empty (<a href="./qcbormap.htm#size" translate="no">size</a>() == 0).</p>
<p><b>See also </b><a href="./qcbormap.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qcbormap.htm#size" translate="no">size</a>().</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end" translate="no"><a name="end"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">end</span>()<a class="plink" href="#end" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="./qcbormap.htm#begin" translate="no">begin</a>(), <a href="./qcbormap.htm#constBegin" translate="no">constBegin</a>(), <a href="./qcbormap.htm#find" translate="no">find</a>(), and <a href="./qcbormap.htm#constFind" translate="no">constFind</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1" translate="no"><a name="end-1"></a><span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> QCborMap::<span class="name">end</span>() const<a class="plink" href="#end-1" title="Direct link to this headline"></a></h3>
<p>Returns a map iterator representing an element just past the last element in the map.</p>
<p><b>See also </b><a href="./qcbormap.htm#begin" translate="no">begin</a>(), <a href="./qcbormap.htm#constBegin" translate="no">constBegin</a>(), <a href="./qcbormap.htm#find" translate="no">find</a>(), and <a href="./qcbormap.htm#constFind" translate="no">constFind</a>().</p>
<!-- @@@end -->
<!-- $$$erase[overload1]$$$eraseQCborMap::const_iterator -->
<h3 class="fn" id="erase" translate="no"><a name="erase"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">erase</span>(<span class="type"><a href="./qcbormap.htm#const_iterator-typedef" translate="no">QCborMap::const_iterator</a></span> <i>it</i>)<a class="plink" href="#erase" title="Direct link to this headline"></a></h3>
<p>Removes the key-value pair pointed to by the map iterator <i translate="no">it</i> and returns a pointer to the next element, after removal.</p>
<p><b>See also </b><a href="./qcbormap.htm#remove" translate="no">remove</a>(), <a href="./qcbormap.htm#begin" translate="no">begin</a>(), <a href="./qcbormap.htm#end" translate="no">end</a>(), <a href="./qcbormap.htm#insert" translate="no">insert</a>(), and <a href="./qcbormap.htm#extract" translate="no">extract</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQCborMap::iterator -->
<h3 class="fn" id="erase-1" translate="no"><a name="erase-1"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">erase</span>(<span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> <i>it</i>)<a class="plink" href="#erase-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Removes the key-value pair pointed to by the map iterator <i translate="no">it</i> and returns a pointer to the next element, after removal.</p>
<p><b>See also </b><a href="./qcbormap.htm#remove" translate="no">remove</a>(), <a href="./qcbormap.htm#begin" translate="no">begin</a>(), <a href="./qcbormap.htm#end" translate="no">end</a>(), and <a href="./qcbormap.htm#insert" translate="no">insert</a>().</p>
<!-- @@@erase -->
<!-- $$$fromJsonObject[overload1]$$$fromJsonObjectconstQJsonObject& -->
<h3 class="fn" id="fromJsonObject" translate="no"><a name="fromJsonObject"></a><code translate="no">[static] </code><span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> QCborMap::<span class="name">fromJsonObject</span>(const <span class="type"><a href="./qjsonobject.htm" translate="no">QJsonObject</a></span> &amp;<i>obj</i>)<a class="plink" href="#fromJsonObject" title="Direct link to this headline"></a></h3>
<p>Converts all JSON items found in the <i translate="no">obj</i> object to CBOR using QCborValue::fromJson(), and returns the map composed of those elements.</p>
<p>This conversion is lossless, as the CBOR type system is a superset of JSON's. Moreover, the map returned by this function can be converted back to the original <i translate="no">obj</i> by using <a href="./qcbormap.htm#toJsonObject" translate="no">toJsonObject</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#toJsonObject" translate="no">toJsonObject</a>(), <a href="./qcbormap.htm#toVariantMap" translate="no">toVariantMap</a>(), <a href="./qcborvalue.htm#fromJsonValue" translate="no">QCborValue::fromJsonValue</a>(), and <a href="./qcborarray.htm#fromJsonArray" translate="no">QCborArray::fromJsonArray</a>().</p>
<!-- @@@fromJsonObject -->
<!-- $$$fromVariantHash[overload1]$$$fromVariantHashconstQVariantHash& -->
<h3 class="fn" id="fromVariantHash" translate="no"><a name="fromVariantHash"></a><code translate="no">[static] </code><span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> QCborMap::<span class="name">fromVariantHash</span>(const <span class="type"><a href="./qvariant.htm#QVariantHash-typedef" translate="no">QVariantHash</a></span> &amp;<i>hash</i>)<a class="plink" href="#fromVariantHash" title="Direct link to this headline"></a></h3>
<p>Converts all the items in <i translate="no">hash</i> to CBOR using <a href="./qcborvalue.htm#fromVariant" translate="no">QCborValue::fromVariant</a>() and returns the map composed of those elements.</p>
<p>Conversion from <a href="./qvariant.htm" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="./qcborvalue.htm#fromVariant" translate="no">QCborValue::fromVariant</a>() for more information.</p>
<p><b>See also </b><a href="./qcbormap.htm#toVariantHash" translate="no">toVariantHash</a>(), <a href="./qcbormap.htm#fromVariantMap" translate="no">fromVariantMap</a>(), <a href="./qcbormap.htm#fromJsonObject" translate="no">fromJsonObject</a>(), and <a href="./qcborvalue.htm#fromVariant" translate="no">QCborValue::fromVariant</a>().</p>
<!-- @@@fromVariantHash -->
<!-- $$$fromVariantMap[overload1]$$$fromVariantMapconstQVariantMap& -->
<h3 class="fn" id="fromVariantMap" translate="no"><a name="fromVariantMap"></a><code translate="no">[static] </code><span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> QCborMap::<span class="name">fromVariantMap</span>(const <span class="type"><a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a></span> &amp;<i>map</i>)<a class="plink" href="#fromVariantMap" title="Direct link to this headline"></a></h3>
<p>Converts all the items in <i translate="no">map</i> to CBOR using <a href="./qcborvalue.htm#fromVariant" translate="no">QCborValue::fromVariant</a>() and returns the map composed of those elements.</p>
<p>Conversion from <a href="./qvariant.htm" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="./qcborvalue.htm#fromVariant" translate="no">QCborValue::fromVariant</a>() for more information.</p>
<p><b>See also </b><a href="./qcbormap.htm#toVariantMap" translate="no">toVariantMap</a>(), <a href="./qcbormap.htm#fromVariantHash" translate="no">fromVariantHash</a>(), <a href="./qcbormap.htm#fromJsonObject" translate="no">fromJsonObject</a>(), and <a href="./qcborvalue.htm#fromVariant" translate="no">QCborValue::fromVariant</a>().</p>
<!-- @@@fromVariantMap -->
<!-- $$$insert[overload1]$$$insertqint64constQCborValue& -->
<h3 class="fn" id="insert" translate="no"><a name="insert"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>, const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>value</i>)<a class="plink" href="#insert" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="./qcbormap.htm#erase" translate="no">erase</a>(), <a href="./qcbormap.htm#remove" translate="no">remove</a>(qint64), <a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64), <a href="./qcbormap.htm#take" translate="no">take</a>(qint64), and <a href="./qcbormap.htm#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQLatin1StringconstQCborValue& -->
<h3 class="fn" id="insert-1" translate="no"><a name="insert-1"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>, const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>value</i>)<a class="plink" href="#insert-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="./qcbormap.htm#erase" translate="no">erase</a>(), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), <a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String), <a href="./qcbormap.htm#take-1" translate="no">take</a>(QLatin1String), and <a href="./qcbormap.htm#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertconstQString&constQCborValue& -->
<h3 class="fn" id="insert-2" translate="no"><a name="insert-2"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>, const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>value</i>)<a class="plink" href="#insert-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="./qcbormap.htm#erase" translate="no">erase</a>(), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), <a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;), <a href="./qcbormap.htm#take-2" translate="no">take</a>(const QString &amp;), and <a href="./qcbormap.htm#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertconstQCborValue&constQCborValue& -->
<h3 class="fn" id="insert-3" translate="no"><a name="insert-3"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>, const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>value</i>)<a class="plink" href="#insert-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts the key <i translate="no">key</i> and value <i translate="no">value</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <i translate="no">key</i>, its value will be overwritten by <i translate="no">value</i>.</p>
<p><b>See also </b><a href="./qcbormap.htm#erase" translate="no">erase</a>(), <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="./qcbormap.htm#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQCborMap::value_type -->
<h3 class="fn" id="insert-4" translate="no"><a name="insert-4"></a><span class="type"><a href="./qcbormap.htm#iterator-typedef" translate="no">QCborMap::iterator</a></span> QCborMap::<span class="name">insert</span>(<span class="type"><a href="./qcbormap.htm#value_type-typedef" translate="no">QCborMap::value_type</a></span> <i>v</i>)<a class="plink" href="#insert-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts the key-value pair in <i translate="no">v</i> into this map and returns a map iterator pointing to the newly inserted pair.</p>
<p>If the map already had a key equal to <code translate="no">v.first</code>, its value will be overwritten by <code translate="no">v.second</code>.</p>
<p><b>See also </b><a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>, <a href="./qcbormap.htm#erase" translate="no">erase</a>(), and <a href="./qcbormap.htm#extract" translate="no">extract</a>().</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty" translate="no"><a name="isEmpty"></a><span class="type">bool</span> QCborMap::<span class="name">isEmpty</span>() const<a class="plink" href="#isEmpty" title="Direct link to this headline"></a></h3>
<p>Returns true if this map is empty (that is, <a href="./qcbormap.htm#size" translate="no">size</a>() is 0).</p>
<p><b>See also </b><a href="./qcbormap.htm#size" translate="no">size</a>() and <a href="./qcbormap.htm#clear" translate="no">clear</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$keys[overload1]$$$keys -->
<h3 class="fn" id="keys" translate="no"><a name="keys"></a><span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span>&gt; QCborMap::<span class="name">keys</span>() const<a class="plink" href="#keys" title="Direct link to this headline"></a></h3>
<p>Returns a list of all keys in this map.</p>
<p><b>See also </b><a href="./qmap.htm#keys" translate="no">QMap::keys</a>() and <a href="./qhash.htm#keys" translate="no">QHash::keys</a>().</p>
<!-- @@@keys -->
<!-- $$$remove[overload1]$$$removeqint64 -->
<h3 class="fn" id="remove" translate="no"><a name="remove"></a><span class="type">void</span> QCborMap::<span class="name">remove</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)<a class="plink" href="#remove" title="Direct link to this headline"></a></h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>remove(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), remove(const <a href="./qstring.htm" translate="no">QString</a> &amp;), remove(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), and <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeQLatin1String -->
<h3 class="fn" id="remove-1" translate="no"><a name="remove-1"></a><span class="type">void</span> QCborMap::<span class="name">remove</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>)<a class="plink" href="#remove-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>remove(qint64), remove(const <a href="./qstring.htm" translate="no">QString</a> &amp;), remove(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), and <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String).</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQString& -->
<h3 class="fn" id="remove-2" translate="no"><a name="remove-2"></a><span class="type">void</span> QCborMap::<span class="name">remove</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>)<a class="plink" href="#remove-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>remove(qint64), remove(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), remove(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), and <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@remove -->
<!-- $$$remove$$$removeconstQCborValue& -->
<h3 class="fn" id="remove-3" translate="no"><a name="remove-3"></a><span class="type">void</span> QCborMap::<span class="name">remove</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>)<a class="plink" href="#remove-3" title="Direct link to this headline"></a></h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>remove(qint64), remove(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), remove(const <a href="./qstring.htm" translate="no">QString</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;).</p>
<!-- @@@remove -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type">int</span> QCborMap::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the number of elements in this map.</p>
<p><b>See also </b><a href="./qcbormap.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@size -->
<!-- $$$swap[overload1]$$$swapQCborMap& -->
<h3 class="fn" id="swap" translate="no"><a name="swap"></a><span class="type">void</span> QCborMap::<span class="name">swap</span>(<span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>)<a class="plink" href="#swap" title="Direct link to this headline"></a></h3>
<p>Swaps the contents of this map and <i translate="no">other</i>.</p>
<!-- @@@swap -->
<!-- $$$take[overload1]$$$takeqint64 -->
<h3 class="fn" id="take" translate="no"><a name="take"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)<a class="plink" href="#take" title="Direct link to this headline"></a></h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64), <a href="./qcbormap.htm#take-1" translate="no">take</a>(QLatin1String), <a href="./qcbormap.htm#take-2" translate="no">take</a>(const QString &amp;), <a href="./qcbormap.htm#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$take$$$takeQLatin1String -->
<h3 class="fn" id="take-1" translate="no"><a name="take-1"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>)<a class="plink" href="#take-1" title="Direct link to this headline"></a></h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String), <a href="./qcbormap.htm#take" translate="no">take</a>(qint64), <a href="./qcbormap.htm#take-2" translate="no">take</a>(const QString &amp;), <a href="./qcbormap.htm#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$take$$$takeconstQString& -->
<h3 class="fn" id="take-2" translate="no"><a name="take-2"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>)<a class="plink" href="#take-2" title="Direct link to this headline"></a></h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;), <a href="./qcbormap.htm#take-1" translate="no">take</a>(QLatin1String), <a href="./qcbormap.htm#take" translate="no">take</a>(qint64), <a href="./qcbormap.htm#take-3" translate="no">take</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$take$$$takeconstQCborValue& -->
<h3 class="fn" id="take-3" translate="no"><a name="take-3"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">take</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>)<a class="plink" href="#take-3" title="Direct link to this headline"></a></h3>
<p>Removes the key <i translate="no">key</i> and the corresponding value from the map and returns the value, if it is found. If the map contains no such key, this function does nothing.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will remove. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="./qcbormap.htm#take-1" translate="no">take</a>(QLatin1String), <a href="./qcbormap.htm#take-2" translate="no">take</a>(const QString &amp;), <a href="./qcbormap.htm#take" translate="no">take</a>(qint64), and <a href="./qcbormap.htm#insert" translate="no">insert</a>().</p>
<!-- @@@take -->
<!-- $$$toCborValue[overload1]$$$toCborValue -->
<h3 class="fn" id="toCborValue" translate="no"><a name="toCborValue"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">toCborValue</span>() const<a class="plink" href="#toCborValue" title="Direct link to this headline"></a></h3>
<p>Explicitly constructs a <a href="./qcborvalue.htm" translate="no">QCborValue</a> object that represents this map. This function is usually not necessary since <a href="./qcborvalue.htm" translate="no">QCborValue</a> has a constructor for <a href="./qcbormap.htm" translate="no">QCborMap</a>, so the conversion is implicit.</p>
<p>Converting <a href="./qcbormap.htm" translate="no">QCborMap</a> to <a href="./qcborvalue.htm" translate="no">QCborValue</a> allows it to be used in any context where QCborValues can be used, including as keys and mapped types in <a href="./qcbormap.htm" translate="no">QCborMap</a>, as well as <a href="./qcborvalue.htm#toCbor" translate="no">QCborValue::toCbor</a>().</p>
<p><b>See also </b><a href="./qcborvalue.htm#QCborValue-14" translate="no">QCborValue::QCborValue</a>(const QCborMap &amp;).</p>
<!-- @@@toCborValue -->
<!-- $$$toJsonObject[overload1]$$$toJsonObject -->
<h3 class="fn" id="toJsonObject" translate="no"><a name="toJsonObject"></a><span class="type"><a href="./qjsonobject.htm" translate="no">QJsonObject</a></span> QCborMap::<span class="name">toJsonObject</span>() const<a class="plink" href="#toJsonObject" title="Direct link to this headline"></a></h3>
<p>Recursively converts every <a href="./qcborvalue.htm" translate="no">QCborValue</a> value in this map to JSON using <a href="./qcborvalue.htm#toJsonValue" translate="no">QCborValue::toJsonValue</a>() and creates a string key for all keys that aren't strings, then returns the corresponding <a href="./qjsonobject.htm" translate="no">QJsonObject</a> composed of those associations.</p>
<p>Please note that CBOR contains a richer and wider type set than JSON, so some information may be lost in this conversion. For more details on what conversions are applied, see <a href="./qcborvalue.htm#toJsonValue" translate="no">QCborValue::toJsonValue</a>().</p>
<a name="map-key-conversion-to-string"></a>
<h6 id="map-key-conversion-to-string">Map key conversion to string<a class="plink" href="#map-key-conversion-to-string" title="Direct link to this headline"></a></h6>
<p>JSON objects are defined as having string keys, unlike CBOR, so the conversion of a <a href="./qcbormap.htm" translate="no">QCborMap</a> to <a href="./qjsonobject.htm" translate="no">QJsonObject</a> will imply a step of "stringification" of the key values. The conversion will use the special handling of tags and extended types from above and will also convert the rest of the types as follows:</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Type</th><th>Transformation</th></tr></thead>
<tbody><tr class="odd" valign="top"><td>Bool</td><td>"true" and "false"</td></tr>
<tr class="even" valign="top"><td>Null</td><td>"null"</td></tr>
<tr class="odd" valign="top"><td>Undefined</td><td>"undefined"</td></tr>
<tr class="even" valign="top"><td>Integer</td><td>The decimal string form of the number</td></tr>
<tr class="odd" valign="top"><td>Double</td><td>The decimal string form of the number</td></tr>
<tr class="even" valign="top"><td>Byte array</td><td>Unless tagged differently (see above), encoded as Base64url</td></tr>
<tr class="odd" valign="top"><td>Array</td><td>Replaced by the compact form of its <a href="./qcborvalue.htm#toDiagnosticNotation" translate="no">Diagnostic notation</a></td></tr>
<tr class="even" valign="top"><td>Map</td><td>Replaced by the compact form of its <a href="./qcborvalue.htm#toDiagnosticNotation" translate="no">Diagnostic notation</a></td></tr>
<tr class="odd" valign="top"><td>Tags and extended types</td><td>Tag number is dropped and the tagged value is converted to string</td></tr>
</tbody></table></div>
<p><b>See also </b><a href="./qcbormap.htm#fromJsonObject" translate="no">fromJsonObject</a>(), <a href="./qcborvalue.htm#toJsonValue" translate="no">QCborValue::toJsonValue</a>(), <a href="./qcborarray.htm#toJsonArray" translate="no">QCborArray::toJsonArray</a>(), and <a href="./qcbormap.htm#toVariantMap" translate="no">toVariantMap</a>().</p>
<!-- @@@toJsonObject -->
<!-- $$$toVariantHash[overload1]$$$toVariantHash -->
<h3 class="fn" id="toVariantHash" translate="no"><a name="toVariantHash"></a><span class="type"><a href="./qvariant.htm#QVariantHash-typedef" translate="no">QVariantHash</a></span> QCborMap::<span class="name">toVariantHash</span>() const<a class="plink" href="#toVariantHash" title="Direct link to this headline"></a></h3>
<p>Converts the CBOR values to <a href="./qvariant.htm" translate="no">QVariant</a> using <a href="./qcborvalue.htm#toVariant" translate="no">QCborValue::toVariant</a>() and "stringifies" all the CBOR keys in this map, returning the <a href="./qvariant.htm#QVariantHash-typedef" translate="no">QVariantHash</a> that results from that association list.</p>
<p>QVariantMaps have string keys, unlike CBOR, so the conversion of a <a href="./qcbormap.htm" translate="no">QCborMap</a> to <a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a> will imply a step of "stringification" of the key values. See <a href="./qcbormap.htm#toJsonObject" translate="no">QCborMap::toJsonObject</a>() for details.</p>
<p>In addition, the conversion to <a href="./qvariant.htm" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="./qcborvalue.htm#toVariant" translate="no">QCborValue::toVariant</a>() for more information.</p>
<p><b>See also </b><a href="./qcbormap.htm#fromVariantHash" translate="no">fromVariantHash</a>(), <a href="./qcbormap.htm#toVariantMap" translate="no">toVariantMap</a>(), <a href="./qcbormap.htm#toJsonObject" translate="no">toJsonObject</a>(), <a href="./qcborvalue.htm#toVariant" translate="no">QCborValue::toVariant</a>(), and <a href="./qcborarray.htm#toVariantList" translate="no">QCborArray::toVariantList</a>().</p>
<!-- @@@toVariantHash -->
<!-- $$$toVariantMap[overload1]$$$toVariantMap -->
<h3 class="fn" id="toVariantMap" translate="no"><a name="toVariantMap"></a><span class="type"><a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a></span> QCborMap::<span class="name">toVariantMap</span>() const<a class="plink" href="#toVariantMap" title="Direct link to this headline"></a></h3>
<p>Converts the CBOR values to <a href="./qvariant.htm" translate="no">QVariant</a> using <a href="./qcborvalue.htm#toVariant" translate="no">QCborValue::toVariant</a>() and "stringifies" all the CBOR keys in this map, returning the <a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a> that results from that association list.</p>
<p>QVariantMaps have string keys, unlike CBOR, so the conversion of a <a href="./qcbormap.htm" translate="no">QCborMap</a> to <a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a> will imply a step of "stringification" of the key values. See <a href="./qcbormap.htm#toJsonObject" translate="no">QCborMap::toJsonObject</a>() for details.</p>
<p>In addition, the conversion to <a href="./qvariant.htm" translate="no">QVariant</a> is not completely lossless. Please see the documentation in <a href="./qcborvalue.htm#toVariant" translate="no">QCborValue::toVariant</a>() for more information.</p>
<p><b>See also </b><a href="./qcbormap.htm#fromVariantMap" translate="no">fromVariantMap</a>(), <a href="./qcbormap.htm#toVariantHash" translate="no">toVariantHash</a>(), <a href="./qcbormap.htm#toJsonObject" translate="no">toJsonObject</a>(), <a href="./qcborvalue.htm#toVariant" translate="no">QCborValue::toVariant</a>(), and <a href="./qcborarray.htm#toVariantList" translate="no">QCborArray::toVariantList</a>().</p>
<!-- @@@toVariantMap -->
<!-- $$$value[overload1]$$$valueqint64 -->
<h3 class="fn" id="value" translate="no"><a name="value"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const<a class="plink" href="#value" title="Direct link to this headline"></a></h3>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return from function will reference. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), <a href="./qcbormap.htm#constFind" translate="no">constFind</a>(qint64), <a href="./qcbormap.htm#remove" translate="no">remove</a>(qint64), and <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@value -->
<!-- $$$value$$$valueQLatin1String -->
<h3 class="fn" id="value-1" translate="no"><a name="value-1"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>) const<a class="plink" href="#value-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), <a href="./qcbormap.htm#constFind-1" translate="no">constFind</a>(QLatin1String), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), and <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String).</p>
<!-- @@@value -->
<!-- $$$value$$$valueconstQString& -->
<h3 class="fn" id="value-2" translate="no"><a name="value-2"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>) const<a class="plink" href="#value-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qcborvalue.htm" translate="no">QCborValue</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), <a href="./qcbormap.htm#constFind-2" translate="no">constFind</a>(const QString &amp;), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@value -->
<!-- $$$value$$$valueconstQCborValue& -->
<h3 class="fn" id="value-3" translate="no"><a name="value-3"></a><span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">value</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>) const<a class="plink" href="#value-3" title="Direct link to this headline"></a></h3>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>value(qint64), value(<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), value(const <a href="./qstring.htm" translate="no">QString</a> &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="./qcbormap.htm#constFind-3" translate="no">constFind</a>(const QCborValue &amp;), <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;).</p>
<!-- @@@value -->
<!-- $$$operator!=[overload1]$$$operator!=constQCborMap& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QCborMap::<span class="name">operator!=</span>(const <span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns true if the two maps contains any different elements or elements in different orders, false otherwise.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR equality in Qt, see, <a href="./qcborvalue.htm#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#compare" translate="no">compare</a>(), <a href="./qcborvalue.htm#operator-eq-eq" translate="no">QCborValue::operator==</a>(), <a href="./qcbormap.htm#operator-eq-eq" translate="no">QCborMap::operator==</a>(), <a href="./qcbormap.htm#operator-eq-eq" translate="no">operator==</a>(), and <a href="./qcbormap.htm#operator-lt" translate="no">operator&lt;</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator<[overload1]$$$operator<constQCborMap& -->
<h3 class="fn" id="operator-lt" translate="no"><a name="operator-lt"></a><span class="type">bool</span> QCborMap::<span class="name">operator&lt;</span>(const <span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const<a class="plink" href="#operator-lt" title="Direct link to this headline"></a></h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns true if this map should be sorted before <i translate="no">other</i>, false otherwise.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR sorting order, see <a href="./qcborvalue.htm#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#compare" translate="no">compare</a>(), <a href="./qcborvalue.htm#operator-eq-eq" translate="no">QCborValue::operator==</a>(), <a href="./qcbormap.htm#operator-eq-eq" translate="no">QCborMap::operator==</a>(), <a href="./qcbormap.htm#operator-eq-eq" translate="no">operator==</a>(), and <a href="./qcbormap.htm#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator==[overload1]$$$operator==constQCborMap& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QCborMap::<span class="name">operator==</span>(const <span class="type"><a href="./qcbormap.htm#QCborMap" translate="no">QCborMap</a></span> &amp;<i>other</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Compares this map and <i translate="no">other</i>, comparing each element in sequence, and returns true if the two maps contains the same elements in the same order, false otherwise.</p>
<p>Note that CBOR maps are unordered, which means that two maps containing the very same pairs but in different order will still compare differently. To avoid this, it is recommended to insert elements into the map in a predictable order, such as by ascending key value. In fact, maps with keys in sorted order are required for Canonical CBOR representation.</p>
<p>For more information on CBOR equality in Qt, see, <a href="./qcborvalue.htm#compare" translate="no">QCborValue::compare</a>().</p>
<p><b>See also </b><a href="./qcbormap.htm#compare" translate="no">compare</a>(), <a href="./qcborvalue.htm#operator-eq-eq" translate="no">QCborValue::operator==</a>(), QCborMap::operator==(), <a href="./qcbormap.htm#operator-not-eq" translate="no">operator!=</a>(), and <a href="./qcbormap.htm#operator-lt" translate="no">operator&lt;</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]qint64 -->
<h3 class="fn" id="operator-5b-5d" translate="no"><a name="operator-5b-5d"></a>const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>) const<a class="plink" href="#operator-5b-5d" title="Direct link to this headline"></a></h3>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), operator[](const <a href="./qstring.htm" translate="no">QString</a> &amp;), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), <a href="./qcbormap.htm#constFind" translate="no">constFind</a>(qint64), <a href="./qcbormap.htm#remove" translate="no">remove</a>(qint64), and <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]QLatin1String -->
<h3 class="fn" id="operator-5b-5d-1" translate="no"><a name="operator-5b-5d-1"></a>const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>) const<a class="plink" href="#operator-5b-5d-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](qint64), operator[](const <a href="./qstring.htm" translate="no">QString</a> &amp;), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), <a href="./qcbormap.htm#constFind-1" translate="no">constFind</a>(QLatin1String), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), and <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQString& -->
<h3 class="fn" id="operator-5b-5d-2" translate="no"><a name="operator-5b-5d-2"></a>const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>) const<a class="plink" href="#operator-5b-5d-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](qint64), operator[](<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), <a href="./qcbormap.htm#constFind-2" translate="no">constFind</a>(const QString &amp;), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), and <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQCborValue& -->
<h3 class="fn" id="operator-5b-5d-3" translate="no"><a name="operator-5b-5d-3"></a>const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>) const<a class="plink" href="#operator-5b-5d-3" title="Direct link to this headline"></a></h3>
<p>Returns the <a href="./qcborvalue.htm" translate="no">QCborValue</a> element in this map that corresponds to key <i translate="no">key</i>, if there is one.</p>
<p>If the map does not contain key <i translate="no">key</i>, this function returns a <a href="./qcborvalue.htm" translate="no">QCborValue</a> containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one this function will return. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p>operator[](qint64), operator[](<a href="./qlatin1string.htm" translate="no">QLatin1String</a>), operator[](const QCborOperator[] &amp;)</p>
<p><b>See also </b><a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="./qcbormap.htm#constFind-3" translate="no">constFind</a>(const QCborValue &amp;), <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;), and <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]qint64 -->
<h3 class="fn" id="operator-5b-5d-5" translate="no"><a name="operator-5b-5d-5"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qcborvalueref.html" translate="no">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>key</i>)<a class="plink" href="#operator-5b-5d-5" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> to the value in this map that corresponds to key <i translate="no">key</i>. CBOR recommends using integer keys, since they occupy less space and are simpler to encode and decode.</p>
<p><a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> has the exact same API as <a href="./qcborvalue.htm" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="./qcborvalue.htm" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value" translate="no">value</a>(qint64), <a href="./qcbormap.htm#find" translate="no">find</a>(qint64), <a href="./qcbormap.htm#contains" translate="no">contains</a>(qint64), <a href="./qcbormap.htm#remove" translate="no">remove</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), and <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]QLatin1String -->
<h3 class="fn" id="operator-5b-5d-6" translate="no"><a name="operator-5b-5d-6"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qcborvalueref.html" translate="no">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(<span class="type"><a href="./qlatin1string.htm" translate="no">QLatin1String</a></span> <i>key</i>)<a class="plink" href="#operator-5b-5d-6" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> to the value in this map that corresponds to key <i translate="no">key</i>.</p>
<p><a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> has the exact same API as <a href="./qcborvalue.htm" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="./qcborvalue.htm" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-1" translate="no">value</a>(QLatin1String), <a href="./qcbormap.htm#find-1" translate="no">find</a>(QLatin1String), <a href="./qcbormap.htm#contains-1" translate="no">contains</a>(QLatin1String), <a href="./qcbormap.htm#remove-1" translate="no">remove</a>(QLatin1String), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;), and <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQString& -->
<h3 class="fn" id="operator-5b-5d-7" translate="no"><a name="operator-5b-5d-7"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qcborvalueref.html" translate="no">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>)<a class="plink" href="#operator-5b-5d-7" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> to the value in this map that corresponds to key <i translate="no">key</i>.</p>
<p><a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> has the exact same API as <a href="./qcborvalue.htm" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="./qcborvalue.htm" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-2" translate="no">value</a>(const QString &amp;), <a href="./qcbormap.htm#find-2" translate="no">find</a>(const QString &amp;), <a href="./qcbormap.htm#contains-2" translate="no">contains</a>(const QString &amp;), <a href="./qcbormap.htm#remove-2" translate="no">remove</a>(const QString &amp;), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), and <a href="./qcbormap.htm#operator-5b-5d-3" translate="no">operator[]</a>(const QCborValue &amp;).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]constQCborValue& -->
<h3 class="fn" id="operator-5b-5d-8" translate="no"><a name="operator-5b-5d-8"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qcborvalueref.html" translate="no">QCborValueRef</a></span> QCborMap::<span class="name">operator[]</span>(const <span class="type"><a href="./qcborvalue.htm" translate="no">QCborValue</a></span> &amp;<i>key</i>)<a class="plink" href="#operator-5b-5d-8" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a <a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> to the value in this map that corresponds to key <i translate="no">key</i>.</p>
<p><a href="./qcborvalue.htm#qcborvalueref" translate="no">QCborValueRef</a> has the exact same API as <a href="./qcborvalue.htm" translate="no">QCborValue</a>, with one important difference: if you assign new values to it, this map will be updated with that new value.</p>
<p>If the map did not have a key equal to <i translate="no">key</i>, one is inserted and this function returns a reference to the new value, which will be a <a href="./qcborvalue.htm" translate="no">QCborValue</a> with an undefined value. For that reason, it is not possible with this function to tell apart the situation where the key was not present from the situation where the key was mapped to an undefined value.</p>
<p>If the map contains more than one key equal to <i translate="no">key</i>, it is undefined which one the return will reference. <a href="./qcbormap.htm" translate="no">QCborMap</a> does not allow inserting duplicate keys, but it is possible to create such a map by decoding a CBOR stream with them. They are usually not permitted and having duplicate keys is usually an indication of a problem in the sender.</p>
<p><b>See also </b><a href="./qcbormap.htm#value-3" translate="no">value</a>(const QCborValue &amp;), <a href="./qcbormap.htm#find-3" translate="no">find</a>(const QCborValue &amp;), <a href="./qcbormap.htm#contains-3" translate="no">contains</a>(const QCborValue &amp;), <a href="./qcbormap.htm#remove-3" translate="no">remove</a>(const QCborValue &amp;), <a href="./qcbormap.htm#operator-5b-5d" translate="no">operator[]</a>(qint64), <a href="./qcbormap.htm#operator-5b-5d-1" translate="no">operator[]</a>(QLatin1String), and <a href="./qcbormap.htm#operator-5b-5d-2" translate="no">operator[]</a>(const QString &amp;).</p>
<!-- @@@operator[] -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>