<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QFuture | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qfuture.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QFuture</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QFuture Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QFuture</span>
<!-- $$$QFuture-brief -->
<p>The QFuture class represents the result of an asynchronous computation. <a href="#details">More...</a></p>
<!-- @@@QFuture -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QFuture&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 4.4</td></tr></tbody></table></div><p>This class was introduced in Qt 4.4.</p>
<ul>
<li><a href="./qfuture-members.htm">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">thread-safe</a> with the following exceptions:</p>
<ul>
<li><a href="./qfuture-const-iterator.htm" translate="no">const_iterator</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qfuture-const-iterator.htm" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#QFuture-2" translate="no">QFuture</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#QFuture" translate="no">QFuture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#operator-eq" translate="no">operator=</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#dtor.QFuture" translate="no">~QFuture</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#begin" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#cancel" translate="no">cancel</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFuture::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#end" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#isCanceled" translate="no">isCanceled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#isFinished" translate="no">isFinished</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#isPaused" translate="no">isPaused</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#isResultReadyAt" translate="no">isResultReadyAt</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#isRunning" translate="no">isRunning</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#isStarted" translate="no">isStarted</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#pause" translate="no">pause</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#progressMaximum" translate="no">progressMaximum</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#progressMinimum" translate="no">progressMinimum</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#progressText" translate="no">progressText</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#progressValue" translate="no">progressValue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#result" translate="no">result</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#resultAt" translate="no">resultAt</a></b>(int <i>index</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#resultCount" translate="no">resultCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#results" translate="no">results</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#resume" translate="no">resume</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#setPaused" translate="no">setPaused</a></b>(bool <i>paused</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#togglePaused" translate="no">togglePaused</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#waitForFinished" translate="no">waitForFinished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#operator-T" translate="no">operator T</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#operator-not-eq" translate="no">operator!=</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qfuture.htm#operator-eq-eq" translate="no">operator==</a></b>(const QFuture&lt;T&gt; &amp;<i>other</i>) const</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QFuture-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>To start a computation, use one of the APIs in the <a href="./qtconcurrent-index.htm" translate="no">Qt Concurrent</a> framework.</p>
<p>QFuture allows threads to be synchronized against one or more results which will be ready at a later point in time. The result can be of any type that has a default constructor and a copy constructor. If a result is not available at the time of calling the <a href="./qfuture.htm#result" translate="no">result</a>(), <a href="./qfuture.htm#resultAt" translate="no">resultAt</a>(), or <a href="./qfuture.htm#results" translate="no">results</a>() functions, QFuture will wait until the result becomes available. You can use the <a href="./qfuture.htm#isResultReadyAt" translate="no">isResultReadyAt</a>() function to determine if a result is ready or not. For QFuture objects that report more than one result, the <a href="./qfuture.htm#resultCount" translate="no">resultCount</a>() function returns the number of continuous results. This means that it is always safe to iterate through the results from 0 to <a href="./qfuture.htm#resultCount" translate="no">resultCount</a>().</p>
<p>QFuture provides a <a href="./containers.htm#java-style-iterators" translate="no">Java-style iterator</a> (<a href="./qfutureiterator.htm" translate="no">QFutureIterator</a>) and an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> (<a href="./qfuture-const-iterator.htm" translate="no">QFuture::const_iterator</a>). Using these iterators is another way to access results in the future.</p>
<p>QFuture also offers ways to interact with a running computation. For instance, the computation can be canceled with the <a href="./qfuture.htm#cancel" translate="no">cancel</a>() function. To pause the computation, use the <a href="./qfuture.htm#setPaused" translate="no">setPaused</a>() function or one of the <a href="./qfuture.htm#pause" translate="no">pause</a>(), <a href="./qfuture.htm#resume" translate="no">resume</a>(), or <a href="./qfuture.htm#togglePaused" translate="no">togglePaused</a>() convenience functions. Be aware that not all running asynchronous computations can be canceled or paused. For example, the future returned by <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() cannot be canceled; but the future returned by <a href="./qtconcurrent.htm#mappedReduced" translate="no">QtConcurrent::mappedReduced</a>() can.</p>
<p>Progress information is provided by the <a href="./qfuture.htm#progressValue" translate="no">progressValue</a>(), <a href="./qfuture.htm#progressMinimum" translate="no">progressMinimum</a>(), <a href="./qfuture.htm#progressMaximum" translate="no">progressMaximum</a>(), and <a href="./qfuture.htm#progressText" translate="no">progressText</a>() functions. The <a href="./qfuture.htm#waitForFinished" translate="no">waitForFinished</a>() function causes the calling thread to block and wait for the computation to finish, ensuring that all results are available.</p>
<p>The state of the computation represented by a QFuture can be queried using the <a href="./qfuture.htm#isCanceled" translate="no">isCanceled</a>(), <a href="./qfuture.htm#isStarted" translate="no">isStarted</a>(), <a href="./qfuture.htm#isFinished" translate="no">isFinished</a>(), <a href="./qfuture.htm#isRunning" translate="no">isRunning</a>(), or <a href="./qfuture.htm#isPaused" translate="no">isPaused</a>() functions.</p>
<p>QFuture is a lightweight reference counted class that can be passed by value.</p>
<p>QFuture&lt;void&gt; is specialized to not contain any of the result fetching functions. Any QFuture&lt;T&gt; can be assigned or copied into a QFuture&lt;void&gt; as well. This is useful if only status or progress information is needed - not the actual result data.</p>
<p>To interact with running tasks using signals and slots, use <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a>.</p>
<div class="admonition note">
<p><b>Note: </b>Some APIs (see <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() allow scheduling the computation to a specific thread pool. However, QFuture implements a work-stealing algorithm to prevent deadlocks and optimize thread usage. As a result, computations can be executed directly in the thread which requests the QFuture's result.</p>
</div>
</div>
<p><b>See also </b><a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> and <a href="./qtconcurrent-index.htm" translate="no">Qt Concurrent</a>.</p>
<!-- @@@QFuture -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" id="ConstIterator-typedef" translate="no"><a name="ConstIterator-typedef"></a>typedef QFuture::<span class="name">ConstIterator</span><a class="plink" href="#ConstIterator-typedef" title="Direct link to this headline"></a></h3>
<p>Qt-style synonym for <a href="./qfuture-const-iterator.htm" translate="no">QFuture::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QFuture$$$QFutureconstQFuture<T>& -->
<h3 class="fn" id="QFuture-2" translate="no"><a name="QFuture-2"></a>QFuture::<span class="name">QFuture</span>(const <span class="type"><a href="./qfuture.htm#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#QFuture-2" title="Direct link to this headline"></a></h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p><b>See also </b><a href="./qfuture.htm#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QFuture -->
<!-- $$$QFuture[overload1]$$$QFuture -->
<h3 class="fn" id="QFuture" translate="no"><a name="QFuture"></a>QFuture::<span class="name">QFuture</span>()<a class="plink" href="#QFuture" title="Direct link to this headline"></a></h3>
<p>Constructs an empty, canceled future.</p>
<!-- @@@QFuture -->
<!-- $$$operator=[overload1]$$$operator=constQFuture<T>& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qfuture.htm#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;QFuture::<span class="name">operator=</span>(const <span class="type"><a href="./qfuture.htm#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns <i translate="no">other</i> to this future and returns a reference to this future.</p>
<!-- @@@operator= -->
<!-- $$$~QFuture[overload1]$$$~QFuture -->
<h3 class="fn" id="dtor.QFuture" translate="no"><a name="dtor.QFuture"></a>QFuture::<span class="name">~QFuture</span>()<a class="plink" href="#dtor.QFuture" title="Direct link to this headline"></a></h3>
<p>Destroys the future.</p>
<p>Note that this neither waits nor cancels the asynchronous computation. Use <a href="./qfuture.htm#waitForFinished" translate="no">waitForFinished</a>() or <a href="./qfuturesynchronizer.htm" translate="no">QFutureSynchronizer</a> when you need to ensure that the computation is completed before the future is destroyed.</p>
<!-- @@@~QFuture -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin" translate="no"><a name="begin"></a><span class="type"><a href="./qfuture-const-iterator.htm" translate="no">QFuture::const_iterator</a></span> QFuture::<span class="name">begin</span>() const<a class="plink" href="#begin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first result in the future.</p>
<p><b>See also </b><a href="./qfuture.htm#constBegin" translate="no">constBegin</a>() and <a href="./qfuture.htm#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$cancel[overload1]$$$cancel -->
<h3 class="fn" id="cancel" translate="no"><a name="cancel"></a><span class="type">void</span> QFuture::<span class="name">cancel</span>()<a class="plink" href="#cancel" title="Direct link to this headline"></a></h3>
<p>Cancels the asynchronous computation represented by this future. Note that the cancellation is asynchronous. Use <a href="./qfuture.htm#waitForFinished" translate="no">waitForFinished</a>() after calling cancel() when you need synchronous cancellation.</p>
<p>Results currently available may still be accessed on a canceled future, but new results will <i>not</i> become available after calling this function. Any <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> object that is watching this future will not deliver progress and result ready signals on a canceled future.</p>
<p>Be aware that not all running asynchronous computations can be canceled. For example, the future returned by <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() cannot be canceled; but the future returned by <a href="./qtconcurrent.htm#mappedReduced" translate="no">QtConcurrent::mappedReduced</a>() can.</p>
<!-- @@@cancel -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin" translate="no"><a name="constBegin"></a><span class="type"><a href="./qfuture-const-iterator.htm" translate="no">QFuture::const_iterator</a></span> QFuture::<span class="name">constBegin</span>() const<a class="plink" href="#constBegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first result in the future.</p>
<p><b>See also </b><a href="./qfuture.htm#begin" translate="no">begin</a>() and <a href="./qfuture.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd" translate="no"><a name="constEnd"></a><span class="type"><a href="./qfuture-const-iterator.htm" translate="no">QFuture::const_iterator</a></span> QFuture::<span class="name">constEnd</span>() const<a class="plink" href="#constEnd" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary result after the last result in the future.</p>
<p><b>See also </b><a href="./qfuture.htm#constBegin" translate="no">constBegin</a>() and <a href="./qfuture.htm#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end" translate="no"><a name="end"></a><span class="type"><a href="./qfuture-const-iterator.htm" translate="no">QFuture::const_iterator</a></span> QFuture::<span class="name">end</span>() const<a class="plink" href="#end" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary result after the last result in the future.</p>
<p><b>See also </b><a href="./qfuture.htm#begin" translate="no">begin</a>() and <a href="./qfuture.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$isCanceled[overload1]$$$isCanceled -->
<h3 class="fn" id="isCanceled" translate="no"><a name="isCanceled"></a><span class="type">bool</span> QFuture::<span class="name">isCanceled</span>() const<a class="plink" href="#isCanceled" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation has been canceled with the <a href="./qfuture.htm#cancel" translate="no">cancel</a>() function; otherwise returns <code translate="no">false</code>.</p>
<p>Be aware that the computation may still be running even though this function returns <code translate="no">true</code>. See <a href="./qfuture.htm#cancel" translate="no">cancel</a>() for more details.</p>
<!-- @@@isCanceled -->
<!-- $$$isFinished[overload1]$$$isFinished -->
<h3 class="fn" id="isFinished" translate="no"><a name="isFinished"></a><span class="type">bool</span> QFuture::<span class="name">isFinished</span>() const<a class="plink" href="#isFinished" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by this future has finished; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isFinished -->
<!-- $$$isPaused[overload1]$$$isPaused -->
<h3 class="fn" id="isPaused" translate="no"><a name="isPaused"></a><span class="type">bool</span> QFuture::<span class="name">isPaused</span>() const<a class="plink" href="#isPaused" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation has been paused with the <a href="./qfuture.htm#pause" translate="no">pause</a>() function; otherwise returns <code translate="no">false</code>.</p>
<p>Be aware that the computation may still be running even though this function returns <code translate="no">true</code>. See <a href="./qfuture.htm#setPaused" translate="no">setPaused</a>() for more details.</p>
<p><b>See also </b><a href="./qfuture.htm#setPaused" translate="no">setPaused</a>() and <a href="./qfuture.htm#togglePaused" translate="no">togglePaused</a>().</p>
<!-- @@@isPaused -->
<!-- $$$isResultReadyAt[overload1]$$$isResultReadyAtint -->
<h3 class="fn" id="isResultReadyAt" translate="no"><a name="isResultReadyAt"></a><span class="type">bool</span> QFuture::<span class="name">isResultReadyAt</span>(<span class="type">int</span> <i>index</i>) const<a class="plink" href="#isResultReadyAt" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the result at <i translate="no">index</i> is immediately available; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qfuture.htm#resultAt" translate="no">resultAt</a>() and <a href="./qfuture.htm#resultCount" translate="no">resultCount</a>().</p>
<!-- @@@isResultReadyAt -->
<!-- $$$isRunning[overload1]$$$isRunning -->
<h3 class="fn" id="isRunning" translate="no"><a name="isRunning"></a><span class="type">bool</span> QFuture::<span class="name">isRunning</span>() const<a class="plink" href="#isRunning" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by this future is currently running; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isRunning -->
<!-- $$$isStarted[overload1]$$$isStarted -->
<h3 class="fn" id="isStarted" translate="no"><a name="isStarted"></a><span class="type">bool</span> QFuture::<span class="name">isStarted</span>() const<a class="plink" href="#isStarted" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the asynchronous computation represented by this future has been started; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@isStarted -->
<!-- $$$pause[overload1]$$$pause -->
<h3 class="fn" id="pause" translate="no"><a name="pause"></a><span class="type">void</span> QFuture::<span class="name">pause</span>()<a class="plink" href="#pause" title="Direct link to this headline"></a></h3>
<p>Pauses the asynchronous computation represented by this future. This is a convenience method that simply calls <a href="./qfuture.htm#setPaused" translate="no">setPaused</a>(true).</p>
<p><b>See also </b><a href="./qfuture.htm#resume" translate="no">resume</a>().</p>
<!-- @@@pause -->
<!-- $$$progressMaximum[overload1]$$$progressMaximum -->
<h3 class="fn" id="progressMaximum" translate="no"><a name="progressMaximum"></a><span class="type">int</span> QFuture::<span class="name">progressMaximum</span>() const<a class="plink" href="#progressMaximum" title="Direct link to this headline"></a></h3>
<p>Returns the maximum <a href="./qfuture.htm#progressValue" translate="no">progressValue</a>().</p>
<p><b>See also </b><a href="./qfuture.htm#progressValue" translate="no">progressValue</a>() and <a href="./qfuture.htm#progressMinimum" translate="no">progressMinimum</a>().</p>
<!-- @@@progressMaximum -->
<!-- $$$progressMinimum[overload1]$$$progressMinimum -->
<h3 class="fn" id="progressMinimum" translate="no"><a name="progressMinimum"></a><span class="type">int</span> QFuture::<span class="name">progressMinimum</span>() const<a class="plink" href="#progressMinimum" title="Direct link to this headline"></a></h3>
<p>Returns the minimum <a href="./qfuture.htm#progressValue" translate="no">progressValue</a>().</p>
<p><b>See also </b><a href="./qfuture.htm#progressValue" translate="no">progressValue</a>() and <a href="./qfuture.htm#progressMaximum" translate="no">progressMaximum</a>().</p>
<!-- @@@progressMinimum -->
<!-- $$$progressText[overload1]$$$progressText -->
<h3 class="fn" id="progressText" translate="no"><a name="progressText"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QFuture::<span class="name">progressText</span>() const<a class="plink" href="#progressText" title="Direct link to this headline"></a></h3>
<p>Returns the (optional) textual representation of the progress as reported by the asynchronous computation.</p>
<p>Be aware that not all computations provide a textual representation of the progress, and as such, this function may return an empty string.</p>
<!-- @@@progressText -->
<!-- $$$progressValue[overload1]$$$progressValue -->
<h3 class="fn" id="progressValue" translate="no"><a name="progressValue"></a><span class="type">int</span> QFuture::<span class="name">progressValue</span>() const<a class="plink" href="#progressValue" title="Direct link to this headline"></a></h3>
<p>Returns the current progress value, which is between the <a href="./qfuture.htm#progressMinimum" translate="no">progressMinimum</a>() and <a href="./qfuture.htm#progressMaximum" translate="no">progressMaximum</a>().</p>
<p><b>See also </b><a href="./qfuture.htm#progressMinimum" translate="no">progressMinimum</a>() and <a href="./qfuture.htm#progressMaximum" translate="no">progressMaximum</a>().</p>
<!-- @@@progressValue -->
<!-- $$$result[overload1]$$$result -->
<h3 class="fn" id="result" translate="no"><a name="result"></a><span class="type">T</span> QFuture::<span class="name">result</span>() const<a class="plink" href="#result" title="Direct link to this headline"></a></h3>
<p>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <a href="./qfuture.htm#resultAt" translate="no">resultAt</a>(0).</p>
<p><b>See also </b><a href="./qfuture.htm#resultAt" translate="no">resultAt</a>() and <a href="./qfuture.htm#results" translate="no">results</a>().</p>
<!-- @@@result -->
<!-- $$$resultAt[overload1]$$$resultAtint -->
<h3 class="fn" id="resultAt" translate="no"><a name="resultAt"></a><span class="type">T</span> QFuture::<span class="name">resultAt</span>(<span class="type">int</span> <i>index</i>) const<a class="plink" href="#resultAt" title="Direct link to this headline"></a></h3>
<p>Returns the result at <i translate="no">index</i> in the future. If the result is not immediately available, this function will block and wait for the result to become available.</p>
<p><b>See also </b><a href="./qfuture.htm#result" translate="no">result</a>(), <a href="./qfuture.htm#results" translate="no">results</a>(), and <a href="./qfuture.htm#resultCount" translate="no">resultCount</a>().</p>
<!-- @@@resultAt -->
<!-- $$$resultCount[overload1]$$$resultCount -->
<h3 class="fn" id="resultCount" translate="no"><a name="resultCount"></a><span class="type">int</span> QFuture::<span class="name">resultCount</span>() const<a class="plink" href="#resultCount" title="Direct link to this headline"></a></h3>
<p>Returns the number of continuous results available in this future. The real number of results stored might be different from this value, due to gaps in the result set. It is always safe to iterate through the results from 0 to resultCount().</p>
<p><b>See also </b><a href="./qfuture.htm#result" translate="no">result</a>(), <a href="./qfuture.htm#resultAt" translate="no">resultAt</a>(), and <a href="./qfuture.htm#results" translate="no">results</a>().</p>
<!-- @@@resultCount -->
<!-- $$$results[overload1]$$$results -->
<h3 class="fn" id="results" translate="no"><a name="results"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QFuture::<span class="name">results</span>() const<a class="plink" href="#results" title="Direct link to this headline"></a></h3>
<p>Returns all results from the future. If the results are not immediately available, this function will block and wait for them to become available.</p>
<p><b>See also </b><a href="./qfuture.htm#result" translate="no">result</a>(), <a href="./qfuture.htm#resultAt" translate="no">resultAt</a>(), and <a href="./qfuture.htm#resultCount" translate="no">resultCount</a>().</p>
<!-- @@@results -->
<!-- $$$resume[overload1]$$$resume -->
<h3 class="fn" id="resume" translate="no"><a name="resume"></a><span class="type">void</span> QFuture::<span class="name">resume</span>()<a class="plink" href="#resume" title="Direct link to this headline"></a></h3>
<p>Resumes the asynchronous computation represented by this future. This is a convenience method that simply calls <a href="./qfuture.htm#setPaused" translate="no">setPaused</a>(false).</p>
<p><b>See also </b><a href="./qfuture.htm#pause" translate="no">pause</a>().</p>
<!-- @@@resume -->
<!-- $$$setPaused[overload1]$$$setPausedbool -->
<h3 class="fn" id="setPaused" translate="no"><a name="setPaused"></a><span class="type">void</span> QFuture::<span class="name">setPaused</span>(<span class="type">bool</span> <i>paused</i>)<a class="plink" href="#setPaused" title="Direct link to this headline"></a></h3>
<p>If <i translate="no">paused</i> is true, this function pauses the asynchronous computation represented by the future. If the computation is already paused, this function does nothing. Any <a href="./qfuturewatcher.htm" translate="no">QFutureWatcher</a> object that is watching this future will stop delivering progress and result ready signals while the future is paused. Signal delivery will continue once the future is resumed.</p>
<p>If <i translate="no">paused</i> is false, this function resumes the asynchronous computation. If the computation was not previously paused, this function does nothing.</p>
<p>Be aware that not all computations can be paused. For example, the future returned by <a href="./qtconcurrent.htm#run" translate="no">QtConcurrent::run</a>() cannot be paused; but the future returned by <a href="./qtconcurrent.htm#mappedReduced" translate="no">QtConcurrent::mappedReduced</a>() can.</p>
<p><b>See also </b><a href="./qfuture.htm#isPaused" translate="no">isPaused</a>(), <a href="./qfuture.htm#pause" translate="no">pause</a>(), <a href="./qfuture.htm#resume" translate="no">resume</a>(), and <a href="./qfuture.htm#togglePaused" translate="no">togglePaused</a>().</p>
<!-- @@@setPaused -->
<!-- $$$togglePaused[overload1]$$$togglePaused -->
<h3 class="fn" id="togglePaused" translate="no"><a name="togglePaused"></a><span class="type">void</span> QFuture::<span class="name">togglePaused</span>()<a class="plink" href="#togglePaused" title="Direct link to this headline"></a></h3>
<p>Toggles the paused state of the asynchronous computation. In other words, if the computation is currently paused, calling this function resumes it; if the computation is running, it is paused. This is a convenience method for calling <a href="./qfuture.htm#setPaused" translate="no">setPaused</a>(!<a href="./qfuture.htm#isPaused" translate="no">isPaused</a>()).</p>
<p><b>See also </b><a href="./qfuture.htm#setPaused" translate="no">setPaused</a>(), <a href="./qfuture.htm#pause" translate="no">pause</a>(), and <a href="./qfuture.htm#resume" translate="no">resume</a>().</p>
<!-- @@@togglePaused -->
<!-- $$$waitForFinished[overload1]$$$waitForFinished -->
<h3 class="fn" id="waitForFinished" translate="no"><a name="waitForFinished"></a><span class="type">void</span> QFuture::<span class="name">waitForFinished</span>()<a class="plink" href="#waitForFinished" title="Direct link to this headline"></a></h3>
<p>Waits for the asynchronous computation to finish (including <a href="./qfuture.htm#cancel" translate="no">cancel</a>()ed computations).</p>
<!-- @@@waitForFinished -->
<!-- $$$operator T[overload1]$$$operator T -->
<h3 class="fn" id="operator-T" translate="no"><a name="operator-T"></a><span class="type">T</span> QFuture::<span class="name">operator T</span>() const<a class="plink" href="#operator-T" title="Direct link to this headline"></a></h3>
<p>Returns the first result in the future. If the result is not immediately available, this function will block and wait for the result to become available. This is a convenience method for calling <a href="./qfuture.htm#result" translate="no">result</a>() or <a href="./qfuture.htm#resultAt" translate="no">resultAt</a>(0).</p>
<p><b>See also </b><a href="./qfuture.htm#result" translate="no">result</a>(), <a href="./qfuture.htm#resultAt" translate="no">resultAt</a>(), and <a href="./qfuture.htm#results" translate="no">results</a>().</p>
<!-- @@@operator T -->
<!-- $$$operator!=[overload1]$$$operator!=constQFuture<T>& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QFuture::<span class="name">operator!=</span>(const <span class="type"><a href="./qfuture.htm#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is <i>not</i> a copy of this future; otherwise returns false.</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQFuture<T>& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QFuture::<span class="name">operator==</span>(const <span class="type"><a href="./qfuture.htm#QFuture" translate="no">QFuture</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is a copy of this future; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@operator== -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>