<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QQuickWindow | Qt Quick</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qquickwindow.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a href="./qtquick-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QQuickWindow</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QQuickWindow Class</h1>
<!-- $$$QQuickWindow-brief -->
<p>The QQuickWindow class provides the window for displaying a graphical QML scene. <a href="#details">More...</a></p>
<!-- @@@QQuickWindow -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQuickWindow&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Instantiated By:</td><td class="memItemRight bottomAlign"> <a href="./qml-qtquick-window-window.htm" translate="no">Window</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qwindow.htm" translate="no">QWindow</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qquickview.htm" translate="no">QQuickView</a></p>
</td></tr></tbody></table></div><p>This class was introduced in Qt 5.0.</p>
<ul>
<li><a href="./qquickwindow-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qquickwindow-obsolete.htm">Obsolete members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> struct </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow-graphicsstateinfo.htm" translate="no">GraphicsStateInfo</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">CreateTextureOption</a></b> { TextureHasAlphaChannel, TextureHasMipmaps, TextureOwnsGLTexture, TextureCanUseAtlas, TextureIsOpaque }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">CreateTextureOptions</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#NativeObjectType-enum" translate="no">NativeObjectType</a></b> { NativeObjectTexture }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#RenderStage-enum" translate="no">RenderStage</a></b> { BeforeSynchronizingStage, AfterSynchronizingStage, BeforeRenderingStage, AfterRenderingStage, AfterSwapStage, NoStage }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#SceneGraphError-enum" translate="no">SceneGraphError</a></b> { ContextNotAvailable }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#TextRenderType-enum" translate="no">TextRenderType</a></b> { QtTextRendering, NativeTextRendering }</td></tr>
</tbody></table></div>
<a name="properties"></a>
<h2 id="properties">Properties<a class="plink" href="#properties" title="Direct link to this headline"></a></h2>
<ul>
<li class="fn" translate="no"><b><a href="./qquickwindow.htm#activeFocusItem-prop" translate="no">activeFocusItem</a></b> : QQuickItem* const</li>
<li class="fn" translate="no"><b><a href="./qquickwindow.htm#color-prop" translate="no">color</a></b> : QColor</li>
<li class="fn" translate="no"><b><a href="./qquickwindow.htm#contentItem-prop" translate="no">contentItem</a></b> : QQuickItem* const</li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#QQuickWindow-1" translate="no">QQuickWindow</a></b>(QQuickRenderControl *<i>control</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#QQuickWindow" translate="no">QQuickWindow</a></b>(QWindow *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#dtor.QQuickWindow" translate="no">~QQuickWindow</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#activeFocusItem-prop" translate="no">activeFocusItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#beginExternalCommands" translate="no">beginExternalCommands</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#clearBeforeRendering" translate="no">clearBeforeRendering</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QColor </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#color-prop" translate="no">color</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#contentItem-prop" translate="no">contentItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGImageNode *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#createImageNode" translate="no">createImageNode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGNinePatchNode *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#createNinePatchNode" translate="no">createNinePatchNode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGRectangleNode *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#createRectangleNode" translate="no">createRectangleNode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#createTextureFromImage" translate="no">createTextureFromImage</a></b>(const QImage &amp;<i>image</i>, QQuickWindow::CreateTextureOptions <i>options</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#createTextureFromImage-1" translate="no">createTextureFromImage</a></b>(const QImage &amp;<i>image</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGTexture *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#createTextureFromNativeObject" translate="no">createTextureFromNativeObject</a></b>(QQuickWindow::NativeObjectType <i>type</i>, const void *<i>nativeObjectPtr</i>, int <i>nativeLayout</i>, const QSize &amp;<i>size</i>, QQuickWindow::CreateTextureOptions <i>options</i> = CreateTextureOption()) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#effectiveDevicePixelRatio" translate="no">effectiveDevicePixelRatio</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#endExternalCommands" translate="no">endExternalCommands</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#grabWindow" translate="no">grabWindow</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QQuickWindow::GraphicsStateInfo &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#graphicsStateInfo" translate="no">graphicsStateInfo</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlIncubationController *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#incubationController" translate="no">incubationController</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#isPersistentOpenGLContext" translate="no">isPersistentOpenGLContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#isPersistentSceneGraph" translate="no">isPersistentSceneGraph</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#isSceneGraphInitialized" translate="no">isSceneGraphInitialized</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#mouseGrabberItem" translate="no">mouseGrabberItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#openglContext" translate="no">openglContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLFramebufferObject *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#renderTarget" translate="no">renderTarget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#renderTargetId" translate="no">renderTargetId</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#renderTargetSize" translate="no">renderTargetSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSGRendererInterface *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#rendererInterface" translate="no">rendererInterface</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#scheduleRenderJob" translate="no">scheduleRenderJob</a></b>(QRunnable *<i>job</i>, QQuickWindow::RenderStage <i>stage</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setClearBeforeRendering" translate="no">setClearBeforeRendering</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#color-prop" translate="no">setColor</a></b>(const QColor &amp;<i>color</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setPersistentOpenGLContext" translate="no">setPersistentOpenGLContext</a></b>(bool <i>persistent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setPersistentSceneGraph" translate="no">setPersistentSceneGraph</a></b>(bool <i>persistent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setRenderTarget" translate="no">setRenderTarget</a></b>(QOpenGLFramebufferObject *<i>fbo</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setRenderTarget-1" translate="no">setRenderTarget</a></b>(uint <i>fboId</i>, const QSize &amp;<i>size</i>)</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual QAccessibleInterface *</td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#accessibleRoot" translate="no">accessibleRoot</a></b>() const override</td></tr>
</tbody></table></div>
<a name="public-slots"></a>
<h2 id="public-slots">Public Slots<a class="plink" href="#public-slots" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#releaseResources" translate="no">releaseResources</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#update" translate="no">update</a></b>()</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#activeFocusItem-prop" translate="no">activeFocusItemChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#afterAnimating" translate="no">afterAnimating</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#afterRenderPassRecording" translate="no">afterRenderPassRecording</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#afterRendering" translate="no">afterRendering</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#afterSynchronizing" translate="no">afterSynchronizing</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">beforeRenderPassRecording</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#beforeSynchronizing" translate="no">beforeSynchronizing</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#closing" translate="no">closing</a></b>(QQuickCloseEvent *<i>close</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#color-prop" translate="no">colorChanged</a></b>(<i>const QColor &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#frameSwapped" translate="no">frameSwapped</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#openglContextCreated" translate="no">openglContextCreated</a></b>(QOpenGLContext *<i>context</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#sceneGraphAboutToStop" translate="no">sceneGraphAboutToStop</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#sceneGraphError" translate="no">sceneGraphError</a></b>(QQuickWindow::SceneGraphError <i>error</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">sceneGraphInitialized</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a></b>()</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#hasDefaultAlphaBuffer" translate="no">hasDefaultAlphaBuffer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#sceneGraphBackend" translate="no">sceneGraphBackend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setDefaultAlphaBuffer" translate="no">setDefaultAlphaBuffer</a></b>(bool <i>useAlpha</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setSceneGraphBackend" translate="no">setSceneGraphBackend</a></b>(QSGRendererInterface::GraphicsApi <i>api</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setSceneGraphBackend-1" translate="no">setSceneGraphBackend</a></b>(const QString &amp;<i>backend</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#setTextRenderType" translate="no">setTextRenderType</a></b>(QQuickWindow::TextRenderType <i>renderType</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWindow::TextRenderType </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#textRenderType" translate="no">textRenderType</a></b>()</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#exposeEvent" translate="no">exposeEvent</a></b>(<i>QExposeEvent *</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#focusInEvent" translate="no">focusInEvent</a></b>(QFocusEvent *<i>ev</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#focusOutEvent" translate="no">focusOutEvent</a></b>(QFocusEvent *<i>ev</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#hideEvent" translate="no">hideEvent</a></b>(<i>QHideEvent *</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#keyPressEvent" translate="no">keyPressEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#keyReleaseEvent" translate="no">keyReleaseEvent</a></b>(QKeyEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#mouseDoubleClickEvent" translate="no">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#mouseMoveEvent" translate="no">mouseMoveEvent</a></b>(QMouseEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#mousePressEvent" translate="no">mousePressEvent</a></b>(QMouseEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#mouseReleaseEvent" translate="no">mouseReleaseEvent</a></b>(QMouseEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#resizeEvent" translate="no">resizeEvent</a></b>(QResizeEvent *<i>ev</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#showEvent" translate="no">showEvent</a></b>(<i>QShowEvent *</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#tabletEvent" translate="no">tabletEvent</a></b>(QTabletEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qquickwindow.htm#wheelEvent" translate="no">wheelEvent</a></b>(QWheelEvent *<i>event</i>) override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QQuickWindow-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QQuickWindow provides the graphical scene management needed to interact with and display a scene of QQuickItems.</p>
<p>A QQuickWindow always has a single invisible root item. To add items to this window, reparent the items to the root item or to an existing item in the scene.</p>
<p>For easily displaying a scene from a QML file, see <a href="./qquickview.htm" translate="no">QQuickView</a>.</p>
<a name="rendering"></a>
<h3 id="rendering">Rendering<a class="plink" href="#rendering" title="Direct link to this headline"></a></h3>
<p>QQuickWindow uses a scene graph to represent what needs to be rendered. This scene graph is disconnected from the QML scene and potentially lives in another thread, depending on the platform implementation. Since the rendering scene graph lives independently from the QML scene, it can also be completely released without affecting the state of the QML scene.</p>
<p>The <a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">sceneGraphInitialized</a>() signal is emitted on the rendering thread before the QML scene is rendered to the screen for the first time. If the rendering scene graph has been released, the signal will be emitted again before the next frame is rendered.</p>
<a name="integration-with-opengl"></a>
<h4 id="integration-with-opengl">Integration with OpenGL<a class="plink" href="#integration-with-opengl" title="Direct link to this headline"></a></h4>
<p>When using the default OpenGL adaptation, it is possible to integrate OpenGL calls directly into the QQuickWindow using the same OpenGL context as the Qt Quick Scene Graph. This is done by connecting to the <a href="./qquickwindow.htm#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>() or <a href="./qquickwindow.htm#afterRendering" translate="no">QQuickWindow::afterRendering</a>() signal.</p>
<div class="admonition note">
<p><b>Note: </b>When using <a href="./qquickwindow.htm#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>(), make sure to disable clearing before rendering with <a href="./qquickwindow.htm#setClearBeforeRendering" translate="no">QQuickWindow::setClearBeforeRendering</a>().</p>
</div>
<a name="exposure-and-visibility"></a>
<h4 id="exposure-and-visibility">Exposure and Visibility<a class="plink" href="#exposure-and-visibility" title="Direct link to this headline"></a></h4>
<p>When a QQuickWindow instance is deliberately hidden with <a href="./qwindow.htm#hide" translate="no">hide</a>() or <a href="./qwindow.htm#visible-prop" translate="no">setVisible</a>(false), it will stop rendering and its scene graph and graphics context might be released. The <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>() signal will be emitted when this happens.</p>
<div class="admonition warning">
<p><b>Warning: </b>It is crucial that graphics operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the updatePaintNode() phase.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>As signals related to rendering might be emitted from the rendering thread, connections should be made using <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::DirectConnection</a>.</p>
</div>
<a name="resource-management"></a>
<h4 id="resource-management">Resource Management<a class="plink" href="#resource-management" title="Direct link to this headline"></a></h4>
<p>QML will try to cache images and scene graph nodes to improve performance, but in some low-memory scenarios it might be required to aggressively release these resources. The <a href="./qquickwindow.htm#releaseResources" translate="no">releaseResources</a>() can be used to force the clean up of certain resources. Calling <a href="./qquickwindow.htm#releaseResources" translate="no">releaseResources</a>() may result in the entire scene graph and in the case of the OpenGL adaptation the associated context will be deleted. The <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>() signal will be emitted when this happens.</p>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="./qtquick-visualcanvas-scenegraph.htm#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
<a name="context-and-surface-formats"></a>
<h4 id="context-and-surface-formats">Context and Surface Formats<a class="plink" href="#context-and-surface-formats" title="Direct link to this headline"></a></h4>
<p>While it is possible to specify a <a href="./qsurfaceformat.htm" translate="no">QSurfaceFormat</a> for every QQuickWindow by calling the member function <a href="./qwindow.htm#setFormat" translate="no">setFormat</a>(), windows may also be created from QML by using the Window and <a href="./qml-qtquick-controls2-applicationwindow.htm" translate="no">ApplicationWindow</a> elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function <a href="./qsurfaceformat.htm#setDefaultFormat" translate="no">QSurfaceFormat::setDefaultFormat</a>() at startup. The specified format will be used for all Quick windows created afterwards.</p>
</div>
<p><b>See also </b><a href="./qtquick-scenegraph-openglunderqml-example.htm" translate="no">Scene Graph - OpenGL Under QML</a>.</p>
<!-- @@@QQuickWindow -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$CreateTextureOption$$$TextureHasAlphaChannel$$$TextureHasMipmaps$$$TextureOwnsGLTexture$$$TextureCanUseAtlas$$$TextureIsOpaque -->
<h3 class="flags" id="CreateTextureOption-enum"><a name="CreateTextureOption-enum"></a>enum QQuickWindow::<span class="name">CreateTextureOption</span><br>flags QQuickWindow::<span class="name">CreateTextureOptions</span><a class="plink" href="#CreateTextureOption-enum" title="Direct link to this headline"></a></h3>
<p>The CreateTextureOption enums are used to customize a texture is wrapped.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::TextureHasAlphaChannel</code></td><td class="topAlign tblval"><code translate="no">0x0001</code></td><td class="topAlign">The texture has an alpha channel and should be drawn using blending.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::TextureHasMipmaps</code></td><td class="topAlign tblval"><code translate="no">0x0002</code></td><td class="topAlign">The texture has mipmaps and can be drawn with mipmapping enabled.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::TextureOwnsGLTexture</code></td><td class="topAlign tblval"><code translate="no">0x0004</code></td><td class="topAlign">The texture object owns the texture id and will delete the OpenGL texture when the texture object is deleted.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::TextureCanUseAtlas</code></td><td class="topAlign tblval"><code translate="no">0x0008</code></td><td class="topAlign">The image can be uploaded into a texture atlas.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::TextureIsOpaque</code></td><td class="topAlign tblval"><code translate="no">0x0010</code></td><td class="topAlign">The texture will return false for <a href="./qsgtexture.htm#hasAlphaChannel" translate="no">QSGTexture::hasAlphaChannel</a>() and will not be blended. This flag was added in Qt 5.6.</td></tr>
</tbody></table></div>
<p>The CreateTextureOptions type is a typedef for <a href="./qflags.htm">QFlags</a>&lt;CreateTextureOption&gt;. It stores an OR combination of CreateTextureOption values.</p>
<!-- @@@CreateTextureOption -->
<!-- $$$NativeObjectType$$$NativeObjectTexture -->
<h3 class="fn" id="NativeObjectType-enum" translate="no"><a name="NativeObjectType-enum"></a>enum QQuickWindow::<span class="name">NativeObjectType</span><a class="plink" href="#NativeObjectType-enum" title="Direct link to this headline"></a></h3>
<p>Specifies the type of the native object passed to functions such as <a href="./qquickwindow.htm#createTextureFromNativeObject" translate="no">createTextureFromNativeObject</a>().</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::NativeObjectTexture</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The native object is a 2D texture (OpenGL, Direct3D 11, Metal) or image (Vulkan).</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 5.14.</p>
<!-- @@@NativeObjectType -->
<!-- $$$RenderStage$$$BeforeSynchronizingStage$$$AfterSynchronizingStage$$$BeforeRenderingStage$$$AfterRenderingStage$$$AfterSwapStage$$$NoStage -->
<h3 class="fn" id="RenderStage-enum" translate="no"><a name="RenderStage-enum"></a>enum QQuickWindow::<span class="name">RenderStage</span><a class="plink" href="#RenderStage-enum" title="Direct link to this headline"></a></h3>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::BeforeSynchronizingStage</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Before synchronization.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::AfterSynchronizingStage</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">After synchronization.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::BeforeRenderingStage</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Before rendering.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::AfterRenderingStage</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">After rendering.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::AfterSwapStage</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">After the frame is swapped.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::NoStage</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">As soon as possible. This value was added in Qt 5.6.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 5.4.</p>
<p><b>See also </b><a href="./qtquick-visualcanvas-scenegraph.htm#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a>.</p>
<!-- @@@RenderStage -->
<!-- $$$SceneGraphError$$$ContextNotAvailable -->
<h3 class="fn" id="SceneGraphError-enum" translate="no"><a name="SceneGraphError-enum"></a>enum QQuickWindow::<span class="name">SceneGraphError</span><a class="plink" href="#SceneGraphError-enum" title="Direct link to this headline"></a></h3>
<p>This enum describes the error in a <a href="./qquickwindow.htm#sceneGraphError" translate="no">sceneGraphError</a>() signal.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::ContextNotAvailable</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">graphics context creation failed. This typically means that no suitable OpenGL implementation was found, for example because no graphics drivers are installed and so no OpenGL 2 support is present. On mobile and embedded boards that use OpenGL ES such an error is likely to indicate issues in the windowing system integration and possibly an incorrect configuration of Qt.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 5.3.</p>
<!-- @@@SceneGraphError -->
<!-- $$$TextRenderType$$$QtTextRendering$$$NativeTextRendering -->
<h3 class="fn" id="TextRenderType-enum" translate="no"><a name="TextRenderType-enum"></a>enum QQuickWindow::<span class="name">TextRenderType</span><a class="plink" href="#TextRenderType-enum" title="Direct link to this headline"></a></h3>
<p>This enum describes the default render type of text-like elements in Qt Quick (<a href="./qml-qtquick-text.htm" translate="no">Text</a>, <a href="./qml-qtquick-textinput.htm" translate="no">TextInput</a>, etc.).</p>
<p>Select NativeTextRendering if you prefer text to look native on the target platform and do not require advanced features such as transformation of the text. Using such features in combination with the NativeTextRendering render type will lend poor and sometimes pixelated results.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::QtTextRendering</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Use Qt's own rasterization algorithm.</td></tr>
<tr><td class="topAlign"><code translate="no">QQuickWindow::NativeTextRendering</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">Use the operating system's native rasterizer for text.</td></tr>
</tbody></table></div>
<p>This enum was introduced or modified in Qt 5.10.</p>
<!-- @@@TextRenderType -->
</div>
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$activeFocusItem-prop$$$activeFocusItem$$$activeFocusItemChanged -->
<h3 class="fn" id="activeFocusItem-prop" translate="no"><a name="activeFocusItem-prop"></a><span class="name">activeFocusItem</span> : <span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span>* const<a class="plink" href="#activeFocusItem-prop" title="Direct link to this headline"></a></h3>
<p>This property holds the item which currently has active focus or <code translate="no">null</code> if there is no item with active focus.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><span class="name"><b>activeFocusItem</b></span>() const</td></tr>
</tbody></table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>activeFocusItemChanged</b></span>()</td></tr>
</tbody></table></div>
<p><b>See also </b><a href="./qquickitem.htm#forceActiveFocus" translate="no">QQuickItem::forceActiveFocus</a>() and <a href="./qtquick-input-focus.htm" translate="no">Keyboard Focus in Qt Quick</a>.</p>
<!-- @@@activeFocusItem -->
<!-- $$$color-prop$$$color$$$setColorconstQColor&$$$colorChangedconstQColor& -->
<h3 class="fn" id="color-prop" translate="no"><a name="color-prop"></a><span class="name">color</span> : <span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span><a class="plink" href="#color-prop" title="Direct link to this headline"></a></h3>
<p>This property holds the color used to clear the OpenGL context.</p>
<p>Setting the clear color has no effect when clearing is disabled. By default, the clear color is white.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> QColor </td><td class="memItemRight bottomAlign"><span class="name"><b>color</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setColor</b></span>(const QColor &amp;<i>color</i>)</td></tr>
</tbody></table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>colorChanged</b></span>(<i>const QColor &amp;</i>)</td></tr>
</tbody></table></div>
<p><b>See also </b><a href="./qquickwindow.htm#setClearBeforeRendering" translate="no">setClearBeforeRendering</a>() and <a href="./qquickwindow.htm#setDefaultAlphaBuffer" translate="no">setDefaultAlphaBuffer</a>().</p>
<!-- @@@color -->
<!-- $$$contentItem-prop$$$contentItem -->
<h3 class="fn" id="contentItem-prop" translate="no"><a name="contentItem-prop"></a><span class="name">contentItem</span> : <span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span>* const<a class="plink" href="#contentItem-prop" title="Direct link to this headline"></a></h3>
<p>This property holds the invisible root item of the scene.</p>
<p>A <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> always has a single invisible root item containing all of its content. To add items to this window, reparent the items to the contentItem or to an existing item in the scene.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft topAlign rightAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><span class="name"><b>contentItem</b></span>() const</td></tr>
</tbody></table></div>
<!-- @@@contentItem -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickWindow$$$QQuickWindowQQuickRenderControl* -->
<h3 class="fn" id="QQuickWindow-1" translate="no"><a name="QQuickWindow-1"></a>QQuickWindow::<span class="name">QQuickWindow</span>(<span class="type"><a href="./qquickrendercontrol.htm" translate="no">QQuickRenderControl</a></span> *<i>control</i>)<a class="plink" href="#QQuickWindow-1" title="Direct link to this headline"></a></h3>
<p>Constructs a window for displaying a QML scene, whose rendering will be controlled by the <i translate="no">control</i> object. Please refer to <a href="./qquickrendercontrol.htm" translate="no">QQuickRenderControl</a>'s documentation for more information.</p>
<p>This function was introduced in Qt 5.4.</p>
<!-- @@@QQuickWindow -->
<!-- $$$QQuickWindow[overload1]$$$QQuickWindowQWindow* -->
<h3 class="fn" id="QQuickWindow" translate="no"><a name="QQuickWindow"></a>QQuickWindow::<span class="name">QQuickWindow</span>(<span class="type"><a href="./qwindow.htm#QWindow" translate="no">QWindow</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QQuickWindow" title="Direct link to this headline"></a></h3>
<p>Constructs a window for displaying a QML scene with parent window <i translate="no">parent</i>.</p>
<!-- @@@QQuickWindow -->
<!-- $$$afterAnimating[overload1]$$$afterAnimating -->
<h3 class="fn" id="afterAnimating" translate="no"><a name="afterAnimating"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">afterAnimating</span>()<a class="plink" href="#afterAnimating" title="Direct link to this headline"></a></h3>
<p>This signal is emitted on the GUI thread before requesting the render thread to perform the synchronization of the scene graph.</p>
<p>Unlike the other similar signals, this one is emitted on the GUI thread instead of the render thread. It can be used to synchronize external animation systems with the QML content. At the same time this means that this signal is not suitable for triggering graphics operations.</p>
<p>This function was introduced in Qt 5.3.</p>
<!-- @@@afterAnimating -->
<!-- $$$afterRenderPassRecording[overload1]$$$afterRenderPassRecording -->
<h3 class="fn" id="afterRenderPassRecording" translate="no"><a name="afterRenderPassRecording"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">afterRenderPassRecording</span>()<a class="plink" href="#afterRenderPassRecording" title="Direct link to this headline"></a></h3>
<p>This signal is emitted after the scenegraph has recorded the commands for its main render pass, but the pass is not yet finalized on the command buffer.</p>
<p>This signal is applicable when using the RHI graphics abstraction with the scenegraph. It is emitted earlier than <a href="./qquickwindow.htm#afterRendering" translate="no">afterRendering</a>() and it guarantees that not just the frame, but also the recording of the scenegraph's main render pass is still active. This allows inserting commands without having to generate an entire, separate render pass (which would typically clear the attached images). The native graphics objects can be queried via <a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a>.</p>
<p>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has finished its rendering, but before <a href="./qquickwindow.htm#afterRendering" translate="no">afterRendering</a>(). This makes it possible to create applications that function identically both with and without the RHI.</p>
<div class="admonition note">
<p><b>Note: </b>Resource updates (uploads, copies) typically cannot be enqueued from within a render pass. Therefore, more complex user rendering will need to connect to both <a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a>() and this signal.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::ConnectionType</a>).</p>
</div>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@afterRenderPassRecording -->
<!-- $$$afterRendering[overload1]$$$afterRendering -->
<h3 class="fn" id="afterRendering" translate="no"><a name="afterRendering"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">afterRendering</span>()<a class="plink" href="#afterRendering" title="Direct link to this headline"></a></h3>
<p>This signal is emitted after the scene has completed rendering, before swapbuffers is called.</p>
<p>This signal can be used to paint using raw OpenGL on top of QML content, or to do screen scraping of the current frame buffer.</p>
<p>The OpenGL context used for rendering the scene graph will be bound at this point.</p>
<p>When using the RHI, the signal is emitted after scene graph has added its commands to the command buffer, which is not yet submitted to the graphics queue. If desired, the slot function connected to this signal can query native resources, like the command buffer, before via <a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a>. Note however that the render pass (or passes) are already recorded at this point and it is not possible to add more commands within the scenegraph's pass. Instead, use <a href="./qquickwindow.htm#afterRenderPassRecording" translate="no">afterRenderPassRecording</a>() for that. This signal has therefore limited use and is rarely needed in an RHI-based setup. Rather, it is the combination of <a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a>() + <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">beforeRenderPassRecording</a>() or <a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a>() + <a href="./qquickwindow.htm#afterRenderPassRecording" translate="no">afterRenderPassRecording</a>() that is typically used to achieve under- or overlaying of the custom rendering.</p>
<div class="admonition warning">
<p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::ConnectionType</a>).</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Make very sure that a signal handler for afterRendering() leaves the OpenGL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<!-- @@@afterRendering -->
<!-- $$$afterSynchronizing[overload1]$$$afterSynchronizing -->
<h3 class="fn" id="afterSynchronizing" translate="no"><a name="afterSynchronizing"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">afterSynchronizing</span>()<a class="plink" href="#afterSynchronizing" title="Direct link to this headline"></a></h3>
<p>This signal is emitted after the scene graph is synchronized with the QML state.</p>
<p>This signal can be used to do preparation required after calls to <a href="./qquickitem.htm#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>(), while the GUI thread is still locked.</p>
<p>The graphics context used for rendering the scene graph will be bound at this point.</p>
<div class="admonition warning">
<p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::ConnectionType</a>).</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>When using the OpenGL adaptation, make sure that a signal handler for afterSynchronizing leaves the OpenGL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p>
</div>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<!-- @@@afterSynchronizing -->
<!-- $$$beforeRenderPassRecording[overload1]$$$beforeRenderPassRecording -->
<h3 class="fn" id="beforeRenderPassRecording" translate="no"><a name="beforeRenderPassRecording"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">beforeRenderPassRecording</span>()<a class="plink" href="#beforeRenderPassRecording" title="Direct link to this headline"></a></h3>
<p>This signal is emitted before the scenegraph starts recording commands for the main render pass. (Layers have their own passes and are fully recorded by the time this signal is emitted.) The render pass is already active on the command buffer when the signal is emitted.</p>
<p>This signal is applicable when using the RHI graphics abstraction with the scenegraph. It is emitted later than <a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a>() and it guarantees that not just the frame, but also the recording of the scenegraph's main render pass is active. This allows inserting commands without having to generate an entire, separate render pass (which would typically clear the attached images). The native graphics objects can be queried via <a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a>.</p>
<p>When not running with the RHI (and using OpenGL directly), the signal is emitted after the renderer has cleared the render target. This makes it possible to create applications that function identically both with and without the RHI.</p>
<div class="admonition note">
<p><b>Note: </b>Resource updates (uploads, copies) typically cannot be enqueued from within a render pass. Therefore, more complex user rendering will need to connect to both <a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a>() and this signal.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::ConnectionType</a>).</p>
</div>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@beforeRenderPassRecording -->
<!-- $$$beforeRendering[overload1]$$$beforeRendering -->
<h3 class="fn" id="beforeRendering" translate="no"><a name="beforeRendering"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">beforeRendering</span>()<a class="plink" href="#beforeRendering" title="Direct link to this headline"></a></h3>
<p>This signal is emitted before the scene starts rendering.</p>
<p>Combined with the modes for clearing the background, this option can be used to paint using raw OpenGL under QML content.</p>
<p>The OpenGL context used for rendering the scene graph will be bound at this point.</p>
<p>When using the RHI, the signal is emitted after the preparations for the frame have been done, meaning there is a command buffer in recording mode, where applicable. If desired, the slot function connected to this signal can query native resources like the command before via <a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a>. Note however that the recording of the main render pass is not yet started at this point and it is not possible to add commands within that pass. Starting a pass means clearing the color, depth, and stencil buffers so it is not possible to achieve an underlay type of rendering by just connecting to this signal. Rather, connect to <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">beforeRenderPassRecording</a>(). However, connecting to this signal is still important if the recording of copy type of commands is desired since those cannot be enqueued within a render pass.</p>
<div class="admonition warning">
<p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::ConnectionType</a>).</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Make very sure that a signal handler for beforeRendering leaves the OpenGL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<!-- @@@beforeRendering -->
<!-- $$$beforeSynchronizing[overload1]$$$beforeSynchronizing -->
<h3 class="fn" id="beforeSynchronizing" translate="no"><a name="beforeSynchronizing"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">beforeSynchronizing</span>()<a class="plink" href="#beforeSynchronizing" title="Direct link to this headline"></a></h3>
<p>This signal is emitted before the scene graph is synchronized with the QML state.</p>
<p>This signal can be used to do any preparation required before calls to <a href="./qquickitem.htm#updatePaintNode" translate="no">QQuickItem::updatePaintNode</a>().</p>
<p>The OpenGL context used for rendering the scene graph will be bound at this point.</p>
<div class="admonition warning">
<p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::ConnectionType</a>).</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Make very sure that a signal handler for beforeSynchronizing leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<!-- @@@beforeSynchronizing -->
<!-- $$$closing[overload1]$$$closingQQuickCloseEvent* -->
<h3 class="fn" id="closing" translate="no"><a name="closing"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">closing</span>(<span class="type">QQuickCloseEvent</span> *<i>close</i>)<a class="plink" href="#closing" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the window receives the event <i translate="no">close</i> from the windowing system.</p>
<p>On macOs, Qt will create a menu item <code translate="no">Quit</code> if there is no menu item whose text is "quit" or "exit". This menu item calls the <code translate="no">QCoreApplication::quit</code> signal, not the <code translate="no">QQuickWindow::closing()</code> signal.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qmenubar.htm#qmenubar-as-a-global-menu-bar" translate="no">QMenuBar as a Global Menu Bar</a>.</p>
<!-- @@@closing -->
<!-- $$$frameSwapped[overload1]$$$frameSwapped -->
<h3 class="fn" id="frameSwapped" translate="no"><a name="frameSwapped"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">frameSwapped</span>()<a class="plink" href="#frameSwapped" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when a frame has been queued for presenting. With vertical synchronization enabled the signal is emitted at most once per vsync interval in a continuously animating scene.</p>
<p>This signal will be emitted from the scene graph rendering thread.</p>
<!-- @@@frameSwapped -->
<!-- $$$openglContextCreated[overload1]$$$openglContextCreatedQOpenGLContext* -->
<h3 class="fn" id="openglContextCreated" translate="no"><a name="openglContextCreated"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">openglContextCreated</span>(<span class="type"><a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a></span> *<i>context</i>)<a class="plink" href="#openglContextCreated" title="Direct link to this headline"></a></h3>
<p>This signal is emitted on the GUI thread when the OpenGL <i translate="no">context</i> for this window is created, before it is made current.</p>
<p>Some implementations will share the same OpenGL context between multiple <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> instances. The openglContextCreated() signal will in this case only be emitted for the first window, when the OpenGL context is actually created.</p>
<p><a href="./qquickwindow.htm#openglContext" translate="no">QQuickWindow::openglContext</a>() will still return 0 for this window until after the <a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">QQuickWindow::sceneGraphInitialized</a>() has been emitted.</p>
<div class="admonition note">
<p><b>Note: </b>This signal will only be emmited when using the default OpenGL scene graph adaptation.</p>
</div>
<p>This function was introduced in Qt 5.3.</p>
<!-- @@@openglContextCreated -->
<!-- $$$releaseResources[overload1]$$$releaseResources -->
<h3 class="fn" id="releaseResources" translate="no"><a name="releaseResources"></a><code translate="no">[slot] </code><span class="type">void</span> QQuickWindow::<span class="name">releaseResources</span>()<a class="plink" href="#releaseResources" title="Direct link to this headline"></a></h3>
<p>This function tries to release redundant resources currently held by the QML scene.</p>
<p>Calling this function might result in the scene graph and the OpenGL context used for rendering being released to release graphics memory. If this happens, the <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>() signal will be called, allowing users to clean up their own graphics resources. The <a href="./qquickwindow.htm#setPersistentOpenGLContext" translate="no">setPersistentOpenGLContext</a>() and <a href="./qquickwindow.htm#setPersistentSceneGraph" translate="no">setPersistentSceneGraph</a>() functions can be used to prevent this from happening, if handling the cleanup is not feasible in the application, at the cost of higher memory usage.</p>
<p><b>See also </b><a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>(), <a href="./qquickwindow.htm#setPersistentOpenGLContext" translate="no">setPersistentOpenGLContext</a>(), and <a href="./qquickwindow.htm#setPersistentSceneGraph" translate="no">setPersistentSceneGraph</a>().</p>
<!-- @@@releaseResources -->
<!-- $$$sceneGraphAboutToStop[overload1]$$$sceneGraphAboutToStop -->
<h3 class="fn" id="sceneGraphAboutToStop" translate="no"><a name="sceneGraphAboutToStop"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphAboutToStop</span>()<a class="plink" href="#sceneGraphAboutToStop" title="Direct link to this headline"></a></h3>
<p>This signal is emitted on the render thread when the scene graph is about to stop rendering. This happens usually because the window has been hidden.</p>
<p>Applications may use this signal to release resources, but should be prepared to reinstantiated them again fast. The scene graph and the graphics context are not released at this time.</p>
<div class="admonition warning">
<p><b>Warning: </b>This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::ConnectionType</a>).</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>Make very sure that a signal handler for sceneGraphAboutToStop() leaves the graphics context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</p>
</div>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>() and <a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<!-- @@@sceneGraphAboutToStop -->
<!-- $$$sceneGraphError[overload1]$$$sceneGraphErrorQQuickWindow::SceneGraphErrorconstQString& -->
<h3 class="fn" id="sceneGraphError" translate="no"><a name="sceneGraphError"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphError</span>(<span class="type"><a href="./qquickwindow.htm#SceneGraphError-enum" translate="no">QQuickWindow::SceneGraphError</a></span> <i>error</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>message</i>)<a class="plink" href="#sceneGraphError" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when an <i translate="no">error</i> occurred during scene graph initialization.</p>
<p>Applications should connect to this signal if they wish to handle errors, like graphics context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the <i translate="no">message</i>, or show a message box, and terminate the application.</p>
<p>This signal will be emitted from the GUI thread.</p>
<p>This function was introduced in Qt 5.3.</p>
<!-- @@@sceneGraphError -->
<!-- $$$sceneGraphInitialized[overload1]$$$sceneGraphInitialized -->
<h3 class="fn" id="sceneGraphInitialized" translate="no"><a name="sceneGraphInitialized"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphInitialized</span>()<a class="plink" href="#sceneGraphInitialized" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the scene graph has been initialized.</p>
<p>This signal will be emitted from the scene graph rendering thread.</p>
<!-- @@@sceneGraphInitialized -->
<!-- $$$sceneGraphInvalidated[overload1]$$$sceneGraphInvalidated -->
<h3 class="fn" id="sceneGraphInvalidated" translate="no"><a name="sceneGraphInvalidated"></a><code translate="no">[signal] </code><span class="type">void</span> QQuickWindow::<span class="name">sceneGraphInvalidated</span>()<a class="plink" href="#sceneGraphInvalidated" title="Direct link to this headline"></a></h3>
<p>This signal is emitted when the scene graph has been invalidated.</p>
<p>This signal implies that the graphics rendering context used has been invalidated and all user resources tied to that context should be released.</p>
<p>In the case of the default OpenGL adaptation the context of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</p>
<p>This signal will be emitted from the scene graph rendering thread.</p>
<!-- @@@sceneGraphInvalidated -->
<!-- $$$update[overload1]$$$update -->
<h3 class="fn" id="update" translate="no"><a name="update"></a><code translate="no">[slot] </code><span class="type">void</span> QQuickWindow::<span class="name">update</span>()<a class="plink" href="#update" title="Direct link to this headline"></a></h3>
<p>Schedules the window to render another frame.</p>
<p>Calling QQuickWindow::update() differs from <a href="./qquickitem.htm#update" translate="no">QQuickItem::update</a>() in that it always triggers a repaint, regardless of changes in the underlying scene graph or not.</p>
<!-- @@@update -->
<!-- $$$~QQuickWindow[overload1]$$$~QQuickWindow -->
<h3 class="fn" id="dtor.QQuickWindow" translate="no"><a name="dtor.QQuickWindow"></a><code translate="no">[override virtual] </code>QQuickWindow::<span class="name">~QQuickWindow</span>()<a class="plink" href="#dtor.QQuickWindow" title="Direct link to this headline"></a></h3>
<p>Destroys the window.</p>
<!-- @@@~QQuickWindow -->
<!-- $$$accessibleRoot[overload1]$$$accessibleRoot -->
<h3 class="fn" id="accessibleRoot" translate="no"><a name="accessibleRoot"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qaccessibleinterface.htm" translate="no">QAccessibleInterface</a></span> *QQuickWindow::<span class="name">accessibleRoot</span>() const<a class="plink" href="#accessibleRoot" title="Direct link to this headline"></a></h3>
<p>Returns an accessibility interface for this window, or 0 if such an interface cannot be created.</p>
<!-- @@@accessibleRoot -->
<!-- $$$beginExternalCommands[overload1]$$$beginExternalCommands -->
<h3 class="fn" id="beginExternalCommands" translate="no"><a name="beginExternalCommands"></a><span class="type">void</span> QQuickWindow::<span class="name">beginExternalCommands</span>()<a class="plink" href="#beginExternalCommands" title="Direct link to this headline"></a></h3>
<p>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function before recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</p>
<p>In practice this function is often called from a slot connected to the <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">beforeRenderPassRecording</a>() or <a href="./qquickwindow.htm#afterRenderPassRecording" translate="no">afterRenderPassRecording</a>() signals.</p>
<p>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), beginExternalCommands() and <a href="./qquickwindow.htm#endExternalCommands" translate="no">endExternalCommands</a>() together provide a replacement for <a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<p>Calling this function and <a href="./qquickwindow.htm#endExternalCommands" translate="no">endExternalCommands</a>() is not necessary within the <a href="./qsgrendernode.htm#render" translate="no">render()</a> implementation of a <a href="./qsgrendernode.htm" translate="no">QSGRenderNode</a> because the scene graph performs the necessary steps implicitly for render nodes.</p>
<p>Native graphics objects (such as, graphics device, command buffer or encoder) are accessible via <a href="./qsgrendererinterface.htm#getResource" translate="no">QSGRendererInterface::getResource</a>().</p>
<div class="admonition warning">
<p><b>Warning: </b>Watch out for the fact that <a href="./qsgrendererinterface.htm#Resource-enum" translate="no">QSGRendererInterface::CommandListResource</a> may return a different object between beginExternalCommands() - <a href="./qquickwindow.htm#endExternalCommands" translate="no">endExternalCommands</a>(). This can happen when the underlying implementation provides a dedicated secondary command buffer for recording external graphics commands within a render pass. Therefore, always query CommandListResource after calling this function. Do not attempt to reuse an object from an earlier query.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function has no effect when the scene graph is using OpenGL directly and the RHI graphics abstraction layer is not in use. Refer to <a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>() in that case.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When the scenegraph is using the RHI graphics abstraction layer with the OpenGL backend underneath, pay attention to the fact that the OpenGL state in the context can have arbitrary settings, and this function does not perform any resetting of the state back to defaults. Call <a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>() if that is seen necessary.</p>
</div>
<p>This function was introduced in Qt 5.14.</p>
<p><b>See also </b><a href="./qquickwindow.htm#endExternalCommands" translate="no">endExternalCommands</a>() and <a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<!-- @@@beginExternalCommands -->
<!-- $$$clearBeforeRendering[overload1]$$$clearBeforeRendering -->
<h3 class="fn" id="clearBeforeRendering" translate="no"><a name="clearBeforeRendering"></a><span class="type">bool</span> QQuickWindow::<span class="name">clearBeforeRendering</span>() const<a class="plink" href="#clearBeforeRendering" title="Direct link to this headline"></a></h3>
<p>Returns whether clearing of the color buffer is done before rendering or not.</p>
<p><b>See also </b><a href="./qquickwindow.htm#setClearBeforeRendering" translate="no">setClearBeforeRendering</a>().</p>
<!-- @@@clearBeforeRendering -->
<!-- $$$createImageNode[overload1]$$$createImageNode -->
<h3 class="fn" id="createImageNode" translate="no"><a name="createImageNode"></a><span class="type"><a href="./qsgimagenode.htm" translate="no">QSGImageNode</a></span> *QQuickWindow::<span class="name">createImageNode</span>() const<a class="plink" href="#createImageNode" title="Direct link to this headline"></a></h3>
<p>Creates a simple image node. When the scenegraph is not initialized, the return value is null.</p>
<p>This is cross-backend alternative to constructing a QSGSimpleTextureNode directly.</p>
<p>This function was introduced in Qt 5.8.</p>
<p><b>See also </b><a href="./qsgimagenode.htm" translate="no">QSGImageNode</a>.</p>
<!-- @@@createImageNode -->
<!-- $$$createNinePatchNode[overload1]$$$createNinePatchNode -->
<h3 class="fn" id="createNinePatchNode" translate="no"><a name="createNinePatchNode"></a><span class="type">QSGNinePatchNode</span> *QQuickWindow::<span class="name">createNinePatchNode</span>() const<a class="plink" href="#createNinePatchNode" title="Direct link to this headline"></a></h3>
<p>Creates a nine patch node. When the scenegraph is not initialized, the return value is null.</p>
<p>This function was introduced in Qt 5.8.</p>
<!-- @@@createNinePatchNode -->
<!-- $$$createRectangleNode[overload1]$$$createRectangleNode -->
<h3 class="fn" id="createRectangleNode" translate="no"><a name="createRectangleNode"></a><span class="type"><a href="./qsgrectanglenode.htm" translate="no">QSGRectangleNode</a></span> *QQuickWindow::<span class="name">createRectangleNode</span>() const<a class="plink" href="#createRectangleNode" title="Direct link to this headline"></a></h3>
<p>Creates a simple rectangle node. When the scenegraph is not initialized, the return value is null.</p>
<p>This is cross-backend alternative to constructing a QSGSimpleRectNode directly.</p>
<p>This function was introduced in Qt 5.8.</p>
<p><b>See also </b><a href="./qsgrectanglenode.htm" translate="no">QSGRectangleNode</a>.</p>
<!-- @@@createRectangleNode -->
<!-- $$$createTextureFromImage[overload1]$$$createTextureFromImageconstQImage&QQuickWindow::CreateTextureOptions -->
<h3 class="fn" id="createTextureFromImage" translate="no"><a name="createTextureFromImage"></a><span class="type"><a href="./qsgtexture.htm" translate="no">QSGTexture</a></span> *QQuickWindow::<span class="name">createTextureFromImage</span>(const <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type"><a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">QQuickWindow::CreateTextureOptions</a></span> <i>options</i>) const<a class="plink" href="#createTextureFromImage" title="Direct link to this headline"></a></h3>
<p>Creates a new <a href="./qsgtexture.htm" translate="no">QSGTexture</a> from the supplied <i translate="no">image</i>. If the image has an alpha channel, the corresponding texture will have an alpha channel.</p>
<p>The caller of the function is responsible for deleting the returned texture. For example whe using the OpenGL adaptation the actual OpenGL texture will be deleted when the texture object is deleted.</p>
<p>When <i translate="no">options</i> contains <a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">TextureCanUseAtlas</a>, the engine may put the image into a texture atlas. Textures in an atlas need to rely on <a href="./qsgtexture.htm#normalizedTextureSubRect" translate="no">QSGTexture::normalizedTextureSubRect</a>() for their geometry and will not support <a href="./qsgtexture.htm#WrapMode-enum" translate="no">QSGTexture::Repeat</a>. Other values from <a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">CreateTextureOption</a> are ignored.</p>
<p>When <i translate="no">options</i> contains <a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">TextureIsOpaque</a>, the engine will create an RGB texture which returns false for <a href="./qsgtexture.htm#hasAlphaChannel" translate="no">QSGTexture::hasAlphaChannel</a>(). Opaque textures will in most cases be faster to render. When this flag is not set, the texture will have an alpha channel based on the image's format.</p>
<p>When <i translate="no">options</i> contains <a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">TextureHasMipmaps</a>, the engine will create a texture which can use mipmap filtering. Mipmapped textures can not be in an atlas.</p>
<p>When using the OpenGL adaptation, the returned texture will be using <code translate="no">GL_TEXTURE_2D</code> as texture target and <code translate="no">GL_RGBA</code> as internal format. Reimplement <a href="./qsgtexture.htm" translate="no">QSGTexture</a> to create textures with different parameters.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function will return 0 if the scene graph has not yet been initialized.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>The returned texture is not memory managed by the scene graph and must be explicitly deleted by the caller on the rendering thread. This is achieved by deleting the texture from a <a href="./qsgnode.htm" translate="no">QSGNode</a> destructor or by using <a href="./qobject.htm#deleteLater" translate="no">deleteLater</a>() in the case where the texture already has affinity to the rendering thread.</p>
</div>
<p>This function can be called from any thread.</p>
<p><b>See also </b><a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">sceneGraphInitialized</a>() and <a href="./qsgtexture.htm" translate="no">QSGTexture</a>.</p>
<!-- @@@createTextureFromImage -->
<!-- $$$createTextureFromImage$$$createTextureFromImageconstQImage& -->
<h3 class="fn" id="createTextureFromImage-1" translate="no"><a name="createTextureFromImage-1"></a><span class="type"><a href="./qsgtexture.htm" translate="no">QSGTexture</a></span> *QQuickWindow::<span class="name">createTextureFromImage</span>(const <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> &amp;<i>image</i>) const<a class="plink" href="#createTextureFromImage-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@createTextureFromImage -->
<!-- $$$createTextureFromNativeObject[overload1]$$$createTextureFromNativeObjectQQuickWindow::NativeObjectTypeconstvoid*intconstQSize&QQuickWindow::CreateTextureOptions -->
<h3 class="fn" id="createTextureFromNativeObject" translate="no"><a name="createTextureFromNativeObject"></a><span class="type"><a href="./qsgtexture.htm" translate="no">QSGTexture</a></span> *QQuickWindow::<span class="name">createTextureFromNativeObject</span>(<span class="type"><a href="./qquickwindow.htm#NativeObjectType-enum" translate="no">QQuickWindow::NativeObjectType</a></span> <i>type</i>, const <span class="type">void</span> *<i>nativeObjectPtr</i>, <span class="type">int</span> <i>nativeLayout</i>, const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>, <span class="type"><a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">QQuickWindow::CreateTextureOptions</a></span> <i>options</i> = CreateTextureOption()) const<a class="plink" href="#createTextureFromNativeObject" title="Direct link to this headline"></a></h3>
<p>Creates a new <a href="./qsgtexture.htm" translate="no">QSGTexture</a> object from an existing native object.</p>
<p>The native object is wrapped, but not owned, by the resulting <a href="./qsgtexture.htm" translate="no">QSGTexture</a>. The caller of the function is responsible for deleting the returned <a href="./qsgtexture.htm" translate="no">QSGTexture</a>, but that will not destroy the underlying native object.</p>
<p><i translate="no">type</i> specifies the type of the object. In practice the type is <a href="./qquickwindow.htm#NativeObjectType-enum" translate="no">NativeObjectTexture</a>, indicating that the native object is a texture or image of the underlying graphics API. Other types may be introduced in the future.</p>
<p>This function is currently suitable for 2D RGBA textures only.</p>
<p>Unlike createTextureFromId(), this function supports both direct OpenGL usage and the RHI abstracted rendering path.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function will return null if the scenegraph has not yet been initialized.</p>
</div>
<p>Use <i translate="no">options</i> to customize the texture attributes. Only the <a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">TextureHasAlphaChannel</a> and <a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">TextureHasMipmaps</a> are taken into account here.</p>
<div class="admonition warning">
<p><b>Warning: </b>Unlike createTextureFromId(), this function never takes ownership of the native object, and the <a href="./qquickwindow.htm#CreateTextureOption-enum" translate="no">TextureOwnsGLTexture</a> flag is ignored.</p>
</div>
<p><i translate="no">size</i> specifies the size in pixels.</p>
<p><i translate="no">nativeObjectPtr</i> is a pointer to the native object handle. With OpenGL, the native handle is a GLuint value, so <i translate="no">nativeObjectPtr</i> is then a pointer to a GLuint. With Vulkan, the native handle is a VkImage, so <i translate="no">nativeObjectPtr</i> is a pointer to a VkImage. With Direct3D 11 and Metal <i translate="no">nativeObjectPtr</i> is a pointer to a ID3D11Texture2D or MTLTexture pointer.</p>
<div class="admonition note">
<p><b>Note: </b>Pay attention to the fact that <i translate="no">nativeObjectPtr</i> is always a pointer to the native texture handle type, even if the native type itself is a pointer.</p>
</div>
<p><i translate="no">nativeLayout</i> is only used for APIs like Vulkan. When applicable, it must specify the current image layout, such as, a VkImageLayout value.</p>
<p>This function was introduced in Qt 5.14.</p>
<p><b>See also </b><a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">sceneGraphInitialized</a>(), <a href="./qsgtexture.htm" translate="no">QSGTexture</a>, and <a href="./qsgtexture.htm#nativeTexture" translate="no">QSGTexture::nativeTexture</a>().</p>
<!-- @@@createTextureFromNativeObject -->
<!-- $$$effectiveDevicePixelRatio[overload1]$$$effectiveDevicePixelRatio -->
<h3 class="fn" id="effectiveDevicePixelRatio" translate="no"><a name="effectiveDevicePixelRatio"></a><span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> QQuickWindow::<span class="name">effectiveDevicePixelRatio</span>() const<a class="plink" href="#effectiveDevicePixelRatio" title="Direct link to this headline"></a></h3>
<p>Returns the device pixel ratio for this window.</p>
<p>This is different from <a href="./qwindow.htm#devicePixelRatio" translate="no">QWindow::devicePixelRatio</a>() in that it supports redirected rendering via <a href="./qquickrendercontrol.htm" translate="no">QQuickRenderControl</a>. When using a <a href="./qquickrendercontrol.htm" translate="no">QQuickRenderControl</a>, the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> is often not created, meaning it is never shown and there is no underlying native window created in the windowing system. As a result, querying properties like the device pixel ratio cannot give correct results. Use this function instead.</p>
<p><b>See also </b><a href="./qwindow.htm#devicePixelRatio" translate="no">QWindow::devicePixelRatio</a>().</p>
<!-- @@@effectiveDevicePixelRatio -->
<!-- $$$endExternalCommands[overload1]$$$endExternalCommands -->
<h3 class="fn" id="endExternalCommands" translate="no"><a name="endExternalCommands"></a><span class="type">void</span> QQuickWindow::<span class="name">endExternalCommands</span>()<a class="plink" href="#endExternalCommands" title="Direct link to this headline"></a></h3>
<p>When mixing raw graphics (OpenGL, Vulkan, Metal, etc.) commands with scene graph rendering, it is necessary to call this function after recording commands to the command buffer used by the scene graph to render its main render pass. This is to avoid clobbering state.</p>
<p>In practice this function is often called from a slot connected to the <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">beforeRenderPassRecording</a>() or <a href="./qquickwindow.htm#afterRenderPassRecording" translate="no">afterRenderPassRecording</a>() signals.</p>
<p>The function does not need to be called when recording commands to the application's own command buffer (such as, a VkCommandBuffer or MTLCommandBuffer + MTLRenderCommandEncoder created and managed by the application, not retrieved from the scene graph). With graphics APIs where no native command buffer concept is exposed (OpenGL, Direct 3D 11), <a href="./qquickwindow.htm#beginExternalCommands" translate="no">beginExternalCommands</a>() and endExternalCommands() together provide a replacement for <a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>().</p>
<p>Calling this function and <a href="./qquickwindow.htm#beginExternalCommands" translate="no">beginExternalCommands</a>() is not necessary within the <a href="./qsgrendernode.htm#render" translate="no">render()</a> implementation of a <a href="./qsgrendernode.htm" translate="no">QSGRenderNode</a> because the scene graph performs the necessary steps implicitly for render nodes.</p>
<div class="admonition note">
<p><b>Note: </b>This function has no effect when the scene graph is using OpenGL directly and the RHI graphics abstraction layer is not in use. Refer to <a href="./qquickwindow.htm#resetOpenGLState" translate="no">resetOpenGLState</a>() in that case.</p>
</div>
<p>This function was introduced in Qt 5.14.</p>
<p><b>See also </b><a href="./qquickwindow.htm#beginExternalCommands" translate="no">beginExternalCommands</a>().</p>
<!-- @@@endExternalCommands -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event" translate="no"><a name="event"></a><code translate="no">[override virtual protected] </code><span class="type">bool</span> QQuickWindow::<span class="name">event</span>(<span class="type"><a href="./qevent.htm" translate="no">QEvent</a></span> *<i>e</i>)<a class="plink" href="#event" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#event" translate="no">QWindow::event</a>(QEvent *ev).</p>
<!-- @@@event -->
<!-- $$$exposeEvent[overload1]$$$exposeEventQExposeEvent* -->
<h3 class="fn" id="exposeEvent" translate="no"><a name="exposeEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">exposeEvent</span>(<i>QExposeEvent *</i>)<a class="plink" href="#exposeEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#exposeEvent" translate="no">QWindow::exposeEvent</a>(QExposeEvent *ev).</p>
<!-- @@@exposeEvent -->
<!-- $$$focusInEvent[overload1]$$$focusInEventQFocusEvent* -->
<h3 class="fn" id="focusInEvent" translate="no"><a name="focusInEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">focusInEvent</span>(<span class="type"><a href="./qfocusevent.htm" translate="no">QFocusEvent</a></span> *<i>ev</i>)<a class="plink" href="#focusInEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#focusInEvent" translate="no">QWindow::focusInEvent</a>(QFocusEvent *ev).</p>
<!-- @@@focusInEvent -->
<!-- $$$focusOutEvent[overload1]$$$focusOutEventQFocusEvent* -->
<h3 class="fn" id="focusOutEvent" translate="no"><a name="focusOutEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">focusOutEvent</span>(<span class="type"><a href="./qfocusevent.htm" translate="no">QFocusEvent</a></span> *<i>ev</i>)<a class="plink" href="#focusOutEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#focusOutEvent" translate="no">QWindow::focusOutEvent</a>(QFocusEvent *ev).</p>
<!-- @@@focusOutEvent -->
<!-- $$$grabWindow[overload1]$$$grabWindow -->
<h3 class="fn" id="grabWindow" translate="no"><a name="grabWindow"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QQuickWindow::<span class="name">grabWindow</span>()<a class="plink" href="#grabWindow" title="Direct link to this headline"></a></h3>
<p>Grabs the contents of the window and returns it as an image.</p>
<p>It is possible to call the grabWindow() function when the window is not visible. This requires that the window is <a href="./qwindow.htm#create" translate="no">created</a> and has a valid size and that no other <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> instances are rendering in the same process.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function will cause performance problems.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the GUI thread.</p>
</div>
<!-- @@@grabWindow -->
<!-- $$$graphicsStateInfo[overload1]$$$graphicsStateInfo -->
<h3 class="fn" id="graphicsStateInfo" translate="no"><a name="graphicsStateInfo"></a>const <span class="type"><a href="./qquickwindow-graphicsstateinfo.htm" translate="no">QQuickWindow::GraphicsStateInfo</a></span> &amp;QQuickWindow::<span class="name">graphicsStateInfo</span>()<a class="plink" href="#graphicsStateInfo" title="Direct link to this headline"></a></h3>
<p>Returns a reference to a <a href="./qquickwindow-graphicsstateinfo.htm" translate="no">GraphicsStateInfo</a> struct describing some of the RHI's internal state, in particular, the double or tripple buffering status of the backend (such as, the Vulkan or Metal integrations). This is relevant when the underlying graphics APIs is Vulkan or Metal, and the external rendering code wishes to perform double or tripple buffering of its own often-changing resources, such as, uniform buffers, in order to avoid stalling the pipeline.</p>
<!-- @@@graphicsStateInfo -->
<!-- $$$hasDefaultAlphaBuffer[overload1]$$$hasDefaultAlphaBuffer -->
<h3 class="fn" id="hasDefaultAlphaBuffer" translate="no"><a name="hasDefaultAlphaBuffer"></a><code translate="no">[static] </code><span class="type">bool</span> QQuickWindow::<span class="name">hasDefaultAlphaBuffer</span>()<a class="plink" href="#hasDefaultAlphaBuffer" title="Direct link to this headline"></a></h3>
<p>Returns whether to use alpha transparency on newly created windows.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qquickwindow.htm#setDefaultAlphaBuffer" translate="no">setDefaultAlphaBuffer</a>().</p>
<!-- @@@hasDefaultAlphaBuffer -->
<!-- $$$hideEvent[overload1]$$$hideEventQHideEvent* -->
<h3 class="fn" id="hideEvent" translate="no"><a name="hideEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">hideEvent</span>(<i>QHideEvent *</i>)<a class="plink" href="#hideEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#hideEvent" translate="no">QWindow::hideEvent</a>(QHideEvent *ev).</p>
<!-- @@@hideEvent -->
<!-- $$$incubationController[overload1]$$$incubationController -->
<h3 class="fn" id="incubationController" translate="no"><a name="incubationController"></a><span class="type"><a href="./qqmlincubationcontroller.htm" translate="no">QQmlIncubationController</a></span> *QQuickWindow::<span class="name">incubationController</span>() const<a class="plink" href="#incubationController" title="Direct link to this headline"></a></h3>
<p>Returns an incubation controller that splices incubation between frames for this window. <a href="./qquickview.htm" translate="no">QQuickView</a> automatically installs this controller for you, otherwise you will need to install it yourself using <a href="./qqmlengine.htm#setIncubationController" translate="no">QQmlEngine::setIncubationController</a>().</p>
<p>The controller is owned by the window and will be destroyed when the window is deleted.</p>
<!-- @@@incubationController -->
<!-- $$$isPersistentOpenGLContext[overload1]$$$isPersistentOpenGLContext -->
<h3 class="fn" id="isPersistentOpenGLContext" translate="no"><a name="isPersistentOpenGLContext"></a><span class="type">bool</span> QQuickWindow::<span class="name">isPersistentOpenGLContext</span>() const<a class="plink" href="#isPersistentOpenGLContext" title="Direct link to this headline"></a></h3>
<p>Returns whether the OpenGL context can be released during the lifetime of the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This is a hint. When and how this happens is implementation specific. It also only has an effect when using the default OpenGL scene graph adaptation</p>
</div>
<!-- @@@isPersistentOpenGLContext -->
<!-- $$$isPersistentSceneGraph[overload1]$$$isPersistentSceneGraph -->
<h3 class="fn" id="isPersistentSceneGraph" translate="no"><a name="isPersistentSceneGraph"></a><span class="type">bool</span> QQuickWindow::<span class="name">isPersistentSceneGraph</span>() const<a class="plink" href="#isPersistentSceneGraph" title="Direct link to this headline"></a></h3>
<p>Returns whether the scene graph nodes and resources can be released during the lifetime of this <a href="./qquickwindow.htm" translate="no">QQuickWindow</a>.</p>
<div class="admonition note">
<p><b>Note: </b>This is a hint. When and how this happens is implementation specific.</p>
</div>
<!-- @@@isPersistentSceneGraph -->
<!-- $$$isSceneGraphInitialized[overload1]$$$isSceneGraphInitialized -->
<h3 class="fn" id="isSceneGraphInitialized" translate="no"><a name="isSceneGraphInitialized"></a><span class="type">bool</span> QQuickWindow::<span class="name">isSceneGraphInitialized</span>() const<a class="plink" href="#isSceneGraphInitialized" title="Direct link to this headline"></a></h3>
<p>Returns true if the scene graph has been initialized; otherwise returns false.</p>
<!-- @@@isSceneGraphInitialized -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" id="keyPressEvent" translate="no"><a name="keyPressEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">keyPressEvent</span>(<span class="type"><a href="./qkeyevent.htm" translate="no">QKeyEvent</a></span> *<i>e</i>)<a class="plink" href="#keyPressEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#keyPressEvent" translate="no">QWindow::keyPressEvent</a>(QKeyEvent *ev).</p>
<!-- @@@keyPressEvent -->
<!-- $$$keyReleaseEvent[overload1]$$$keyReleaseEventQKeyEvent* -->
<h3 class="fn" id="keyReleaseEvent" translate="no"><a name="keyReleaseEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="./qkeyevent.htm" translate="no">QKeyEvent</a></span> *<i>e</i>)<a class="plink" href="#keyReleaseEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#keyReleaseEvent" translate="no">QWindow::keyReleaseEvent</a>(QKeyEvent *ev).</p>
<!-- @@@keyReleaseEvent -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" id="mouseDoubleClickEvent" translate="no"><a name="mouseDoubleClickEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> *<i>event</i>)<a class="plink" href="#mouseDoubleClickEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#mouseDoubleClickEvent" translate="no">QWindow::mouseDoubleClickEvent</a>(QMouseEvent *ev).</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseGrabberItem[overload1]$$$mouseGrabberItem -->
<h3 class="fn" id="mouseGrabberItem" translate="no"><a name="mouseGrabberItem"></a><span class="type"><a href="./qquickitem.htm" translate="no">QQuickItem</a></span> *QQuickWindow::<span class="name">mouseGrabberItem</span>() const<a class="plink" href="#mouseGrabberItem" title="Direct link to this headline"></a></h3>
<p>Returns the item which currently has the mouse grab.</p>
<!-- @@@mouseGrabberItem -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" id="mouseMoveEvent" translate="no"><a name="mouseMoveEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> *<i>event</i>)<a class="plink" href="#mouseMoveEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#mouseMoveEvent" translate="no">QWindow::mouseMoveEvent</a>(QMouseEvent *ev).</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" id="mousePressEvent" translate="no"><a name="mousePressEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mousePressEvent</span>(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> *<i>event</i>)<a class="plink" href="#mousePressEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#mousePressEvent" translate="no">QWindow::mousePressEvent</a>(QMouseEvent *ev).</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" id="mouseReleaseEvent" translate="no"><a name="mouseReleaseEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="./qmouseevent.htm" translate="no">QMouseEvent</a></span> *<i>event</i>)<a class="plink" href="#mouseReleaseEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#mouseReleaseEvent" translate="no">QWindow::mouseReleaseEvent</a>(QMouseEvent *ev).</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$openglContext[overload1]$$$openglContext -->
<h3 class="fn" id="openglContext" translate="no"><a name="openglContext"></a><span class="type"><a href="./qopenglcontext.htm" translate="no">QOpenGLContext</a></span> *QQuickWindow::<span class="name">openglContext</span>() const<a class="plink" href="#openglContext" title="Direct link to this headline"></a></h3>
<p>Returns the OpenGL context used for rendering.</p>
<div class="admonition note">
<p><b>Note: </b>If the scene graph is not ready, or the scene graph is not using OpenGL (or RHI over OpenGL), this function will return null.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">sceneGraphInitialized</a>() and <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>().</p>
<!-- @@@openglContext -->
<!-- $$$renderTarget[overload1]$$$renderTarget -->
<h3 class="fn" id="renderTarget" translate="no"><a name="renderTarget"></a><span class="type"><a href="./qopenglframebufferobject.htm" translate="no">QOpenGLFramebufferObject</a></span> *QQuickWindow::<span class="name">renderTarget</span>() const<a class="plink" href="#renderTarget" title="Direct link to this headline"></a></h3>
<p>Returns the render target for this window.</p>
<p>The default is to render to the surface of the window, in which case the render target is 0.</p>
<div class="admonition note">
<p><b>Note: </b>This function will return nullptr when not using the OpenGL scene graph adaptation.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function has no effect and returns nullptr when running on the RHI graphics abstraction.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#setRenderTarget" translate="no">setRenderTarget</a>().</p>
<!-- @@@renderTarget -->
<!-- $$$renderTargetId[overload1]$$$renderTargetId -->
<h3 class="fn" id="renderTargetId" translate="no"><a name="renderTargetId"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> QQuickWindow::<span class="name">renderTargetId</span>() const<a class="plink" href="#renderTargetId" title="Direct link to this headline"></a></h3>
<p>Returns the FBO id of the render target when set; otherwise returns 0.</p>
<!-- @@@renderTargetId -->
<!-- $$$renderTargetSize[overload1]$$$renderTargetSize -->
<h3 class="fn" id="renderTargetSize" translate="no"><a name="renderTargetSize"></a><span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> QQuickWindow::<span class="name">renderTargetSize</span>() const<a class="plink" href="#renderTargetSize" title="Direct link to this headline"></a></h3>
<p>Returns the size of the currently set render target; otherwise returns an empty size.</p>
<!-- @@@renderTargetSize -->
<!-- $$$rendererInterface[overload1]$$$rendererInterface -->
<h3 class="fn" id="rendererInterface" translate="no"><a name="rendererInterface"></a><span class="type"><a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a></span> *QQuickWindow::<span class="name">rendererInterface</span>() const<a class="plink" href="#rendererInterface" title="Direct link to this headline"></a></h3>
<p>Returns the current renderer interface. The value is always valid and is never null.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called at any time after constructing the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a>, even while <a href="./qquickwindow.htm#isSceneGraphInitialized" translate="no">isSceneGraphInitialized</a>() is still false. However, some renderer interface functions, in particular <a href="./qsgrendererinterface.htm#getResource" translate="no">QSGRendererInterface::getResource</a>() will not be functional until the scenegraph is up and running. Backend queries, like <a href="./qsgrendererinterface.htm#graphicsApi" translate="no">QSGRendererInterface::graphicsApi</a>() or <a href="./qsgrendererinterface.htm#shaderType" translate="no">QSGRendererInterface::shaderType</a>(), will always be functional on the other hand.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The ownership of the returned pointer stays with Qt. The returned instance may or may not be shared between different <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> instances, depending on the scenegraph backend in use. Therefore applications are expected to query the interface object for each <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> instead of reusing the already queried pointer.</p>
</div>
<p>This function was introduced in Qt 5.8.</p>
<p><b>See also </b><a href="./qsgrendernode.htm" translate="no">QSGRenderNode</a> and <a href="./qsgrendererinterface.htm" translate="no">QSGRendererInterface</a>.</p>
<!-- @@@rendererInterface -->
<!-- $$$resetOpenGLState[overload1]$$$resetOpenGLState -->
<h3 class="fn" id="resetOpenGLState" translate="no"><a name="resetOpenGLState"></a><span class="type">void</span> QQuickWindow::<span class="name">resetOpenGLState</span>()<a class="plink" href="#resetOpenGLState" title="Direct link to this headline"></a></h3>
<p>Call this function to reset the OpenGL context its default state.</p>
<p>The scene graph uses the OpenGL context and will both rely on and clobber its state. When mixing raw OpenGL commands with scene graph rendering, this function provides a convenient way of resetting the OpenGL context state back to its default values.</p>
<p>This function does not touch state in the fixed-function pipeline.</p>
<p>This function does not clear the color, depth and stencil buffers. Use <a href="./qquickwindow.htm#setClearBeforeRendering" translate="no">QQuickWindow::setClearBeforeRendering</a> to control clearing of the color buffer. The depth and stencil buffer might be clobbered by the scene graph renderer. Clear these manually on demand.</p>
<div class="admonition note">
<p><b>Note: </b>This function only has an effect when using the default OpenGL scene graph adaptation.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function will only reset the OpenGL context in relation to what has been changed internally as part of the OpenGL scene graph. It does not reset anything that has been changed externally such as direct OpenGL calls done inside the application code if those same calls are not used internally.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function has no effect when running on the RHI graphics abstraction and the underlying RHI backend is not OpenGL.</p>
</div>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qquickwindow.htm#beforeRendering" translate="no">QQuickWindow::beforeRendering</a>(), <a href="./qquickwindow.htm#beginExternalCommands" translate="no">beginExternalCommands</a>(), and <a href="./qquickwindow.htm#endExternalCommands" translate="no">endExternalCommands</a>().</p>
<!-- @@@resetOpenGLState -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" id="resizeEvent" translate="no"><a name="resizeEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">resizeEvent</span>(<span class="type"><a href="./qresizeevent.htm" translate="no">QResizeEvent</a></span> *<i>ev</i>)<a class="plink" href="#resizeEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#resizeEvent" translate="no">QWindow::resizeEvent</a>(QResizeEvent *ev).</p>
<!-- @@@resizeEvent -->
<!-- $$$sceneGraphBackend[overload1]$$$sceneGraphBackend -->
<h3 class="fn" id="sceneGraphBackend" translate="no"><a name="sceneGraphBackend"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QQuickWindow::<span class="name">sceneGraphBackend</span>()<a class="plink" href="#sceneGraphBackend" title="Direct link to this headline"></a></h3>
<p>Returns the requested Qt Quick scenegraph backend.</p>
<div class="admonition note">
<p><b>Note: </b>The return value of this function may still be outdated by subsequent calls to <a href="./qquickwindow.htm#setSceneGraphBackend" translate="no">setSceneGraphBackend</a>() until the first <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> in the application has been constructed.</p>
</div>
<p>This function was introduced in Qt 5.9.</p>
<p><b>See also </b><a href="./qquickwindow.htm#setSceneGraphBackend" translate="no">setSceneGraphBackend</a>().</p>
<!-- @@@sceneGraphBackend -->
<!-- $$$scheduleRenderJob[overload1]$$$scheduleRenderJobQRunnable*QQuickWindow::RenderStage -->
<h3 class="fn" id="scheduleRenderJob" translate="no"><a name="scheduleRenderJob"></a><span class="type">void</span> QQuickWindow::<span class="name">scheduleRenderJob</span>(<span class="type"><a href="./qrunnable.htm" translate="no">QRunnable</a></span> *<i>job</i>, <span class="type"><a href="./qquickwindow.htm#RenderStage-enum" translate="no">QQuickWindow::RenderStage</a></span> <i>stage</i>)<a class="plink" href="#scheduleRenderJob" title="Direct link to this headline"></a></h3>
<p>Schedules <i translate="no">job</i> to run when the rendering of this window reaches the given <i translate="no">stage</i>.</p>
<p>This is a convenience to the equivalent signals in <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> for "one shot" tasks.</p>
<p>The window takes ownership over <i translate="no">job</i> and will delete it when the job is completed.</p>
<p>If rendering is shut down before <i translate="no">job</i> has a chance to run, the job will be run and then deleted as part of the scene graph cleanup. If the window is never shown and no rendering happens before the <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> is destroyed, all pending jobs will be destroyed without their run() method being called.</p>
<p>If the rendering is happening on a different thread, then the job will happen on the rendering thread.</p>
<p>If <i translate="no">stage</i> is <a href="./qquickwindow.htm#RenderStage-enum" translate="no">NoStage</a>, <i translate="no">job</i> will be run at the earliest opportunity whenever the render thread is not busy rendering a frame. If there is no OpenGL context available or the window is not exposed at the time the job is either posted or handled, it is deleted without executing the run() method. If a non-threaded renderer is in use, the run() method of the job is executed synchronously. The OpenGL context is changed to the renderer context before executing a <a href="./qquickwindow.htm#RenderStage-enum" translate="no">NoStage</a> job.</p>
<div class="admonition note">
<p><b>Note: </b>This function does not trigger rendering; the jobs targeting any other stage than <a href="./qquickwindow.htm#RenderStage-enum" translate="no">NoStage</a> will be stored run until rendering is triggered elsewhere. To force the job to run earlier, call <a href="./qquickwindow.htm#update" translate="no">QQuickWindow::update</a>();</p>
</div>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a>(), <a href="./qquickwindow.htm#afterRendering" translate="no">afterRendering</a>(), <a href="./qquickwindow.htm#beforeSynchronizing" translate="no">beforeSynchronizing</a>(), <a href="./qquickwindow.htm#afterSynchronizing" translate="no">afterSynchronizing</a>(), <a href="./qquickwindow.htm#frameSwapped" translate="no">frameSwapped</a>(), and <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>().</p>
<!-- @@@scheduleRenderJob -->
<!-- $$$setClearBeforeRendering[overload1]$$$setClearBeforeRenderingbool -->
<h3 class="fn" id="setClearBeforeRendering" translate="no"><a name="setClearBeforeRendering"></a><span class="type">void</span> QQuickWindow::<span class="name">setClearBeforeRendering</span>(<span class="type">bool</span> <i>enabled</i>)<a class="plink" href="#setClearBeforeRendering" title="Direct link to this headline"></a></h3>
<p>Sets whether the scene graph rendering of QML should clear the color buffer before it starts rendering to <i translate="no">enabled</i>.</p>
<p>By disabling clearing of the color buffer, it is possible to render OpengGL content under the scene graph.</p>
<p>The color buffer is cleared by default.</p>
<div class="admonition warning">
<p><b>Warning: </b>This flag is ignored completely when running with the RHI graphics abstraction instead of using OpenGL directly. As explicit clear commands simply do not exist in some modern APIs, the scene graph cannot offer this flexibility anymore. The images associated with a render target will always get cleared when a render pass starts. As a solution, an alternative to disabling scene graph issued clears is provided in form of the <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">beforeRenderPassRecording</a>() signal.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#clearBeforeRendering" translate="no">clearBeforeRendering</a>(), <a href="./qquickwindow.htm#beforeRendering" translate="no">beforeRendering</a>(), and <a href="./qquickwindow.htm#beforeRenderPassRecording" translate="no">beforeRenderPassRecording</a>().</p>
<!-- @@@setClearBeforeRendering -->
<!-- $$$setDefaultAlphaBuffer[overload1]$$$setDefaultAlphaBufferbool -->
<h3 class="fn" id="setDefaultAlphaBuffer" translate="no"><a name="setDefaultAlphaBuffer"></a><code translate="no">[static] </code><span class="type">void</span> QQuickWindow::<span class="name">setDefaultAlphaBuffer</span>(<span class="type">bool</span> <i>useAlpha</i>)<a class="plink" href="#setDefaultAlphaBuffer" title="Direct link to this headline"></a></h3>
<p><i translate="no">useAlpha</i> specifies whether to use alpha transparency on newly created windows.</p>
<p>In any application which expects to create translucent windows, it's necessary to set this to true before creating the first <a href="./qquickwindow.htm" translate="no">QQuickWindow</a>. The default value is false.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qquickwindow.htm#hasDefaultAlphaBuffer" translate="no">hasDefaultAlphaBuffer</a>().</p>
<!-- @@@setDefaultAlphaBuffer -->
<!-- $$$setPersistentOpenGLContext[overload1]$$$setPersistentOpenGLContextbool -->
<h3 class="fn" id="setPersistentOpenGLContext" translate="no"><a name="setPersistentOpenGLContext"></a><span class="type">void</span> QQuickWindow::<span class="name">setPersistentOpenGLContext</span>(<span class="type">bool</span> <i>persistent</i>)<a class="plink" href="#setPersistentOpenGLContext" title="Direct link to this headline"></a></h3>
<p>Sets whether the OpenGL context should be preserved, and cannot be released until the last window is deleted, to <i translate="no">persistent</i>. The default value is true.</p>
<p>The OpenGL context can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</p>
<p>The <a href="./qopenglcontext.htm#aboutToBeDestroyed" translate="no">QOpenGLContext::aboutToBeDestroyed</a>() signal is emitted from the <a href="./qquickwindow.htm#openglContext" translate="no">QQuickWindow::openglContext</a>() when the OpenGL context is about to be released. The <a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">QQuickWindow::sceneGraphInitialized</a>() signal is emitted when a new OpenGL context is created for this window. Make a <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::DirectConnection</a> to these signals to be notified.</p>
<p>The OpenGL context is still released when the last <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> is deleted.</p>
<div class="admonition note">
<p><b>Note: </b>This only has an effect when using the default OpenGL scene graph adaptation.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#isPersistentOpenGLContext" translate="no">isPersistentOpenGLContext</a>(), <a href="./qquickwindow.htm#setPersistentSceneGraph" translate="no">setPersistentSceneGraph</a>(), <a href="./qopenglcontext.htm#aboutToBeDestroyed" translate="no">QOpenGLContext::aboutToBeDestroyed</a>(), and <a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">sceneGraphInitialized</a>().</p>
<!-- @@@setPersistentOpenGLContext -->
<!-- $$$setPersistentSceneGraph[overload1]$$$setPersistentSceneGraphbool -->
<h3 class="fn" id="setPersistentSceneGraph" translate="no"><a name="setPersistentSceneGraph"></a><span class="type">void</span> QQuickWindow::<span class="name">setPersistentSceneGraph</span>(<span class="type">bool</span> <i>persistent</i>)<a class="plink" href="#setPersistentSceneGraph" title="Direct link to this headline"></a></h3>
<p>Sets whether the scene graph nodes and resources are <i translate="no">persistent</i>. Persistent means the nodes and resources cannot be released. The default value is <code translate="no">true</code>.</p>
<p>The scene graph nodes and resources can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</p>
<p>The <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">QQuickWindow::sceneGraphInvalidated</a>() signal is emitted when cleanup occurs. The <a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">QQuickWindow::sceneGraphInitialized</a>() signal is emitted when a new scene graph is recreated for this window. Make a <a href="./qt.htm#ConnectionType-enum" translate="no">Qt::DirectConnection</a> to these signals to be notified.</p>
<p>The scene graph nodes and resources are still released when the last <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> is deleted.</p>
<p><b>See also </b><a href="./qquickwindow.htm#isPersistentSceneGraph" translate="no">isPersistentSceneGraph</a>(), <a href="./qquickwindow.htm#setPersistentOpenGLContext" translate="no">setPersistentOpenGLContext</a>(), <a href="./qquickwindow.htm#sceneGraphInvalidated" translate="no">sceneGraphInvalidated</a>(), and <a href="./qquickwindow.htm#sceneGraphInitialized" translate="no">sceneGraphInitialized</a>().</p>
<!-- @@@setPersistentSceneGraph -->
<!-- $$$setRenderTarget[overload1]$$$setRenderTargetQOpenGLFramebufferObject* -->
<h3 class="fn" id="setRenderTarget" translate="no"><a name="setRenderTarget"></a><span class="type">void</span> QQuickWindow::<span class="name">setRenderTarget</span>(<span class="type"><a href="./qopenglframebufferobject.htm" translate="no">QOpenGLFramebufferObject</a></span> *<i>fbo</i>)<a class="plink" href="#setRenderTarget" title="Direct link to this headline"></a></h3>
<p>Sets the render target for this window to be <i translate="no">fbo</i>.</p>
<p>The specified fbo must be created in the context of the window or one that shares with it.</p>
<div class="admonition note">
<p><b>Note: </b>This function only has an effect when using the default OpenGL scene graph adaptation.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function has no effect when running on the RHI graphics abstraction.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the thread doing the rendering.</p>
</div>
<p><b>See also </b><a href="./qquickwindow.htm#renderTarget" translate="no">renderTarget</a>().</p>
<!-- @@@setRenderTarget -->
<!-- $$$setRenderTarget$$$setRenderTargetuintconstQSize& -->
<h3 class="fn" id="setRenderTarget-1" translate="no"><a name="setRenderTarget-1"></a><span class="type">void</span> QQuickWindow::<span class="name">setRenderTarget</span>(<span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>fboId</i>, const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>)<a class="plink" href="#setRenderTarget-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Sets the render target for this window to be an FBO with <i translate="no">fboId</i> and <i translate="no">size</i>.</p>
<p>The specified FBO must be created in the context of the window or one that shares with it.</p>
<div class="admonition note">
<p><b>Note: </b><i translate="no">fboId</i> can also be set to 0. In this case rendering will target the default framebuffer of whichever surface is current when the scenegraph renders. <i translate="no">size</i> must still be valid, specifying the dimensions of the surface.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function only has an effect when using the default OpenGL scene graph adaptation.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>This function can only be called from the thread doing the rendering.</p>
</div>
<!-- @@@setRenderTarget -->
<!-- $$$setSceneGraphBackend[overload1]$$$setSceneGraphBackendQSGRendererInterface::GraphicsApi -->
<h3 class="fn" id="setSceneGraphBackend" translate="no"><a name="setSceneGraphBackend"></a><code translate="no">[static] </code><span class="type">void</span> QQuickWindow::<span class="name">setSceneGraphBackend</span>(<span class="type"><a href="./qsgrendererinterface.htm#GraphicsApi-enum" translate="no">QSGRendererInterface::GraphicsApi</a></span> <i>api</i>)<a class="plink" href="#setSceneGraphBackend" title="Direct link to this headline"></a></h3>
<p>Requests a Qt Quick scenegraph backend for the specified graphics <i translate="no">api</i>. Backends can either be built-in or be installed in form of dynamically loaded plugins.</p>
<div class="admonition note">
<p><b>Note: </b>The call to the function must happen before constructing the first <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> in the application. It cannot be changed afterwards.</p>
</div>
<p>If the selected backend is invalid or an error occurs, the default backend (OpenGL or software, depending on the Qt configuration) is used.</p>
<p>This function was introduced in Qt 5.8.</p>
<p><b>See also </b><a href="./qquickwindow.htm#sceneGraphBackend" translate="no">sceneGraphBackend</a>().</p>
<!-- @@@setSceneGraphBackend -->
<!-- $$$setSceneGraphBackend$$$setSceneGraphBackendconstQString& -->
<h3 class="fn" id="setSceneGraphBackend-1" translate="no"><a name="setSceneGraphBackend-1"></a><code translate="no">[static] </code><span class="type">void</span> QQuickWindow::<span class="name">setSceneGraphBackend</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>backend</i>)<a class="plink" href="#setSceneGraphBackend-1" title="Direct link to this headline"></a></h3>
<p>Requests the specified Qt Quick scenegraph <i translate="no">backend</i>. Backends can either be built-in or be installed in form of dynamically loaded plugins.</p>
<p>This is an overloaded function.</p>
<div class="admonition note">
<p><b>Note: </b>The call to the function must happen before constructing the first <a href="./qquickwindow.htm" translate="no">QQuickWindow</a> in the application. It cannot be changed afterwards.</p>
</div>
<p>If <i translate="no">backend</i> is invalid or an error occurs, the default backend (OpenGL or software, depending on the Qt configuration) is used.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is equivalent to setting the <code translate="no">QT_QUICK_BACKEND</code> or <code translate="no">QMLSCENE_DEVICE</code> environment variables. However, this API is safer to use in applications that spawn other processes as there is no need to worry about environment inheritance.</p>
</div>
<p>This function was introduced in Qt 5.8.</p>
<!-- @@@setSceneGraphBackend -->
<!-- $$$setTextRenderType[overload1]$$$setTextRenderTypeQQuickWindow::TextRenderType -->
<h3 class="fn" id="setTextRenderType" translate="no"><a name="setTextRenderType"></a><code translate="no">[static] </code><span class="type">void</span> QQuickWindow::<span class="name">setTextRenderType</span>(<span class="type"><a href="./qquickwindow.htm#TextRenderType-enum" translate="no">QQuickWindow::TextRenderType</a></span> <i>renderType</i>)<a class="plink" href="#setTextRenderType" title="Direct link to this headline"></a></h3>
<p>Sets the default render type of text-like elements in Qt Quick to <i translate="no">renderType</i>.</p>
<div class="admonition note">
<p><b>Note: </b>setting the render type will only affect elements created afterwards; the render type of existing elements will not be modified.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qquickwindow.htm#textRenderType" translate="no">textRenderType</a>().</p>
<!-- @@@setTextRenderType -->
<!-- $$$showEvent[overload1]$$$showEventQShowEvent* -->
<h3 class="fn" id="showEvent" translate="no"><a name="showEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">showEvent</span>(<i>QShowEvent *</i>)<a class="plink" href="#showEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#showEvent" translate="no">QWindow::showEvent</a>(QShowEvent *ev).</p>
<!-- @@@showEvent -->
<!-- $$$tabletEvent[overload1]$$$tabletEventQTabletEvent* -->
<h3 class="fn" id="tabletEvent" translate="no"><a name="tabletEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">tabletEvent</span>(<span class="type"><a href="./qtabletevent.htm" translate="no">QTabletEvent</a></span> *<i>event</i>)<a class="plink" href="#tabletEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#tabletEvent" translate="no">QWindow::tabletEvent</a>(QTabletEvent *ev).</p>
<!-- @@@tabletEvent -->
<!-- $$$textRenderType[overload1]$$$textRenderType -->
<h3 class="fn" id="textRenderType" translate="no"><a name="textRenderType"></a><code translate="no">[static] </code><span class="type"><a href="./qquickwindow.htm#TextRenderType-enum" translate="no">QQuickWindow::TextRenderType</a></span> QQuickWindow::<span class="name">textRenderType</span>()<a class="plink" href="#textRenderType" title="Direct link to this headline"></a></h3>
<p>Returns the render type of text-like elements in Qt Quick. The default is <a href="./qquickwindow.htm#TextRenderType-enum" translate="no">QQuickWindow::QtTextRendering</a>.</p>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qquickwindow.htm#setTextRenderType" translate="no">setTextRenderType</a>().</p>
<!-- @@@textRenderType -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" id="wheelEvent" translate="no"><a name="wheelEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QQuickWindow::<span class="name">wheelEvent</span>(<span class="type"><a href="./qwheelevent.htm" translate="no">QWheelEvent</a></span> *<i>event</i>)<a class="plink" href="#wheelEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwindow.htm#wheelEvent" translate="no">QWindow::wheelEvent</a>(QWheelEvent *ev).</p>
<!-- @@@wheelEvent -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>