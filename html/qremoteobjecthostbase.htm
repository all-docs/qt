<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QRemoteObjectHostBase | Qt Remote Objects</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qremoteobjecthostbase.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtremoteobjects-index.htm" translate="no">Qt Remote Objects</a></li>
                            <li><a href="./qtremoteobjects-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QRemoteObjectHostBase</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QRemoteObjectHostBase Class</h1>
<!-- $$$QRemoteObjectHostBase-brief -->
<p>The QRemoteObjectHostBase class provides base functionality common to <a href="./qremoteobjecthost.htm" translate="no">Host</a> and <a href="./qremoteobjectregistryhost.htm" translate="no">RegistryHost</a> classes. <a href="#details">More...</a></p>
<!-- @@@QRemoteObjectHostBase -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QRemoteObjectHostBase&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += remoteobjects</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qremoteobjectnode.htm" translate="no">QRemoteObjectNode</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a> and <a href="./qremoteobjectregistryhost.htm" translate="no">QRemoteObjectRegistryHost</a></p>
</td></tr></tbody></table></div><ul>
<li><a href="./qremoteobjecthostbase-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#AllowedSchemas-enum" translate="no">AllowedSchemas</a></b> { BuiltInSchemasOnly, AllowExternalRegistration }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#addHostSideConnection" translate="no">addHostSideConnection</a></b>(QIODevice *<i>ioDevice</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#disableRemoting" translate="no">disableRemoting</a></b>(QObject *<i>remoteObject</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#enableRemoting" translate="no">enableRemoting</a></b>(ObjectType *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#enableRemoting-1" translate="no">enableRemoting</a></b>(QObject *<i>object</i>, const QString &amp;<i>name</i> = QString())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#enableRemoting-2" translate="no">enableRemoting</a></b>(QAbstractItemModel *<i>model</i>, const QString &amp;<i>name</i>, const QVector&lt;int&gt; <i>roles</i>, QItemSelectionModel *<i>selectionModel</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#proxy" translate="no">proxy</a></b>(const QUrl &amp;<i>registryUrl</i>, const QUrl &amp;<i>hostUrl</i> = {}, QRemoteObjectHostBase::RemoteObjectNameFilter <i>filter</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#reverseProxy" translate="no">reverseProxy</a></b>(QRemoteObjectHostBase::RemoteObjectNameFilter <i>filter</i> = ...)</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qremoteobjecthostbase.htm#setName" translate="no">setName</a></b>(const QString &amp;<i>name</i>) override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QRemoteObjectHostBase-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QRemoteObjectHostBase is a base class that cannot be instantiated directly. It provides the <a href="./qremoteobjecthostbase.htm#enableRemoting" translate="no">enableRemoting</a> and <a href="./qremoteobjecthostbase.htm#disableRemoting" translate="no">disableRemoting</a> functionality shared by all host nodes (<a href="./qremoteobjecthost.htm" translate="no">Host</a> and <a href="./qremoteobjectregistryhost.htm" translate="no">RegistryHost</a>) as well as the logic required to expose <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects on the Remote Objects network.</p>
</div>
<!-- @@@QRemoteObjectHostBase -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$AllowedSchemas$$$BuiltInSchemasOnly$$$AllowExternalRegistration -->
<h3 class="fn" id="AllowedSchemas-enum" translate="no"><a name="AllowedSchemas-enum"></a>enum QRemoteObjectHostBase::<span class="name">AllowedSchemas</span><a class="plink" href="#AllowedSchemas-enum" title="Direct link to this headline"></a></h3>
<p>This enum is used to specify whether a Node will accept a url with an unrecognized schema for the hostUrl. By default only urls with known schemas are accepted, but using <code translate="no">AllowExternalRegistration</code> will enable the <a href="./qtremoteobjects-registry.htm#registry" translate="no">Registry</a> to pass your external (to QtRO) url to client Nodes.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRemoteObjectHostBase::BuiltInSchemasOnly</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">Only allow the hostUrl to be set to a QtRO supported schema. This is the default value, and causes a Node error to be set if an unrecognized schema is provided.</td></tr>
<tr><td class="topAlign"><code translate="no">QRemoteObjectHostBase::AllowExternalRegistration</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The provided schema is registered as an <a href="./qtremoteobjects-external-schemas.htm#external-schemas" translate="no">External Schema</a></td></tr>
</tbody></table></div>
<p><b>See also </b><a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a>.</p>
<!-- @@@AllowedSchemas -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$addHostSideConnection[overload1]$$$addHostSideConnectionQIODevice* -->
<h3 class="fn" id="addHostSideConnection" translate="no"><a name="addHostSideConnection"></a><span class="type">void</span> QRemoteObjectHostBase::<span class="name">addHostSideConnection</span>(<span class="type"><a href="./qiodevice.htm" translate="no">QIODevice</a></span> *<i>ioDevice</i>)<a class="plink" href="#addHostSideConnection" title="Direct link to this headline"></a></h3>
<p>In order to <a href="./qremoteobjecthostbase.htm#enableRemoting" translate="no">QRemoteObjectHost::enableRemoting</a>() <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects over <a href="./qtremoteobjects-external-schemas.htm#external-qiodevices" translate="no">External QIODevices</a>, Qt Remote Objects needs access to the communications channel (a <a href="./qiodevice.htm" translate="no">QIODevice</a>) between the respective nodes. It is the addHostSideConnection() call that enables this on the <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> side, taking the <i translate="no">ioDevice</i> as input. Any <a href="./qremoteobjecthostbase.htm#enableRemoting" translate="no">enableRemoting</a>() call will still work without calling addHostSideConnection, but the Node will not be able to share the <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects without being provided the connection to the Replica node. Before calling this function you must call <a href="./qremoteobjecthost.htm#setHostUrl" translate="no">setHostUrl</a>() with a unique URL and <a href="./qremoteobjecthostbase.htm#AllowedSchemas-enum" translate="no">AllowExternalRegistration</a>.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="./qremoteobjectnode.htm#addClientSideConnection" translate="no">addClientSideConnection</a>.</p>
<!-- @@@addHostSideConnection -->
<!-- $$$disableRemoting[overload1]$$$disableRemotingQObject* -->
<h3 class="fn" id="disableRemoting" translate="no"><a name="disableRemoting"></a><span class="type">bool</span> QRemoteObjectHostBase::<span class="name">disableRemoting</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>remoteObject</i>)<a class="plink" href="#disableRemoting" title="Direct link to this headline"></a></h3>
<p>Disables remote access for the <a href="./qobject.htm" translate="no">QObject</a> <i translate="no">remoteObject</i>. Returns <code translate="no">false</code> if the current node is a client node or if the <i translate="no">remoteObject</i> is not registered, and returns <code translate="no">true</code> if remoting is successfully disabled for the Source object.</p>
<div class="admonition warning">
<p><b>Warning: </b>Replicas of this object will no longer be valid after calling this method.</p>
</div>
<p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="./qobject.htm#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
<p><b>See also </b><a href="./qremoteobjecthostbase.htm#enableRemoting" translate="no">enableRemoting</a>().</p>
<!-- @@@disableRemoting -->
<!-- $$$enableRemoting[overload1]$$$enableRemotingObjectType* -->
<h3 class="fn" id="enableRemoting" translate="no"><a name="enableRemoting"></a>template &lt;template &lt;typename&gt; class ApiDefinition, typename ObjectType&gt; <span class="type">bool</span> QRemoteObjectHostBase::<span class="name">enableRemoting</span>(<span class="type">ObjectType</span> *<i>object</i>)<a class="plink" href="#enableRemoting" title="Direct link to this headline"></a></h3>
<p>This templated function overload enables a host node to provide remote access to a <a href="./qobject.htm" translate="no">QObject</a> <i translate="no">object</i> with a specified (and compile-time checked) interface. Client nodes connected to the node hosting this object may obtain Replicas of this Source.</p>
<p>This is best illustrated by example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor">#include "rep_TimeModel_source.h"</span>
MinuteTimer timer;
hostNode<span class="operator">.</span>enableRemoting<span class="operator">&lt;</span>MinuteTimerSourceAPI<span class="operator">&gt;</span>(<span class="operator">&amp;</span>timer);</pre></div>
<p>Here the MinuteTimerSourceAPI is the set of Signals/Slots/Properties defined by the TimeModel.rep file. Compile time checks are made to verify the input <a href="./qobject.htm" translate="no">QObject</a> can expose the requested API, it will fail to compile otherwise. This allows a subset of <i translate="no">object</i> 's interface to be exposed, and allows the types of conversions supported by Signal/Slot connections.</p>
<p>Returns <code translate="no">false</code> if the current node is a client node, or if the <a href="./qobject.htm" translate="no">QObject</a> is already registered to be remoted, and <code translate="no">true</code> if remoting is successfully enabled for the <a href="./qobject.htm" translate="no">QObject</a>.</p>
<p><b>See also </b><a href="./qremoteobjecthostbase.htm#disableRemoting" translate="no">disableRemoting</a>().</p>
<!-- @@@enableRemoting -->
<!-- $$$enableRemoting$$$enableRemotingQObject*constQString& -->
<h3 class="fn" id="enableRemoting-1" translate="no"><a name="enableRemoting-1"></a><span class="type">bool</span> QRemoteObjectHostBase::<span class="name">enableRemoting</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>object</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>name</i> = QString())<a class="plink" href="#enableRemoting-1" title="Direct link to this headline"></a></h3>
<p>Enables a host node to dynamically provide remote access to the <a href="./qobject.htm" translate="no">QObject</a> <i translate="no">object</i>. Client nodes connected to the node hosting this object may obtain Replicas of this Source.</p>
<p>The optional <i translate="no">name</i> defines the lookup-name under which the <a href="./qobject.htm" translate="no">QObject</a> can be acquired using <a href="./qremoteobjectnode.htm#acquire" translate="no">QRemoteObjectNode::acquire</a>() . If not explicitly set then the name given in the QCLASSINFO_REMOTEOBJECT_TYPE will be used. If no such macro was defined for the <a href="./qobject.htm" translate="no">QObject</a> then the <a href="./qobject.htm#objectName-prop" translate="no">QObject::objectName</a>() is used.</p>
<p>Returns <code translate="no">false</code> if the current node is a client node, or if the <a href="./qobject.htm" translate="no">QObject</a> is already registered to be remoted, and <code translate="no">true</code> if remoting is successfully enabled for the dynamic <a href="./qobject.htm" translate="no">QObject</a>.</p>
<p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="./qobject.htm#Q_INVOKABLE" translate="no">Q_INVOKABLE</a>.</p>
<p><b>See also </b><a href="./qremoteobjecthostbase.htm#disableRemoting" translate="no">disableRemoting</a>().</p>
<!-- @@@enableRemoting -->
<!-- $$$enableRemoting$$$enableRemotingQAbstractItemModel*constQString&constQVector<int>QItemSelectionModel* -->
<h3 class="fn" id="enableRemoting-2" translate="no"><a name="enableRemoting-2"></a><span class="type">bool</span> QRemoteObjectHostBase::<span class="name">enableRemoting</span>(<span class="type"><a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a></span> *<i>model</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>name</i>, const <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type">int</span>&gt; <i>roles</i>, <span class="type"><a href="./qitemselectionmodel.htm" translate="no">QItemSelectionModel</a></span> *<i>selectionModel</i> = nullptr)<a class="plink" href="#enableRemoting-2" title="Direct link to this headline"></a></h3>
<p>This overload of enableRemoting() is specific to <a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a> types (or any type derived from <a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a>). This is useful if you want to have a model and the HMI for the model in different processes.</p>
<p>The three required parameters are the <i translate="no">model</i> itself, the <i translate="no">name</i> by which to lookup the model, and the <i translate="no">roles</i> that should be exposed on the Replica side. If you want to synchronize selection between <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> and <a href="./qtremoteobjects-replica.htm#replica" translate="no">Replica</a>, the optional <i translate="no">selectionModel</i> parameter can be used. This is only recommended when using a single Replica.</p>
<p>Behind the scenes, Qt Remote Objects batches data() lookups and prefetches data when possible to make the model interaction as responsive as possible.</p>
<p>Returns <code translate="no">false</code> if the current node is a client node, or if the <a href="./qobject.htm" translate="no">QObject</a> is already registered to be remoted, and <code translate="no">true</code> if remoting is successfully enabled for the <a href="./qabstractitemmodel.htm" translate="no">QAbstractItemModel</a>.</p>
<p><b>See also </b><a href="./qremoteobjecthostbase.htm#disableRemoting" translate="no">disableRemoting</a>().</p>
<!-- @@@enableRemoting -->
<!-- $$$proxy[overload1]$$$proxyconstQUrl&constQUrl&QRemoteObjectHostBase::RemoteObjectNameFilter -->
<h3 class="fn" id="proxy" translate="no"><a name="proxy"></a><span class="type">bool</span> QRemoteObjectHostBase::<span class="name">proxy</span>(const <span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span> &amp;<i>registryUrl</i>, const <span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span> &amp;<i>hostUrl</i> = {}, <span class="type">QRemoteObjectHostBase::RemoteObjectNameFilter</span> <i>filter</i> = ...)<a class="plink" href="#proxy" title="Direct link to this headline"></a></h3>
<p>Forward Remote Objects from another network</p>
<p>The proxy functionality is useful when you want to share <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects over multiple networks. For instance, if you have an embedded target using target-only connections (like local) and you want to make some of those same objects available externally.</p>
<p>As a concrete example, say you have a set of processes talking to each other on your target hardware using a registry, with the <a href="./qtremoteobjects-registry.htm#registry" translate="no">Registry</a> at "local:registry" and separate processes using a node at "local:MyHost" that holds <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects. If you wanted to access these objects, but over tcp, you could create a new proxyNode like so:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// myInternalHost is a node only visible on the device...</span>
<span class="type"><a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a></span> myInternalHost(<span class="string">"local:MyHost"</span>);
myInternalHost<span class="operator">.</span>enableRemoting<span class="operator">&lt;</span>SomeObject<span class="operator">&gt;</span>(<span class="operator">&amp;</span>someObject);

<span class="comment">// Regular host node, listening on port 12123, so visible to other</span>
<span class="comment">// devices</span>
<span class="type"><a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a></span> proxyNode(<span class="string">"tcp://localhost:12123"</span>);

<span class="comment">// Enable proxying objects from nodes on the local machine's internal</span>
<span class="comment">// QtRO bus</span>
proxyNode<span class="operator">.</span>proxy(<span class="string">"local:registry"</span>);</pre></div>
<p>And from another device you create another node:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// NB: localhost resolves to a different ip address than proxyNode</span>
<span class="type"><a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a></span> nodeOnRemoteDevice(<span class="string">"tcp://localhost:23234"</span>);

<span class="comment">// Connect to the target's proxyNode directly, or use a tcp registry...</span>
nodeOnRemoteDevice<span class="operator">.</span>connectToNode(<span class="string">"tcp://&lt;target device&gt;:12123"</span>);

<span class="comment">// Because of the proxy, we can get the object over tcp/ip port 12123,</span>
<span class="comment">// even though we can't connect directly to "local:MyHost"</span>
SomeObject <span class="operator">*</span>so <span class="operator">=</span> nodeOnRemoteDevice<span class="operator">.</span>acquire<span class="operator">&lt;</span>SomeObject<span class="operator">&gt;</span>();</pre></div>
<p>This would (internally) create a node in proxyNode, which (again internally/automatically) connects to the provided registry (given by the <i translate="no">registryUrl</i> parameter, "local:registry" in this example). Whenever local:registry emits the <a href="./qremoteobjectnode.htm#remoteObjectAdded" translate="no">remoteObjectAdded</a> signal, the <code translate="no">QRemoteObjectSourceLocation</code> is passed to the <i translate="no">filter</i> given to the proxy call. If this method returns true (the default filter simply returns true without any filtering), the object is acquired() from the internal node and <a href="./qremoteobjecthostbase.htm#enableRemoting" translate="no">enableRemoting</a>() (once the replica is initialized) is called on proxyNode.</p>
<p>If a <i translate="no">hostUrl</i> is provided (which is required to enable <a href="./qremoteobjecthostbase.htm#reverseProxy" translate="no">reverseProxy</a>, but not needed otherwise), the internal node will be a <a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a> node configured with the provided address. If no <i translate="no">hostUrl</i> is provided, the internal node will be a <a href="./qremoteobjectnode.htm" translate="no">QRemoteObjectNode</a> (not HostNode).</p>
<p>Returns <code translate="no">true</code> if the object is acquired from the internal node.</p>
<p>This function was introduced in Qt 5.11.</p>
<p><b>See also </b><a href="./qremoteobjecthostbase.htm#reverseProxy" translate="no">reverseProxy</a>().</p>
<!-- @@@proxy -->
<!-- $$$reverseProxy[overload1]$$$reverseProxyQRemoteObjectHostBase::RemoteObjectNameFilter -->
<h3 class="fn" id="reverseProxy" translate="no"><a name="reverseProxy"></a><span class="type">bool</span> QRemoteObjectHostBase::<span class="name">reverseProxy</span>(<span class="type">QRemoteObjectHostBase::RemoteObjectNameFilter</span> <i>filter</i> = ...)<a class="plink" href="#reverseProxy" title="Direct link to this headline"></a></h3>
<p>Forwards remote objects to another network.</p>
<p>The reverseProxy() function allows the <a href="./qremoteobjecthostbase.htm#proxy" translate="no">proxy</a>() functionality to be extended, in effect mirroring the proxy functionality in the "reverse" direction. These are distinct, because node communication is not symmetric, one side calls <a href="./qremoteobjecthostbase.htm#enableRemoting" translate="no">enableRemoting</a>() with a <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> object, the other side calls <a href="./qremoteobjectnode.htm#acquire" translate="no">acquire</a>() to get a <a href="./qtremoteobjects-replica.htm#replica" translate="no">Replica</a>. Using <a href="./qremoteobjecthostbase.htm#proxy" translate="no">proxy</a>() allows you to "observe" objects on a target device remotely via acquire, but it does not allow off-target <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects to be acquired from the device's local:* network. That is where reverseProxy() comes in. If a proxyNode is created like so:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// myInternalHost is a node only visible on the device...</span>
<span class="type"><a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a></span> myInternalHost(<span class="string">"local:MyHost"</span>);

<span class="comment">// RegistryHost node, listening on port 12123, so visible to other</span>
<span class="comment">// devices.  The node must be a RegistryHost, so the Sources on</span>
<span class="comment">// the "outside" network can be forwarded to the inner network.</span>
<span class="type"><a href="./qremoteobjectregistryhost.htm" translate="no">QRemoteObjectRegistryHost</a></span> proxyNode(<span class="string">"tcp://localhost:12123"</span>);

<span class="comment">// Enable proxying objects from nodes on the local machine's internal</span>
<span class="comment">// QtRO bus.  Note the hostUrl parameter is now needed.</span>
proxyNode<span class="operator">.</span>proxy(<span class="string">"local:registry"</span><span class="operator">,</span> <span class="string">"local:fromProxy"</span>);
proxyNode<span class="operator">.</span>reverseProxy();</pre></div>
<p>And from another device you create another node:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// NB: localhost resolves to a different ip address than proxyNode</span>
<span class="type"><a href="./qremoteobjecthost.htm" translate="no">QRemoteObjectHost</a></span> nodeOnRemoteDevice(<span class="string">"tcp://localhost:23234"</span>);

<span class="comment">// Connect to the target's proxyNode directly, or use a tcp registry...</span>
nodeOnRemoteDevice<span class="operator">.</span>connectToNode(<span class="string">"tcp://&lt;target device&gt;:12123"</span>);

<span class="comment">// Because of the reverseProxy, we can expose objects on this device</span>
<span class="comment">// and they will make their way to proxyNode...</span>
nodeOnRemoteDevice<span class="operator">.</span>enableRemoting<span class="operator">&lt;</span>OtherObject<span class="operator">&gt;</span>(<span class="operator">&amp;</span>otherObject);</pre></div>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// Acquire() can now see the objects on other devices through proxyNode,</span>
<span class="comment">// due to the reverseProxy call.</span>
OtherObject <span class="operator">*</span>oo <span class="operator">=</span> myInternalHost<span class="operator">.</span>acquire<span class="operator">&lt;</span>OtherObject<span class="operator">&gt;</span>();</pre></div>
<p>While the <a href="./qremoteobjecthostbase.htm#proxy" translate="no">proxy</a>() functionality allows <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects on another network to be acquired(), reverseProxy() allows <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects to be "pushed" to an otherwise inaccessible network.</p>
<div class="admonition note">
<p><b>Note: </b><a href="./qremoteobjecthostbase.htm#proxy" translate="no">proxy</a>() needs to be called before reverseProxy(), and a hostUrl needs to be provided to <a href="./qremoteobjecthostbase.htm#proxy" translate="no">proxy</a> for reverseProxy() to work. The reverseProxy() method allows a separate <i translate="no">filter</i> to be applied. This reverseProxy specific filter will receive notifications of new <a href="./qtremoteobjects-source.htm#source" translate="no">Source</a> objects on proxyNode and acquire them on the internal node if they pass the reverseFilter.</p>
</div>
<p>Returns <code translate="no">true</code> on success, <code translate="no">false</code> otherwise.</p>
<p>This function was introduced in Qt 5.11.</p>
<p><b>See also </b><a href="./qremoteobjecthostbase.htm#proxy" translate="no">proxy</a>().</p>
<!-- @@@reverseProxy -->
<!-- $$$setName[overload1]$$$setNameconstQString& -->
<h3 class="fn" id="setName" translate="no"><a name="setName"></a><code translate="no">[override virtual] </code><span class="type">void</span> QRemoteObjectHostBase::<span class="name">setName</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>name</i>)<a class="plink" href="#setName" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qremoteobjectnode.htm#setName" translate="no">QRemoteObjectNode::setName</a>(const QString &amp;name).</p>
<p>Similar to <a href="./qobject.htm#objectName-prop" translate="no">QObject::setObjectName</a>() (which this method calls), but this version also applies the <i translate="no">name</i> to internal classes as well, which are used in some of the debugging output.</p>
<!-- @@@setName -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>