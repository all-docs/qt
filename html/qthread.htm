<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QThread | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qthread.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QThread</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QThread Class</h1>
<!-- $$$QThread-brief -->
<p>The QThread class provides a platform-independent way to manage threads. <a href="#details">More...</a></p>
<!-- @@@QThread -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QThread&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qobject.htm" translate="no">QObject</a></td></tr></tbody></table></div><ul>
<li><a href="./qthread-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#Priority-enum" translate="no">Priority</a></b> { IdlePriority, LowestPriority, LowPriority, NormalPriority, HighPriority, â€¦, InheritPriority }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#QThread" translate="no">QThread</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#dtor.QThread" translate="no">~QThread</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractEventDispatcher *</td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#eventDispatcher" translate="no">eventDispatcher</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#exit" translate="no">exit</a></b>(int <i>returnCode</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#isFinished" translate="no">isFinished</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#isInterruptionRequested" translate="no">isInterruptionRequested</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#isRunning" translate="no">isRunning</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#loopLevel" translate="no">loopLevel</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QThread::Priority </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#priority" translate="no">priority</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#requestInterruption" translate="no">requestInterruption</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#setEventDispatcher" translate="no">setEventDispatcher</a></b>(QAbstractEventDispatcher *<i>eventDispatcher</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#setPriority" translate="no">setPriority</a></b>(QThread::Priority <i>priority</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#setStackSize" translate="no">setStackSize</a></b>(uint <i>stackSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#stackSize" translate="no">stackSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#wait" translate="no">wait</a></b>(QDeadlineTimer <i>deadline</i> = QDeadlineTimer(QDeadlineTimer::Forever))</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#wait-1" translate="no">wait</a></b>(unsigned long <i>time</i>)</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#event" translate="no">event</a></b>(QEvent *<i>event</i>) override</td></tr>
</tbody></table></div>
<a name="public-slots"></a>
<h2 id="public-slots">Public Slots<a class="plink" href="#public-slots" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#quit" translate="no">quit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#start" translate="no">start</a></b>(QThread::Priority <i>priority</i> = InheritPriority)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#terminate" translate="no">terminate</a></b>()</td></tr>
</tbody></table></div>
<a name="signals"></a>
<h2 id="signals">Signals<a class="plink" href="#signals" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#finished" translate="no">finished</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#started" translate="no">started</a></b>()</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QThread *</td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#create" translate="no">create</a></b>(Function &amp;&amp;<i>f</i>, Args &amp;&amp;... <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QThread *</td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#create-1" translate="no">create</a></b>(Function &amp;&amp;<i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QThread *</td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#currentThread" translate="no">currentThread</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::HANDLE </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#currentThreadId" translate="no">currentThreadId</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#idealThreadCount" translate="no">idealThreadCount</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#msleep" translate="no">msleep</a></b>(unsigned long <i>msecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#sleep" translate="no">sleep</a></b>(unsigned long <i>secs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#usleep" translate="no">usleep</a></b>(unsigned long <i>usecs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#yieldCurrentThread" translate="no">yieldCurrentThread</a></b>()</td></tr>
</tbody></table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions<a class="plink" href="#protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#exec" translate="no">exec</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#run" translate="no">run</a></b>()</td></tr>
</tbody></table></div>
<a name="static-protected-members"></a>
<h2 id="static-protected-members">Static Protected Members<a class="plink" href="#static-protected-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qthread.htm#setTerminationEnabled" translate="no">setTerminationEnabled</a></b>(bool <i>enabled</i> = true)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QThread-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>A QThread object manages one thread of control within the program. QThreads begin executing in <a href="./qthread.htm#run" translate="no">run</a>(). By default, <a href="./qthread.htm#run" translate="no">run</a>() starts the event loop by calling <a href="./qthread.htm#exec" translate="no">exec</a>() and runs a Qt event loop inside the thread.</p>
<p>You can use worker objects by moving them to the thread using <a href="./qobject.htm#moveToThread" translate="no">QObject::moveToThread</a>().</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> Worker : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT

<span class="keyword">public</span> <span class="keyword">slots</span>:
    <span class="type">void</span> doWork(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>parameter) {
        <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> result;
        <span class="comment">/* ... here is the expensive or blocking operation ... */</span>
        <span class="keyword">emit</span> resultReady(result);
    }

<span class="keyword">signals</span>:
    <span class="type">void</span> resultReady(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>result);
};

<span class="keyword">class</span> Controller : <span class="keyword">public</span> <span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span>
{
    Q_OBJECT
    <span class="type"><a href="./qthread.htm#QThread" translate="no">QThread</a></span> workerThread;
<span class="keyword">public</span>:
    Controller() {
        Worker <span class="operator">*</span>worker <span class="operator">=</span> <span class="keyword">new</span> Worker;
        worker<span class="operator">-</span><span class="operator">&gt;</span>moveToThread(<span class="operator">&amp;</span>workerThread);
        connect(<span class="operator">&amp;</span>workerThread<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qthread.htm#QThread" translate="no">QThread</a></span><span class="operator">::</span>finished<span class="operator">,</span> worker<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span><span class="operator">::</span>deleteLater);
        connect(<span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>Controller<span class="operator">::</span>operate<span class="operator">,</span> worker<span class="operator">,</span> <span class="operator">&amp;</span>Worker<span class="operator">::</span>doWork);
        connect(worker<span class="operator">,</span> <span class="operator">&amp;</span>Worker<span class="operator">::</span>resultReady<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>Controller<span class="operator">::</span>handleResults);
        workerThread<span class="operator">.</span>start();
    }
    <span class="operator">~</span>Controller() {
        workerThread<span class="operator">.</span>quit();
        workerThread<span class="operator">.</span>wait();
    }
<span class="keyword">public</span> <span class="keyword">slots</span>:
    <span class="type">void</span> handleResults(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>);
<span class="keyword">signals</span>:
    <span class="type">void</span> operate(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>);
};</pre></div>
<p>The code inside the Worker's slot would then execute in a separate thread. However, you are free to connect the Worker's slots to any signal, from any object, in any thread. It is safe to connect signals and slots across different threads, thanks to a mechanism called <a href="./qt.htm#ConnectionType-enum" translate="no">queued connections</a>.</p>
<p>Another way to make code run in a separate thread, is to subclass QThread and reimplement <a href="./qthread.htm#run" translate="no">run</a>(). For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> WorkerThread : <span class="keyword">public</span> <span class="type"><a href="./qthread.htm#QThread" translate="no">QThread</a></span>
{
    Q_OBJECT
    <span class="type">void</span> run() override {
        <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> result;
        <span class="comment">/* ... here is the expensive or blocking operation ... */</span>
        <span class="keyword">emit</span> resultReady(result);
    }
<span class="keyword">signals</span>:
    <span class="type">void</span> resultReady(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>s);
};

<span class="type">void</span> MyObject<span class="operator">::</span>startWorkInAThread()
{
    WorkerThread <span class="operator">*</span>workerThread <span class="operator">=</span> <span class="keyword">new</span> WorkerThread(<span class="keyword">this</span>);
    connect(workerThread<span class="operator">,</span> <span class="operator">&amp;</span>WorkerThread<span class="operator">::</span>resultReady<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>MyObject<span class="operator">::</span>handleResults);
    connect(workerThread<span class="operator">,</span> <span class="operator">&amp;</span>WorkerThread<span class="operator">::</span>finished<span class="operator">,</span> workerThread<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span><span class="operator">::</span>deleteLater);
    workerThread<span class="operator">-</span><span class="operator">&gt;</span>start();
}</pre></div>
<p>In that example, the thread will exit after the run function has returned. There will not be any event loop running in the thread unless you call <a href="./qthread.htm#exec" translate="no">exec</a>().</p>
<p>It is important to remember that a QThread instance <a href="./qobject.htm#thread-affinity" translate="no">lives in</a> the old thread that instantiated it, not in the new thread that calls <a href="./qthread.htm#run" translate="no">run</a>(). This means that all of QThread's queued slots and <a href="./qmetaobject.htm#invokeMethod" translate="no">invoked methods</a> will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed QThread.</p>
<p>Unlike queued slots or invoked methods, methods called directly on the QThread object will execute in the thread that calls the method. When subclassing QThread, keep in mind that the constructor executes in the old thread while <a href="./qthread.htm#run" translate="no">run</a>() executes in the new thread. If a member variable is accessed from both functions, then the variable is accessed from two different threads. Check that it is safe to do so.</p>
<div class="admonition note">
<p><b>Note: </b>Care must be taken when interacting with objects across different threads. As a general rule, functions can only be called from the thread that created the QThread object itself (e.g. <a href="./qthread.htm#setPriority" translate="no">setPriority</a>()), unless the documentation says otherwise. See <a href="./threads-synchronizing.htm" translate="no">Synchronizing Threads</a> for details.</p>
</div>
<a name="managing-threads"></a>
<h3 id="managing-threads">Managing Threads<a class="plink" href="#managing-threads" title="Direct link to this headline"></a></h3>
<p>QThread will notify you via a signal when the thread is <a href="./qthread.htm#started" translate="no">started</a>() and <a href="./qthread.htm#finished" translate="no">finished</a>(), or you can use <a href="./qthread.htm#isFinished" translate="no">isFinished</a>() and <a href="./qthread.htm#isRunning" translate="no">isRunning</a>() to query the state of the thread.</p>
<p>You can stop the thread by calling <a href="./qthread.htm#exit" translate="no">exit</a>() or <a href="./qthread.htm#quit" translate="no">quit</a>(). In extreme cases, you may want to forcibly <a href="./qthread.htm#terminate" translate="no">terminate</a>() an executing thread. However, doing so is dangerous and discouraged. Please read the documentation for <a href="./qthread.htm#terminate" translate="no">terminate</a>() and <a href="./qthread.htm#setTerminationEnabled" translate="no">setTerminationEnabled</a>() for detailed information.</p>
<p>From Qt 4.8 onwards, it is possible to deallocate objects that live in a thread that has just ended, by connecting the <a href="./qthread.htm#finished" translate="no">finished</a>() signal to <a href="./qobject.htm#deleteLater" translate="no">QObject::deleteLater</a>().</p>
<p>Use <a href="./qthread.htm#wait" translate="no">wait</a>() to block the calling thread, until the other thread has finished execution (or until a specified time has passed).</p>
<p>QThread also provides static, platform independent sleep functions: <a href="./qthread.htm#sleep" translate="no">sleep</a>(), <a href="./qthread.htm#msleep" translate="no">msleep</a>(), and <a href="./qthread.htm#usleep" translate="no">usleep</a>() allow full second, millisecond, and microsecond resolution respectively. These functions were made public in Qt 5.0.</p>
<div class="admonition note">
<p><b>Note: </b><a href="./qthread.htm#wait" translate="no">wait</a>() and the <a href="./qthread.htm#sleep" translate="no">sleep</a>() functions should be unnecessary in general, since Qt is an event-driven framework. Instead of <a href="./qthread.htm#wait" translate="no">wait</a>(), consider listening for the <a href="./qthread.htm#finished" translate="no">finished</a>() signal. Instead of the <a href="./qthread.htm#sleep" translate="no">sleep</a>() functions, consider using <a href="./qtimer.htm" translate="no">QTimer</a>.</p>
</div>
<p>The static functions <a href="./qthread.htm#currentThreadId" translate="no">currentThreadId</a>() and <a href="./qthread.htm#currentThread" translate="no">currentThread</a>() return identifiers for the currently executing thread. The former returns a platform specific ID for the thread; the latter returns a QThread pointer.</p>
<p>To choose the name that your thread will be given (as identified by the command <code translate="no">ps -L</code> on Linux, for example), you can call <a href="./qobject.htm#objectName-prop" translate="no">setObjectName()</a> before starting the thread. If you don't call <a href="./qobject.htm#objectName-prop" translate="no">setObjectName()</a>, the name given to your thread will be the class name of the runtime type of your thread object (for example, <code translate="no">"RenderThread"</code> in the case of the <a href="./qtcore-threads-mandelbrot-example.htm" translate="no">Mandelbrot Example</a>, as that is the name of the QThread subclass). Note that this is currently not available with release builds on Windows.</p>
</div>
<p><b>See also </b><a href="./threads.htm" translate="no">Thread Support in Qt</a>, <a href="./qthreadstorage.htm" translate="no">QThreadStorage</a>, <a href="./threads-synchronizing.htm" translate="no">Synchronizing Threads</a>, <a href="./qtcore-threads-mandelbrot-example.htm" translate="no">Mandelbrot Example</a>, <a href="./qtcore-threads-semaphores-example.htm" translate="no">Semaphores Example</a>, and <a href="./qtcore-threads-waitconditions-example.htm" translate="no">Wait Conditions Example</a>.</p>
<!-- @@@QThread -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Priority$$$IdlePriority$$$LowestPriority$$$LowPriority$$$NormalPriority$$$HighPriority$$$HighestPriority$$$TimeCriticalPriority$$$InheritPriority -->
<h3 class="fn" id="Priority-enum" translate="no"><a name="Priority-enum"></a>enum QThread::<span class="name">Priority</span><a class="plink" href="#Priority-enum" title="Direct link to this headline"></a></h3>
<p>This enum type indicates how the operating system should schedule newly created threads.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QThread::IdlePriority</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">scheduled only when no other threads are running.</td></tr>
<tr><td class="topAlign"><code translate="no">QThread::LowestPriority</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">scheduled less often than LowPriority.</td></tr>
<tr><td class="topAlign"><code translate="no">QThread::LowPriority</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">scheduled less often than NormalPriority.</td></tr>
<tr><td class="topAlign"><code translate="no">QThread::NormalPriority</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">the default priority of the operating system.</td></tr>
<tr><td class="topAlign"><code translate="no">QThread::HighPriority</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">scheduled more often than NormalPriority.</td></tr>
<tr><td class="topAlign"><code translate="no">QThread::HighestPriority</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">scheduled more often than HighPriority.</td></tr>
<tr><td class="topAlign"><code translate="no">QThread::TimeCriticalPriority</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">scheduled as often as possible.</td></tr>
<tr><td class="topAlign"><code translate="no">QThread::InheritPriority</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">use the same priority as the creating thread. This is the default.</td></tr>
</tbody></table></div>
<!-- @@@Priority -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QThread[overload1]$$$QThreadQObject* -->
<h3 class="fn" id="QThread" translate="no"><a name="QThread"></a>QThread::<span class="name">QThread</span>(<span class="type"><a href="./qobject.htm#QObject" translate="no">QObject</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QThread" title="Direct link to this headline"></a></h3>
<p>Constructs a new QThread to manage a new thread. The <i translate="no">parent</i> takes ownership of the QThread. The thread does not begin executing until <a href="./qthread.htm#start" translate="no">start</a>() is called.</p>
<p><b>See also </b><a href="./qthread.htm#start" translate="no">start</a>().</p>
<!-- @@@QThread -->
<!-- $$$finished[overload1]$$$finished -->
<h3 class="fn" id="finished" translate="no"><a name="finished"></a><code translate="no">[signal] </code><span class="type">void</span> QThread::<span class="name">finished</span>()<a class="plink" href="#finished" title="Direct link to this headline"></a></h3>
<p>This signal is emitted from the associated thread right before it finishes executing.</p>
<p>When this signal is emitted, the event loop has already stopped running. No more events will be processed in the thread, except for deferred deletion events. This signal can be connected to <a href="./qobject.htm#deleteLater" translate="no">QObject::deleteLater</a>(), to free objects in that thread.</p>
<div class="admonition note">
<p><b>Note: </b>If the associated thread was terminated using <a href="./qthread.htm#terminate" translate="no">terminate</a>(), it is undefined from which thread this signal is emitted.</p>
</div>
<p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
<p><b>See also </b><a href="./qthread.htm#started" translate="no">started</a>().</p>
<!-- @@@finished -->
<!-- $$$quit[overload1]$$$quit -->
<h3 class="fn" id="quit" translate="no"><a name="quit"></a><code translate="no">[slot] </code><span class="type">void</span> QThread::<span class="name">quit</span>()<a class="plink" href="#quit" title="Direct link to this headline"></a></h3>
<p>Tells the thread's event loop to exit with return code 0 (success). Equivalent to calling <a href="./qthread.htm#exit" translate="no">QThread::exit</a>(0).</p>
<p>This function does nothing if the thread does not have an event loop.</p>
<p><b>Note:</b> This function is <a href="./threads-reentrancy.htm" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="./qthread.htm#exit" translate="no">exit</a>() and <a href="./qeventloop.htm" translate="no">QEventLoop</a>.</p>
<!-- @@@quit -->
<!-- $$$start[overload1]$$$startQThread::Priority -->
<h3 class="fn" id="start" translate="no"><a name="start"></a><code translate="no">[slot] </code><span class="type">void</span> QThread::<span class="name">start</span>(<span class="type"><a href="./qthread.htm#Priority-enum" translate="no">QThread::Priority</a></span> <i>priority</i> = InheritPriority)<a class="plink" href="#start" title="Direct link to this headline"></a></h3>
<p>Begins execution of the thread by calling <a href="./qthread.htm#run" translate="no">run</a>(). The operating system will schedule the thread according to the <i translate="no">priority</i> parameter. If the thread is already running, this function does nothing.</p>
<p>The effect of the <i translate="no">priority</i> parameter is dependent on the operating system's scheduling policy. In particular, the <i translate="no">priority</i> will be ignored on systems that do not support thread priorities (such as on Linux, see the <a href="http://linux.die.net/man/2/sched_setscheduler" translate="no">sched_setscheduler</a> documentation for more details).</p>
<p><b>See also </b><a href="./qthread.htm#run" translate="no">run</a>() and <a href="./qthread.htm#terminate" translate="no">terminate</a>().</p>
<!-- @@@start -->
<!-- $$$started[overload1]$$$started -->
<h3 class="fn" id="started" translate="no"><a name="started"></a><code translate="no">[signal] </code><span class="type">void</span> QThread::<span class="name">started</span>()<a class="plink" href="#started" title="Direct link to this headline"></a></h3>
<p>This signal is emitted from the associated thread when it starts executing, before the <a href="./qthread.htm#run" translate="no">run</a>() function is called.</p>
<p><b>Note: </b>This is a private signal. It can be used in signal connections but cannot be emitted by the user.</p>
<p><b>See also </b><a href="./qthread.htm#finished" translate="no">finished</a>().</p>
<!-- @@@started -->
<!-- $$$terminate[overload1]$$$terminate -->
<h3 class="fn" id="terminate" translate="no"><a name="terminate"></a><code translate="no">[slot] </code><span class="type">void</span> QThread::<span class="name">terminate</span>()<a class="plink" href="#terminate" title="Direct link to this headline"></a></h3>
<p>Terminates the execution of the thread. The thread may or may not be terminated immediately, depending on the operating system's scheduling policies. Use <a href="./qthread.htm#wait" translate="no">QThread::wait</a>() after terminate(), to be sure.</p>
<p>When the thread is terminated, all threads waiting for the thread to finish will be woken up.</p>
<div class="admonition warning">
<p><b>Warning: </b>This function is dangerous and its use is discouraged. The thread can be terminated at any point in its code path. Threads can be terminated while modifying data. There is no chance for the thread to clean up after itself, unlock any held mutexes, etc. In short, use this function only if absolutely necessary.</p>
</div>
<p>Termination can be explicitly enabled or disabled by calling <a href="./qthread.htm#setTerminationEnabled" translate="no">QThread::setTerminationEnabled</a>(). Calling this function while termination is disabled results in the termination being deferred, until termination is re-enabled. See the documentation of <a href="./qthread.htm#setTerminationEnabled" translate="no">QThread::setTerminationEnabled</a>() for more information.</p>
<p><b>Note:</b> This function is <a href="./threads-reentrancy.htm" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="./qthread.htm#setTerminationEnabled" translate="no">setTerminationEnabled</a>().</p>
<!-- @@@terminate -->
<!-- $$$~QThread[overload1]$$$~QThread -->
<h3 class="fn" id="dtor.QThread" translate="no"><a name="dtor.QThread"></a><code translate="no">[virtual] </code>QThread::<span class="name">~QThread</span>()<a class="plink" href="#dtor.QThread" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qthread.htm" translate="no">QThread</a>.</p>
<p>Note that deleting a <a href="./qthread.htm" translate="no">QThread</a> object will not stop the execution of the thread it manages. Deleting a running <a href="./qthread.htm" translate="no">QThread</a> (i.e. <a href="./qthread.htm#isFinished" translate="no">isFinished</a>() returns <code translate="no">false</code>) will result in a program crash. Wait for the <a href="./qthread.htm#finished" translate="no">finished</a>() signal before deleting the <a href="./qthread.htm" translate="no">QThread</a>.</p>
<!-- @@@~QThread -->
<!-- $$$create[overload1]$$$createFunction&&Args&&... -->
<h3 class="fn" id="create" translate="no"><a name="create"></a><code translate="no">[static] </code>template &lt;typename Function, typename Args&gt; <span class="type"><a href="./qthread.htm#QThread" translate="no">QThread</a></span> *QThread::<span class="name">create</span>(<span class="type">Function</span> &amp;&amp;<i>f</i>, <span class="type">Args</span> &amp;&amp;... <i>args</i>)<a class="plink" href="#create" title="Direct link to this headline"></a></h3>
<p>Creates a new <a href="./qthread.htm" translate="no">QThread</a> object that will execute the function <i translate="no">f</i> with the arguments <i translate="no">args</i>.</p>
<p>The new thread is not started -- it must be started by an explicit call to <a href="./qthread.htm#start" translate="no">start</a>(). This allows you to connect to its signals, move QObjects to the thread, choose the new thread's priority and so on. The function <i translate="no">f</i> will be called in the new thread.</p>
<p>Returns the newly created <a href="./qthread.htm" translate="no">QThread</a> instance.</p>
<div class="admonition note">
<p><b>Note: </b>the caller acquires ownership of the returned <a href="./qthread.htm" translate="no">QThread</a> instance.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>this function is only available when using C++17.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>do not call <a href="./qthread.htm#start" translate="no">start</a>() on the returned <a href="./qthread.htm" translate="no">QThread</a> instance more than once; doing so will result in undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qthread.htm#start" translate="no">start</a>().</p>
<!-- @@@create -->
<!-- $$$create$$$createFunction&& -->
<h3 class="fn" id="create-1" translate="no"><a name="create-1"></a><code translate="no">[static] </code>template &lt;typename Function&gt; <span class="type"><a href="./qthread.htm#QThread" translate="no">QThread</a></span> *QThread::<span class="name">create</span>(<span class="type">Function</span> &amp;&amp;<i>f</i>)<a class="plink" href="#create-1" title="Direct link to this headline"></a></h3>
<p>Creates a new <a href="./qthread.htm" translate="no">QThread</a> object that will execute the function <i translate="no">f</i>.</p>
<p>The new thread is not started -- it must be started by an explicit call to <a href="./qthread.htm#start" translate="no">start</a>(). This allows you to connect to its signals, move QObjects to the thread, choose the new thread's priority and so on. The function <i translate="no">f</i> will be called in the new thread.</p>
<p>Returns the newly created <a href="./qthread.htm" translate="no">QThread</a> instance.</p>
<div class="admonition note">
<p><b>Note: </b>the caller acquires ownership of the returned <a href="./qthread.htm" translate="no">QThread</a> instance.</p>
</div>
<div class="admonition warning">
<p><b>Warning: </b>do not call <a href="./qthread.htm#start" translate="no">start</a>() on the returned <a href="./qthread.htm" translate="no">QThread</a> instance more than once; doing so will result in undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qthread.htm#start" translate="no">start</a>().</p>
<!-- @@@create -->
<!-- $$$currentThread[overload1]$$$currentThread -->
<h3 class="fn" id="currentThread" translate="no"><a name="currentThread"></a><code translate="no">[static] </code><span class="type"><a href="./qthread.htm#QThread" translate="no">QThread</a></span> *QThread::<span class="name">currentThread</span>()<a class="plink" href="#currentThread" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to a <a href="./qthread.htm" translate="no">QThread</a> which manages the currently executing thread.</p>
<!-- @@@currentThread -->
<!-- $$$currentThreadId[overload1]$$$currentThreadId -->
<h3 class="fn" id="currentThreadId" translate="no"><a name="currentThreadId"></a><code translate="no">[static] </code><span class="type"><a href="./qt.htm#HANDLE-typedef" translate="no">Qt::HANDLE</a></span> QThread::<span class="name">currentThreadId</span>()<a class="plink" href="#currentThreadId" title="Direct link to this headline"></a></h3>
<p>Returns the thread handle of the currently executing thread.</p>
<div class="admonition warning">
<p><b>Warning: </b>The handle returned by this function is used for internal purposes and should not be used in any application code.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>On Windows, this function returns the DWORD (Windows-Thread ID) returned by the Win32 function GetCurrentThreadId(), not the pseudo-HANDLE (Windows-Thread HANDLE) returned by the Win32 function GetCurrentThread().</p>
</div>
<!-- @@@currentThreadId -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event" translate="no"><a name="event"></a><code translate="no">[override virtual] </code><span class="type">bool</span> QThread::<span class="name">event</span>(<span class="type"><a href="./qevent.htm" translate="no">QEvent</a></span> *<i>event</i>)<a class="plink" href="#event" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qobject.htm#event" translate="no">QObject::event</a>(QEvent *e).</p>
<!-- @@@event -->
<!-- $$$eventDispatcher[overload1]$$$eventDispatcher -->
<h3 class="fn" id="eventDispatcher" translate="no"><a name="eventDispatcher"></a><span class="type"><a href="./qabstracteventdispatcher.htm" translate="no">QAbstractEventDispatcher</a></span> *QThread::<span class="name">eventDispatcher</span>() const<a class="plink" href="#eventDispatcher" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the event dispatcher object for the thread. If no event dispatcher exists for the thread, this function returns <code translate="no">nullptr</code>.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qthread.htm#setEventDispatcher" translate="no">setEventDispatcher</a>().</p>
<!-- @@@eventDispatcher -->
<!-- $$$exec[overload1]$$$exec -->
<h3 class="fn" id="exec" translate="no"><a name="exec"></a><code translate="no">[protected] </code><span class="type">int</span> QThread::<span class="name">exec</span>()<a class="plink" href="#exec" title="Direct link to this headline"></a></h3>
<p>Enters the event loop and waits until <a href="./qthread.htm#exit" translate="no">exit</a>() is called, returning the value that was passed to <a href="./qthread.htm#exit" translate="no">exit</a>(). The value returned is 0 if <a href="./qthread.htm#exit" translate="no">exit</a>() is called via <a href="./qthread.htm#quit" translate="no">quit</a>().</p>
<p>This function is meant to be called from within <a href="./qthread.htm#run" translate="no">run</a>(). It is necessary to call this function to start event handling.</p>
<div class="admonition note">
<p><b>Note: </b>This can only be called within the thread itself, i.e. when it is the current thread.</p>
</div>
<p><b>See also </b><a href="./qthread.htm#quit" translate="no">quit</a>() and <a href="./qthread.htm#exit" translate="no">exit</a>().</p>
<!-- @@@exec -->
<!-- $$$exit[overload1]$$$exitint -->
<h3 class="fn" id="exit" translate="no"><a name="exit"></a><span class="type">void</span> QThread::<span class="name">exit</span>(<span class="type">int</span> <i>returnCode</i> = 0)<a class="plink" href="#exit" title="Direct link to this headline"></a></h3>
<p>Tells the thread's event loop to exit with a return code.</p>
<p>After calling this function, the thread leaves the event loop and returns from the call to <a href="./qeventloop.htm#exec" translate="no">QEventLoop::exec</a>(). The <a href="./qeventloop.htm#exec" translate="no">QEventLoop::exec</a>() function returns <i translate="no">returnCode</i>.</p>
<p>By convention, a <i translate="no">returnCode</i> of 0 means success, any non-zero value indicates an error.</p>
<p>Note that unlike the C library function of the same name, this function <i>does</i> return to the caller -- it is event processing that stops.</p>
<p>No QEventLoops will be started anymore in this thread until <a href="./qthread.htm#exec" translate="no">QThread::exec</a>() has been called again. If the eventloop in <a href="./qthread.htm#exec" translate="no">QThread::exec</a>() is not running then the next call to <a href="./qthread.htm#exec" translate="no">QThread::exec</a>() will also return immediately.</p>
<p><b>Note:</b> This function is <a href="./threads-reentrancy.htm" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="./qthread.htm#quit" translate="no">quit</a>() and <a href="./qeventloop.htm" translate="no">QEventLoop</a>.</p>
<!-- @@@exit -->
<!-- $$$idealThreadCount[overload1]$$$idealThreadCount -->
<h3 class="fn" id="idealThreadCount" translate="no"><a name="idealThreadCount"></a><code translate="no">[static] </code><span class="type">int</span> QThread::<span class="name">idealThreadCount</span>()<a class="plink" href="#idealThreadCount" title="Direct link to this headline"></a></h3>
<p>Returns the ideal number of threads that can be run on the system. This is done querying the number of processor cores, both real and logical, in the system. This function returns 1 if the number of processor cores could not be detected.</p>
<!-- @@@idealThreadCount -->
<!-- $$$isFinished[overload1]$$$isFinished -->
<h3 class="fn" id="isFinished" translate="no"><a name="isFinished"></a><span class="type">bool</span> QThread::<span class="name">isFinished</span>() const<a class="plink" href="#isFinished" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the thread is finished; otherwise returns <code translate="no">false</code>.</p>
<p><b>Note:</b> This function is <a href="./threads-reentrancy.htm" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="./qthread.htm#isRunning" translate="no">isRunning</a>().</p>
<!-- @@@isFinished -->
<!-- $$$isInterruptionRequested[overload1]$$$isInterruptionRequested -->
<h3 class="fn" id="isInterruptionRequested" translate="no"><a name="isInterruptionRequested"></a><span class="type">bool</span> QThread::<span class="name">isInterruptionRequested</span>() const<a class="plink" href="#isInterruptionRequested" title="Direct link to this headline"></a></h3>
<p>Return true if the task running on this thread should be stopped. An interruption can be requested by <a href="./qthread.htm#requestInterruption" translate="no">requestInterruption</a>().</p>
<p>This function can be used to make long running tasks cleanly interruptible. Never checking or acting on the value returned by this function is safe, however it is advisable do so regularly in long running functions. Take care not to call it too often, to keep the overhead low.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> long_task() {
     forever {
        <span class="keyword">if</span> ( <span class="type"><a href="./qthread.htm#QThread" translate="no">QThread</a></span><span class="operator">::</span>currentThread()<span class="operator">-</span><span class="operator">&gt;</span>isInterruptionRequested() ) {
            <span class="keyword">return</span>;
        }
    }
}</pre></div>
<div class="admonition note">
<p><b>Note: </b>This can only be called within the thread itself, i.e. when it is the current thread.</p>
</div>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qthread.htm#currentThread" translate="no">currentThread</a>() and <a href="./qthread.htm#requestInterruption" translate="no">requestInterruption</a>().</p>
<!-- @@@isInterruptionRequested -->
<!-- $$$isRunning[overload1]$$$isRunning -->
<h3 class="fn" id="isRunning" translate="no"><a name="isRunning"></a><span class="type">bool</span> QThread::<span class="name">isRunning</span>() const<a class="plink" href="#isRunning" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the thread is running; otherwise returns <code translate="no">false</code>.</p>
<p><b>Note:</b> This function is <a href="./threads-reentrancy.htm" translate="no">thread-safe</a>.</p>
<p><b>See also </b><a href="./qthread.htm#isFinished" translate="no">isFinished</a>().</p>
<!-- @@@isRunning -->
<!-- $$$loopLevel[overload1]$$$loopLevel -->
<h3 class="fn" id="loopLevel" translate="no"><a name="loopLevel"></a><span class="type">int</span> QThread::<span class="name">loopLevel</span>() const<a class="plink" href="#loopLevel" title="Direct link to this headline"></a></h3>
<p>Returns the current event loop level for the thread.</p>
<div class="admonition note">
<p><b>Note: </b>This can only be called within the thread itself, i.e. when it is the current thread.</p>
</div>
<p>This function was introduced in Qt 5.5.</p>
<!-- @@@loopLevel -->
<!-- $$$msleep[overload1]$$$msleepunsignedlong -->
<h3 class="fn" id="msleep" translate="no"><a name="msleep"></a><code translate="no">[static] </code><span class="type">void</span> QThread::<span class="name">msleep</span>(<span class="type">unsigned</span> <span class="type">long</span> <i>msecs</i>)<a class="plink" href="#msleep" title="Direct link to this headline"></a></h3>
<p>Forces the current thread to sleep for <i translate="no">msecs</i> milliseconds.</p>
<p>Avoid using this function if you need to wait for a given condition to change. Instead, connect a slot to the signal that indicates the change or use an event handler (see <a href="./qobject.htm#event" translate="no">QObject::event</a>()).</p>
<div class="admonition note">
<p><b>Note: </b>This function does not guarantee accuracy. The application may sleep longer than <i translate="no">msecs</i> under heavy load conditions. Some OSes might round <i translate="no">msecs</i> up to 10 ms or 15 ms.</p>
</div>
<p><b>See also </b><a href="./qthread.htm#sleep" translate="no">sleep</a>() and <a href="./qthread.htm#usleep" translate="no">usleep</a>().</p>
<!-- @@@msleep -->
<!-- $$$priority[overload1]$$$priority -->
<h3 class="fn" id="priority" translate="no"><a name="priority"></a><span class="type"><a href="./qthread.htm#Priority-enum" translate="no">QThread::Priority</a></span> QThread::<span class="name">priority</span>() const<a class="plink" href="#priority" title="Direct link to this headline"></a></h3>
<p>Returns the priority for a running thread. If the thread is not running, this function returns <code translate="no">InheritPriority</code>.</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also </b><a href="./qthread.htm#Priority-enum" translate="no">Priority</a>, <a href="./qthread.htm#setPriority" translate="no">setPriority</a>(), and <a href="./qthread.htm#start" translate="no">start</a>().</p>
<!-- @@@priority -->
<!-- $$$requestInterruption[overload1]$$$requestInterruption -->
<h3 class="fn" id="requestInterruption" translate="no"><a name="requestInterruption"></a><span class="type">void</span> QThread::<span class="name">requestInterruption</span>()<a class="plink" href="#requestInterruption" title="Direct link to this headline"></a></h3>
<p>Request the interruption of the thread. That request is advisory and it is up to code running on the thread to decide if and how it should act upon such request. This function does not stop any event loop running on the thread and does not terminate it in any way.</p>
<p><b>Note:</b> This function is <a href="./threads-reentrancy.htm" translate="no">thread-safe</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qthread.htm#isInterruptionRequested" translate="no">isInterruptionRequested</a>().</p>
<!-- @@@requestInterruption -->
<!-- $$$run[overload1]$$$run -->
<h3 class="fn" id="run" translate="no"><a name="run"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QThread::<span class="name">run</span>()<a class="plink" href="#run" title="Direct link to this headline"></a></h3>
<p>The starting point for the thread. After calling <a href="./qthread.htm#start" translate="no">start</a>(), the newly created thread calls this function. The default implementation simply calls <a href="./qthread.htm#exec" translate="no">exec</a>().</p>
<p>You can reimplement this function to facilitate advanced thread management. Returning from this method will end the execution of the thread.</p>
<p><b>See also </b><a href="./qthread.htm#start" translate="no">start</a>() and <a href="./qthread.htm#wait" translate="no">wait</a>().</p>
<!-- @@@run -->
<!-- $$$setEventDispatcher[overload1]$$$setEventDispatcherQAbstractEventDispatcher* -->
<h3 class="fn" id="setEventDispatcher" translate="no"><a name="setEventDispatcher"></a><span class="type">void</span> QThread::<span class="name">setEventDispatcher</span>(<span class="type"><a href="./qabstracteventdispatcher.htm" translate="no">QAbstractEventDispatcher</a></span> *<i>eventDispatcher</i>)<a class="plink" href="#setEventDispatcher" title="Direct link to this headline"></a></h3>
<p>Sets the event dispatcher for the thread to <i translate="no">eventDispatcher</i>. This is only possible as long as there is no event dispatcher installed for the thread yet. That is, before the thread has been started with <a href="./qthread.htm#start" translate="no">start</a>() or, in case of the main thread, before <a href="./qcoreapplication.htm" translate="no">QCoreApplication</a> has been instantiated. This method takes ownership of the object.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qthread.htm#eventDispatcher" translate="no">eventDispatcher</a>().</p>
<!-- @@@setEventDispatcher -->
<!-- $$$setPriority[overload1]$$$setPriorityQThread::Priority -->
<h3 class="fn" id="setPriority" translate="no"><a name="setPriority"></a><span class="type">void</span> QThread::<span class="name">setPriority</span>(<span class="type"><a href="./qthread.htm#Priority-enum" translate="no">QThread::Priority</a></span> <i>priority</i>)<a class="plink" href="#setPriority" title="Direct link to this headline"></a></h3>
<p>This function sets the <i translate="no">priority</i> for a running thread. If the thread is not running, this function does nothing and returns immediately. Use <a href="./qthread.htm#start" translate="no">start</a>() to start a thread with a specific priority.</p>
<p>The <i translate="no">priority</i> argument can be any value in the <code translate="no">QThread::Priority</code> enum except for <code translate="no">InheritPriority</code>.</p>
<p>The effect of the <i translate="no">priority</i> parameter is dependent on the operating system's scheduling policy. In particular, the <i translate="no">priority</i> will be ignored on systems that do not support thread priorities (such as on Linux, see http://linux.die.net/man/2/sched_setscheduler for more details).</p>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also </b><a href="./qthread.htm#Priority-enum" translate="no">Priority</a>, <a href="./qthread.htm#priority" translate="no">priority</a>(), and <a href="./qthread.htm#start" translate="no">start</a>().</p>
<!-- @@@setPriority -->
<!-- $$$setStackSize[overload1]$$$setStackSizeuint -->
<h3 class="fn" id="setStackSize" translate="no"><a name="setStackSize"></a><span class="type">void</span> QThread::<span class="name">setStackSize</span>(<span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>stackSize</i>)<a class="plink" href="#setStackSize" title="Direct link to this headline"></a></h3>
<p>Sets the maximum stack size for the thread to <i translate="no">stackSize</i>. If <i translate="no">stackSize</i> is greater than zero, the maximum stack size is set to <i translate="no">stackSize</i> bytes, otherwise the maximum stack size is automatically determined by the operating system.</p>
<div class="admonition warning">
<p><b>Warning: </b>Most operating systems place minimum and maximum limits on thread stack sizes. The thread will fail to start if the stack size is outside these limits.</p>
</div>
<p><b>See also </b><a href="./qthread.htm#stackSize" translate="no">stackSize</a>().</p>
<!-- @@@setStackSize -->
<!-- $$$setTerminationEnabled[overload1]$$$setTerminationEnabledbool -->
<h3 class="fn" id="setTerminationEnabled" translate="no"><a name="setTerminationEnabled"></a><code translate="no">[static protected] </code><span class="type">void</span> QThread::<span class="name">setTerminationEnabled</span>(<span class="type">bool</span> <i>enabled</i> = true)<a class="plink" href="#setTerminationEnabled" title="Direct link to this headline"></a></h3>
<p>Enables or disables termination of the current thread based on the <i translate="no">enabled</i> parameter. The thread must have been started by <a href="./qthread.htm" translate="no">QThread</a>.</p>
<p>When <i translate="no">enabled</i> is false, termination is disabled. Future calls to <a href="./qthread.htm#terminate" translate="no">QThread::terminate</a>() will return immediately without effect. Instead, the termination is deferred until termination is enabled.</p>
<p>When <i translate="no">enabled</i> is true, termination is enabled. Future calls to <a href="./qthread.htm#terminate" translate="no">QThread::terminate</a>() will terminate the thread normally. If termination has been deferred (i.e. <a href="./qthread.htm#terminate" translate="no">QThread::terminate</a>() was called with termination disabled), this function will terminate the calling thread <i>immediately</i>. Note that this function will not return in this case.</p>
<p><b>See also </b><a href="./qthread.htm#terminate" translate="no">terminate</a>().</p>
<!-- @@@setTerminationEnabled -->
<!-- $$$sleep[overload1]$$$sleepunsignedlong -->
<h3 class="fn" id="sleep" translate="no"><a name="sleep"></a><code translate="no">[static] </code><span class="type">void</span> QThread::<span class="name">sleep</span>(<span class="type">unsigned</span> <span class="type">long</span> <i>secs</i>)<a class="plink" href="#sleep" title="Direct link to this headline"></a></h3>
<p>Forces the current thread to sleep for <i translate="no">secs</i> seconds.</p>
<p>Avoid using this function if you need to wait for a given condition to change. Instead, connect a slot to the signal that indicates the change or use an event handler (see <a href="./qobject.htm#event" translate="no">QObject::event</a>()).</p>
<div class="admonition note">
<p><b>Note: </b>This function does not guarantee accuracy. The application may sleep longer than <i translate="no">secs</i> under heavy load conditions.</p>
</div>
<p><b>See also </b><a href="./qthread.htm#msleep" translate="no">msleep</a>() and <a href="./qthread.htm#usleep" translate="no">usleep</a>().</p>
<!-- @@@sleep -->
<!-- $$$stackSize[overload1]$$$stackSize -->
<h3 class="fn" id="stackSize" translate="no"><a name="stackSize"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> QThread::<span class="name">stackSize</span>() const<a class="plink" href="#stackSize" title="Direct link to this headline"></a></h3>
<p>Returns the maximum stack size for the thread (if set with <a href="./qthread.htm#setStackSize" translate="no">setStackSize</a>()); otherwise returns zero.</p>
<p><b>See also </b><a href="./qthread.htm#setStackSize" translate="no">setStackSize</a>().</p>
<!-- @@@stackSize -->
<!-- $$$usleep[overload1]$$$usleepunsignedlong -->
<h3 class="fn" id="usleep" translate="no"><a name="usleep"></a><code translate="no">[static] </code><span class="type">void</span> QThread::<span class="name">usleep</span>(<span class="type">unsigned</span> <span class="type">long</span> <i>usecs</i>)<a class="plink" href="#usleep" title="Direct link to this headline"></a></h3>
<p>Forces the current thread to sleep for <i translate="no">usecs</i> microseconds.</p>
<p>Avoid using this function if you need to wait for a given condition to change. Instead, connect a slot to the signal that indicates the change or use an event handler (see <a href="./qobject.htm#event" translate="no">QObject::event</a>()).</p>
<div class="admonition note">
<p><b>Note: </b>This function does not guarantee accuracy. The application may sleep longer than <i translate="no">usecs</i> under heavy load conditions. Some OSes might round <i translate="no">usecs</i> up to 10 ms or 15 ms; on Windows, it will be rounded up to a multiple of 1 ms.</p>
</div>
<p><b>See also </b><a href="./qthread.htm#sleep" translate="no">sleep</a>() and <a href="./qthread.htm#msleep" translate="no">msleep</a>().</p>
<!-- @@@usleep -->
<!-- $$$wait[overload1]$$$waitQDeadlineTimer -->
<h3 class="fn" id="wait" translate="no"><a name="wait"></a><span class="type">bool</span> QThread::<span class="name">wait</span>(<span class="type"><a href="./qdeadlinetimer.htm" translate="no">QDeadlineTimer</a></span> <i>deadline</i> = QDeadlineTimer(QDeadlineTimer::Forever))<a class="plink" href="#wait" title="Direct link to this headline"></a></h3>
<p>Blocks the thread until either of these conditions is met:</p>
<ul>
<li>The thread associated with this <a href="./qthread.htm" translate="no">QThread</a> object has finished execution (i.e. when it returns from <a href="./qthread.htm#run" translate="no">run</a>()). This function will return true if the thread has finished. It also returns true if the thread has not been started yet.</li>
<li>The <i translate="no">deadline</i> is reached. This function will return false if the deadline is reached.</li>
</ul>
<p>A deadline timer set to <code translate="no">QDeadlineTimer::Forever</code> (the default) will never time out: in this case, the function only returns when the thread returns from <a href="./qthread.htm#run" translate="no">run</a>() or if the thread has not yet started.</p>
<p>This provides similar functionality to the POSIX <code translate="no">pthread_join()</code> function.</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qthread.htm#sleep" translate="no">sleep</a>() and <a href="./qthread.htm#terminate" translate="no">terminate</a>().</p>
<!-- @@@wait -->
<!-- $$$wait$$$waitunsignedlong -->
<h3 class="fn" id="wait-1" translate="no"><a name="wait-1"></a><span class="type">bool</span> QThread::<span class="name">wait</span>(<span class="type">unsigned</span> <span class="type">long</span> <i>time</i>)<a class="plink" href="#wait-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@wait -->
<!-- $$$yieldCurrentThread[overload1]$$$yieldCurrentThread -->
<h3 class="fn" id="yieldCurrentThread" translate="no"><a name="yieldCurrentThread"></a><code translate="no">[static] </code><span class="type">void</span> QThread::<span class="name">yieldCurrentThread</span>()<a class="plink" href="#yieldCurrentThread" title="Direct link to this headline"></a></h3>
<p>Yields execution of the current thread to another runnable thread, if any. Note that the operating system decides to which thread to switch.</p>
<!-- @@@yieldCurrentThread -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>