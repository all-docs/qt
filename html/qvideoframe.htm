<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QVideoFrame | Qt Multimedia</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qvideoframe.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtmultimedia-index.htm" translate="no">Qt Multimedia</a></li>
                            <li><a href="./qtmultimedia-modules.htm" translate="no">C++ Classes</a></li>
                            <li><a>QVideoFrame</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QVideoFrame Class</h1>
<!-- $$$QVideoFrame-brief -->
<p>The QVideoFrame class represents a frame of video data. <a href="#details">More...</a></p>
<!-- @@@QVideoFrame -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QVideoFrame&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += multimedia</td></tr></tbody></table></div><ul>
<li><a href="./qvideoframe-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#FieldType-enum" translate="no">FieldType</a></b> { ProgressiveFrame, TopField, BottomField, InterlacedFrame }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#PixelFormat-enum" translate="no">PixelFormat</a></b> { Format_Invalid, Format_ARGB32, Format_ARGB32_Premultiplied, Format_RGB32, Format_RGB24, â€¦, Format_User }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#QVideoFrame-4" translate="no">QVideoFrame</a></b>(const QVideoFrame &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#QVideoFrame-3" translate="no">QVideoFrame</a></b>(const QImage &amp;<i>image</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#QVideoFrame-2" translate="no">QVideoFrame</a></b>(int <i>bytes</i>, const QSize &amp;<i>size</i>, int <i>bytesPerLine</i>, QVideoFrame::PixelFormat <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#QVideoFrame-1" translate="no">QVideoFrame</a></b>(QAbstractVideoBuffer *<i>buffer</i>, const QSize &amp;<i>size</i>, QVideoFrame::PixelFormat <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#QVideoFrame" translate="no">QVideoFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVideoFrame &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#operator-eq" translate="no">operator=</a></b>(const QVideoFrame &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#dtor.QVideoFrame" translate="no">~QVideoFrame</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariantMap </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#availableMetaData" translate="no">availableMetaData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uchar *</td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#bits" translate="no">bits</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uchar *</td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#bits-1" translate="no">bits</a></b>(int <i>plane</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const uchar *</td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#bits-2" translate="no">bits</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const uchar *</td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#bits-3" translate="no">bits</a></b>(int <i>plane</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractVideoBuffer *</td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#buffer" translate="no">buffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#bytesPerLine" translate="no">bytesPerLine</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#bytesPerLine-1" translate="no">bytesPerLine</a></b>(int <i>plane</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#endTime" translate="no">endTime</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVideoFrame::FieldType </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#fieldType" translate="no">fieldType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#handle" translate="no">handle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractVideoBuffer::HandleType </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#handleType" translate="no">handleType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#height" translate="no">height</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#image" translate="no">image</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#isMapped" translate="no">isMapped</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#isReadable" translate="no">isReadable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#isWritable" translate="no">isWritable</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#map" translate="no">map</a></b>(QAbstractVideoBuffer::MapMode <i>mode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractVideoBuffer::MapMode </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#mapMode" translate="no">mapMode</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVariant </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#metaData" translate="no">metaData</a></b>(const QString &amp;<i>key</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVideoFrame::PixelFormat </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#pixelFormat" translate="no">pixelFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#planeCount" translate="no">planeCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#setEndTime" translate="no">setEndTime</a></b>(qint64 <i>time</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#setFieldType" translate="no">setFieldType</a></b>(QVideoFrame::FieldType <i>field</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#setMetaData" translate="no">setMetaData</a></b>(const QString &amp;<i>key</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#setStartTime" translate="no">setStartTime</a></b>(qint64 <i>time</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qint64 </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#startTime" translate="no">startTime</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#unmap" translate="no">unmap</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#width" translate="no">width</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#operator-not-eq" translate="no">operator!=</a></b>(const QVideoFrame &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#operator-eq-eq" translate="no">operator==</a></b>(const QVideoFrame &amp;<i>other</i>) const</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QImage::Format </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#imageFormatFromPixelFormat" translate="no">imageFormatFromPixelFormat</a></b>(QVideoFrame::PixelFormat <i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVideoFrame::PixelFormat </td><td class="memItemRight bottomAlign"><b><a href="./qvideoframe.htm#pixelFormatFromImageFormat" translate="no">pixelFormatFromImageFormat</a></b>(QImage::Format <i>format</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QVideoFrame-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>A QVideoFrame encapsulates the pixel data of a video frame, and information about the frame.</p>
<p>Video frames can come from several places - decoded <a href="./qmediaplayer.htm" translate="no">media</a>, a <a href="./qcamera.htm" translate="no">camera</a>, or generated programmatically. The way pixels are described in these frames can vary greatly, and some pixel formats offer greater compression opportunities at the expense of ease of use.</p>
<p>The pixel contents of a video frame can be mapped to memory using the <a href="./qvideoframe.htm#map" translate="no">map</a>() function. While mapped, the video data can accessed using the <a href="./qvideoframe.htm#bits" translate="no">bits</a>() function, which returns a pointer to a buffer. The total size of this buffer is given by the <a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a>() function, and the size of each line is given by <a href="./qvideoframe.htm#bytesPerLine" translate="no">bytesPerLine</a>(). The return value of the <a href="./qvideoframe.htm#handle" translate="no">handle</a>() function may also be used to access frame data using the internal buffer's native APIs (for example - an OpenGL texture handle).</p>
<p>A video frame can also have timestamp information associated with it. These timestamps can be used by an implementation of <a href="./qabstractvideosurface.htm" translate="no">QAbstractVideoSurface</a> to determine when to start and stop displaying the frame, but not all surfaces might respect this setting.</p>
<p>The video pixel data in a QVideoFrame is encapsulated in a <a href="./qabstractvideobuffer.htm" translate="no">QAbstractVideoBuffer</a>. A QVideoFrame may be constructed from any buffer type by subclassing the <a href="./qabstractvideobuffer.htm" translate="no">QAbstractVideoBuffer</a> class.</p>
<div class="admonition note">
<p><b>Note: </b>Since video frames can be expensive to copy, QVideoFrame is explicitly shared, so any change made to a video frame will also apply to any copies.</p>
</div>
</div>
<!-- @@@QVideoFrame -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$FieldType$$$ProgressiveFrame$$$TopField$$$BottomField$$$InterlacedFrame -->
<h3 class="fn" id="FieldType-enum" translate="no"><a name="FieldType-enum"></a>enum QVideoFrame::<span class="name">FieldType</span><a class="plink" href="#FieldType-enum" title="Direct link to this headline"></a></h3>
<p>Specifies the field an interlaced video frame belongs to.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::ProgressiveFrame</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The frame is not interlaced.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::TopField</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The frame contains a top field.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::BottomField</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The frame contains a bottom field.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::InterlacedFrame</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The frame contains a merged top and bottom field.</td></tr>
</tbody></table></div>
<!-- @@@FieldType -->
<!-- $$$PixelFormat$$$Format_Invalid$$$Format_ARGB32$$$Format_ARGB32_Premultiplied$$$Format_RGB32$$$Format_RGB24$$$Format_RGB565$$$Format_RGB555$$$Format_ARGB8565_Premultiplied$$$Format_BGRA32$$$Format_BGRA32_Premultiplied$$$Format_BGR32$$$Format_BGR24$$$Format_BGR565$$$Format_BGR555$$$Format_BGRA5658_Premultiplied$$$Format_AYUV444$$$Format_AYUV444_Premultiplied$$$Format_YUV444$$$Format_YUV420P$$$Format_YV12$$$Format_UYVY$$$Format_YUYV$$$Format_NV12$$$Format_NV21$$$Format_IMC1$$$Format_IMC2$$$Format_IMC3$$$Format_IMC4$$$Format_Y8$$$Format_Y16$$$Format_Jpeg$$$Format_CameraRaw$$$Format_AdobeDng$$$Format_ABGR32$$$Format_YUV422P$$$Format_User -->
<h3 class="fn" id="PixelFormat-enum" translate="no"><a name="PixelFormat-enum"></a>enum QVideoFrame::<span class="name">PixelFormat</span><a class="plink" href="#PixelFormat-enum" title="Direct link to this headline"></a></h3>
<p>Enumerates video data types.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_Invalid</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The frame is invalid.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_ARGB32</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The frame is stored using a 32-bit ARGB format (0xAARRGGBB). This is equivalent to <a href="./qimage.htm#Format-enum" translate="no">QImage::Format_ARGB32</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_ARGB32_Premultiplied</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The frame stored using a premultiplied 32-bit ARGB format (0xAARRGGBB). This is equivalent to <a href="./qimage.htm#Format-enum" translate="no">QImage::Format_ARGB32_Premultiplied</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_RGB32</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The frame stored using a 32-bit RGB format (0xffRRGGBB). This is equivalent to <a href="./qimage.htm#Format-enum" translate="no">QImage::Format_RGB32</a></td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_RGB24</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The frame is stored using a 24-bit RGB format (8-8-8). This is equivalent to <a href="./qimage.htm#Format-enum" translate="no">QImage::Format_RGB888</a></td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_RGB565</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The frame is stored using a 16-bit RGB format (5-6-5). This is equivalent to <a href="./qimage.htm#Format-enum" translate="no">QImage::Format_RGB16</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_RGB555</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The frame is stored using a 16-bit RGB format (5-5-5). This is equivalent to <a href="./qimage.htm#Format-enum" translate="no">QImage::Format_RGB555</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_ARGB8565_Premultiplied</code></td><td class="topAlign tblval"><code translate="no">7</code></td><td class="topAlign">The frame is stored using a 24-bit premultiplied ARGB format (8-5-6-5).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_BGRA32</code></td><td class="topAlign tblval"><code translate="no">8</code></td><td class="topAlign">The frame is stored using a 32-bit BGRA format (0xBBGGRRAA).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_BGRA32_Premultiplied</code></td><td class="topAlign tblval"><code translate="no">9</code></td><td class="topAlign">The frame is stored using a premultiplied 32bit BGRA format.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_ABGR32</code></td><td class="topAlign tblval"><code translate="no">33</code></td><td class="topAlign">The frame is stored using a 32-bit ABGR format (0xAABBGGRR).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_BGR32</code></td><td class="topAlign tblval"><code translate="no">10</code></td><td class="topAlign">The frame is stored using a 32-bit BGR format (0xBBGGRRff).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_BGR24</code></td><td class="topAlign tblval"><code translate="no">11</code></td><td class="topAlign">The frame is stored using a 24-bit BGR format (0xBBGGRR).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_BGR565</code></td><td class="topAlign tblval"><code translate="no">12</code></td><td class="topAlign">The frame is stored using a 16-bit BGR format (5-6-5).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_BGR555</code></td><td class="topAlign tblval"><code translate="no">13</code></td><td class="topAlign">The frame is stored using a 16-bit BGR format (5-5-5).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_BGRA5658_Premultiplied</code></td><td class="topAlign tblval"><code translate="no">14</code></td><td class="topAlign">The frame is stored using a 24-bit premultiplied BGRA format (5-6-5-8).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_AYUV444</code></td><td class="topAlign tblval"><code translate="no">15</code></td><td class="topAlign">The frame is stored using a packed 32-bit AYUV format (0xAAYYUUVV).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_AYUV444_Premultiplied</code></td><td class="topAlign tblval"><code translate="no">16</code></td><td class="topAlign">The frame is stored using a packed premultiplied 32-bit AYUV format (0xAAYYUUVV).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_YUV444</code></td><td class="topAlign tblval"><code translate="no">17</code></td><td class="topAlign">The frame is stored using a 24-bit packed YUV format (8-8-8).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_YUV420P</code></td><td class="topAlign tblval"><code translate="no">18</code></td><td class="topAlign">The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled, i.e. the height and width of the U and V planes are half that of the Y plane.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_YUV422P</code></td><td class="topAlign tblval"><code translate="no">34</code></td><td class="topAlign">The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally sub-sampled, i.e. the width of the U and V planes are half that of the Y plane, and height of U and V planes is the same as Y.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_YV12</code></td><td class="topAlign tblval"><code translate="no">19</code></td><td class="topAlign">The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled, i.e. the height and width of the V and U planes are half that of the Y plane.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_UYVY</code></td><td class="topAlign tblval"><code translate="no">20</code></td><td class="topAlign">The frame is stored using an 8-bit per component packed YUV format with the U and V planes horizontally sub-sampled (U-Y-V-Y), i.e. two horizontally adjacent pixels are stored as a 32-bit macropixel which has a Y value for each pixel and common U and V values.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_YUYV</code></td><td class="topAlign tblval"><code translate="no">21</code></td><td class="topAlign">The frame is stored using an 8-bit per component packed YUV format with the U and V planes horizontally sub-sampled (Y-U-Y-V), i.e. two horizontally adjacent pixels are stored as a 32-bit macropixel which has a Y value for each pixel and common U and V values.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_NV12</code></td><td class="topAlign tblval"><code translate="no">22</code></td><td class="topAlign">The frame is stored using an 8-bit per component semi-planar YUV format with a Y plane (Y) followed by a horizontally and vertically sub-sampled, packed UV plane (U-V).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_NV21</code></td><td class="topAlign tblval"><code translate="no">23</code></td><td class="topAlign">The frame is stored using an 8-bit per component semi-planar YUV format with a Y plane (Y) followed by a horizontally and vertically sub-sampled, packed VU plane (V-U).</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_IMC1</code></td><td class="topAlign tblval"><code translate="no">24</code></td><td class="topAlign">The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled. This is similar to the Format_YUV420P type, except that the bytes per line of the U and V planes are padded out to the same stride as the Y plane.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_IMC2</code></td><td class="topAlign tblval"><code translate="no">25</code></td><td class="topAlign">The frame is stored using an 8-bit per component planar YUV format with the U and V planes horizontally and vertically sub-sampled. This is similar to the Format_YUV420P type, except that the lines of the U and V planes are interleaved, i.e. each line of U data is followed by a line of V data creating a single line of the same stride as the Y data.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_IMC3</code></td><td class="topAlign tblval"><code translate="no">26</code></td><td class="topAlign">The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled. This is similar to the Format_YV12 type, except that the bytes per line of the V and U planes are padded out to the same stride as the Y plane.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_IMC4</code></td><td class="topAlign tblval"><code translate="no">27</code></td><td class="topAlign">The frame is stored using an 8-bit per component planar YVU format with the V and U planes horizontally and vertically sub-sampled. This is similar to the Format_YV12 type, except that the lines of the V and U planes are interleaved, i.e. each line of V data is followed by a line of U data creating a single line of the same stride as the Y data.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_Y8</code></td><td class="topAlign tblval"><code translate="no">28</code></td><td class="topAlign">The frame is stored using an 8-bit greyscale format.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_Y16</code></td><td class="topAlign tblval"><code translate="no">29</code></td><td class="topAlign">The frame is stored using a 16-bit linear greyscale format. Little endian.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_Jpeg</code></td><td class="topAlign tblval"><code translate="no">30</code></td><td class="topAlign">The frame is stored in compressed Jpeg format.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_CameraRaw</code></td><td class="topAlign tblval"><code translate="no">31</code></td><td class="topAlign">The frame is stored using a device specific camera raw format.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_AdobeDng</code></td><td class="topAlign tblval"><code translate="no">32</code></td><td class="topAlign">The frame is stored using raw Adobe Digital Negative (DNG) format.</td></tr>
<tr><td class="topAlign"><code translate="no">QVideoFrame::Format_User</code></td><td class="topAlign tblval"><code translate="no">1000</code></td><td class="topAlign">Start value for user defined pixel formats.</td></tr>
</tbody></table></div>
<!-- @@@PixelFormat -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QVideoFrame$$$QVideoFrameconstQVideoFrame& -->
<h3 class="fn" id="QVideoFrame-4" translate="no"><a name="QVideoFrame-4"></a>QVideoFrame::<span class="name">QVideoFrame</span>(const <span class="type"><a href="./qvideoframe.htm#QVideoFrame" translate="no">QVideoFrame</a></span> &amp;<i>other</i>)<a class="plink" href="#QVideoFrame-4" title="Direct link to this headline"></a></h3>
<p>Constructs a shallow copy of <i translate="no">other</i>. Since QVideoFrame is explicitly shared, these two instances will reflect the same frame.</p>
<!-- @@@QVideoFrame -->
<!-- $$$QVideoFrame$$$QVideoFrameconstQImage& -->
<h3 class="fn" id="QVideoFrame-3" translate="no"><a name="QVideoFrame-3"></a>QVideoFrame::<span class="name">QVideoFrame</span>(const <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> &amp;<i>image</i>)<a class="plink" href="#QVideoFrame-3" title="Direct link to this headline"></a></h3>
<p>Constructs a video frame from an <i translate="no">image</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This will construct an invalid video frame if there is no frame type equivalent to the image format.</p>
</div>
<p><b>See also </b><a href="./qvideoframe.htm#pixelFormatFromImageFormat" translate="no">pixelFormatFromImageFormat</a>().</p>
<!-- @@@QVideoFrame -->
<!-- $$$QVideoFrame$$$QVideoFrameintconstQSize&intQVideoFrame::PixelFormat -->
<h3 class="fn" id="QVideoFrame-2" translate="no"><a name="QVideoFrame-2"></a>QVideoFrame::<span class="name">QVideoFrame</span>(<span class="type">int</span> <i>bytes</i>, const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>, <span class="type">int</span> <i>bytesPerLine</i>, <span class="type"><a href="./qvideoframe.htm#PixelFormat-enum" translate="no">QVideoFrame::PixelFormat</a></span> <i>format</i>)<a class="plink" href="#QVideoFrame-2" title="Direct link to this headline"></a></h3>
<p>Constructs a video frame of the given pixel <i translate="no">format</i> and <i translate="no">size</i> in pixels.</p>
<p>The <i translate="no">bytesPerLine</i> (stride) is the length of each scan line in bytes, and <i translate="no">bytes</i> is the total number of bytes that must be allocated for the frame.</p>
<!-- @@@QVideoFrame -->
<!-- $$$QVideoFrame$$$QVideoFrameQAbstractVideoBuffer*constQSize&QVideoFrame::PixelFormat -->
<h3 class="fn" id="QVideoFrame-1" translate="no"><a name="QVideoFrame-1"></a>QVideoFrame::<span class="name">QVideoFrame</span>(<span class="type"><a href="./qabstractvideobuffer.htm" translate="no">QAbstractVideoBuffer</a></span> *<i>buffer</i>, const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>size</i>, <span class="type"><a href="./qvideoframe.htm#PixelFormat-enum" translate="no">QVideoFrame::PixelFormat</a></span> <i>format</i>)<a class="plink" href="#QVideoFrame-1" title="Direct link to this headline"></a></h3>
<p>Constructs a video frame from a <i translate="no">buffer</i> with the given pixel <i translate="no">format</i> and <i translate="no">size</i> in pixels.</p>
<div class="admonition note">
<p><b>Note: </b>This doesn't increment the reference count of the video buffer.</p>
</div>
<!-- @@@QVideoFrame -->
<!-- $$$QVideoFrame[overload1]$$$QVideoFrame -->
<h3 class="fn" id="QVideoFrame" translate="no"><a name="QVideoFrame"></a>QVideoFrame::<span class="name">QVideoFrame</span>()<a class="plink" href="#QVideoFrame" title="Direct link to this headline"></a></h3>
<p>Constructs a null video frame.</p>
<!-- @@@QVideoFrame -->
<!-- $$$operator=[overload1]$$$operator=constQVideoFrame& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qvideoframe.htm#QVideoFrame" translate="no">QVideoFrame</a></span> &amp;QVideoFrame::<span class="name">operator=</span>(const <span class="type"><a href="./qvideoframe.htm#QVideoFrame" translate="no">QVideoFrame</a></span> &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns the contents of <i translate="no">other</i> to this video frame. Since <a href="./qvideoframe.htm" translate="no">QVideoFrame</a> is explicitly shared, these two instances will reflect the same frame.</p>
<!-- @@@operator= -->
<!-- $$$~QVideoFrame[overload1]$$$~QVideoFrame -->
<h3 class="fn" id="dtor.QVideoFrame" translate="no"><a name="dtor.QVideoFrame"></a>QVideoFrame::<span class="name">~QVideoFrame</span>()<a class="plink" href="#dtor.QVideoFrame" title="Direct link to this headline"></a></h3>
<p>Destroys a video frame.</p>
<!-- @@@~QVideoFrame -->
<!-- $$$availableMetaData[overload1]$$$availableMetaData -->
<h3 class="fn" id="availableMetaData" translate="no"><a name="availableMetaData"></a><span class="type"><a href="./qvariant.htm#QVariantMap-typedef" translate="no">QVariantMap</a></span> QVideoFrame::<span class="name">availableMetaData</span>() const<a class="plink" href="#availableMetaData" title="Direct link to this headline"></a></h3>
<p>Returns any extra metadata associated with this frame.</p>
<!-- @@@availableMetaData -->
<!-- $$$bits[overload1]$$$bits -->
<h3 class="fn" id="bits" translate="no"><a name="bits"></a><span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *QVideoFrame::<span class="name">bits</span>()<a class="plink" href="#bits" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the start of the frame data buffer.</p>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p>Changes made to data accessed via this pointer (when mapped with write access) are only guaranteed to have been persisted when <a href="./qvideoframe.htm#unmap" translate="no">unmap</a>() is called and when the buffer has been mapped for writing.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>(), <a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a>(), and <a href="./qvideoframe.htm#bytesPerLine" translate="no">bytesPerLine</a>().</p>
<!-- @@@bits -->
<!-- $$$bits$$$bitsint -->
<h3 class="fn" id="bits-1" translate="no"><a name="bits-1"></a><span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *QVideoFrame::<span class="name">bits</span>(<span class="type">int</span> <i>plane</i>)<a class="plink" href="#bits-1" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the start of the frame data buffer for a <i translate="no">plane</i>.</p>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p>Changes made to data accessed via this pointer (when mapped with write access) are only guaranteed to have been persisted when <a href="./qvideoframe.htm#unmap" translate="no">unmap</a>() is called and when the buffer has been mapped for writing.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>(), <a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a>(), <a href="./qvideoframe.htm#bytesPerLine" translate="no">bytesPerLine</a>(), and <a href="./qvideoframe.htm#planeCount" translate="no">planeCount</a>().</p>
<!-- @@@bits -->
<!-- $$$bits$$$bits -->
<h3 class="fn" id="bits-2" translate="no"><a name="bits-2"></a>const <span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *QVideoFrame::<span class="name">bits</span>() const<a class="plink" href="#bits-2" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the start of the frame data buffer.</p>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p>If the buffer was not mapped with read access, the contents of this buffer will initially be uninitialized.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>(), <a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a>(), and <a href="./qvideoframe.htm#bytesPerLine" translate="no">bytesPerLine</a>().</p>
<!-- @@@bits -->
<!-- $$$bits$$$bitsint -->
<h3 class="fn" id="bits-3" translate="no"><a name="bits-3"></a>const <span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *QVideoFrame::<span class="name">bits</span>(<span class="type">int</span> <i>plane</i>) const<a class="plink" href="#bits-3" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the start of the frame data buffer for a <i translate="no">plane</i>.</p>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p>If the buffer was not mapped with read access, the contents of this buffer will initially be uninitialized.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>(), <a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a>(), <a href="./qvideoframe.htm#bytesPerLine" translate="no">bytesPerLine</a>(), and <a href="./qvideoframe.htm#planeCount" translate="no">planeCount</a>().</p>
<!-- @@@bits -->
<!-- $$$buffer[overload1]$$$buffer -->
<h3 class="fn" id="buffer" translate="no"><a name="buffer"></a><span class="type"><a href="./qabstractvideobuffer.htm" translate="no">QAbstractVideoBuffer</a></span> *QVideoFrame::<span class="name">buffer</span>() const<a class="plink" href="#buffer" title="Direct link to this headline"></a></h3>
<p>Returns underlying video buffer or <code translate="no">null</code> if there is none.</p>
<p>This function was introduced in Qt 5.13.</p>
<!-- @@@buffer -->
<!-- $$$bytesPerLine[overload1]$$$bytesPerLine -->
<h3 class="fn" id="bytesPerLine" translate="no"><a name="bytesPerLine"></a><span class="type">int</span> QVideoFrame::<span class="name">bytesPerLine</span>() const<a class="plink" href="#bytesPerLine" title="Direct link to this headline"></a></h3>
<p>Returns the number of bytes in a scan line.</p>
<div class="admonition note">
<p><b>Note: </b>For planar formats this is the bytes per line of the first plane only. The bytes per line of subsequent planes should be calculated as per the frame <a href="./qvideoframe.htm#PixelFormat-enum" translate="no">pixel format</a>.</p>
</div>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p><b>See also </b><a href="./qvideoframe.htm#bits" translate="no">bits</a>(), <a href="./qvideoframe.htm#map" translate="no">map</a>(), and <a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a>().</p>
<!-- @@@bytesPerLine -->
<!-- $$$bytesPerLine$$$bytesPerLineint -->
<h3 class="fn" id="bytesPerLine-1" translate="no"><a name="bytesPerLine-1"></a><span class="type">int</span> QVideoFrame::<span class="name">bytesPerLine</span>(<span class="type">int</span> <i>plane</i>) const<a class="plink" href="#bytesPerLine-1" title="Direct link to this headline"></a></h3>
<p>Returns the number of bytes in a scan line of a <i translate="no">plane</i>.</p>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qvideoframe.htm#bits" translate="no">bits</a>(), <a href="./qvideoframe.htm#map" translate="no">map</a>(), <a href="./qvideoframe.htm#mappedBytes" translate="no">mappedBytes</a>(), and <a href="./qvideoframe.htm#planeCount" translate="no">planeCount</a>().</p>
<!-- @@@bytesPerLine -->
<!-- $$$endTime[overload1]$$$endTime -->
<h3 class="fn" id="endTime" translate="no"><a name="endTime"></a><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QVideoFrame::<span class="name">endTime</span>() const<a class="plink" href="#endTime" title="Direct link to this headline"></a></h3>
<p>Returns the presentation time (in microseconds) when a frame should stop being displayed.</p>
<p>An invalid time is represented as -1.</p>
<p><b>See also </b><a href="./qvideoframe.htm#setEndTime" translate="no">setEndTime</a>().</p>
<!-- @@@endTime -->
<!-- $$$fieldType[overload1]$$$fieldType -->
<h3 class="fn" id="fieldType" translate="no"><a name="fieldType"></a><span class="type"><a href="./qvideoframe.htm#FieldType-enum" translate="no">QVideoFrame::FieldType</a></span> QVideoFrame::<span class="name">fieldType</span>() const<a class="plink" href="#fieldType" title="Direct link to this headline"></a></h3>
<p>Returns the field an interlaced video frame belongs to.</p>
<p>If the video is not interlaced this will return WholeFrame.</p>
<p><b>See also </b><a href="./qvideoframe.htm#setFieldType" translate="no">setFieldType</a>().</p>
<!-- @@@fieldType -->
<!-- $$$handle[overload1]$$$handle -->
<h3 class="fn" id="handle" translate="no"><a name="handle"></a><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> QVideoFrame::<span class="name">handle</span>() const<a class="plink" href="#handle" title="Direct link to this headline"></a></h3>
<p>Returns a type specific handle to a video frame's buffer.</p>
<p>For an OpenGL texture this would be the texture ID.</p>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#handle" translate="no">QAbstractVideoBuffer::handle</a>().</p>
<!-- @@@handle -->
<!-- $$$handleType[overload1]$$$handleType -->
<h3 class="fn" id="handleType" translate="no"><a name="handleType"></a><span class="type"><a href="./qabstractvideobuffer.htm#HandleType-enum" translate="no">QAbstractVideoBuffer::HandleType</a></span> QVideoFrame::<span class="name">handleType</span>() const<a class="plink" href="#handleType" title="Direct link to this headline"></a></h3>
<p>Returns the type of a video frame's handle.</p>
<!-- @@@handleType -->
<!-- $$$height[overload1]$$$height -->
<h3 class="fn" id="height" translate="no"><a name="height"></a><span class="type">int</span> QVideoFrame::<span class="name">height</span>() const<a class="plink" href="#height" title="Direct link to this headline"></a></h3>
<p>Returns the height of a video frame.</p>
<!-- @@@height -->
<!-- $$$image[overload1]$$$image -->
<h3 class="fn" id="image" translate="no"><a name="image"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QVideoFrame::<span class="name">image</span>() const<a class="plink" href="#image" title="Direct link to this headline"></a></h3>
<p>Based on the pixel format converts current video frame to image.</p>
<p>This function was introduced in Qt 5.15.</p>
<!-- @@@image -->
<!-- $$$imageFormatFromPixelFormat[overload1]$$$imageFormatFromPixelFormatQVideoFrame::PixelFormat -->
<h3 class="fn" id="imageFormatFromPixelFormat" translate="no"><a name="imageFormatFromPixelFormat"></a><code translate="no">[static] </code><span class="type"><a href="./qimage.htm#Format-enum" translate="no">QImage::Format</a></span> QVideoFrame::<span class="name">imageFormatFromPixelFormat</span>(<span class="type"><a href="./qvideoframe.htm#PixelFormat-enum" translate="no">QVideoFrame::PixelFormat</a></span> <i>format</i>)<a class="plink" href="#imageFormatFromPixelFormat" title="Direct link to this headline"></a></h3>
<p>Returns an image format equivalent to a video frame pixel <i translate="no">format</i>. If there is no equivalent format <a href="./qimage.htm#Format-enum" translate="no">QImage::Format_Invalid</a> is returned instead.</p>
<div class="admonition note">
<p><b>Note: </b>In general <a href="./qimage.htm" translate="no">QImage</a> does not handle YUV formats.</p>
</div>
<!-- @@@imageFormatFromPixelFormat -->
<!-- $$$isMapped[overload1]$$$isMapped -->
<h3 class="fn" id="isMapped" translate="no"><a name="isMapped"></a><span class="type">bool</span> QVideoFrame::<span class="name">isMapped</span>() const<a class="plink" href="#isMapped" title="Direct link to this headline"></a></h3>
<p>Identifies if a video frame's contents are currently mapped to system memory.</p>
<p>This is a convenience function which checks that the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">MapMode</a> of the frame is not equal to <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::NotMapped</a>.</p>
<p>Returns true if the contents of the video frame are mapped to system memory, and false otherwise.</p>
<p><b>See also </b><a href="./qvideoframe.htm#mapMode" translate="no">mapMode</a>() and <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a>.</p>
<!-- @@@isMapped -->
<!-- $$$isReadable[overload1]$$$isReadable -->
<h3 class="fn" id="isReadable" translate="no"><a name="isReadable"></a><span class="type">bool</span> QVideoFrame::<span class="name">isReadable</span>() const<a class="plink" href="#isReadable" title="Direct link to this headline"></a></h3>
<p>Identifies if the mapped contents of a video frame were read from the frame when it was mapped.</p>
<p>This is a convenience function which checks if the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">MapMode</a> contains the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::WriteOnly</a> flag.</p>
<p>Returns true if the contents of the mapped memory were read from the video frame, and false otherwise.</p>
<p><b>See also </b><a href="./qvideoframe.htm#mapMode" translate="no">mapMode</a>() and <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a>.</p>
<!-- @@@isReadable -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QVideoFrame::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Identifies whether a video frame is valid.</p>
<p>An invalid frame has no video buffer associated with it.</p>
<p>Returns true if the frame is valid, and false if it is not.</p>
<!-- @@@isValid -->
<!-- $$$isWritable[overload1]$$$isWritable -->
<h3 class="fn" id="isWritable" translate="no"><a name="isWritable"></a><span class="type">bool</span> QVideoFrame::<span class="name">isWritable</span>() const<a class="plink" href="#isWritable" title="Direct link to this headline"></a></h3>
<p>Identifies if the mapped contents of a video frame will be persisted when the frame is unmapped.</p>
<p>This is a convenience function which checks if the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">MapMode</a> contains the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::WriteOnly</a> flag.</p>
<p>Returns true if the video frame will be updated when unmapped, and false otherwise.</p>
<div class="admonition note">
<p><b>Note: </b>The result of altering the data of a frame that is mapped in read-only mode is undefined. Depending on the buffer implementation the changes may be persisted, or worse alter a shared buffer.</p>
</div>
<p><b>See also </b><a href="./qvideoframe.htm#mapMode" translate="no">mapMode</a>() and <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a>.</p>
<!-- @@@isWritable -->
<!-- $$$map[overload1]$$$mapQAbstractVideoBuffer::MapMode -->
<h3 class="fn" id="map" translate="no"><a name="map"></a><span class="type">bool</span> QVideoFrame::<span class="name">map</span>(<span class="type"><a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a></span> <i>mode</i>)<a class="plink" href="#map" title="Direct link to this headline"></a></h3>
<p>Maps the contents of a video frame to system (CPU addressable) memory.</p>
<p>In some cases the video frame data might be stored in video memory or otherwise inaccessible memory, so it is necessary to map a frame before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.</p>
<p>The map <i translate="no">mode</i> indicates whether the contents of the mapped memory should be read from and/or written to the frame. If the map mode includes the <code translate="no">QAbstractVideoBuffer::ReadOnly</code> flag the mapped memory will be populated with the content of the video frame when initially mapped. If the map mode includes the <code translate="no">QAbstractVideoBuffer::WriteOnly</code> flag the content of the possibly modified mapped memory will be written back to the frame when unmapped.</p>
<p>While mapped the contents of a video frame can be accessed directly through the pointer returned by the <a href="./qvideoframe.htm#bits" translate="no">bits</a>() function.</p>
<p>When access to the data is no longer needed, be sure to call the <a href="./qvideoframe.htm#unmap" translate="no">unmap</a>() function to release the mapped memory and possibly update the video frame contents.</p>
<p>If the video frame has been mapped in read only mode, it is permissible to map it multiple times in read only mode (and unmap it a corresponding number of times). In all other cases it is necessary to unmap the frame first before mapping a second time.</p>
<div class="admonition note">
<p><b>Note: </b>Writing to memory that is mapped as read-only is undefined, and may result in changes to shared data or crashes.</p>
</div>
<p>Returns true if the frame was mapped to memory in the given <i translate="no">mode</i> and false otherwise.</p>
<p><b>See also </b><a href="./qvideoframe.htm#unmap" translate="no">unmap</a>(), <a href="./qvideoframe.htm#mapMode" translate="no">mapMode</a>(), and <a href="./qvideoframe.htm#bits" translate="no">bits</a>().</p>
<!-- @@@map -->
<!-- $$$mapMode[overload1]$$$mapMode -->
<h3 class="fn" id="mapMode" translate="no"><a name="mapMode"></a><span class="type"><a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a></span> QVideoFrame::<span class="name">mapMode</span>() const<a class="plink" href="#mapMode" title="Direct link to this headline"></a></h3>
<p>Returns the mode a video frame was mapped to system memory in.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>() and <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a>.</p>
<!-- @@@mapMode -->
<!-- $$$mappedBytes[overload1]$$$mappedBytes -->
<h3 class="fn" id="mappedBytes" translate="no"><a name="mappedBytes"></a><span class="type">int</span> QVideoFrame::<span class="name">mappedBytes</span>() const<a class="plink" href="#mappedBytes" title="Direct link to this headline"></a></h3>
<p>Returns the number of bytes occupied by the mapped frame data.</p>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>().</p>
<!-- @@@mappedBytes -->
<!-- $$$metaData[overload1]$$$metaDataconstQString& -->
<h3 class="fn" id="metaData" translate="no"><a name="metaData"></a><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> QVideoFrame::<span class="name">metaData</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>) const<a class="plink" href="#metaData" title="Direct link to this headline"></a></h3>
<p>Returns any metadata for this frame for the given <i translate="no">key</i>.</p>
<p>This might include frame specific information from a camera, or subtitles from a decoded video stream.</p>
<p>See the documentation for the relevant video frame producer for further information about available metadata.</p>
<p><b>See also </b><a href="./qvideoframe.htm#setMetaData" translate="no">setMetaData</a>().</p>
<!-- @@@metaData -->
<!-- $$$pixelFormat[overload1]$$$pixelFormat -->
<h3 class="fn" id="pixelFormat" translate="no"><a name="pixelFormat"></a><span class="type"><a href="./qvideoframe.htm#PixelFormat-enum" translate="no">QVideoFrame::PixelFormat</a></span> QVideoFrame::<span class="name">pixelFormat</span>() const<a class="plink" href="#pixelFormat" title="Direct link to this headline"></a></h3>
<p>Returns the color format of a video frame.</p>
<!-- @@@pixelFormat -->
<!-- $$$pixelFormatFromImageFormat[overload1]$$$pixelFormatFromImageFormatQImage::Format -->
<h3 class="fn" id="pixelFormatFromImageFormat" translate="no"><a name="pixelFormatFromImageFormat"></a><code translate="no">[static] </code><span class="type"><a href="./qvideoframe.htm#PixelFormat-enum" translate="no">QVideoFrame::PixelFormat</a></span> QVideoFrame::<span class="name">pixelFormatFromImageFormat</span>(<span class="type"><a href="./qimage.htm#Format-enum" translate="no">QImage::Format</a></span> <i>format</i>)<a class="plink" href="#pixelFormatFromImageFormat" title="Direct link to this headline"></a></h3>
<p>Returns a video pixel format equivalent to an image <i translate="no">format</i>. If there is no equivalent format QVideoFrame::InvalidType is returned instead.</p>
<div class="admonition note">
<p><b>Note: </b>In general <a href="./qimage.htm" translate="no">QImage</a> does not handle YUV formats.</p>
</div>
<!-- @@@pixelFormatFromImageFormat -->
<!-- $$$planeCount[overload1]$$$planeCount -->
<h3 class="fn" id="planeCount" translate="no"><a name="planeCount"></a><span class="type">int</span> QVideoFrame::<span class="name">planeCount</span>() const<a class="plink" href="#planeCount" title="Direct link to this headline"></a></h3>
<p>Returns the number of planes in the video frame.</p>
<p>This value is only valid while the frame data is <a href="./qvideoframe.htm#map" translate="no">mapped</a>.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>().</p>
<!-- @@@planeCount -->
<!-- $$$setEndTime[overload1]$$$setEndTimeqint64 -->
<h3 class="fn" id="setEndTime" translate="no"><a name="setEndTime"></a><span class="type">void</span> QVideoFrame::<span class="name">setEndTime</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>time</i>)<a class="plink" href="#setEndTime" title="Direct link to this headline"></a></h3>
<p>Sets the presentation <i translate="no">time</i> (in microseconds) when a frame should stop being displayed.</p>
<p>An invalid time is represented as -1.</p>
<p><b>See also </b><a href="./qvideoframe.htm#endTime" translate="no">endTime</a>().</p>
<!-- @@@setEndTime -->
<!-- $$$setFieldType[overload1]$$$setFieldTypeQVideoFrame::FieldType -->
<h3 class="fn" id="setFieldType" translate="no"><a name="setFieldType"></a><span class="type">void</span> QVideoFrame::<span class="name">setFieldType</span>(<span class="type"><a href="./qvideoframe.htm#FieldType-enum" translate="no">QVideoFrame::FieldType</a></span> <i>field</i>)<a class="plink" href="#setFieldType" title="Direct link to this headline"></a></h3>
<p>Sets the <i translate="no">field</i> an interlaced video frame belongs to.</p>
<p><b>See also </b><a href="./qvideoframe.htm#fieldType" translate="no">fieldType</a>().</p>
<!-- @@@setFieldType -->
<!-- $$$setMetaData[overload1]$$$setMetaDataconstQString&constQVariant& -->
<h3 class="fn" id="setMetaData" translate="no"><a name="setMetaData"></a><span class="type">void</span> QVideoFrame::<span class="name">setMetaData</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>key</i>, const <span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> &amp;<i>value</i>)<a class="plink" href="#setMetaData" title="Direct link to this headline"></a></h3>
<p>Sets the metadata for the given <i translate="no">key</i> to <i translate="no">value</i>.</p>
<p>If <i translate="no">value</i> is a null variant, any metadata for this key will be removed.</p>
<p>The producer of the video frame might use this to associate certain data with this frame, or for an intermediate processor to add information for a consumer of this frame.</p>
<p><b>See also </b><a href="./qvideoframe.htm#metaData" translate="no">metaData</a>().</p>
<!-- @@@setMetaData -->
<!-- $$$setStartTime[overload1]$$$setStartTimeqint64 -->
<h3 class="fn" id="setStartTime" translate="no"><a name="setStartTime"></a><span class="type">void</span> QVideoFrame::<span class="name">setStartTime</span>(<span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> <i>time</i>)<a class="plink" href="#setStartTime" title="Direct link to this headline"></a></h3>
<p>Sets the presentation <i translate="no">time</i> (in microseconds) when the frame should initially be displayed.</p>
<p>An invalid time is represented as -1.</p>
<p><b>See also </b><a href="./qvideoframe.htm#startTime" translate="no">startTime</a>().</p>
<!-- @@@setStartTime -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> QVideoFrame::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the dimensions of a video frame.</p>
<!-- @@@size -->
<!-- $$$startTime[overload1]$$$startTime -->
<h3 class="fn" id="startTime" translate="no"><a name="startTime"></a><span class="type"><a href="./qtglobal.htm#qint64-typedef" translate="no">qint64</a></span> QVideoFrame::<span class="name">startTime</span>() const<a class="plink" href="#startTime" title="Direct link to this headline"></a></h3>
<p>Returns the presentation time (in microseconds) when the frame should be displayed.</p>
<p>An invalid time is represented as -1.</p>
<p><b>See also </b><a href="./qvideoframe.htm#setStartTime" translate="no">setStartTime</a>().</p>
<!-- @@@startTime -->
<!-- $$$unmap[overload1]$$$unmap -->
<h3 class="fn" id="unmap" translate="no"><a name="unmap"></a><span class="type">void</span> QVideoFrame::<span class="name">unmap</span>()<a class="plink" href="#unmap" title="Direct link to this headline"></a></h3>
<p>Releases the memory mapped by the <a href="./qvideoframe.htm#map" translate="no">map</a>() function.</p>
<p>If the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">MapMode</a> included the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::WriteOnly</a> flag this will persist the current content of the mapped memory to the video frame.</p>
<p>unmap() should not be called if <a href="./qvideoframe.htm#map" translate="no">map</a>() function failed.</p>
<p><b>See also </b><a href="./qvideoframe.htm#map" translate="no">map</a>().</p>
<!-- @@@unmap -->
<!-- $$$width[overload1]$$$width -->
<h3 class="fn" id="width" translate="no"><a name="width"></a><span class="type">int</span> QVideoFrame::<span class="name">width</span>() const<a class="plink" href="#width" title="Direct link to this headline"></a></h3>
<p>Returns the width of a video frame.</p>
<!-- @@@width -->
<!-- $$$operator!=[overload1]$$$operator!=constQVideoFrame& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QVideoFrame::<span class="name">operator!=</span>(const <span class="type"><a href="./qvideoframe.htm#QVideoFrame" translate="no">QVideoFrame</a></span> &amp;<i>other</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this <a href="./qvideoframe.htm" translate="no">QVideoFrame</a> and <i translate="no">other</i> do not reflect the same frame.</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQVideoFrame& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QVideoFrame::<span class="name">operator==</span>(const <span class="type"><a href="./qvideoframe.htm#QVideoFrame" translate="no">QVideoFrame</a></span> &amp;<i>other</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this <a href="./qvideoframe.htm" translate="no">QVideoFrame</a> and <i translate="no">other</i> reflect the same frame.</p>
<!-- @@@operator== -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>