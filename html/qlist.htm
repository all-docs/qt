<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QList | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qlist.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QList</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QList Class</h1>
<span class="small-subtitle" translate="no">template &lt;typename T&gt; class QList</span>
<!-- $$$QList-brief -->
<p>The QList class is a template class that provides lists. <a href="#details">More...</a></p>
<!-- @@@QList -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QList&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qqueue.htm" translate="no">QQueue</a></p>
</td></tr></tbody></table></div><ul>
<li><a href="./qlist-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qlist-obsolete.htm">Obsolete members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qlist-const-iterator.htm" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qlist-iterator.htm" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#ConstIterator-typedef" translate="no">ConstIterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#Iterator-typedef" translate="no">Iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#const_pointer-typedef" translate="no">const_pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#const_reference-typedef" translate="no">const_reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#difference_type-typedef" translate="no">difference_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#pointer-typedef" translate="no">pointer</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#reference-typedef" translate="no">reference</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#reverse_iterator-typedef" translate="no">reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#size_type-typedef" translate="no">size_type</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#value_type-typedef" translate="no">value_type</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#QList-4" translate="no">QList</a></b>(InputIterator <i>first</i>, InputIterator <i>last</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#QList-3" translate="no">QList</a></b>(int <i>args</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#QList-2" translate="no">QList</a></b>(QList&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#QList-1" translate="no">QList</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#QList" translate="no">QList</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-eq-1" translate="no">operator=</a></b>(QList&lt;T&gt; &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-eq" translate="no">operator=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#dtor.QList" translate="no">~QList</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#append" translate="no">append</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#append-1" translate="no">append</a></b>(const QList&lt;T&gt; &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#at" translate="no">at</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#back" translate="no">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#back-1" translate="no">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#constFirst" translate="no">constFirst</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#constLast" translate="no">constLast</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#contains" translate="no">contains</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#count" translate="no">count</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#count-1" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#crbegin" translate="no">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#crend" translate="no">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#empty" translate="no">empty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#endsWith" translate="no">endsWith</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#erase" translate="no">erase</a></b>(QList::iterator <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#erase-1" translate="no">erase</a></b>(QList::iterator <i>begin</i>, QList::iterator <i>end</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#first" translate="no">first</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#first-1" translate="no">first</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#front" translate="no">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#front-1" translate="no">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#indexOf" translate="no">indexOf</a></b>(const T &amp;<i>value</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#insert" translate="no">insert</a></b>(int <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#insert-1" translate="no">insert</a></b>(QList::iterator <i>before</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#last" translate="no">last</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#last-1" translate="no">last</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#lastIndexOf" translate="no">lastIndexOf</a></b>(const T &amp;<i>value</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#length" translate="no">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#mid" translate="no">mid</a></b>(int <i>pos</i>, int <i>length</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#move" translate="no">move</a></b>(int <i>from</i>, int <i>to</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#pop_back" translate="no">pop_back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#pop_front" translate="no">pop_front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#prepend" translate="no">prepend</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#push_back" translate="no">push_back</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#push_front" translate="no">push_front</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#rbegin" translate="no">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#rbegin-1" translate="no">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#removeAll" translate="no">removeAll</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#removeAt" translate="no">removeAt</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#removeFirst" translate="no">removeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#removeLast" translate="no">removeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#removeOne" translate="no">removeOne</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#rend" translate="no">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#rend-1" translate="no">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#replace" translate="no">replace</a></b>(int <i>i</i>, const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#reserve" translate="no">reserve</a></b>(int <i>alloc</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#startsWith" translate="no">startsWith</a></b>(const T &amp;<i>value</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#swap" translate="no">swap</a></b>(QList&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#swapItemsAt" translate="no">swapItemsAt</a></b>(int <i>i</i>, int <i>j</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#takeAt" translate="no">takeAt</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#takeFirst" translate="no">takeFirst</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#takeLast" translate="no">takeLast</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#toVector" translate="no">toVector</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#value" translate="no">value</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#value-1" translate="no">value</a></b>(int <i>i</i>, const T &amp;<i>defaultValue</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-not-eq" translate="no">operator!=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-2b" translate="no">operator+</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-2b-eq" translate="no">operator+=</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-2b-eq-1" translate="no">operator+=</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(const QList&lt;T&gt; &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-lt-lt-1" translate="no">operator&lt;&lt;</a></b>(const T &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-eq-eq" translate="no">operator==</a></b>(const QList&lt;T&gt; &amp;<i>other</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-5b-5d" translate="no">operator[]</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const T &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-5b-5d-1" translate="no">operator[]</a></b>(int <i>i</i>) const</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QList&lt;T&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#fromVector" translate="no">fromVector</a></b>(const QVector&lt;T&gt; &amp;<i>vector</i>)</td></tr>
</tbody></table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members<a class="plink" href="#related-non-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#qHash" translate="no">qHash</a></b>(const QList&lt;T&gt; &amp;<i>key</i>, uint <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-lt" translate="no">operator&lt;</a></b>(const QList&lt;T&gt; &amp;<i>lhs</i>, const QList&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-lt-eq" translate="no">operator&lt;=</a></b>(const QList&lt;T&gt; &amp;<i>lhs</i>, const QList&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-gt" translate="no">operator&gt;</a></b>(const QList&lt;T&gt; &amp;<i>lhs</i>, const QList&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qlist.htm#operator-gt-eq" translate="no">operator&gt;=</a></b>(const QList&lt;T&gt; &amp;<i>lhs</i>, const QList&lt;T&gt; &amp;<i>rhs</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QList-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QList&lt;T&gt; is one of Qt's generic <a href="./containers.htm" translate="no">container classes</a>. It stores items in a list that provides fast index-based access and index-based insertions and removals.</p>
<p>QList&lt;T&gt;, QLinkedList&lt;T&gt;, and <a href="./qvector.htm" translate="no">QVector</a>&lt;T&gt; provide similar APIs and functionality. They are often interchangeable, but there are performance consequences. Here is an overview of use cases:</p>
<ul>
<li><a href="./qvector.htm" translate="no">QVector</a> should be your default first choice. <a href="./qvector.htm" translate="no">QVector</a>&lt;T&gt; will usually give better performance than QList&lt;T&gt;, because <a href="./qvector.htm" translate="no">QVector</a>&lt;T&gt; always stores its items sequentially in memory, where QList&lt;T&gt; will allocate its items on the heap unless <code translate="no">sizeof(T) &lt;= sizeof(void*)</code> and T has been declared to be either a <code translate="no">Q_MOVABLE_TYPE</code> or a <code translate="no">Q_PRIMITIVE_TYPE</code> using <a href="./qtglobal.htm#Q_DECLARE_TYPEINFO" translate="no">Q_DECLARE_TYPEINFO</a>. See the <a href="http://marcmutz.wordpress.com/effective-qt/containers/#containers-qlist" translate="no">Pros and Cons of Using QList</a> for an explanation.</li>
<li>However, QList is used throughout the Qt APIs for passing parameters and for returning values. Use QList to interface with those APIs.</li>
<li>If you need a real linked list, which guarantees <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a> insertions mid-list and uses iterators to items rather than indexes, use QLinkedList.</li>
</ul>
<div class="admonition note">
<p><b>Note: </b><a href="./qvector.htm" translate="no">QVector</a> and <a href="./qvarlengtharray.htm" translate="no">QVarLengthArray</a> both guarantee C-compatible array layout. QList does not. This might be important if your application must interface with a C API.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Iterators into a QLinkedList and references into heap-allocating QLists remain valid as long as the referenced items remain in the container. This is not true for iterators and references into a <a href="./qvector.htm" translate="no">QVector</a> and non-heap-allocating QLists.</p>
</div>
<p>Internally, QList&lt;T&gt; is represented as an array of T if <code translate="no">sizeof(T) &lt;= sizeof(void*)</code> and T has been declared to be either a <code translate="no">Q_MOVABLE_TYPE</code> or a <code translate="no">Q_PRIMITIVE_TYPE</code> using <a href="./qtglobal.htm#Q_DECLARE_TYPEINFO" translate="no">Q_DECLARE_TYPEINFO</a>. Otherwise, QList&lt;T&gt; is represented as an array of T* and the items are allocated on the heap.</p>
<p>The array representation allows very fast insertions and index-based access. The <a href="./qlist.htm#prepend" translate="no">prepend</a>() and <a href="./qlist.htm#append" translate="no">append</a>() operations are also very fast because QList preallocates memory at both ends of its internal array. (See <a href="./containers.htm#algorithmic-complexity" translate="no">Algorithmic Complexity</a> for details.</p>
<p>Note, however, that when the conditions specified above are not met, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation will make <a href="./qvector.htm" translate="no">QVector</a> a better choice for use cases that do a lot of appending or inserting, because <a href="./qvector.htm" translate="no">QVector</a> can allocate memory for many items in a single heap allocation.</p>
<p>Note that the internal array only ever gets bigger over the life of the list. It never shrinks. The internal array is deallocated by the destructor and by the assignment operator, when one list is assigned to another.</p>
<p>Here's an example of a QList that stores integers and a QList that stores <a href="./qdate.htm" translate="no">QDate</a> values:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> integerList;
<span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qdate.htm" translate="no">QDate</a></span><span class="operator">&gt;</span> dateList;</pre></div>
<p>Qt includes a <a href="./qstringlist.htm" translate="no">QStringList</a> class that inherits QList&lt;<a href="./qstring.htm" translate="no">QString</a>&gt; and adds a few convenience functions, such as <a href="./qstringlist.htm#join" translate="no">QStringList::join</a>() and <a href="./qstringlist.htm#filter" translate="no">QStringList::filter</a>(). <a href="./qstring.htm#split" translate="no">QString::split</a>() creates QStringLists from strings.</p>
<p>QList stores a list of items. The default constructor creates an empty list. You can use the initializer-list constructor to create a list with elements:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list <span class="operator">=</span> { <span class="string">"one"</span><span class="operator">,</span> <span class="string">"two"</span><span class="operator">,</span> <span class="string">"three"</span> };</pre></div>
<p>QList provides these basic functions to add, move, and remove items: <a href="./qlist.htm#insert" translate="no">insert</a>(), <a href="./qlist.htm#replace" translate="no">replace</a>(), <a href="./qlist.htm#removeAt" translate="no">removeAt</a>(), <a href="./qlist.htm#move" translate="no">move</a>(), and <a href="./qlist.htm#swap" translate="no">swap</a>(). In addition, it provides the following convenience functions: <a href="./qlist.htm#append" translate="no">append</a>(), <a href="./qlist.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>(), <a href="./qlist.htm#operator-2b-eq" translate="no">operator+=</a>(), <a href="./qlist.htm#prepend" translate="no">prepend</a>(), <a href="./qlist.htm#removeFirst" translate="no">removeFirst</a>(), and <a href="./qlist.htm#removeLast" translate="no">removeLast</a>().</p>
<p><a href="./qlist.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>() allows to conveniently add multiple elements to a list:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"four"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"five"</span>;</pre></div>
<p>QList uses 0-based indexes, just like C++ arrays. To access the item at a particular index position, you can use operator[](). On non-const lists, operator[]() returns a reference to the item and can be used on the left side of an assignment:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">if</span> (list<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="string">"Bob"</span>)
    list<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="string">"Robert"</span>;</pre></div>
<p>Because QList is implemented as an array of pointers for types that are larger than a pointer or are not movable, this operation requires (<a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>). For read-only access, an alternative syntax is to use <a href="./qlist.htm#at" translate="no">at</a>():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> list<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
    <span class="keyword">if</span> (list<span class="operator">.</span>at(i) <span class="operator">=</span><span class="operator">=</span> <span class="string">"Jane"</span>)
        cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Found Jane at position "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
}</pre></div>
<p><a href="./qlist.htm#at" translate="no">at</a>() can be faster than operator[](), because it never causes a <a href="./implicit-sharing.htm#deep-copy" translate="no">deep copy</a> to occur.</p>
<p>A common requirement is to remove an item from a list and do something with it. For this, QList provides <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(), <a href="./qlist.htm#takeFirst" translate="no">takeFirst</a>(), and <a href="./qlist.htm#takeLast" translate="no">takeLast</a>(). Here's a loop that removes the items from a list one at a time and calls <code translate="no">delete</code> on them:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qwidget.htm" translate="no">QWidget</a></span> <span class="operator">*</span><span class="operator">&gt;</span> list;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
<span class="keyword">while</span> (<span class="operator">!</span>list<span class="operator">.</span>isEmpty())
    <span class="keyword">delete</span> list<span class="operator">.</span>takeFirst();</pre></div>
<p>Inserting and removing items at either end of the list is very fast (<a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a> in most cases), because QList preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<p>If you want to find all occurrences of a particular value in a list, use <a href="./qlist.htm#indexOf" translate="no">indexOf</a>() or <a href="./qlist.htm#lastIndexOf" translate="no">lastIndexOf</a>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index of a matching item if they find it; otherwise, they return -1. For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> i <span class="operator">=</span> list<span class="operator">.</span>indexOf(<span class="string">"Jane"</span>);
<span class="keyword">if</span> (i <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>)
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"First occurrence of Jane is at position "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> i <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;</pre></div>
<p>If you simply want to check whether a list contains a particular value, use <a href="./qlist.htm#contains" translate="no">contains</a>(). If you want to find out how many times a particular value occurs in the list, use <a href="./qlist.htm#count-1" translate="no">count</a>(). If you want to replace all occurrences of a particular value with another, use <a href="./qlist.htm#replace" translate="no">replace</a>().</p>
<p>QList's value type must be an <a href="./containers.htm#assignable-data-type" translate="no">assignable data type</a>. This covers most data types that are commonly used, but the compiler won't let you, for example, store a <a href="./qwidget.htm" translate="no">QWidget</a> as a value; instead, store a <a href="./qwidget.htm" translate="no">QWidget</a> *. A few functions have additional requirements; for example, <a href="./qlist.htm#indexOf" translate="no">indexOf</a>() and <a href="./qlist.htm#lastIndexOf" translate="no">lastIndexOf</a>() expect the value type to support <code translate="no">operator==()</code>. These requirements are documented on a per-function basis.</p>
<p>Like the other container classes, QList provides <a href="./containers.htm#java-style-iterators" translate="no">Java-style iterators</a> (<a href="./qlistiterator.htm" translate="no">QListIterator</a> and <a href="./qmutablelistiterator.htm" translate="no">QMutableListIterator</a>) and <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterators</a> (<a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a> and <a href="./qlist-iterator.htm" translate="no">QList::iterator</a>). In practice, these are rarely used, because you can use indexes into the QList. QList is implemented in such a way that direct index-based access is just as fast as using iterators.</p>
<p>QList does <i>not</i> support inserting, prepending, appending or replacing with references to its own values. Doing so will cause your application to abort with an error message.</p>
<p>To make QList as efficient as possible, its member functions don't validate their input before using it. Except for <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>(), member functions always assume the list is <i>not</i> empty. Member functions that take index values as parameters always assume their index value parameters are in the valid range. This means QList member functions can fail. If you define QT_NO_DEBUG when you compile, failures will not be detected. If you <i>don't</i> define QT_NO_DEBUG, failures will be detected using <a href="./qtglobal.htm#Q_ASSERT" translate="no">Q_ASSERT</a>() or <a href="./qtglobal.htm#Q_ASSERT_X" translate="no">Q_ASSERT_X</a>() with an appropriate message.</p>
<p>To avoid failures when your list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling other member functions. If you must pass an index value that might not be in the valid range, check that it is less than the value returned by <a href="./qlist.htm#size" translate="no">size</a>() but <i>not</i> less than 0.</p>
<a name="more-members"></a>
<h3 id="more-members">More Members<a class="plink" href="#more-members" title="Direct link to this headline"></a></h3>
<p>If T is a <a href="./qbytearray.htm" translate="no">QByteArray</a>, this class has a couple more members that can be used. See the documentation for <a href="./qbytearraylist.htm" translate="no">QByteArrayList</a> for more information.</p>
<p>If T is <a href="./qstring.htm" translate="no">QString</a>, this class has the following additional members: <a href="./qstringlist.htm#filter" translate="no">filter</a>, <a href="./qstringlist.htm#join" translate="no">join</a>, <a href="./qstringlist.htm#removeDuplicates" translate="no">removeDuplicates</a>, <a href="./qstringlist.htm#sort" translate="no">sort</a>.</p>
<a name="more-information-on-using-qt-containers"></a>
<h3 id="more-information-on-using-qt-containers">More Information on Using Qt Containers<a class="plink" href="#more-information-on-using-qt-containers" title="Direct link to this headline"></a></h3>
<p>For a detailed discussion comparing Qt containers with each other and with STL containers, see <a href="http://marcmutz.wordpress.com/effective-qt/containers/" translate="no">Understand the Qt Containers</a>.</p>
</div>
<p><b>See also </b><a href="./qlistiterator.htm" translate="no">QListIterator</a>, <a href="./qmutablelistiterator.htm" translate="no">QMutableListIterator</a>, <a href="./qlinkedlist.htm" translate="no">QLinkedList</a>, and <a href="./qvector.htm" translate="no">QVector</a>.</p>
<!-- @@@QList -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$ConstIterator -->
<h3 class="fn" id="ConstIterator-typedef" translate="no"><a name="ConstIterator-typedef"></a>typedef QList::<span class="name">ConstIterator</span><a class="plink" href="#ConstIterator-typedef" title="Direct link to this headline"></a></h3>
<p>Qt-style synonym for <a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a>.</p>
<!-- @@@ConstIterator -->
<!-- $$$Iterator -->
<h3 class="fn" id="Iterator-typedef" translate="no"><a name="Iterator-typedef"></a>typedef QList::<span class="name">Iterator</span><a class="plink" href="#Iterator-typedef" title="Direct link to this headline"></a></h3>
<p>Qt-style synonym for <a href="./qlist-iterator.htm" translate="no">QList::iterator</a>.</p>
<!-- @@@Iterator -->
<!-- $$$const_pointer -->
<h3 class="fn" id="const_pointer-typedef" translate="no"><a name="const_pointer-typedef"></a>typedef QList::<span class="name">const_pointer</span><a class="plink" href="#const_pointer-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for const T *. Provided for STL compatibility.</p>
<!-- @@@const_pointer -->
<!-- $$$const_reference -->
<h3 class="fn" id="const_reference-typedef" translate="no"><a name="const_reference-typedef"></a>typedef QList::<span class="name">const_reference</span><a class="plink" href="#const_reference-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for const T &amp;. Provided for STL compatibility.</p>
<!-- @@@const_reference -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef" translate="no"><a name="const_reverse_iterator-typedef"></a>typedef QList::<span class="name">const_reverse_iterator</span><a class="plink" href="#const_reverse_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>The QList::const_reverse_iterator typedef provides an STL-style const reverse iterator for <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>It is simply a typedef for <code translate="no">std::reverse_iterator&lt;const_iterator&gt;</code>.</p>
<div class="admonition warning">
<p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="./containers.htm#implicit-sharing-iterator-problem" translate="no">Implicit sharing iterator problem</a>.</p>
</div>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#rbegin" translate="no">QList::rbegin</a>(), <a href="./qlist.htm#rend" translate="no">QList::rend</a>(), <a href="./qlist.htm#reverse_iterator-typedef" translate="no">QList::reverse_iterator</a>, and <a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$difference_type -->
<h3 class="fn" id="difference_type-typedef" translate="no"><a name="difference_type-typedef"></a>typedef QList::<span class="name">difference_type</span><a class="plink" href="#difference_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for ptrdiff_t. Provided for STL compatibility.</p>
<!-- @@@difference_type -->
<!-- $$$pointer -->
<h3 class="fn" id="pointer-typedef" translate="no"><a name="pointer-typedef"></a>typedef QList::<span class="name">pointer</span><a class="plink" href="#pointer-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T *. Provided for STL compatibility.</p>
<!-- @@@pointer -->
<!-- $$$reference -->
<h3 class="fn" id="reference-typedef" translate="no"><a name="reference-typedef"></a>typedef QList::<span class="name">reference</span><a class="plink" href="#reference-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T &amp;. Provided for STL compatibility.</p>
<!-- @@@reference -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef" translate="no"><a name="reverse_iterator-typedef"></a>typedef QList::<span class="name">reverse_iterator</span><a class="plink" href="#reverse_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>The QList::reverse_iterator typedef provides an STL-style non-const reverse iterator for <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>It is simply a typedef for <code translate="no">std::reverse_iterator&lt;iterator&gt;</code>.</p>
<div class="admonition warning">
<p><b>Warning: </b>Iterators on implicitly shared containers do not work exactly like STL-iterators. You should avoid copying a container while iterators are active on that container. For more information, read <a href="./containers.htm#implicit-sharing-iterator-problem" translate="no">Implicit sharing iterator problem</a>.</p>
</div>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#rbegin" translate="no">QList::rbegin</a>(), <a href="./qlist.htm#rend" translate="no">QList::rend</a>(), <a href="./qlist.htm#const_reverse_iterator-typedef" translate="no">QList::const_reverse_iterator</a>, and <a href="./qlist-iterator.htm" translate="no">QList::iterator</a>.</p>
<!-- @@@reverse_iterator -->
<!-- $$$size_type -->
<h3 class="fn" id="size_type-typedef" translate="no"><a name="size_type-typedef"></a>typedef QList::<span class="name">size_type</span><a class="plink" href="#size_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<!-- @@@size_type -->
<!-- $$$value_type -->
<h3 class="fn" id="value_type-typedef" translate="no"><a name="value_type-typedef"></a>typedef QList::<span class="name">value_type</span><a class="plink" href="#value_type-typedef" title="Direct link to this headline"></a></h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<!-- @@@value_type -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QList$$$QListInputIteratorInputIterator -->
<h3 class="fn" id="QList-4" translate="no"><a name="QList-4"></a>template &lt;typename InputIterator, int&gt; QList::<span class="name">QList</span>(<span class="type">InputIterator</span> <i>first</i>, <span class="type">InputIterator</span> <i>last</i>)<a class="plink" href="#QList-4" title="Direct link to this headline"></a></h3>
<p>Constructs a QList with the contents in the iterator range [<i translate="no">first</i>, <i translate="no">last</i>).</p>
<p>The value type of <code translate="no">InputIterator</code> must be convertible to <code translate="no">T</code>.</p>
<p>This function was introduced in Qt 5.14.</p>
<!-- @@@QList -->
<!-- $$$QList$$$QListint -->
<h3 class="fn" id="QList-3" translate="no"><a name="QList-3"></a>QList::<span class="name">QList</span>(<span class="type">int</span> <i>args</i>)<a class="plink" href="#QList-3" title="Direct link to this headline"></a></h3>
<p>Construct a list from the std::initializer_list specified by <i translate="no">args</i>.</p>
<p>This constructor is only enabled if the compiler supports C++11 initializer lists.</p>
<p>This function was introduced in Qt 4.8.</p>
<!-- @@@QList -->
<!-- $$$QList$$$QListQList<T>&& -->
<h3 class="fn" id="QList-2" translate="no"><a name="QList-2"></a>QList::<span class="name">QList</span>(<span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)<a class="plink" href="#QList-2" title="Direct link to this headline"></a></h3>
<p>Move-constructs a QList instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@QList -->
<!-- $$$QList$$$QListconstQList<T>& -->
<h3 class="fn" id="QList-1" translate="no"><a name="QList-1"></a>QList::<span class="name">QList</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#QList-1" title="Direct link to this headline"></a></h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p>This operation takes <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>, because QList is <a href="./implicit-sharing.htm" translate="no">implicitly shared</a>. This makes returning a QList from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes <a href="./containers.htm#algorithmic-complexity" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="./qlist.htm#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QList -->
<!-- $$$QList[overload1]$$$QList -->
<h3 class="fn" id="QList" translate="no"><a name="QList"></a>QList::<span class="name">QList</span>()<a class="plink" href="#QList" title="Direct link to this headline"></a></h3>
<p>Constructs an empty list.</p>
<!-- @@@QList -->
<!-- $$$operator=$$$operator=QList<T>&& -->
<h3 class="fn" id="operator-eq-1" translate="no"><a name="operator-eq-1"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator=</span>(<span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;&amp;<i>other</i>)<a class="plink" href="#operator-eq-1" title="Direct link to this headline"></a></h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="./qlist.htm" translate="no">QList</a> instance.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@operator= -->
<!-- $$$operator=[overload1]$$$operator=constQList<T>& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator=</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns <i translate="no">other</i> to this list and returns a reference to this list.</p>
<!-- @@@operator= -->
<!-- $$$~QList[overload1]$$$~QList -->
<h3 class="fn" id="dtor.QList" translate="no"><a name="dtor.QList"></a>QList::<span class="name">~QList</span>()<a class="plink" href="#dtor.QList" title="Direct link to this headline"></a></h3>
<p>Destroys the list. References to the values in the list and all iterators of this list become invalid.</p>
<!-- @@@~QList -->
<!-- $$$append[overload1]$$$appendconstT& -->
<h3 class="fn" id="append" translate="no"><a name="append"></a><span class="type">void</span> QList::<span class="name">append</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#append" title="Direct link to this headline"></a></h3>
<p>Inserts <i translate="no">value</i> at the end of the list.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list<span class="operator">.</span>append(<span class="string">"one"</span>);
list<span class="operator">.</span>append(<span class="string">"two"</span>);
list<span class="operator">.</span>append(<span class="string">"three"</span>);
<span class="comment">// list: ["one", "two", "three"]</span></pre></div>
<p>This is the same as list.insert(<a href="./qlist.htm#size" translate="no">size</a>(), <i translate="no">value</i>).</p>
<p>If this list is not shared, this operation is typically very fast (amortized <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>), because <a href="./qlist.htm" translate="no">QList</a> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<p><b>See also </b><a href="./qlist.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>(), <a href="./qlist.htm#prepend" translate="no">prepend</a>(), and <a href="./qlist.htm#insert" translate="no">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstQList<T>& -->
<h3 class="fn" id="append-1" translate="no"><a name="append-1"></a><span class="type">void</span> QList::<span class="name">append</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>value</i>)<a class="plink" href="#append-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends the items of the <i translate="no">value</i> list to this list.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="./qlist.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>() and <a href="./qlist.htm#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@append -->
<!-- $$$at[overload1]$$$atint -->
<h3 class="fn" id="at" translate="no"><a name="at"></a>const <span class="type">T</span> &amp;QList::<span class="name">at</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#at" title="Direct link to this headline"></a></h3>
<p>Returns the item at index position <i translate="no">i</i> in the list. <i translate="no">i</i> must be a valid index position in the list (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qlist.htm#size" translate="no">size</a>()).</p>
<p>This function is very fast (<a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>).</p>
<p><b>See also </b><a href="./qlist.htm#value" translate="no">value</a>() and <a href="./qlist.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" id="back" translate="no"><a name="back"></a><span class="type">T</span> &amp;QList::<span class="name">back</span>()<a class="plink" href="#back" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qlist.htm#last" translate="no">last</a>(). The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" id="back-1" translate="no"><a name="back-1"></a>const <span class="type">T</span> &amp;QList::<span class="name">back</span>() const<a class="plink" href="#back-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin" translate="no"><a name="begin"></a><span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> QList::<span class="name">begin</span>()<a class="plink" href="#begin" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the list.</p>
<p><b>See also </b><a href="./qlist.htm#constBegin" translate="no">constBegin</a>() and <a href="./qlist.htm#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1" translate="no"><a name="begin-1"></a><span class="type"><a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a></span> QList::<span class="name">begin</span>() const<a class="plink" href="#begin-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@begin -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin" translate="no"><a name="cbegin"></a><span class="type"><a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a></span> QList::<span class="name">cbegin</span>() const<a class="plink" href="#cbegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the list.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qlist.htm#begin" translate="no">begin</a>() and <a href="./qlist.htm#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend" translate="no"><a name="cend"></a><span class="type"><a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a></span> QList::<span class="name">cend</span>() const<a class="plink" href="#cend" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the list.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qlist.htm#cbegin" translate="no">cbegin</a>() and <a href="./qlist.htm#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear" translate="no"><a name="clear"></a><span class="type">void</span> QList::<span class="name">clear</span>()<a class="plink" href="#clear" title="Direct link to this headline"></a></h3>
<p>Removes all items from the list.</p>
<p><b>See also </b><a href="./qlist.htm#removeAll" translate="no">removeAll</a>().</p>
<!-- @@@clear -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin" translate="no"><a name="constBegin"></a><span class="type"><a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a></span> QList::<span class="name">constBegin</span>() const<a class="plink" href="#constBegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first item in the list.</p>
<p><b>See also </b><a href="./qlist.htm#begin" translate="no">begin</a>() and <a href="./qlist.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd" translate="no"><a name="constEnd"></a><span class="type"><a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a></span> QList::<span class="name">constEnd</span>() const<a class="plink" href="#constEnd" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the list.</p>
<p><b>See also </b><a href="./qlist.htm#constBegin" translate="no">constBegin</a>() and <a href="./qlist.htm#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$constFirst[overload1]$$$constFirst -->
<h3 class="fn" id="constFirst" translate="no"><a name="constFirst"></a>const <span class="type">T</span> &amp;QList::<span class="name">constFirst</span>() const<a class="plink" href="#constFirst" title="Direct link to this headline"></a></h3>
<p>Returns a const reference to the first item in the list. The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#constLast" translate="no">constLast</a>(), <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>(), and <a href="./qlist.htm#first" translate="no">first</a>().</p>
<!-- @@@constFirst -->
<!-- $$$constLast[overload1]$$$constLast -->
<h3 class="fn" id="constLast" translate="no"><a name="constLast"></a>const <span class="type">T</span> &amp;QList::<span class="name">constLast</span>() const<a class="plink" href="#constLast" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the last item in the list. The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#constFirst" translate="no">constFirst</a>(), <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>(), and <a href="./qlist.htm#last" translate="no">last</a>().</p>
<!-- @@@constLast -->
<!-- $$$contains[overload1]$$$containsconstT& -->
<h3 class="fn" id="contains" translate="no"><a name="contains"></a><span class="type">bool</span> QList::<span class="name">contains</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#contains" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the list contains an occurrence of <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qlist.htm#indexOf" translate="no">indexOf</a>() and <a href="./qlist.htm#count-1" translate="no">count</a>().</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstT& -->
<h3 class="fn" id="count" translate="no"><a name="count"></a><span class="type">int</span> QList::<span class="name">count</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#count" title="Direct link to this headline"></a></h3>
<p>Returns the number of occurrences of <i translate="no">value</i> in the list.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qlist.htm#contains" translate="no">contains</a>() and <a href="./qlist.htm#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-1" translate="no"><a name="count-1"></a><span class="type">int</span> QList::<span class="name">count</span>() const<a class="plink" href="#count-1" title="Direct link to this headline"></a></h3>
<p>Returns the number of items in the list. This is effectively the same as <a href="./qlist.htm#size" translate="no">size</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin" translate="no"><a name="crbegin"></a><span class="type"><a href="./qlist.htm#const_reverse_iterator-typedef" translate="no">QList::const_reverse_iterator</a></span> QList::<span class="name">crbegin</span>() const<a class="plink" href="#crbegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first item in the list, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#begin" translate="no">begin</a>(), <a href="./qlist.htm#rbegin" translate="no">rbegin</a>(), and <a href="./qlist.htm#rend" translate="no">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend" translate="no"><a name="crend"></a><span class="type"><a href="./qlist.htm#const_reverse_iterator-typedef" translate="no">QList::const_reverse_iterator</a></span> QList::<span class="name">crend</span>() const<a class="plink" href="#crend" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last item in the list, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#end" translate="no">end</a>(), <a href="./qlist.htm#rend" translate="no">rend</a>(), and <a href="./qlist.htm#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$empty[overload1]$$$empty -->
<h3 class="fn" id="empty" translate="no"><a name="empty"></a><span class="type">bool</span> QList::<span class="name">empty</span>() const<a class="plink" href="#empty" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() and returns <code translate="no">true</code> if the list is empty.</p>
<!-- @@@empty -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end" translate="no"><a name="end"></a><span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> QList::<span class="name">end</span>()<a class="plink" href="#end" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary item after the last item in the list.</p>
<p><b>See also </b><a href="./qlist.htm#begin" translate="no">begin</a>() and <a href="./qlist.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1" translate="no"><a name="end-1"></a><span class="type"><a href="./qlist-const-iterator.htm" translate="no">QList::const_iterator</a></span> QList::<span class="name">end</span>() const<a class="plink" href="#end-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithconstT& -->
<h3 class="fn" id="endsWith" translate="no"><a name="endsWith"></a><span class="type">bool</span> QList::<span class="name">endsWith</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#endsWith" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this list is not empty and its last item is equal to <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qlist.htm#contains" translate="no">contains</a>().</p>
<!-- @@@endsWith -->
<!-- $$$erase[overload1]$$$eraseQList::iterator -->
<h3 class="fn" id="erase" translate="no"><a name="erase"></a><span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> QList::<span class="name">erase</span>(<span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> <i>pos</i>)<a class="plink" href="#erase" title="Direct link to this headline"></a></h3>
<p>Removes the item associated with the iterator <i translate="no">pos</i> from the list, and returns an iterator to the next item in the list (which may be <a href="./qlist.htm#end" translate="no">end</a>()).</p>
<p><b>See also </b><a href="./qlist.htm#insert" translate="no">insert</a>() and <a href="./qlist.htm#removeAt" translate="no">removeAt</a>().</p>
<!-- @@@erase -->
<!-- $$$erase$$$eraseQList::iteratorQList::iterator -->
<h3 class="fn" id="erase-1" translate="no"><a name="erase-1"></a><span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> QList::<span class="name">erase</span>(<span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> <i>begin</i>, <span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> <i>end</i>)<a class="plink" href="#erase-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Removes all the items from <i translate="no">begin</i> up to (but not including) <i translate="no">end</i>. Returns an iterator to the same item that <i translate="no">end</i> referred to before the call.</p>
<!-- @@@erase -->
<!-- $$$first[overload1]$$$first -->
<h3 class="fn" id="first" translate="no"><a name="first"></a><span class="type">T</span> &amp;QList::<span class="name">first</span>()<a class="plink" href="#first" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the first item in the list. The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p><b>See also </b><a href="./qlist.htm#constFirst" translate="no">constFirst</a>(), <a href="./qlist.htm#last" translate="no">last</a>(), and <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@first -->
<!-- $$$first$$$first -->
<h3 class="fn" id="first-1" translate="no"><a name="first-1"></a>const <span class="type">T</span> &amp;QList::<span class="name">first</span>() const<a class="plink" href="#first-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@first -->
<!-- $$$fromVector[overload1]$$$fromVectorconstQVector<T>& -->
<h3 class="fn" id="fromVector" translate="no"><a name="fromVector"></a><code translate="no">[static] </code><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QList::<span class="name">fromVector</span>(const <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>vector</i>)<a class="plink" href="#fromVector" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./qlist.htm" translate="no">QList</a> object with the data contained in <i translate="no">vector</i>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> vect;
vect <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">20.0</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">30.0</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">40.0</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="number">50.0</span>;

<span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span> list <span class="operator">=</span> <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;</span><span class="operator">::</span>fromVector(vect);
<span class="comment">// list: [20.0, 30.0, 40.0, 50.0]</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>Since Qt 5.14, range constructors are available for Qt's generic <a href="./containers.htm" translate="no">container classes</a> and should be used in place of this method.</p>
</div>
<p><b>See also </b><a href="./qlist.htm#toVector" translate="no">toVector</a>() and <a href="./qvector.htm#toList" translate="no">QVector::toList</a>().</p>
<!-- @@@fromVector -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" id="front" translate="no"><a name="front"></a><span class="type">T</span> &amp;QList::<span class="name">front</span>()<a class="plink" href="#front" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qlist.htm#first" translate="no">first</a>(). The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" id="front-1" translate="no"><a name="front-1"></a>const <span class="type">T</span> &amp;QList::<span class="name">front</span>() const<a class="plink" href="#front-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfconstT&int -->
<h3 class="fn" id="indexOf" translate="no"><a name="indexOf"></a><span class="type">int</span> QList::<span class="name">indexOf</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>from</i> = 0) const<a class="plink" href="#indexOf" title="Direct link to this headline"></a></h3>
<p>Returns the index position of the first occurrence of <i translate="no">value</i> in the list, searching forward from index position <i translate="no">from</i>. Returns -1 if no item matched.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"C"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span>;
list<span class="operator">.</span>indexOf(<span class="string">"B"</span>);          <span class="comment">// returns 1</span>
list<span class="operator">.</span>indexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">1</span>);       <span class="comment">// returns 1</span>
list<span class="operator">.</span>indexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">2</span>);       <span class="comment">// returns 3</span>
list<span class="operator">.</span>indexOf(<span class="string">"X"</span>);          <span class="comment">// returns -1</span></pre></div>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p>Note that <a href="./qlist.htm" translate="no">QList</a> uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<p><b>See also </b><a href="./qlist.htm#lastIndexOf" translate="no">lastIndexOf</a>() and <a href="./qlist.htm#contains" translate="no">contains</a>().</p>
<!-- @@@indexOf -->
<!-- $$$insert[overload1]$$$insertintconstT& -->
<h3 class="fn" id="insert" translate="no"><a name="insert"></a><span class="type">void</span> QList::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert" title="Direct link to this headline"></a></h3>
<p>Inserts <i translate="no">value</i> at index position <i translate="no">i</i> in the list.</p>
<p>If <i translate="no">i</i> == 0, the value is prepended to the list. If <i translate="no">i</i> == <a href="./qlist.htm#size" translate="no">size</a>(), the value is appended to the list.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"alpha"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"beta"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"delta"</span>;
list<span class="operator">.</span>insert(<span class="number">2</span><span class="operator">,</span> <span class="string">"gamma"</span>);
<span class="comment">// list: ["alpha", "beta", "gamma", "delta"]</span></pre></div>
<p><b>See also </b><a href="./qlist.htm#append" translate="no">append</a>(), <a href="./qlist.htm#prepend" translate="no">prepend</a>(), <a href="./qlist.htm#replace" translate="no">replace</a>(), and <a href="./qlist.htm#removeAt" translate="no">removeAt</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertQList::iteratorconstT& -->
<h3 class="fn" id="insert-1" translate="no"><a name="insert-1"></a><span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> QList::<span class="name">insert</span>(<span class="type"><a href="./qlist-iterator.htm" translate="no">QList::iterator</a></span> <i>before</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#insert-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts <i translate="no">value</i> in front of the item pointed to by the iterator <i translate="no">before</i>. Returns an iterator pointing at the inserted item. Note that the iterator passed to the function will be invalid after the call; the returned iterator should be used instead.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty" translate="no"><a name="isEmpty"></a><span class="type">bool</span> QList::<span class="name">isEmpty</span>() const<a class="plink" href="#isEmpty" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the list contains no items; otherwise returns false.</p>
<p><b>See also </b><a href="./qlist.htm#size" translate="no">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$last[overload1]$$$last -->
<h3 class="fn" id="last" translate="no"><a name="last"></a><span class="type">T</span> &amp;QList::<span class="name">last</span>()<a class="plink" href="#last" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the last item in the list. The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p><b>See also </b><a href="./qlist.htm#constLast" translate="no">constLast</a>(), <a href="./qlist.htm#first" translate="no">first</a>(), and <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@last -->
<!-- $$$last$$$last -->
<h3 class="fn" id="last-1" translate="no"><a name="last-1"></a>const <span class="type">T</span> &amp;QList::<span class="name">last</span>() const<a class="plink" href="#last-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@last -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstT&int -->
<h3 class="fn" id="lastIndexOf" translate="no"><a name="lastIndexOf"></a><span class="type">int</span> QList::<span class="name">lastIndexOf</span>(const <span class="type">T</span> &amp;<i>value</i>, <span class="type">int</span> <i>from</i> = -1) const<a class="plink" href="#lastIndexOf" title="Direct link to this headline"></a></h3>
<p>Returns the index position of the last occurrence of <i translate="no">value</i> in the list, searching backward from index position <i translate="no">from</i>. If <i translate="no">from</i> is -1 (the default), the search starts at the last item. Returns -1 if no item matched.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"C"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span>;
list<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span>);      <span class="comment">// returns 3</span>
list<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">3</span>);   <span class="comment">// returns 3</span>
list<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">2</span>);   <span class="comment">// returns 1</span>
list<span class="operator">.</span>lastIndexOf(<span class="string">"X"</span>);      <span class="comment">// returns -1</span></pre></div>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p>Note that <a href="./qlist.htm" translate="no">QList</a> uses 0-based indexes, just like C++ arrays. Negative indexes are not supported with the exception of the value mentioned above.</p>
<p><b>See also </b><a href="./qlist.htm#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" id="length" translate="no"><a name="length"></a><span class="type">int</span> QList::<span class="name">length</span>() const<a class="plink" href="#length" title="Direct link to this headline"></a></h3>
<p>This function is identical to <a href="./qlist.htm#count-1" translate="no">count</a>().</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="./qlist.htm#count-1" translate="no">count</a>().</p>
<!-- @@@length -->
<!-- $$$mid[overload1]$$$midintint -->
<h3 class="fn" id="mid" translate="no"><a name="mid"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QList::<span class="name">mid</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>length</i> = -1) const<a class="plink" href="#mid" title="Direct link to this headline"></a></h3>
<p>Returns a sub-list which includes elements from this list, starting at position <i translate="no">pos</i>. If <i translate="no">length</i> is -1 (the default), all elements from <i translate="no">pos</i> are included; otherwise <i translate="no">length</i> elements (or all remaining elements if there are less than <i translate="no">length</i> elements) are included.</p>
<!-- @@@mid -->
<!-- $$$move[overload1]$$$moveintint -->
<h3 class="fn" id="move" translate="no"><a name="move"></a><span class="type">void</span> QList::<span class="name">move</span>(<span class="type">int</span> <i>from</i>, <span class="type">int</span> <i>to</i>)<a class="plink" href="#move" title="Direct link to this headline"></a></h3>
<p>Moves the item at index position <i translate="no">from</i> to index position <i translate="no">to</i>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"C"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"D"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"E"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"F"</span>;
list<span class="operator">.</span>move(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
<span class="comment">// list: ["A", "C", "D", "E", "B", "F"]</span></pre></div>
<p>This is the same as insert(<i translate="no">to</i>, <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(<i translate="no">from</i>)).This function assumes that both <i translate="no">from</i> and <i translate="no">to</i> are at least 0 but less than <a href="./qlist.htm#size" translate="no">size</a>(). To avoid failure, test that both <i translate="no">from</i> and <i translate="no">to</i> are at least 0 and less than <a href="./qlist.htm#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="./qlist.htm#swap" translate="no">swap</a>(), <a href="./qlist.htm#insert" translate="no">insert</a>(), and <a href="./qlist.htm#takeAt" translate="no">takeAt</a>().</p>
<!-- @@@move -->
<!-- $$$pop_back[overload1]$$$pop_back -->
<h3 class="fn" id="pop_back" translate="no"><a name="pop_back"></a><span class="type">void</span> QList::<span class="name">pop_back</span>()<a class="plink" href="#pop_back" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qlist.htm#removeLast" translate="no">removeLast</a>(). The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<!-- @@@pop_back -->
<!-- $$$pop_front[overload1]$$$pop_front -->
<h3 class="fn" id="pop_front" translate="no"><a name="pop_front"></a><span class="type">void</span> QList::<span class="name">pop_front</span>()<a class="plink" href="#pop_front" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qlist.htm#removeFirst" translate="no">removeFirst</a>(). The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<!-- @@@pop_front -->
<!-- $$$prepend[overload1]$$$prependconstT& -->
<h3 class="fn" id="prepend" translate="no"><a name="prepend"></a><span class="type">void</span> QList::<span class="name">prepend</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#prepend" title="Direct link to this headline"></a></h3>
<p>Inserts <i translate="no">value</i> at the beginning of the list.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list<span class="operator">.</span>prepend(<span class="string">"one"</span>);
list<span class="operator">.</span>prepend(<span class="string">"two"</span>);
list<span class="operator">.</span>prepend(<span class="string">"three"</span>);
<span class="comment">// list: ["three", "two", "one"]</span></pre></div>
<p>This is the same as list.insert(0, <i translate="no">value</i>).</p>
<p>If this list is not shared, this operation is typically very fast (amortized <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>), because <a href="./qlist.htm" translate="no">QList</a> preallocates extra space on both sides of its internal buffer to allow for fast growth at both ends of the list.</p>
<p><b>See also </b><a href="./qlist.htm#append" translate="no">append</a>() and <a href="./qlist.htm#insert" translate="no">insert</a>().</p>
<!-- @@@prepend -->
<!-- $$$push_back[overload1]$$$push_backconstT& -->
<h3 class="fn" id="push_back" translate="no"><a name="push_back"></a><span class="type">void</span> QList::<span class="name">push_back</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#push_back" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qlist.htm#append" translate="no">append</a>(<i translate="no">value</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_front[overload1]$$$push_frontconstT& -->
<h3 class="fn" id="push_front" translate="no"><a name="push_front"></a><span class="type">void</span> QList::<span class="name">push_front</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#push_front" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qlist.htm#prepend" translate="no">prepend</a>(<i translate="no">value</i>).</p>
<!-- @@@push_front -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin" translate="no"><a name="rbegin"></a><span class="type"><a href="./qlist.htm#reverse_iterator-typedef" translate="no">QList::reverse_iterator</a></span> QList::<span class="name">rbegin</span>()<a class="plink" href="#rbegin" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first item in the list, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#begin" translate="no">begin</a>(), <a href="./qlist.htm#crbegin" translate="no">crbegin</a>(), and <a href="./qlist.htm#rend" translate="no">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1" translate="no"><a name="rbegin-1"></a><span class="type"><a href="./qlist.htm#const_reverse_iterator-typedef" translate="no">QList::const_reverse_iterator</a></span> QList::<span class="name">rbegin</span>() const<a class="plink" href="#rbegin-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rbegin -->
<!-- $$$removeAll[overload1]$$$removeAllconstT& -->
<h3 class="fn" id="removeAll" translate="no"><a name="removeAll"></a><span class="type">int</span> QList::<span class="name">removeAll</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#removeAll" title="Direct link to this headline"></a></h3>
<p>Removes all occurrences of <i translate="no">value</i> in the list and returns the number of entries removed.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"sun"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"cloud"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"sun"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"rain"</span>;
list<span class="operator">.</span>removeAll(<span class="string">"sun"</span>);
<span class="comment">// list: ["cloud", "rain"]</span></pre></div>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qlist.htm#removeOne" translate="no">removeOne</a>(), <a href="./qlist.htm#removeAt" translate="no">removeAt</a>(), <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(), and <a href="./qlist.htm#replace" translate="no">replace</a>().</p>
<!-- @@@removeAll -->
<!-- $$$removeAt[overload1]$$$removeAtint -->
<h3 class="fn" id="removeAt" translate="no"><a name="removeAt"></a><span class="type">void</span> QList::<span class="name">removeAt</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#removeAt" title="Direct link to this headline"></a></h3>
<p>Removes the item at index position <i translate="no">i</i>. <i translate="no">i</i> must be a valid index position in the list (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qlist.htm#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="./qlist.htm#takeAt" translate="no">takeAt</a>(), <a href="./qlist.htm#removeFirst" translate="no">removeFirst</a>(), <a href="./qlist.htm#removeLast" translate="no">removeLast</a>(), and <a href="./qlist.htm#removeOne" translate="no">removeOne</a>().</p>
<!-- @@@removeAt -->
<!-- $$$removeFirst[overload1]$$$removeFirst -->
<h3 class="fn" id="removeFirst" translate="no"><a name="removeFirst"></a><span class="type">void</span> QList::<span class="name">removeFirst</span>()<a class="plink" href="#removeFirst" title="Direct link to this headline"></a></h3>
<p>Removes the first item in the list. Calling this function is equivalent to calling <a href="./qlist.htm#removeAt" translate="no">removeAt</a>(0). The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p><b>See also </b><a href="./qlist.htm#removeAt" translate="no">removeAt</a>() and <a href="./qlist.htm#takeFirst" translate="no">takeFirst</a>().</p>
<!-- @@@removeFirst -->
<!-- $$$removeLast[overload1]$$$removeLast -->
<h3 class="fn" id="removeLast" translate="no"><a name="removeLast"></a><span class="type">void</span> QList::<span class="name">removeLast</span>()<a class="plink" href="#removeLast" title="Direct link to this headline"></a></h3>
<p>Removes the last item in the list. Calling this function is equivalent to calling <a href="./qlist.htm#removeAt" translate="no">removeAt</a>(<a href="./qlist.htm#size" translate="no">size</a>() - 1). The list must not be empty. If the list can be empty, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p><b>See also </b><a href="./qlist.htm#removeAt" translate="no">removeAt</a>() and <a href="./qlist.htm#takeLast" translate="no">takeLast</a>().</p>
<!-- @@@removeLast -->
<!-- $$$removeOne[overload1]$$$removeOneconstT& -->
<h3 class="fn" id="removeOne" translate="no"><a name="removeOne"></a><span class="type">bool</span> QList::<span class="name">removeOne</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#removeOne" title="Direct link to this headline"></a></h3>
<p>Removes the first occurrence of <i translate="no">value</i> in the list and returns true on success; otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"sun"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"cloud"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"sun"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"rain"</span>;
list<span class="operator">.</span>removeOne(<span class="string">"sun"</span>);
<span class="comment">// list: ["cloud", "sun", "rain"]</span></pre></div>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qlist.htm#removeAll" translate="no">removeAll</a>(), <a href="./qlist.htm#removeAt" translate="no">removeAt</a>(), <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(), and <a href="./qlist.htm#replace" translate="no">replace</a>().</p>
<!-- @@@removeOne -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend" translate="no"><a name="rend"></a><span class="type"><a href="./qlist.htm#reverse_iterator-typedef" translate="no">QList::reverse_iterator</a></span> QList::<span class="name">rend</span>()<a class="plink" href="#rend" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last item in the list, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qlist.htm#end" translate="no">end</a>(), <a href="./qlist.htm#crend" translate="no">crend</a>(), and <a href="./qlist.htm#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1" translate="no"><a name="rend-1"></a><span class="type"><a href="./qlist.htm#const_reverse_iterator-typedef" translate="no">QList::const_reverse_iterator</a></span> QList::<span class="name">rend</span>() const<a class="plink" href="#rend-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rend -->
<!-- $$$replace[overload1]$$$replaceintconstT& -->
<h3 class="fn" id="replace" translate="no"><a name="replace"></a><span class="type">void</span> QList::<span class="name">replace</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#replace" title="Direct link to this headline"></a></h3>
<p>Replaces the item at index position <i translate="no">i</i> with <i translate="no">value</i>. <i translate="no">i</i> must be a valid index position in the list (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qlist.htm#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="./qlist.htm#operator-5b-5d" translate="no">operator[]</a>() and <a href="./qlist.htm#removeAt" translate="no">removeAt</a>().</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn" id="reserve" translate="no"><a name="reserve"></a><span class="type">void</span> QList::<span class="name">reserve</span>(<span class="type">int</span> <i>alloc</i>)<a class="plink" href="#reserve" title="Direct link to this headline"></a></h3>
<p>Reserve space for <i translate="no">alloc</i> elements.</p>
<p>If <i translate="no">alloc</i> is smaller than the current size of the list, nothing will happen.</p>
<p>Use this function to avoid repetetive reallocation of <a href="./qlist.htm" translate="no">QList</a>'s internal data if you can predict how many elements will be appended. Note that the reservation applies only to the internal pointer array.</p>
<p>This function was introduced in Qt 4.7.</p>
<!-- @@@reserve -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type">int</span> QList::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the number of items in the list.</p>
<p><b>See also </b><a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qlist.htm#count-1" translate="no">count</a>().</p>
<!-- @@@size -->
<!-- $$$startsWith[overload1]$$$startsWithconstT& -->
<h3 class="fn" id="startsWith" translate="no"><a name="startsWith"></a><span class="type">bool</span> QList::<span class="name">startsWith</span>(const <span class="type">T</span> &amp;<i>value</i>) const<a class="plink" href="#startsWith" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this list is not empty and its first item is equal to <i translate="no">value</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function was introduced in Qt 4.5.</p>
<p><b>See also </b><a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qlist.htm#contains" translate="no">contains</a>().</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQList<T>& -->
<h3 class="fn" id="swap" translate="no"><a name="swap"></a><span class="type">void</span> QList::<span class="name">swap</span>(<span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#swap" title="Direct link to this headline"></a></h3>
<p>Swaps list <i translate="no">other</i> with this list. This operation is very fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>
<!-- @@@swap -->
<!-- $$$swapItemsAt[overload1]$$$swapItemsAtintint -->
<h3 class="fn" id="swapItemsAt" translate="no"><a name="swapItemsAt"></a><span class="type">void</span> QList::<span class="name">swapItemsAt</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>j</i>)<a class="plink" href="#swapItemsAt" title="Direct link to this headline"></a></h3>
<p>Exchange the item at index position <i translate="no">i</i> with the item at index position <i translate="no">j</i>. This function assumes that both <i translate="no">i</i> and <i translate="no">j</i> are at least 0 but less than <a href="./qlist.htm#size" translate="no">size</a>(). To avoid failure, test that both <i translate="no">i</i> and <i translate="no">j</i> are at least 0 and less than <a href="./qlist.htm#size" translate="no">size</a>().</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"A"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"B"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"C"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"D"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"E"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"F"</span>;
list<span class="operator">.</span>swapItemsAt(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
<span class="comment">// list: ["A", "E", "C", "D", "B", "F"]</span></pre></div>
<p>This function was introduced in Qt 5.13.</p>
<p><b>See also </b><a href="./qlist.htm#move" translate="no">move</a>().</p>
<!-- @@@swapItemsAt -->
<!-- $$$takeAt[overload1]$$$takeAtint -->
<h3 class="fn" id="takeAt" translate="no"><a name="takeAt"></a><span class="type">T</span> QList::<span class="name">takeAt</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#takeAt" title="Direct link to this headline"></a></h3>
<p>Removes the item at index position <i translate="no">i</i> and returns it. <i translate="no">i</i> must be a valid index position in the list (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qlist.htm#size" translate="no">size</a>()).</p>
<p>If you don't use the return value, <a href="./qlist.htm#removeAt" translate="no">removeAt</a>() is more efficient.</p>
<p><b>See also </b><a href="./qlist.htm#removeAt" translate="no">removeAt</a>(), <a href="./qlist.htm#takeFirst" translate="no">takeFirst</a>(), and <a href="./qlist.htm#takeLast" translate="no">takeLast</a>().</p>
<!-- @@@takeAt -->
<!-- $$$takeFirst[overload1]$$$takeFirst -->
<h3 class="fn" id="takeFirst" translate="no"><a name="takeFirst"></a><span class="type">T</span> QList::<span class="name">takeFirst</span>()<a class="plink" href="#takeFirst" title="Direct link to this headline"></a></h3>
<p>Removes the first item in the list and returns it. This is the same as <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(0). This function assumes the list is not empty. To avoid failure, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>If this list is not shared, this operation takes <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>.</p>
<p>If you don't use the return value, <a href="./qlist.htm#removeFirst" translate="no">removeFirst</a>() is more efficient.</p>
<p><b>See also </b><a href="./qlist.htm#takeLast" translate="no">takeLast</a>(), <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(), and <a href="./qlist.htm#removeFirst" translate="no">removeFirst</a>().</p>
<!-- @@@takeFirst -->
<!-- $$$takeLast[overload1]$$$takeLast -->
<h3 class="fn" id="takeLast" translate="no"><a name="takeLast"></a><span class="type">T</span> QList::<span class="name">takeLast</span>()<a class="plink" href="#takeLast" title="Direct link to this headline"></a></h3>
<p>Removes the last item in the list and returns it. This is the same as <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(<a href="./qlist.htm#size" translate="no">size</a>() - 1). This function assumes the list is not empty. To avoid failure, call <a href="./qlist.htm#isEmpty" translate="no">isEmpty</a>() before calling this function.</p>
<p>If this list is not shared, this operation takes <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>.</p>
<p>If you don't use the return value, <a href="./qlist.htm#removeLast" translate="no">removeLast</a>() is more efficient.</p>
<p><b>See also </b><a href="./qlist.htm#takeFirst" translate="no">takeFirst</a>(), <a href="./qlist.htm#takeAt" translate="no">takeAt</a>(), and <a href="./qlist.htm#removeLast" translate="no">removeLast</a>().</p>
<!-- @@@takeLast -->
<!-- $$$toVector[overload1]$$$toVector -->
<h3 class="fn" id="toVector" translate="no"><a name="toVector"></a><span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type">T</span>&gt; QList::<span class="name">toVector</span>() const<a class="plink" href="#toVector" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./qvector.htm" translate="no">QVector</a> object with the data contained in this <a href="./qlist.htm" translate="no">QList</a>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> list;
list <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Sven"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Kim"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Ola"</span>;

<span class="type"><a href="./qvector.htm" translate="no">QVector</a></span><span class="operator">&lt;</span><span class="type"><a href="./qstring.htm" translate="no">QString</a></span><span class="operator">&gt;</span> vect <span class="operator">=</span> list<span class="operator">.</span>toVector();
<span class="comment">// vect: ["Sven", "Kim", "Ola"]</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>Since Qt 5.14, range constructors are available for Qt's generic <a href="./containers.htm" translate="no">container classes</a> and should be used in place of this method.</p>
</div>
<p><b>See also </b><a href="./qlist.htm#fromVector" translate="no">fromVector</a>() and <a href="./qvector.htm#fromList" translate="no">QVector::fromList</a>().</p>
<!-- @@@toVector -->
<!-- $$$value[overload1]$$$valueint -->
<h3 class="fn" id="value" translate="no"><a name="value"></a><span class="type">T</span> QList::<span class="name">value</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#value" title="Direct link to this headline"></a></h3>
<p>Returns the value at index position <i translate="no">i</i> in the list.</p>
<p>If the index <i translate="no">i</i> is out of bounds, the function returns a <a href="./containers.htm#default-constructed-value" translate="no">default-constructed value</a>. If you are certain that the index is going to be within bounds, you can use <a href="./qlist.htm#at" translate="no">at</a>() instead, which is slightly faster.</p>
<p><b>See also </b><a href="./qlist.htm#at" translate="no">at</a>() and <a href="./qlist.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@value -->
<!-- $$$value$$$valueintconstT& -->
<h3 class="fn" id="value-1" translate="no"><a name="value-1"></a><span class="type">T</span> QList::<span class="name">value</span>(<span class="type">int</span> <i>i</i>, const <span class="type">T</span> &amp;<i>defaultValue</i>) const<a class="plink" href="#value-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>If the index <i translate="no">i</i> is out of bounds, the function returns <i translate="no">defaultValue</i>.</p>
<!-- @@@value -->
<!-- $$$operator!=[overload1]$$$operator!=constQList<T>& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QList::<span class="name">operator!=</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is not equal to this list; otherwise returns <code translate="no">false</code>.</p>
<p>Two lists are considered equal if they contain the same values in the same order.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qlist.htm#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator+[overload1]$$$operator+constQList<T>& -->
<h3 class="fn" id="operator-2b" translate="no"><a name="operator-2b"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; QList::<span class="name">operator+</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-2b" title="Direct link to this headline"></a></h3>
<p>Returns a list that contains all the items in this list followed by all the items in the <i translate="no">other</i> list.</p>
<p><b>See also </b><a href="./qlist.htm#operator-2b-eq" translate="no">operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+=[overload1]$$$operator+=constQList<T>& -->
<h3 class="fn" id="operator-2b-eq" translate="no"><a name="operator-2b-eq"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator+=</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-2b-eq" title="Direct link to this headline"></a></h3>
<p>Appends the items of the <i translate="no">other</i> list to this list and returns a reference to this list.</p>
<p><b>See also </b><a href="./qlist.htm#operator-2b" translate="no">operator+</a>() and <a href="./qlist.htm#append" translate="no">append</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constT& -->
<h3 class="fn" id="operator-2b-eq-1" translate="no"><a name="operator-2b-eq-1"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator+=</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#operator-2b-eq-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends <i translate="no">value</i> to the list.</p>
<p><b>See also </b><a href="./qlist.htm#append" translate="no">append</a>() and <a href="./qlist.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator<<[overload1]$$$operator<<constQList<T>& -->
<h3 class="fn" id="operator-lt-lt" translate="no"><a name="operator-lt-lt"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator&lt;&lt;</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>)<a class="plink" href="#operator-lt-lt" title="Direct link to this headline"></a></h3>
<p>Appends the items of the <i translate="no">other</i> list to this list and returns a reference to this list.</p>
<p><b>See also </b><a href="./qlist.htm#operator-2b-eq" translate="no">operator+=</a>() and <a href="./qlist.htm#append" translate="no">append</a>().</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<constT& -->
<h3 class="fn" id="operator-lt-lt-1" translate="no"><a name="operator-lt-lt-1"></a><span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;QList::<span class="name">operator&lt;&lt;</span>(const <span class="type">T</span> &amp;<i>value</i>)<a class="plink" href="#operator-lt-lt-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends <i translate="no">value</i> to the list.</p>
<!-- @@@operator<< -->
<!-- $$$operator==[overload1]$$$operator==constQList<T>& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QList::<span class="name">operator==</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>other</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if <i translate="no">other</i> is equal to this list; otherwise returns false.</p>
<p>Two lists are considered equal if they contain the same values in the same order.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator==()</code>.</p>
<p><b>See also </b><a href="./qlist.htm#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator[][overload1]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d" translate="no"><a name="operator-5b-5d"></a><span class="type">T</span> &amp;QList::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#operator-5b-5d" title="Direct link to this headline"></a></h3>
<p>Returns the item at index position <i translate="no">i</i> as a modifiable reference. <i translate="no">i</i> must be a valid index position in the list (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qlist.htm#size" translate="no">size</a>()).</p>
<p>If this function is called on a list that is currently being shared, it will trigger a copy of all elements. Otherwise, this function runs in <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>. If you do not want to modify the list you should use <a href="./qlist.htm#at" translate="no">QList::at</a>().</p>
<p><b>See also </b><a href="./qlist.htm#at" translate="no">at</a>() and <a href="./qlist.htm#value" translate="no">value</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d-1" translate="no"><a name="operator-5b-5d-1"></a>const <span class="type">T</span> &amp;QList::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#operator-5b-5d-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="./qlist.htm#at" translate="no">at</a>(). This function runs in <a href="./containers.htm#algorithmic-complexity" translate="no">constant time</a>.</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash[overload1]$$$qHashconstQList<T>&uint -->
<h3 class="fn" id="qHash" translate="no"><a name="qHash"></a>template &lt;typename T&gt; <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qHash</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>key</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>seed</i> = 0)<a class="plink" href="#qHash" title="Direct link to this headline"></a></h3>
<p>Returns the hash value for <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<p>This function requires qHash() to be overloaded for the value type <code translate="no">T</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qHash -->
<!-- $$$operator<[overload1]$$$operator<constQList<T>&constQList<T>& -->
<h3 class="fn" id="operator-lt" translate="no"><a name="operator-lt"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-lt" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if list <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically less than</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator< -->
<!-- $$$operator<=[overload1]$$$operator<=constQList<T>&constQList<T>& -->
<h3 class="fn" id="operator-lt-eq" translate="no"><a name="operator-lt-eq"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-lt-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if list <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically less than or equal to</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator<= -->
<!-- $$$operator>[overload1]$$$operator>constQList<T>&constQList<T>& -->
<h3 class="fn" id="operator-gt" translate="no"><a name="operator-gt"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-gt" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if list <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically greater than</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=constQList<T>&constQList<T>& -->
<h3 class="fn" id="operator-gt-eq" translate="no"><a name="operator-gt-eq"></a>template &lt;typename T&gt; <span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>lhs</i>, const <span class="type"><a href="./qlist.htm#QList" translate="no">QList</a></span>&lt;<span class="type">T</span>&gt; &amp;<i>rhs</i>)<a class="plink" href="#operator-gt-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if list <i translate="no">lhs</i> is <a href="http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare" translate="no">lexicographically greater than or equal to</a> <i translate="no">rhs</i>; otherwise returns <code translate="no">false</code>.</p>
<p>This function requires the value type to have an implementation of <code translate="no">operator&lt;()</code>.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@operator>= -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>