<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Qt Quick 2 Oscilloscope Example | Qt Data Visualization</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtdatavisualization-index.htm" translate="no">Qt Data Visualization</a></li>
                            <li class="last"><a>Qt Quick 2 Oscilloscope Example</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Qt Quick 2 Oscilloscope Example</h1>
<span class="subtitle"></span>
<!-- $$$qmloscilloscope-brief -->
<p>Example of a hybrid C++ and QML application.</p>
<!-- @@@qmloscilloscope -->
<!-- $$$qmloscilloscope-description -->
<div class="descr"> <a name="details"></a>
<p>The Qt Quick 2 oscilloscope example shows how to combine C++ and QML in an application, as well as showing data that changes realtime.</p>
<p class="centerAlign"><img alt="" src="./images/qmloscilloscope-example.png"></p><p>The interesting thing about this example is combining C++ and QML, so we'll concentrate on that and skip explaining the basic functionality - for more detailed QML example documentation, see <a href="./qtdatavisualization-qmlscatter-example.htm" translate="no">Qt Quick 2 Scatter Example</a>.</p>
<a name="running-the-example"></a>
<h4 id="running-the-example">Running the Example<a class="plink" href="#running-the-example" title="Direct link to this headline"></a></h4>
<p>To run the example from <a href="http://doc.qt.io/qtcreator/index.html" translate="no">Qt Creator</a>, open the <b>Welcome</b> mode and select the example from <b>Examples</b>. For more information, visit <a href="https://doc.qt.io/qtcreator/creator-build-example-application.html" translate="no">Building and Running an Example</a>.</p>
<a name="data-source-in-c"></a>
<h4 id="data-source-in-c">Data Source in C++<a class="plink" href="#data-source-in-c" title="Direct link to this headline"></a></h4>
<p>The item model based proxies are good for simple and/or static graphs, but to achieve best performance when displaying data changing in realtime, the basic proxies should be used. Those are not supported in QML, as the data items they store are not <a href="./qobject.htm" translate="no">QObject</a>s and cannot therefore be directly manipulated from QML code. To overcome this limitation, we implement a simple <code translate="no">DataSource</code> class in C++ to populate the data proxy of the series.</p>
<p>The <code translate="no">DataSource</code> class provides three methods that can be called from QML:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">public</span> Q_SLOTS:
<span class="type">void</span> generateData(<span class="type">int</span> cacheCount<span class="operator">,</span> <span class="type">int</span> rowCount<span class="operator">,</span> <span class="type">int</span> columnCount<span class="operator">,</span>
                  <span class="type">float</span> xMin<span class="operator">,</span> <span class="type">float</span> xMax<span class="operator">,</span> <span class="type">float</span> yMin<span class="operator">,</span> <span class="type">float</span> yMax<span class="operator">,</span> <span class="type">float</span> zMin<span class="operator">,</span> <span class="type">float</span> zMax);

<span class="type">void</span> update(QSurface3DSeries <span class="operator">*</span>series);</pre></div>
<p>The first method, <code translate="no">generateData()</code>, creates a cache of simulated oscilloscope data for us to display. The data is cached in a format accepted by <a href="./qsurfacedataproxy.htm" translate="no">QSurfaceDataProxy</a>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> DataSource<span class="operator">::</span>generateData(<span class="type">int</span> cacheCount<span class="operator">,</span> <span class="type">int</span> rowCount<span class="operator">,</span> <span class="type">int</span> columnCount<span class="operator">,</span>
                              <span class="type">float</span> xMin<span class="operator">,</span> <span class="type">float</span> xMax<span class="operator">,</span> <span class="type">float</span> yMin<span class="operator">,</span> <span class="type">float</span> yMax<span class="operator">,</span>
                              <span class="type">float</span> zMin<span class="operator">,</span> <span class="type">float</span> zMax)
{
    <span class="keyword">if</span> (<span class="operator">!</span>cacheCount <span class="operator">|</span><span class="operator">|</span> <span class="operator">!</span>rowCount <span class="operator">|</span><span class="operator">|</span> <span class="operator">!</span>columnCount)
        <span class="keyword">return</span>;

    clearData();
    <span class="comment">// Re-create the cache array</span>
    m_data<span class="operator">.</span>resize(cacheCount);
    <span class="keyword">for</span> (<span class="type">int</span> i(<span class="number">0</span>); i <span class="operator">&lt;</span> cacheCount; i<span class="operator">+</span><span class="operator">+</span>) {
        <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataArray-typedef" translate="no">QSurfaceDataArray</a></span> <span class="operator">&amp;</span>array <span class="operator">=</span> m_data<span class="operator">[</span>i<span class="operator">]</span>;
        array<span class="operator">.</span>reserve(rowCount);
        <span class="keyword">for</span> (<span class="type">int</span> j(<span class="number">0</span>); j <span class="operator">&lt;</span> rowCount; j<span class="operator">+</span><span class="operator">+</span>)
            array<span class="operator">.</span>append(<span class="keyword">new</span> <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span>(columnCount));
    }

    <span class="type">float</span> xRange <span class="operator">=</span> xMax <span class="operator">-</span> xMin;
    <span class="type">float</span> yRange <span class="operator">=</span> yMax <span class="operator">-</span> yMin;
    <span class="type">float</span> zRange <span class="operator">=</span> zMax <span class="operator">-</span> zMin;
    <span class="type">int</span> cacheIndexStep <span class="operator">=</span> columnCount <span class="operator">/</span> cacheCount;
    <span class="type">float</span> cacheStep <span class="operator">=</span> <span class="type">float</span>(cacheIndexStep) <span class="operator">*</span> xRange <span class="operator">/</span> <span class="type">float</span>(columnCount);

    <span class="comment">// Populate caches</span>
    <span class="keyword">for</span> (<span class="type">int</span> i(<span class="number">0</span>); i <span class="operator">&lt;</span> cacheCount; i<span class="operator">+</span><span class="operator">+</span>) {
        <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataArray-typedef" translate="no">QSurfaceDataArray</a></span> <span class="operator">&amp;</span>cache <span class="operator">=</span> m_data<span class="operator">[</span>i<span class="operator">]</span>;
        <span class="type">float</span> cacheXAdjustment <span class="operator">=</span> cacheStep <span class="operator">*</span> i;
        <span class="type">float</span> cacheIndexAdjustment <span class="operator">=</span> cacheIndexStep <span class="operator">*</span> i;
        <span class="keyword">for</span> (<span class="type">int</span> j(<span class="number">0</span>); j <span class="operator">&lt;</span> rowCount; j<span class="operator">+</span><span class="operator">+</span>) {
            <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span> <span class="operator">&amp;</span>row <span class="operator">=</span> <span class="operator">*</span>(cache<span class="operator">[</span>j<span class="operator">]</span>);
            <span class="type">float</span> rowMod <span class="operator">=</span> (<span class="type">float</span>(j)) <span class="operator">/</span> <span class="type">float</span>(rowCount);
            <span class="type">float</span> yRangeMod <span class="operator">=</span> yRange <span class="operator">*</span> rowMod;
            <span class="type">float</span> zRangeMod <span class="operator">=</span> zRange <span class="operator">*</span> rowMod;
            <span class="type">float</span> z <span class="operator">=</span> zRangeMod <span class="operator">+</span> zMin;
            <span class="type"><a href="./qtglobal.htm#qreal-typedef" translate="no">qreal</a></span> rowColWaveAngleMul <span class="operator">=</span> M_PI <span class="operator">*</span> M_PI <span class="operator">*</span> rowMod;
            <span class="type">float</span> rowColWaveMul <span class="operator">=</span> yRangeMod <span class="operator">*</span> <span class="number">0.2f</span>;
            <span class="keyword">for</span> (<span class="type">int</span> k(<span class="number">0</span>); k <span class="operator">&lt;</span> columnCount; k<span class="operator">+</span><span class="operator">+</span>) {
                <span class="type">float</span> colMod <span class="operator">=</span> (<span class="type">float</span>(k)) <span class="operator">/</span> <span class="type">float</span>(columnCount);
                <span class="type">float</span> xRangeMod <span class="operator">=</span> xRange <span class="operator">*</span> colMod;
                <span class="type">float</span> x <span class="operator">=</span> xRangeMod <span class="operator">+</span> xMin <span class="operator">+</span> cacheXAdjustment;
                <span class="type">float</span> colWave <span class="operator">=</span> <span class="type">float</span>(<a href="./qtmath.htm#qSin" translate="no">qSin</a>((<span class="number">2.0</span> <span class="operator">*</span> M_PI <span class="operator">*</span> colMod) <span class="operator">-</span> (<span class="number">1.0</span> <span class="operator">/</span> <span class="number">2.0</span> <span class="operator">*</span> M_PI)) <span class="operator">+</span> <span class="number">1.0</span>);
                <span class="type">float</span> y <span class="operator">=</span> (colWave <span class="operator">*</span> ((<span class="type">float</span>(<a href="./qtmath.htm#qSin" translate="no">qSin</a>(rowColWaveAngleMul <span class="operator">*</span> colMod) <span class="operator">+</span> <span class="number">1.0</span>))))
                        <span class="operator">*</span> rowColWaveMul
                        <span class="operator">+</span> <span class="type"><a href="./qrandomgenerator.htm" translate="no">QRandomGenerator</a></span><span class="operator">::</span>global()<span class="operator">-</span><span class="operator">&gt;</span>bounded(<span class="number">0.15f</span>) <span class="operator">*</span> yRangeMod;

                <span class="type">int</span> index <span class="operator">=</span> k <span class="operator">+</span> cacheIndexAdjustment;
                <span class="keyword">if</span> (index <span class="operator">&gt;</span><span class="operator">=</span> columnCount) {
                    <span class="comment">// Wrap over</span>
                    index <span class="operator">-</span><span class="operator">=</span> columnCount;
                    x <span class="operator">-</span><span class="operator">=</span> xRange;
                }
                row<span class="operator">[</span>index<span class="operator">]</span> <span class="operator">=</span> QVector3D(x<span class="operator">,</span> y<span class="operator">,</span> z);
            }
        }
    }
}</pre></div>
<p>The second method, <code translate="no">update()</code>, copies one set of the cached data into another array, which we set to the data proxy of the series by calling <a href="./qsurfacedataproxy.htm#resetArray" translate="no">QSurfaceDataProxy::resetArray</a>(). We reuse the same array if the array dimensions have not changed to minimize overhead:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> DataSource<span class="operator">::</span>update(QSurface3DSeries <span class="operator">*</span>series)
{
    <span class="keyword">if</span> (series <span class="operator">&amp;</span><span class="operator">&amp;</span> m_data<span class="operator">.</span>size()) {
        <span class="comment">// Each iteration uses data from a different cached array</span>
        m_index<span class="operator">+</span><span class="operator">+</span>;
        <span class="keyword">if</span> (m_index <span class="operator">&gt;</span> m_data<span class="operator">.</span>count() <span class="operator">-</span> <span class="number">1</span>)
            m_index <span class="operator">=</span> <span class="number">0</span>;

        <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataArray-typedef" translate="no">QSurfaceDataArray</a></span> array <span class="operator">=</span> m_data<span class="operator">.</span>at(m_index);
        <span class="type">int</span> newRowCount <span class="operator">=</span> array<span class="operator">.</span>size();
        <span class="type">int</span> newColumnCount <span class="operator">=</span> array<span class="operator">.</span>at(<span class="number">0</span>)<span class="operator">-</span><span class="operator">&gt;</span>size();

        <span class="comment">// If the first time or the dimensions of the cache array have changed,</span>
        <span class="comment">// reconstruct the reset array</span>
        <span class="keyword">if</span> (<span class="operator">!</span>m_resetArray <span class="operator">|</span><span class="operator">|</span> series<span class="operator">-</span><span class="operator">&gt;</span>dataProxy()<span class="operator">-</span><span class="operator">&gt;</span>rowCount() <span class="operator">!</span><span class="operator">=</span> newRowCount
                <span class="operator">|</span><span class="operator">|</span> series<span class="operator">-</span><span class="operator">&gt;</span>dataProxy()<span class="operator">-</span><span class="operator">&gt;</span>columnCount() <span class="operator">!</span><span class="operator">=</span> newColumnCount) {
            m_resetArray <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataArray-typedef" translate="no">QSurfaceDataArray</a></span>();
            m_resetArray<span class="operator">-</span><span class="operator">&gt;</span>reserve(newRowCount);
            <span class="keyword">for</span> (<span class="type">int</span> i(<span class="number">0</span>); i <span class="operator">&lt;</span> newRowCount; i<span class="operator">+</span><span class="operator">+</span>)
                m_resetArray<span class="operator">-</span><span class="operator">&gt;</span>append(<span class="keyword">new</span> <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span>(newColumnCount));
        }

        <span class="comment">// Copy items from our cache to the reset array</span>
        <span class="keyword">for</span> (<span class="type">int</span> i(<span class="number">0</span>); i <span class="operator">&lt;</span> newRowCount; i<span class="operator">+</span><span class="operator">+</span>) {
            <span class="keyword">const</span> <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span> <span class="operator">&amp;</span>sourceRow <span class="operator">=</span> <span class="operator">*</span>(array<span class="operator">.</span>at(i));
            <span class="type"><a href="./qsurfacedataproxy.htm#QSurfaceDataRow-typedef" translate="no">QSurfaceDataRow</a></span> <span class="operator">&amp;</span>row <span class="operator">=</span> <span class="operator">*</span>(<span class="operator">*</span>m_resetArray)<span class="operator">[</span>i<span class="operator">]</span>;
            <span class="keyword">for</span> (<span class="type">int</span> j(<span class="number">0</span>); j <span class="operator">&lt;</span> newColumnCount; j<span class="operator">+</span><span class="operator">+</span>)
                row<span class="operator">[</span>j<span class="operator">]</span><span class="operator">.</span>setPosition(sourceRow<span class="operator">.</span>at(j)<span class="operator">.</span>position());
        }

        <span class="comment">// Notify the proxy that data has changed</span>
        series<span class="operator">-</span><span class="operator">&gt;</span>dataProxy()<span class="operator">-</span><span class="operator">&gt;</span>resetArray(m_resetArray);
    }
}</pre></div>
<div class="admonition note">
<p><b>Note: </b>Even though we are operating on the array pointer we have previously set to the proxy we still need to call <a href="./qsurfacedataproxy.htm#resetArray" translate="no">QSurfaceDataProxy::resetArray</a>() after changing the data in it to prompt the graph to render the data.</p>
</div>
<p>To be able to access the <code translate="no">DataSource</code> methods from QML, we need to expose it. We do this by defining a context property in application main:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">DataSource dataSource;
viewer<span class="operator">.</span>rootContext()<span class="operator">-</span><span class="operator">&gt;</span>setContextProperty(<span class="string">"dataSource"</span><span class="operator">,</span> <span class="operator">&amp;</span>dataSource);</pre></div>
<p>To make it possible to use <a href="./qsurface3dseries.htm" translate="no">QSurface3DSeries</a> pointers as parameters on the <code translate="no">DataSource</code> class methods on all environments and builds, we need to make sure the meta type is registered:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">Q_DECLARE_METATYPE(QSurface3DSeries <span class="operator">*</span>)
...
<a href="./qmetatype.htm#qRegisterMetaType-1" translate="no">qRegisterMetaType</a><span class="operator">&lt;</span>QSurface3DSeries <span class="operator">*</span><span class="operator">&gt;</span>();</pre></div>
<a name="qml"></a>
<h4 id="qml">QML<a class="plink" href="#qml" title="Direct link to this headline"></a></h4>
<p>In the QML codes, we define a <a href="./qml-qtdatavisualization-surface3d.htm" translate="no">Surface3D</a> graph normally and give it a <a href="./qml-qtdatavisualization-surface3dseries.htm" translate="no">Surface3DSeries</a>:</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="type"><a href="./qml-qtdatavisualization-surface3dseries.htm" translate="no">Surface3DSeries</a></span> {
    <span class="name">id</span>: <span class="name">surfaceSeries</span>
    <span class="name">drawMode</span>: <span class="name">Surface3DSeries</span>.<span class="name">DrawSurface</span>;
    <span class="name">flatShadingEnabled</span>: <span class="number">false</span>;
    <span class="name">meshSmooth</span>: <span class="number">true</span>
    <span class="name">itemLabelFormat</span>: <span class="string">"@xLabel, @zLabel: @yLabel"</span>
    <span class="name">itemLabelVisible</span>: <span class="number">false</span>

    <span class="name">onItemLabelChanged</span>: {
        <span class="keyword">if</span> (<span class="name">surfaceSeries</span>.<span class="name">selectedPoint</span> <span class="operator">===</span> <span class="name">surfaceSeries</span>.<span class="name">invalidSelectionPosition</span>)
            <span class="name">selectionText</span>.<span class="name">text</span> <span class="operator">=</span> <span class="string">"No selection"</span>
        <span class="keyword">else</span>
            <span class="name">selectionText</span>.<span class="name">text</span> <span class="operator">=</span> <span class="name">surfaceSeries</span>.<span class="name">itemLabel</span>
    }
}</pre></div>
<p>One interesting detail is that we don't specify a proxy for the <a href="./qml-qtdatavisualization-surface3dseries.htm" translate="no">Surface3DSeries</a> we attach to the graph. This makes the series to utilize the default <a href="./qsurfacedataproxy.htm" translate="no">QSurfaceDataProxy</a>.</p>
<p>We also hide the item label with <a href="./qml-qtdatavisualization-abstract3dseries.htm#itemLabelVisible-prop" translate="no">itemLabelVisible</a>, since we want to display the selected item information in a <code translate="no">Text</code> element instead of a floating label above the selection pointer. This is done because the selection pointer moves around a lot as the data changes, which makes the regular selection label difficult to read.</p>
<p>We initialize the <code translate="no">DataSource</code> cache when the graph is complete by calling a helper function <code translate="no">generateData()</code>, which calls the method with the same name on the <code translate="no">DataSource</code>:</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="name">Component</span>.onCompleted: <span class="name">mainView</span>.<span class="name">generateData</span>()
    ...
<span class="keyword">function </span><span class="name">generateData</span>() {
    <span class="name">dataSource</span>.<span class="name">generateData</span>(<span class="name">mainView</span>.<span class="name">sampleCache</span>, <span class="name">mainView</span>.<span class="name">sampleRows</span>,
                            <span class="name">mainView</span>.<span class="name">sampleColumns</span>, <span class="name">surfaceGraph</span>.<span class="name">axisX</span>.<span class="name">min</span>,
                            <span class="name">surfaceGraph</span>.<span class="name">axisX</span>.<span class="name">max</span>, <span class="name">surfaceGraph</span>.<span class="name">axisY</span>.<span class="name">min</span>,
                            <span class="name">surfaceGraph</span>.<span class="name">axisY</span>.<span class="name">max</span>, <span class="name">surfaceGraph</span>.<span class="name">axisZ</span>.<span class="name">min</span>,
                            <span class="name">surfaceGraph</span>.<span class="name">axisZ</span>.<span class="name">max</span>)
}</pre></div>
<p>To trigger the updates in data, we define a <code translate="no">Timer</code> item which calls the <code translate="no">update()</code> method on the <code translate="no">DataSource</code> at requested intervals. The label update is also triggered on each cycle:</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="type"><a href="./qml-qtqml-timer.htm" translate="no">Timer</a></span> {
    <span class="name">id</span>: <span class="name">refreshTimer</span>
    <span class="name">interval</span>: <span class="number">1000</span> <span class="operator">/</span> <span class="name">frequencySlider</span>.<span class="name">value</span>
    <span class="name">running</span>: <span class="number">true</span>
    <span class="name">repeat</span>: <span class="number">true</span>
    <span class="name">onTriggered</span>: <span class="name">dataSource</span>.<span class="name">update</span>(<span class="name">surfaceSeries</span>)
}</pre></div>
<a name="enabling-direct-rendering"></a>
<h4 id="enabling-direct-rendering">Enabling Direct Rendering<a class="plink" href="#enabling-direct-rendering" title="Direct link to this headline"></a></h4>
<p>Since this application potentially deals with a lot of rapidly changing data, we use direct rendering mode for performance. To enable antialiasing in this mode the surface format of the application window needs to be changed, as the default format used by <a href="./qquickview.htm" translate="no">QQuickView</a> doesn't support antialiasing. We use the utility function provided by Qt Data Visualization to change the surface format in <code translate="no">main.cpp</code>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">viewer<span class="operator">.</span>setFormat(<span class="type"><a href="./qtdatavisualization-qmlmodule.htm" translate="no">QtDataVisualization</a></span><span class="operator">::</span>qDefaultSurfaceFormat());
...
<span class="preprocessor">#include &lt;QtDataVisualization/qutils.h&gt;</span></pre></div>
<p>On the QML side, direct rendering mode is enabled via <a href="./qml-qtdatavisualization-abstractgraph3d.htm#renderingMode-prop" translate="no">renderingMode</a> property:</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="name">renderingMode</span>: <span class="name">AbstractGraph3D</span>.<span class="name">RenderDirectToBackground</span></pre></div>
<p><a href="https://code.qt.io/cgit/qt/qtdatavis3d.git/tree/examples/datavisualization/qmloscilloscope?h=5.15" translate="no">Example project @ code.qt.io</a></p>
</div>
<!-- @@@qmloscilloscope -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>