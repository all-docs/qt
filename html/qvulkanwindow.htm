<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QVulkanWindow | Qt GUI</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qvulkanwindow.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtgui-index.htm" translate="no">Qt GUI</a></li>
                            <li><a href="./qtgui-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QVulkanWindow</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QVulkanWindow Class</h1>
<!-- $$$QVulkanWindow-brief -->
<p>The QVulkanWindow class is a convenience subclass of <a href="./qwindow.htm" translate="no">QWindow</a> to perform Vulkan rendering. <a href="#details">More...</a></p>
<!-- @@@QVulkanWindow -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QVulkanWindow&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += gui</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.10</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qwindow.htm" translate="no">QWindow</a></td></tr></tbody></table></div><p>This class was introduced in Qt 5.10.</p>
<ul>
<li><a href="./qvulkanwindow-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#Flag-enum" translate="no">Flag</a></b> { PersistentResources }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#Flag-enum" translate="no">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#QueueCreateInfoModifier-typedef" translate="no">QueueCreateInfoModifier</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#QVulkanWindow" translate="no">QVulkanWindow</a></b>(QWindow *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#dtor.QVulkanWindow" translate="no">~QVulkanWindow</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;VkPhysicalDeviceProperties&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#availablePhysicalDevices" translate="no">availablePhysicalDevices</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMatrix4x4 </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#clipCorrectionMatrix" translate="no">clipCorrectionMatrix</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkFormat </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#colorFormat" translate="no">colorFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#concurrentFrameCount" translate="no">concurrentFrameCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVulkanWindowRenderer *</td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#createRenderer" translate="no">createRenderer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkCommandBuffer </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#currentCommandBuffer" translate="no">currentCommandBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#currentFrame" translate="no">currentFrame</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkFramebuffer </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#currentFramebuffer" translate="no">currentFramebuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#currentSwapChainImageIndex" translate="no">currentSwapChainImageIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkRenderPass </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#defaultRenderPass" translate="no">defaultRenderPass</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkFormat </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#depthStencilFormat" translate="no">depthStencilFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImage </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#depthStencilImage" translate="no">depthStencilImage</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImageView </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#depthStencilImageView" translate="no">depthStencilImageView</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkDevice </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#device" translate="no">device</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint32_t </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#deviceLocalMemoryIndex" translate="no">deviceLocalMemoryIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVulkanWindow::Flags </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#flags" translate="no">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#grab" translate="no">grab</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkCommandPool </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#graphicsCommandPool" translate="no">graphicsCommandPool</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkQueue </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#graphicsQueue" translate="no">graphicsQueue</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint32_t </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#graphicsQueueFamilyIndex" translate="no">graphicsQueueFamilyIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint32_t </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#hostVisibleMemoryIndex" translate="no">hostVisibleMemoryIndex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImage </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#msaaColorImage" translate="no">msaaColorImage</a></b>(int <i>idx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImageView </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#msaaColorImageView" translate="no">msaaColorImageView</a></b>(int <i>idx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkPhysicalDevice </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#physicalDevice" translate="no">physicalDevice</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const VkPhysicalDeviceProperties *</td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#physicalDeviceProperties" translate="no">physicalDeviceProperties</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkSampleCountFlagBits </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#sampleCountFlagBits" translate="no">sampleCountFlagBits</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#setDeviceExtensions" translate="no">setDeviceExtensions</a></b>(const QByteArrayList &amp;<i>extensions</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#setFlags" translate="no">setFlags</a></b>(QVulkanWindow::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#setPhysicalDeviceIndex" translate="no">setPhysicalDeviceIndex</a></b>(int <i>idx</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#setPreferredColorFormats" translate="no">setPreferredColorFormats</a></b>(const QVector&lt;VkFormat&gt; &amp;<i>formats</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#setQueueCreateInfoModifier" translate="no">setQueueCreateInfoModifier</a></b>(const QVulkanWindow::QueueCreateInfoModifier &amp;<i>modifier</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#setSampleCount" translate="no">setSampleCount</a></b>(int <i>sampleCount</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVulkanInfoVector&lt;QVulkanExtension&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#supportedDeviceExtensions" translate="no">supportedDeviceExtensions</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QVector&lt;int&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#supportedSampleCounts" translate="no">supportedSampleCounts</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#supportsGrab" translate="no">supportsGrab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImage </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#swapChainImage" translate="no">swapChainImage</a></b>(int <i>idx</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#swapChainImageCount" translate="no">swapChainImageCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#swapChainImageSize" translate="no">swapChainImageSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> VkImageView </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#swapChainImageView" translate="no">swapChainImageView</a></b>(int <i>idx</i>) const</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> const int </td><td class="memItemRight bottomAlign"><b><a href="./qvulkanwindow.htm#MAX_CONCURRENT_FRAME_COUNT-var" translate="no">MAX_CONCURRENT_FRAME_COUNT</a></b></td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QVulkanWindow-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QVulkanWindow is a Vulkan-capable <a href="./qwindow.htm" translate="no">QWindow</a> that manages a Vulkan device, a graphics queue, a command pool and buffer, a depth-stencil image and a double-buffered FIFO swapchain, while taking care of correct behavior when it comes to events like resize, special situations like not having a device queue supporting both graphics and presentation, device lost scenarios, and additional functionality like reading the rendered content back. Conceptually it is the counterpart of <a href="./qopenglwindow.htm" translate="no">QOpenGLWindow</a> in the Vulkan world.</p>
<div class="admonition note">
<p><b>Note: </b>QVulkanWindow does not always eliminate the need to implement a fully custom <a href="./qwindow.htm" translate="no">QWindow</a> subclass as it will not necessarily be sufficient in advanced use cases.</p>
</div>
<p>QVulkanWindow can be embedded into <a href="./qwidget.htm" translate="no">QWidget</a>-based user interfaces via <a href="./qwidget.htm#createWindowContainer" translate="no">QWidget::createWindowContainer</a>(). This approach has a number of limitations, however. Make sure to study the <a href="./qwidget.htm#createWindowContainer" translate="no">documentation</a> first.</p>
<p>A typical application using QVulkanWindow may look like the following:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">  <span class="keyword">class</span> VulkanRenderer : <span class="keyword">public</span> <span class="type"><a href="./qvulkanwindowrenderer.htm" translate="no">QVulkanWindowRenderer</a></span>
  {
  <span class="keyword">public</span>:
      VulkanRenderer(<span class="type"><a href="./qvulkanwindow.htm#QVulkanWindow" translate="no">QVulkanWindow</a></span> <span class="operator">*</span>w) : m_window(w) { }

      <span class="type">void</span> initResources() override
      {
          m_devFuncs <span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>vulkanInstance()<span class="operator">-</span><span class="operator">&gt;</span>deviceFunctions(m_window<span class="operator">-</span><span class="operator">&gt;</span>device());
          <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
      }
      <span class="type">void</span> initSwapChainResources() override { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> }
      <span class="type">void</span> releaseSwapChainResources() override { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> }
      <span class="type">void</span> releaseResources() override { <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span> }

      <span class="type">void</span> startNextFrame() override
      {
          VkCommandBuffer cmdBuf <span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>currentCommandBuffer();
          <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
          m_devFuncs<span class="operator">-</span><span class="operator">&gt;</span>vkCmdBeginRenderPass(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
          <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
          m_window<span class="operator">-</span><span class="operator">&gt;</span>frameReady();
      }

  <span class="keyword">private</span>:
      <span class="type"><a href="./qvulkanwindow.htm#QVulkanWindow" translate="no">QVulkanWindow</a></span> <span class="operator">*</span>m_window;
      <span class="type"><a href="./qvulkandevicefunctions.htm" translate="no">QVulkanDeviceFunctions</a></span> <span class="operator">*</span>m_devFuncs;
  };

  <span class="keyword">class</span> VulkanWindow : <span class="keyword">public</span> <span class="type"><a href="./qvulkanwindow.htm#QVulkanWindow" translate="no">QVulkanWindow</a></span>
  {
  <span class="keyword">public</span>:
      <span class="type"><a href="./qvulkanwindowrenderer.htm" translate="no">QVulkanWindowRenderer</a></span> <span class="operator">*</span>createRenderer() override {
          <span class="keyword">return</span> <span class="keyword">new</span> VulkanRenderer(<span class="keyword">this</span>);
      }
  };

  <span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
  {
      <span class="type"><a href="./qguiapplication.htm" translate="no">QGuiApplication</a></span> app(argc<span class="operator">,</span> argv);

      <span class="type"><a href="./qvulkaninstance.htm" translate="no">QVulkanInstance</a></span> inst;
      <span class="comment">// enable the standard validation layers, when available</span>
      inst<span class="operator">.</span>setLayers(<span class="type"><a href="./qbytearraylist.htm" translate="no">QByteArrayList</a></span>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"VK_LAYER_LUNARG_standard_validation"</span>);
      <span class="keyword">if</span> (<span class="operator">!</span>inst<span class="operator">.</span>create())
          <a href="./qtglobal.htm#qFatal" translate="no">qFatal</a>(<span class="string">"Failed to create Vulkan instance: %d"</span><span class="operator">,</span> inst<span class="operator">.</span>errorCode());

      VulkanWindow w;
      w<span class="operator">.</span>setVulkanInstance(<span class="operator">&amp;</span>inst);
      w<span class="operator">.</span>showMaximized();

      <span class="keyword">return</span> app<span class="operator">.</span>exec();
  }</pre></div>
<p>As it can be seen in the example, the main patterns in QVulkanWindow usage are:</p>
<ul>
<li>The <a href="./qvulkaninstance.htm" translate="no">QVulkanInstance</a> is associated via <a href="./qwindow.htm#setVulkanInstance" translate="no">QWindow::setVulkanInstance</a>(). It is then retrievable via <a href="./qwindow.htm#vulkanInstance" translate="no">QWindow::vulkanInstance</a>() from everywhere, on any thread.</li>
<li>Similarly to <a href="./qvulkaninstance.htm" translate="no">QVulkanInstance</a>, device extensions can be queried via <a href="./qvulkanwindow.htm#supportedDeviceExtensions" translate="no">supportedDeviceExtensions</a>() before the actual initialization. Requesting an extension to be enabled is done via <a href="./qvulkanwindow.htm#setDeviceExtensions" translate="no">setDeviceExtensions</a>(). Such calls must be made before the window becomes visible, that is, before calling <a href="./qwindow.htm#show" translate="no">show</a>() or similar functions. Unsupported extension requests are gracefully ignored.</li>
<li>The renderer is implemented in a <a href="./qvulkanwindowrenderer.htm" translate="no">QVulkanWindowRenderer</a> subclass, an instance of which is created in the <a href="./qvulkanwindow.htm#createRenderer" translate="no">createRenderer</a>() factory function.</li>
<li>The core Vulkan commands are exposed via the <a href="./qvulkanfunctions.htm" translate="no">QVulkanFunctions</a> object, retrievable by calling <a href="./qvulkaninstance.htm#functions" translate="no">QVulkanInstance::functions</a>(). Device level functions are available after creating a VkDevice by calling <a href="./qvulkaninstance.htm#deviceFunctions" translate="no">QVulkanInstance::deviceFunctions</a>().</li>
<li>The building of the draw calls for the next frame happens in QVulkanWindowRenderer::startNextFrame(). The implementation is expected to add commands to the command buffer returned from <a href="./qvulkanwindow.htm#currentCommandBuffer" translate="no">currentCommandBuffer</a>(). Returning from the function does not indicate that the commands are ready for submission. Rather, an explicit call to <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>() is required. This allows asynchronous generation of commands, possibly on multiple threads. Simple implementations will simply call <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>() at the end of their QVulkanWindowRenderer::startNextFrame().</li>
<li>The basic Vulkan resources (physical device, graphics queue, a command pool, the window's main command buffer, image formats, etc.) are exposed on the QVulkanWindow via lightweight getter functions. Some of these are for convenience only, and applications are always free to query, create and manage additional resources directly via the Vulkan API.</li>
<li>The renderer lives in the gui/main thread, like the window itself. This thread is then throttled to the presentation rate, similarly to how OpenGL with a swap interval of 1 would behave. However, the renderer implementation is free to utilize multiple threads in any way it sees fit. The accessors like <a href="./qwindow.htm#vulkanInstance" translate="no">vulkanInstance</a>(), <a href="./qvulkanwindow.htm#currentCommandBuffer" translate="no">currentCommandBuffer</a>(), etc. can be called from any thread. The submission of the main command buffer, the queueing of present, and the building of the next frame do not start until <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>() is invoked on the gui/main thread.</li>
<li>When the window is made visible, the content is updated automatically. Further updates can be requested by calling <a href="./qwindow.htm#requestUpdate" translate="no">QWindow::requestUpdate</a>(). To render continuously, call <a href="./qwindow.htm#requestUpdate" translate="no">requestUpdate</a>() after <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>().</li>
</ul>
<p>For troubleshooting, enable the logging category <code translate="no">qt.vulkan</code>. Critical errors are printed via <a href="./qtglobal.htm#qWarning" translate="no">qWarning</a>() automatically.</p>
<a name="coordinate-system-differences-between-opengl-and-vulkan"></a>
<h3 id="coordinate-system-differences-between-opengl-and-vulkan">Coordinate system differences between OpenGL and Vulkan<a class="plink" href="#coordinate-system-differences-between-opengl-and-vulkan" title="Direct link to this headline"></a></h3>
<p>There are two notable differences to be aware of: First, with Vulkan Y points down the screen in clip space, while OpenGL uses an upwards pointing Y axis. Second, the standard OpenGL projection matrix assume a near and far plane values of -1 and 1, while Vulkan prefers 0 and 1.</p>
<p>In order to help applications migrate from OpenGL-based code without having to flip Y coordinates in the vertex data, and to allow using <a href="./qmatrix4x4.htm" translate="no">QMatrix4x4</a> functions like <a href="./qmatrix4x4.htm#perspective" translate="no">QMatrix4x4::perspective</a>() while keeping the Vulkan viewport's minDepth and maxDepth set to 0 and 1, QVulkanWindow provides a correction matrix retrievable by calling <a href="./qvulkanwindow.htm#clipCorrectionMatrix" translate="no">clipCorrectionMatrix</a>().</p>
<a name="multisampling"></a>
<h3 id="multisampling">Multisampling<a class="plink" href="#multisampling" title="Direct link to this headline"></a></h3>
<p>While disabled by default, multisample antialiasing is fully supported by QVulkanWindow. Additional color buffers and resolving into the swapchain's non-multisample buffers are all managed automatically.</p>
<p>To query the supported sample counts, call <a href="./qvulkanwindow.htm#supportedSampleCounts" translate="no">supportedSampleCounts</a>(). When the returned set contains 4, 8, ..., passing one of those values to <a href="./qvulkanwindow.htm#setSampleCount" translate="no">setSampleCount</a>() requests multisample rendering.</p>
<div class="admonition note">
<p><b>Note: </b>unlike <a href="./qsurfaceformat.htm#setSamples" translate="no">QSurfaceFormat::setSamples</a>(), the list of supported sample counts are exposed to the applications in advance and there is no automatic falling back to lower sample counts in <a href="./qvulkanwindow.htm#setSampleCount" translate="no">setSampleCount</a>(). If the requested value is not supported, a warning is shown and a no multisampling will be used.</p>
</div>
<a name="reading-images-back"></a>
<h3 id="reading-images-back">Reading images back<a class="plink" href="#reading-images-back" title="Direct link to this headline"></a></h3>
<p>When <a href="./qvulkanwindow.htm#supportsGrab" translate="no">supportsGrab</a>() returns true, QVulkanWindow can perform readbacks from the color buffer into a <a href="./qimage.htm" translate="no">QImage</a>. <a href="./qvulkanwindow.htm#grab" translate="no">grab</a>() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</p>
<a name="srgb-support"></a>
<h3 id="srgb-support">sRGB support<a class="plink" href="#srgb-support" title="Direct link to this headline"></a></h3>
<p>While many applications will be fine with the default behavior of QVulkanWindow when it comes to swapchain image formats, <a href="./qvulkanwindow.htm#setPreferredColorFormats" translate="no">setPreferredColorFormats</a>() allows requesting a pre-defined format. This is useful most notably when working in the sRGB color space. Passing a format like <code translate="no">VK_FORMAT_B8G8R8A8_SRGB</code> results in choosing an sRGB format, when available.</p>
<a name="validation-layers"></a>
<h3 id="validation-layers">Validation layers<a class="plink" href="#validation-layers" title="Direct link to this headline"></a></h3>
<p>During application development it can be extremely valuable to have the Vulkan validation layers enabled. As shown in the example code above, calling <a href="./qvulkaninstance.htm#setLayers" translate="no">QVulkanInstance::setLayers</a>() on the <a href="./qvulkaninstance.htm" translate="no">QVulkanInstance</a> before <a href="./qvulkaninstance.htm#create" translate="no">QVulkanInstance::create</a>() enables validation, assuming the Vulkan driver stack in the system contains the necessary layers.</p>
<div class="admonition note">
<p><b>Note: </b>Be aware of platform-specific differences. On desktop platforms installing the <a href="https://www.lunarg.com/vulkan-sdk/" translate="no">Vulkan SDK</a> is typically sufficient. However, Android for example requires deploying additional shared libraries together with the application, and also mandates a different list of validation layer names. See <a href="https://developer.android.com/ndk/guides/graphics/validation-layer.html" translate="no">the Android Vulkan development pages</a> for more information.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>QVulkanWindow does not expose device layers since this functionality has been deprecated since version 1.0.13 of the Vulkan API.</p>
</div>
<a name="layers-device-features-and-extensions"></a>
<h3 id="layers-device-features-and-extensions">Layers, device features, and extensions<a class="plink" href="#layers-device-features-and-extensions" title="Direct link to this headline"></a></h3>
<p>To enable instance layers, call <a href="./qvulkaninstance.htm#setLayers" translate="no">QVulkanInstance::setLayers</a>() before creating the <a href="./qvulkaninstance.htm" translate="no">QVulkanInstance</a>. To query what instance layer are available, call <a href="./qvulkaninstance.htm#supportedLayers" translate="no">QVulkanInstance::supportedLayers</a>().</p>
<p>To enable device extensions, call <a href="./qvulkanwindow.htm#setDeviceExtensions" translate="no">setDeviceExtensions</a>() early on when setting up the QVulkanWindow. To query what device extensions are available, call <a href="./qvulkanwindow.htm#supportedDeviceExtensions" translate="no">supportedDeviceExtensions</a>().</p>
<p>Specifying an unsupported layer or extension is handled gracefully: this will not fail instance or device creation, but the layer or extension request is rather ignored.</p>
<p>When it comes to device features, QVulkanWindow enables all Vulkan 1.0 features that are reported as supported from vkGetPhysicalDeviceFeatures().</p>
</div>
<p><b>See also </b><a href="./qvulkaninstance.htm" translate="no">QVulkanInstance</a> and <a href="./qwindow.htm" translate="no">QWindow</a>.</p>
<!-- @@@QVulkanWindow -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Flag$$$PersistentResources -->
<h3 class="flags" id="Flag-enum"><a name="Flag-enum"></a>enum QVulkanWindow::<span class="name">Flag</span><br>flags QVulkanWindow::<span class="name">Flags</span><a class="plink" href="#Flag-enum" title="Direct link to this headline"></a></h3>
<p>This enum describes the flags that can be passed to <a href="./qvulkanwindow.htm#setFlags" translate="no">setFlags</a>().</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QVulkanWindow::PersistentResources</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">Ensures no graphics resources are released when the window becomes unexposed. The default behavior is to release everything, and reinitialize later when becoming visible again.</td></tr>
</tbody></table></div>
<p>The Flags type is a typedef for <a href="./qflags.htm">QFlags</a>&lt;Flag&gt;. It stores an OR combination of Flag values.</p>
<!-- @@@Flag -->
<!-- $$$QueueCreateInfoModifier -->
<h3 class="fn" id="QueueCreateInfoModifier-typedef" translate="no"><a name="QueueCreateInfoModifier-typedef"></a>typedef QVulkanWindow::<span class="name">QueueCreateInfoModifier</span><a class="plink" href="#QueueCreateInfoModifier-typedef" title="Direct link to this headline"></a></h3>
<p>A function function that is called during graphics initialization to add additAional queues that should be created.</p>
<p>Set if the renderer needs additional queues besides the default graphics queue (e.g. a transfer queue). The provided queue family properties can be used to select the indices for the additional queues. The renderer can subsequently request the actual queue in initResources().</p>
<p>Note when requesting additional graphics queues: Qt itself always requests a graphics queue, you'll need to search queueCreateInfo for the appropriate entry and manipulate it to obtain the additional queue.</p>
<p><b>See also </b><a href="./qvulkanwindow.htm#setQueueCreateInfoModifier" translate="no">setQueueCreateInfoModifier</a>().</p>
<!-- @@@QueueCreateInfoModifier -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QVulkanWindow[overload1]$$$QVulkanWindowQWindow* -->
<h3 class="fn" id="QVulkanWindow" translate="no"><a name="QVulkanWindow"></a>QVulkanWindow::<span class="name">QVulkanWindow</span>(<span class="type"><a href="./qwindow.htm#QWindow" translate="no">QWindow</a></span> *<i>parent</i> = nullptr)<a class="plink" href="#QVulkanWindow" title="Direct link to this headline"></a></h3>
<p>Constructs a new QVulkanWindow with the given <i translate="no">parent</i>.</p>
<p>The surface type is set to <a href="./qsurface.htm#SurfaceType-enum" translate="no">QSurface::VulkanSurface</a>.</p>
<!-- @@@QVulkanWindow -->
<!-- $$$~QVulkanWindow[overload1]$$$~QVulkanWindow -->
<h3 class="fn" id="dtor.QVulkanWindow" translate="no"><a name="dtor.QVulkanWindow"></a><code translate="no">[virtual] </code>QVulkanWindow::<span class="name">~QVulkanWindow</span>()<a class="plink" href="#dtor.QVulkanWindow" title="Direct link to this headline"></a></h3>
<p>Destructor.</p>
<!-- @@@~QVulkanWindow -->
<!-- $$$availablePhysicalDevices[overload1]$$$availablePhysicalDevices -->
<h3 class="fn" id="availablePhysicalDevices" translate="no"><a name="availablePhysicalDevices"></a><span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type">VkPhysicalDeviceProperties</span>&gt; QVulkanWindow::<span class="name">availablePhysicalDevices</span>()<a class="plink" href="#availablePhysicalDevices" title="Direct link to this headline"></a></h3>
<p>Returns the list of properties for the supported physical devices in the system.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called before making the window visible.</p>
</div>
<!-- @@@availablePhysicalDevices -->
<!-- $$$clipCorrectionMatrix[overload1]$$$clipCorrectionMatrix -->
<h3 class="fn" id="clipCorrectionMatrix" translate="no"><a name="clipCorrectionMatrix"></a><span class="type"><a href="./qmatrix4x4.htm" translate="no">QMatrix4x4</a></span> QVulkanWindow::<span class="name">clipCorrectionMatrix</span>()<a class="plink" href="#clipCorrectionMatrix" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./qmatrix4x4.htm" translate="no">QMatrix4x4</a> that can be used to correct for coordinate system differences between OpenGL and Vulkan.</p>
<p>By pre-multiplying the projection matrix with this matrix, applications can continue to assume that Y is pointing upwards, and can set minDepth and maxDepth in the viewport to 0 and 1, respectively, without having to do any further corrections to the vertex Z positions. Geometry from OpenGL applications can then be used as-is, assuming a rasterization state matching the OpenGL culling and front face settings.</p>
<!-- @@@clipCorrectionMatrix -->
<!-- $$$colorFormat[overload1]$$$colorFormat -->
<h3 class="fn" id="colorFormat" translate="no"><a name="colorFormat"></a><span class="type">VkFormat</span> QVulkanWindow::<span class="name">colorFormat</span>() const<a class="plink" href="#colorFormat" title="Direct link to this headline"></a></h3>
<p>Returns the color buffer format used by the swapchain.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#setPreferredColorFormats" translate="no">setPreferredColorFormats</a>().</p>
<!-- @@@colorFormat -->
<!-- $$$concurrentFrameCount[overload1]$$$concurrentFrameCount -->
<h3 class="fn" id="concurrentFrameCount" translate="no"><a name="concurrentFrameCount"></a><span class="type">int</span> QVulkanWindow::<span class="name">concurrentFrameCount</span>() const<a class="plink" href="#concurrentFrameCount" title="Direct link to this headline"></a></h3>
<p>Returns the number of frames that can be potentially active at the same time.</p>
<div class="admonition note">
<p><b>Note: </b>The value is constant for the entire lifetime of the <a href="./qvulkanwindow.htm" translate="no">QVulkanWindow</a>.</p>
</div>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="keyword">class</span> Renderer {
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        VkDescriptorBufferInfo m_uniformBufInfo<span class="operator">[</span><span class="type"><a href="./qvulkanwindow.htm#QVulkanWindow" translate="no">QVulkanWindow</a></span><span class="operator">::</span>MAX_CONCURRENT_FRAME_COUNT<span class="operator">]</span>;
    };

    <span class="type">void</span> Renderer<span class="operator">::</span>startNextFrame()
    {
        <span class="keyword">const</span> <span class="type">int</span> count <span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>concurrentFrameCount();
        <span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> count; <span class="operator">+</span><span class="operator">+</span>i)
            m_uniformBufInfo<span class="operator">[</span>i<span class="operator">]</span> <span class="operator">=</span> <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
    }</pre></div>
<p><b>See also </b><a href="./qvulkanwindow.htm#currentFrame" translate="no">currentFrame</a>().</p>
<!-- @@@concurrentFrameCount -->
<!-- $$$createRenderer[overload1]$$$createRenderer -->
<h3 class="fn" id="createRenderer" translate="no"><a name="createRenderer"></a><code translate="no">[virtual] </code><span class="type"><a href="./qvulkanwindowrenderer.htm" translate="no">QVulkanWindowRenderer</a></span> *QVulkanWindow::<span class="name">createRenderer</span>()<a class="plink" href="#createRenderer" title="Direct link to this headline"></a></h3>
<p>Returns a new instance of <a href="./qvulkanwindowrenderer.htm" translate="no">QVulkanWindowRenderer</a>.</p>
<p>This virtual function is called once during the lifetime of the window, at some point after making it visible for the first time.</p>
<p>The default implementation returns null and so no rendering will be performed apart from clearing the buffers.</p>
<p>The window takes ownership of the returned renderer object.</p>
<!-- @@@createRenderer -->
<!-- $$$currentCommandBuffer[overload1]$$$currentCommandBuffer -->
<h3 class="fn" id="currentCommandBuffer" translate="no"><a name="currentCommandBuffer"></a><span class="type">VkCommandBuffer</span> QVulkanWindow::<span class="name">currentCommandBuffer</span>() const<a class="plink" href="#currentCommandBuffer" title="Direct link to this headline"></a></h3>
<p>Returns The active command buffer for the current swap chain image. Implementations of QVulkanWindowRenderer::startNextFrame() are expected to add commands to this command buffer.</p>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>().</p>
</div>
<!-- @@@currentCommandBuffer -->
<!-- $$$currentFrame[overload1]$$$currentFrame -->
<h3 class="fn" id="currentFrame" translate="no"><a name="currentFrame"></a><span class="type">int</span> QVulkanWindow::<span class="name">currentFrame</span>() const<a class="plink" href="#currentFrame" title="Direct link to this headline"></a></h3>
<p>Returns the current frame index in the range [0, <a href="./qvulkanwindow.htm#concurrentFrameCount" translate="no">concurrentFrameCount</a>() - 1].</p>
<p>Renderer implementations will have to ensure that uniform data and other dynamic resources exist in multiple copies, in order to prevent frame N altering the data used by the still-active frames N - 1, N - 2, ... N - <a href="./qvulkanwindow.htm#concurrentFrameCount" translate="no">concurrentFrameCount</a>() + 1.</p>
<p>To avoid relying on dynamic array sizes, applications can use <a href="./qvulkanwindow.htm#MAX_CONCURRENT_FRAME_COUNT-var" translate="no">MAX_CONCURRENT_FRAME_COUNT</a> when declaring arrays. This is guaranteed to be always equal to or greater than the value returned from <a href="./qvulkanwindow.htm#concurrentFrameCount" translate="no">concurrentFrameCount</a>(). Such arrays can then be indexed by the value returned from this function.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    <span class="keyword">class</span> Renderer {
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        VkDescriptorBufferInfo m_uniformBufInfo<span class="operator">[</span><span class="type"><a href="./qvulkanwindow.htm#QVulkanWindow" translate="no">QVulkanWindow</a></span><span class="operator">::</span>MAX_CONCURRENT_FRAME_COUNT<span class="operator">]</span>;
    };

    <span class="type">void</span> Renderer<span class="operator">::</span>startNextFrame()
    {
        VkDescriptorBufferInfo <span class="operator">&amp;</span>uniformBufInfo(m_uniformBufInfo<span class="operator">[</span>m_window<span class="operator">-</span><span class="operator">&gt;</span>currentFrame()<span class="operator">]</span>);
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
    }</pre></div>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>().</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#concurrentFrameCount" translate="no">concurrentFrameCount</a>().</p>
<!-- @@@currentFrame -->
<!-- $$$currentFramebuffer[overload1]$$$currentFramebuffer -->
<h3 class="fn" id="currentFramebuffer" translate="no"><a name="currentFramebuffer"></a><span class="type">VkFramebuffer</span> QVulkanWindow::<span class="name">currentFramebuffer</span>() const<a class="plink" href="#currentFramebuffer" title="Direct link to this headline"></a></h3>
<p>Returns a VkFramebuffer for the current swapchain image using the default render pass.</p>
<p>The framebuffer has two attachments (color, depth-stencil) when multisampling is not in use, and three (color resolve, depth-stencil, multisample color) when <a href="./qvulkanwindow.htm#sampleCountFlagBits" translate="no">sampleCountFlagBits</a>() is greater than <code translate="no">VK_SAMPLE_COUNT_1_BIT</code>. Renderers must take this into account, for example when providing clear values.</p>
<div class="admonition note">
<p><b>Note: </b>Applications are not required to use this framebuffer in case they provide their own render pass instead of using the one returned from <a href="./qvulkanwindow.htm#defaultRenderPass" translate="no">defaultRenderPass</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>().</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#defaultRenderPass" translate="no">defaultRenderPass</a>().</p>
<!-- @@@currentFramebuffer -->
<!-- $$$currentSwapChainImageIndex[overload1]$$$currentSwapChainImageIndex -->
<h3 class="fn" id="currentSwapChainImageIndex" translate="no"><a name="currentSwapChainImageIndex"></a><span class="type">int</span> QVulkanWindow::<span class="name">currentSwapChainImageIndex</span>() const<a class="plink" href="#currentSwapChainImageIndex" title="Direct link to this headline"></a></h3>
<p>Returns the current swap chain image index in the range [0, <a href="./qvulkanwindow.htm#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from within startNextFrame() and, in case of asynchronous command generation, up until the call to <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>().</p>
</div>
<!-- @@@currentSwapChainImageIndex -->
<!-- $$$defaultRenderPass[overload1]$$$defaultRenderPass -->
<h3 class="fn" id="defaultRenderPass" translate="no"><a name="defaultRenderPass"></a><span class="type">VkRenderPass</span> QVulkanWindow::<span class="name">defaultRenderPass</span>() const<a class="plink" href="#defaultRenderPass" title="Direct link to this headline"></a></h3>
<p>Returns a typical render pass with one sub-pass.</p>
<div class="admonition note">
<p><b>Note: </b>Applications are not required to use this render pass. However, they are then responsible for ensuring the current swap chain and depth-stencil images get transitioned from <code translate="no">VK_IMAGE_LAYOUT_UNDEFINED</code> to <code translate="no">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code> and <code translate="no">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code> either via the application's custom render pass or by other means.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Stencil read/write is not enabled in this render pass.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#currentFramebuffer" translate="no">currentFramebuffer</a>().</p>
<!-- @@@defaultRenderPass -->
<!-- $$$depthStencilFormat[overload1]$$$depthStencilFormat -->
<h3 class="fn" id="depthStencilFormat" translate="no"><a name="depthStencilFormat"></a><span class="type">VkFormat</span> QVulkanWindow::<span class="name">depthStencilFormat</span>() const<a class="plink" href="#depthStencilFormat" title="Direct link to this headline"></a></h3>
<p>Returns the format used by the depth-stencil buffer(s).</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@depthStencilFormat -->
<!-- $$$depthStencilImage[overload1]$$$depthStencilImage -->
<h3 class="fn" id="depthStencilImage" translate="no"><a name="depthStencilImage"></a><span class="type">VkImage</span> QVulkanWindow::<span class="name">depthStencilImage</span>() const<a class="plink" href="#depthStencilImage" title="Direct link to this headline"></a></h3>
<p>Returns the depth-stencil image.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@depthStencilImage -->
<!-- $$$depthStencilImageView[overload1]$$$depthStencilImageView -->
<h3 class="fn" id="depthStencilImageView" translate="no"><a name="depthStencilImageView"></a><span class="type">VkImageView</span> QVulkanWindow::<span class="name">depthStencilImageView</span>() const<a class="plink" href="#depthStencilImageView" title="Direct link to this headline"></a></h3>
<p>Returns the depth-stencil image view.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@depthStencilImageView -->
<!-- $$$device[overload1]$$$device -->
<h3 class="fn" id="device" translate="no"><a name="device"></a><span class="type">VkDevice</span> QVulkanWindow::<span class="name">device</span>() const<a class="plink" href="#device" title="Direct link to this headline"></a></h3>
<p>Returns the active logical device.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@device -->
<!-- $$$deviceLocalMemoryIndex[overload1]$$$deviceLocalMemoryIndex -->
<h3 class="fn" id="deviceLocalMemoryIndex" translate="no"><a name="deviceLocalMemoryIndex"></a><span class="type">uint32_t</span> QVulkanWindow::<span class="name">deviceLocalMemoryIndex</span>() const<a class="plink" href="#deviceLocalMemoryIndex" title="Direct link to this headline"></a></h3>
<p>Returns a device local memory type index suitable for general use.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>It is not guaranteed that this memory type is always suitable. The correct, cross-implementation solution - especially for device local images - is to manually pick a memory type after checking the mask returned from <code translate="no">vkGetImageMemoryRequirements</code>.</p>
</div>
<!-- @@@deviceLocalMemoryIndex -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" id="flags" translate="no"><a name="flags"></a><span class="type"><a href="./qvulkanwindow.htm#Flag-enum" translate="no">QVulkanWindow::Flags</a></span> QVulkanWindow::<span class="name">flags</span>() const<a class="plink" href="#flags" title="Direct link to this headline"></a></h3>
<p>Return the requested flags.</p>
<p><b>See also </b><a href="./qvulkanwindow.htm#setFlags" translate="no">setFlags</a>().</p>
<!-- @@@flags -->
<!-- $$$frameReady[overload1]$$$frameReady -->
<h3 class="fn" id="frameReady" translate="no"><a name="frameReady"></a><span class="type">void</span> QVulkanWindow::<span class="name">frameReady</span>()<a class="plink" href="#frameReady" title="Direct link to this headline"></a></h3>
<p>This function must be called exactly once in response to each invocation of the QVulkanWindowRenderer::startNextFrame() implementation. At the time of this call, the main command buffer, exposed via <a href="./qvulkanwindow.htm#currentCommandBuffer" translate="no">currentCommandBuffer</a>(), must have all necessary rendering commands added to it since this function will trigger submitting the commands and queuing the present command.</p>
<div class="admonition note">
<p><b>Note: </b>This function must only be called from the gui/main thread, which is where <a href="./qvulkanwindowrenderer.htm" translate="no">QVulkanWindowRenderer</a>'s functions are invoked and where the <a href="./qvulkanwindow.htm" translate="no">QVulkanWindow</a> instance lives.</p>
</div>
<p><b>See also </b>QVulkanWindowRenderer::startNextFrame().</p>
<!-- @@@frameReady -->
<!-- $$$grab[overload1]$$$grab -->
<h3 class="fn" id="grab" translate="no"><a name="grab"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QVulkanWindow::<span class="name">grab</span>()<a class="plink" href="#grab" title="Direct link to this headline"></a></h3>
<p>Builds and renders the next frame without presenting it, then performs a blocking readback of the image content.</p>
<p>Returns the image if the renderer's startNextFrame() implementation calls back <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>() directly. Otherwise, returns an incomplete image, that has the correct size but not the content yet. The content will be delivered via the frameGrabbed() signal in the latter case.</p>
<div class="admonition note">
<p><b>Note: </b>This function should not be called when a frame is in progress (that is, <a href="./qvulkanwindow.htm#frameReady" translate="no">frameReady</a>() has not yet been called back by the application).</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function is potentially expensive due to the additional, blocking readback.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function currently requires that the swapchain supports usage as a transfer source (<code translate="no">VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code>), and will fail otherwise.</p>
</div>
<!-- @@@grab -->
<!-- $$$graphicsCommandPool[overload1]$$$graphicsCommandPool -->
<h3 class="fn" id="graphicsCommandPool" translate="no"><a name="graphicsCommandPool"></a><span class="type">VkCommandPool</span> QVulkanWindow::<span class="name">graphicsCommandPool</span>() const<a class="plink" href="#graphicsCommandPool" title="Direct link to this headline"></a></h3>
<p>Returns the active graphics command pool.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@graphicsCommandPool -->
<!-- $$$graphicsQueue[overload1]$$$graphicsQueue -->
<h3 class="fn" id="graphicsQueue" translate="no"><a name="graphicsQueue"></a><span class="type">VkQueue</span> QVulkanWindow::<span class="name">graphicsQueue</span>() const<a class="plink" href="#graphicsQueue" title="Direct link to this headline"></a></h3>
<p>Returns the active graphics queue.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@graphicsQueue -->
<!-- $$$graphicsQueueFamilyIndex[overload1]$$$graphicsQueueFamilyIndex -->
<h3 class="fn" id="graphicsQueueFamilyIndex" translate="no"><a name="graphicsQueueFamilyIndex"></a><span class="type">uint32_t</span> QVulkanWindow::<span class="name">graphicsQueueFamilyIndex</span>() const<a class="plink" href="#graphicsQueueFamilyIndex" title="Direct link to this headline"></a></h3>
<p>Returns the family index of the active graphics queue.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>(). Implementations of QVulkanWindowRenderer::updateQueueCreateInfo() can also call this function.</p>
</div>
<p>This function was introduced in Qt 5.15.</p>
<!-- @@@graphicsQueueFamilyIndex -->
<!-- $$$hostVisibleMemoryIndex[overload1]$$$hostVisibleMemoryIndex -->
<h3 class="fn" id="hostVisibleMemoryIndex" translate="no"><a name="hostVisibleMemoryIndex"></a><span class="type">uint32_t</span> QVulkanWindow::<span class="name">hostVisibleMemoryIndex</span>() const<a class="plink" href="#hostVisibleMemoryIndex" title="Direct link to this headline"></a></h3>
<p>Returns a host visible memory type index suitable for general use.</p>
<p>The returned memory type will be both host visible and coherent. In addition, it will also be cached, if possible.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initResources" translate="no">QVulkanWindowRenderer::initResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@hostVisibleMemoryIndex -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QVulkanWindow::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Returns true if this window has successfully initialized all Vulkan resources, including the swapchain.</p>
<div class="admonition note">
<p><b>Note: </b>Initialization happens on the first expose event after the window is made visible.</p>
</div>
<!-- @@@isValid -->
<!-- $$$msaaColorImage[overload1]$$$msaaColorImageint -->
<h3 class="fn" id="msaaColorImage" translate="no"><a name="msaaColorImage"></a><span class="type">VkImage</span> QVulkanWindow::<span class="name">msaaColorImage</span>(<span class="type">int</span> <i>idx</i>) const<a class="plink" href="#msaaColorImage" title="Direct link to this headline"></a></h3>
<p>Returns the specified multisample color image, or <code translate="no">VK_NULL_HANDLE</code> if multisampling is not in use.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="./qvulkanwindow.htm#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@msaaColorImage -->
<!-- $$$msaaColorImageView[overload1]$$$msaaColorImageViewint -->
<h3 class="fn" id="msaaColorImageView" translate="no"><a name="msaaColorImageView"></a><span class="type">VkImageView</span> QVulkanWindow::<span class="name">msaaColorImageView</span>(<span class="type">int</span> <i>idx</i>) const<a class="plink" href="#msaaColorImageView" title="Direct link to this headline"></a></h3>
<p>Returns the specified multisample color image view, or <code translate="no">VK_NULL_HANDLE</code> if multisampling is not in use.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="./qvulkanwindow.htm#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@msaaColorImageView -->
<!-- $$$physicalDevice[overload1]$$$physicalDevice -->
<h3 class="fn" id="physicalDevice" translate="no"><a name="physicalDevice"></a><span class="type">VkPhysicalDevice</span> QVulkanWindow::<span class="name">physicalDevice</span>() const<a class="plink" href="#physicalDevice" title="Direct link to this headline"></a></h3>
<p>Returns the active physical device.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@physicalDevice -->
<!-- $$$physicalDeviceProperties[overload1]$$$physicalDeviceProperties -->
<h3 class="fn" id="physicalDeviceProperties" translate="no"><a name="physicalDeviceProperties"></a>const <span class="type">VkPhysicalDeviceProperties</span> *QVulkanWindow::<span class="name">physicalDeviceProperties</span>() const<a class="plink" href="#physicalDeviceProperties" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the properties for the active physical device.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseResources" translate="no">QVulkanWindowRenderer::releaseResources</a>().</p>
</div>
<!-- @@@physicalDeviceProperties -->
<!-- $$$sampleCountFlagBits[overload1]$$$sampleCountFlagBits -->
<h3 class="fn" id="sampleCountFlagBits" translate="no"><a name="sampleCountFlagBits"></a><span class="type">VkSampleCountFlagBits</span> QVulkanWindow::<span class="name">sampleCountFlagBits</span>() const<a class="plink" href="#sampleCountFlagBits" title="Direct link to this headline"></a></h3>
<p>Returns the current sample count as a <code translate="no">VkSampleCountFlagBits</code> value.</p>
<p>When targeting the default render target, the <code translate="no">rasterizationSamples</code> field of <code translate="no">VkPipelineMultisampleStateCreateInfo</code> must be set to this value.</p>
<p><b>See also </b><a href="./qvulkanwindow.htm#setSampleCount" translate="no">setSampleCount</a>() and <a href="./qvulkanwindow.htm#supportedSampleCounts" translate="no">supportedSampleCounts</a>().</p>
<!-- @@@sampleCountFlagBits -->
<!-- $$$setDeviceExtensions[overload1]$$$setDeviceExtensionsconstQByteArrayList& -->
<h3 class="fn" id="setDeviceExtensions" translate="no"><a name="setDeviceExtensions"></a><span class="type">void</span> QVulkanWindow::<span class="name">setDeviceExtensions</span>(const <span class="type"><a href="./qbytearraylist.htm" translate="no">QByteArrayList</a></span> &amp;<i>extensions</i>)<a class="plink" href="#setDeviceExtensions" title="Direct link to this headline"></a></h3>
<p>Sets the list of device <i translate="no">extensions</i> to be enabled.</p>
<p>Unsupported extensions are ignored.</p>
<p>The swapchain extension will always be added automatically, no need to include it in this list.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<!-- @@@setDeviceExtensions -->
<!-- $$$setFlags[overload1]$$$setFlagsQVulkanWindow::Flags -->
<h3 class="fn" id="setFlags" translate="no"><a name="setFlags"></a><span class="type">void</span> QVulkanWindow::<span class="name">setFlags</span>(<span class="type"><a href="./qvulkanwindow.htm#Flag-enum" translate="no">QVulkanWindow::Flags</a></span> <i>flags</i>)<a class="plink" href="#setFlags" title="Direct link to this headline"></a></h3>
<p>Configures the behavior based on the provided <i translate="no">flags</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#flags" translate="no">flags</a>().</p>
<!-- @@@setFlags -->
<!-- $$$setPhysicalDeviceIndex[overload1]$$$setPhysicalDeviceIndexint -->
<h3 class="fn" id="setPhysicalDeviceIndex" translate="no"><a name="setPhysicalDeviceIndex"></a><span class="type">void</span> QVulkanWindow::<span class="name">setPhysicalDeviceIndex</span>(<span class="type">int</span> <i>idx</i>)<a class="plink" href="#setPhysicalDeviceIndex" title="Direct link to this headline"></a></h3>
<p>Requests the usage of the physical device with index <i translate="no">idx</i>. The index corresponds to the list returned from <a href="./qvulkanwindow.htm#availablePhysicalDevices" translate="no">availablePhysicalDevices</a>().</p>
<p>By default the first physical device is used.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<!-- @@@setPhysicalDeviceIndex -->
<!-- $$$setPreferredColorFormats[overload1]$$$setPreferredColorFormatsconstQVector<VkFormat>& -->
<h3 class="fn" id="setPreferredColorFormats" translate="no"><a name="setPreferredColorFormats"></a><span class="type">void</span> QVulkanWindow::<span class="name">setPreferredColorFormats</span>(const <span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type">VkFormat</span>&gt; &amp;<i>formats</i>)<a class="plink" href="#setPreferredColorFormats" title="Direct link to this headline"></a></h3>
<p>Sets the preferred <i translate="no">formats</i> of the swapchain.</p>
<p>By default no application-preferred format is set. In this case the surface's preferred format will be used or, in absence of that, <code translate="no">VK_FORMAT_B8G8R8A8_UNORM</code>.</p>
<p>The list in <i translate="no">formats</i> is ordered. If the first format is not supported, the second will be considered, and so on. When no formats in the list are supported, the behavior is the same as in the default case.</p>
<p>To query the actual format after initialization, call <a href="./qvulkanwindow.htm#colorFormat" translate="no">colorFormat</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Reimplementing <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>() allows dynamically examining the list of supported formats, should that be desired. There the surface is retrievable via QVulkanInstace::surfaceForWindow(), while this function can still safely be called to affect the later stages of initialization.</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#colorFormat" translate="no">colorFormat</a>().</p>
<!-- @@@setPreferredColorFormats -->
<!-- $$$setQueueCreateInfoModifier[overload1]$$$setQueueCreateInfoModifierconstQVulkanWindow::QueueCreateInfoModifier& -->
<h3 class="fn" id="setQueueCreateInfoModifier" translate="no"><a name="setQueueCreateInfoModifier"></a><span class="type">void</span> QVulkanWindow::<span class="name">setQueueCreateInfoModifier</span>(const <span class="type"><a href="./qvulkanwindow.htm#QueueCreateInfoModifier-typedef" translate="no">QVulkanWindow::QueueCreateInfoModifier</a></span> &amp;<i>modifier</i>)<a class="plink" href="#setQueueCreateInfoModifier" title="Direct link to this headline"></a></h3>
<p>Set a queue create info modification function.</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b>queueCreateInfoModifier().</p>
<!-- @@@setQueueCreateInfoModifier -->
<!-- $$$setSampleCount[overload1]$$$setSampleCountint -->
<h3 class="fn" id="setSampleCount" translate="no"><a name="setSampleCount"></a><span class="type">void</span> QVulkanWindow::<span class="name">setSampleCount</span>(<span class="type">int</span> <i>sampleCount</i>)<a class="plink" href="#setSampleCount" title="Direct link to this headline"></a></h3>
<p>Requests multisample antialiasing with the given <i translate="no">sampleCount</i>. The valid values are 1, 2, 4, 8, ... up until the maximum value supported by the physical device.</p>
<p>When the sample count is greater than 1, <a href="./qvulkanwindow.htm" translate="no">QVulkanWindow</a> will create a multisample color buffer instead of simply targeting the swapchain's images. The rendering in the multisample buffer will get resolved into the non-multisample buffers at the end of each frame.</p>
<p>To examine the list of supported sample counts, call <a href="./qvulkanwindow.htm#supportedSampleCounts" translate="no">supportedSampleCounts</a>().</p>
<p>When setting up the rendering pipeline, call <a href="./qvulkanwindow.htm#sampleCountFlagBits" translate="no">sampleCountFlagBits</a>() to query the active sample count as a <code translate="no">VkSampleCountFlagBits</code> value.</p>
<div class="admonition note">
<p><b>Note: </b>This function must be called before the window is made visible or at latest in <a href="./qvulkanwindowrenderer.htm#preInitResources" translate="no">QVulkanWindowRenderer::preInitResources</a>(), and has no effect if called afterwards.</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#supportedSampleCounts" translate="no">supportedSampleCounts</a>() and <a href="./qvulkanwindow.htm#sampleCountFlagBits" translate="no">sampleCountFlagBits</a>().</p>
<!-- @@@setSampleCount -->
<!-- $$$supportedDeviceExtensions[overload1]$$$supportedDeviceExtensions -->
<h3 class="fn" id="supportedDeviceExtensions" translate="no"><a name="supportedDeviceExtensions"></a><span class="type"><a href="./qvulkaninfovector.htm" translate="no">QVulkanInfoVector</a></span>&lt;<span class="type"><a href="./qvulkanextension.htm" translate="no">QVulkanExtension</a></span>&gt; QVulkanWindow::<span class="name">supportedDeviceExtensions</span>()<a class="plink" href="#supportedDeviceExtensions" title="Direct link to this headline"></a></h3>
<p>Returns the list of the extensions that are supported by logical devices created from the physical device selected by <a href="./qvulkanwindow.htm#setPhysicalDeviceIndex" translate="no">setPhysicalDeviceIndex</a>().</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called before making the window visible.</p>
</div>
<!-- @@@supportedDeviceExtensions -->
<!-- $$$supportedSampleCounts[overload1]$$$supportedSampleCounts -->
<h3 class="fn" id="supportedSampleCounts" translate="no"><a name="supportedSampleCounts"></a><span class="type"><a href="./qvector.htm" translate="no">QVector</a></span>&lt;<span class="type">int</span>&gt; QVulkanWindow::<span class="name">supportedSampleCounts</span>()<a class="plink" href="#supportedSampleCounts" title="Direct link to this headline"></a></h3>
<p>Returns the set of supported sample counts when using the physical device selected by <a href="./qvulkanwindow.htm#setPhysicalDeviceIndex" translate="no">setPhysicalDeviceIndex</a>(), as a sorted vector.</p>
<p>By default <a href="./qvulkanwindow.htm" translate="no">QVulkanWindow</a> uses a sample count of 1. By calling <a href="./qvulkanwindow.htm#setSampleCount" translate="no">setSampleCount</a>() with a different value (2, 4, 8, ...) from the set returned by this function, multisample anti-aliasing can be requested.</p>
<div class="admonition note">
<p><b>Note: </b>This function can be called before making the window visible.</p>
</div>
<p><b>See also </b><a href="./qvulkanwindow.htm#setSampleCount" translate="no">setSampleCount</a>().</p>
<!-- @@@supportedSampleCounts -->
<!-- $$$supportsGrab[overload1]$$$supportsGrab -->
<h3 class="fn" id="supportsGrab" translate="no"><a name="supportsGrab"></a><span class="type">bool</span> QVulkanWindow::<span class="name">supportsGrab</span>() const<a class="plink" href="#supportsGrab" title="Direct link to this headline"></a></h3>
<p>Returns true if the swapchain supports usage as transfer source, meaning <a href="./qvulkanwindow.htm#grab" translate="no">grab</a>() is functional.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@supportsGrab -->
<!-- $$$swapChainImage[overload1]$$$swapChainImageint -->
<h3 class="fn" id="swapChainImage" translate="no"><a name="swapChainImage"></a><span class="type">VkImage</span> QVulkanWindow::<span class="name">swapChainImage</span>(<span class="type">int</span> <i>idx</i>) const<a class="plink" href="#swapChainImage" title="Direct link to this headline"></a></h3>
<p>Returns the specified swap chain image.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="./qvulkanwindow.htm#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImage -->
<!-- $$$swapChainImageCount[overload1]$$$swapChainImageCount -->
<h3 class="fn" id="swapChainImageCount" translate="no"><a name="swapChainImageCount"></a><span class="type">int</span> QVulkanWindow::<span class="name">swapChainImageCount</span>() const<a class="plink" href="#swapChainImageCount" title="Direct link to this headline"></a></h3>
<p>Returns the number of images in the swap chain.</p>
<div class="admonition note">
<p><b>Note: </b>Accessing this is necessary when providing a custom render pass and framebuffer. The framebuffer is specific to the current swapchain image and hence the application must provide multiple framebuffers.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImageCount -->
<!-- $$$swapChainImageSize[overload1]$$$swapChainImageSize -->
<h3 class="fn" id="swapChainImageSize" translate="no"><a name="swapChainImageSize"></a><span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> QVulkanWindow::<span class="name">swapChainImageSize</span>() const<a class="plink" href="#swapChainImageSize" title="Direct link to this headline"></a></h3>
<p>Returns the image size of the swapchain.</p>
<p>This usually matches the size of the window, but may also differ in case <code translate="no">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</code> reports a fixed size.</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImageSize -->
<!-- $$$swapChainImageView[overload1]$$$swapChainImageViewint -->
<h3 class="fn" id="swapChainImageView" translate="no"><a name="swapChainImageView"></a><span class="type">VkImageView</span> QVulkanWindow::<span class="name">swapChainImageView</span>(<span class="type">int</span> <i>idx</i>) const<a class="plink" href="#swapChainImageView" title="Direct link to this headline"></a></h3>
<p>Returns the specified swap chain image view.</p>
<p><i translate="no">idx</i> must be in the range [0, <a href="./qvulkanwindow.htm#swapChainImageCount" translate="no">swapChainImageCount</a>() - 1].</p>
<div class="admonition note">
<p><b>Note: </b>Calling this function is only valid from the invocation of <a href="./qvulkanwindowrenderer.htm#initSwapChainResources" translate="no">QVulkanWindowRenderer::initSwapChainResources</a>() up until <a href="./qvulkanwindowrenderer.htm#releaseSwapChainResources" translate="no">QVulkanWindowRenderer::releaseSwapChainResources</a>().</p>
</div>
<!-- @@@swapChainImageView -->
</div>
<div class="vars">
<h2>Member Variable Documentation</h2>
<!-- $$$MAX_CONCURRENT_FRAME_COUNT -->
<h3 class="fn" id="MAX_CONCURRENT_FRAME_COUNT-var" translate="no"><a name="MAX_CONCURRENT_FRAME_COUNT-var"></a>const <span class="type">int</span> QVulkanWindow::<span class="name">MAX_CONCURRENT_FRAME_COUNT</span><a class="plink" href="#MAX_CONCURRENT_FRAME_COUNT-var" title="Direct link to this headline"></a></h3>
<p>This variable holds a constant value that is always equal to or greater than the maximum value of <a href="./qvulkanwindow.htm#concurrentFrameCount" translate="no">concurrentFrameCount</a>().</p>
<!-- @@@MAX_CONCURRENT_FRAME_COUNT -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>