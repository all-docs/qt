<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Module Definition qmldir Files | Qt QML</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qtqml-modules-qmldir.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtqml-index.htm" translate="no">Qt QML</a></li>
                            <li><a>Module Definition qmldir Files</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title">Module Definition qmldir Files</h1>
<span class="subtitle"></span>
<!-- $$$qtqml-modules-qmldir.html-description -->
<div class="descr"> <a name="details"></a>
<p>There are two distinct types of <code translate="no">qmldir</code> files:</p>
<ul>
<li>QML document directory listing files</li>
<li>QML module definition files</li>
</ul>
<p>This documentation covers only the second form of <code translate="no">qmldir</code> file, which lists the QML types, JavaScript files, and plugins that are available under a module. For more information about the first form of <code translate="no">qmldir</code> file, see <a href="./qtqml-syntax-directoryimports.htm#directory-listing-qmldir-files" translate="no">directory listing qmldir files</a>.</p>
<a name="contents-of-a-module-definition-qmldir-file"></a>
<h2 id="contents-of-a-module-definition-qmldir-file">Contents of a Module Definition qmldir File<a class="plink" href="#contents-of-a-module-definition-qmldir-file" title="Direct link to this headline"></a></h2>
<p>A <code translate="no">qmldir</code> file is a plain-text file that contains the following commands:</p>
<div class="table"><table class="generic" width="70%">
<thead><tr class="qt-style"><th>Syntax</th><th>Usage</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no">module <span class="operator">&lt;</span>ModuleIdentifier<span class="operator">&gt;</span></pre></div>
</td><td>Declares the module identifier of the module. The &lt;ModuleIdentifier&gt; is the (dotted URI notation) identifier for the module, which must match the module's install path.<p>The <a href="./qtqml-modules-identifiedmodules.htm#semantics-of-identified-modules" translate="no">module identifier directive</a> must be the first line of the file. Exactly one module identifier directive may exist in the <code translate="no">qmldir</code> file.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp" translate="no">module ExampleModule</pre></div>
</td></tr>
<tr class="even" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no"><span class="operator">[</span>singleton<span class="operator">]</span> <span class="operator">&lt;</span>TypeName<span class="operator">&gt;</span> <span class="operator">&lt;</span>InitialVersion<span class="operator">&gt;</span> <span class="operator">&lt;</span>File<span class="operator">&gt;</span></pre></div>
</td><td>Declares a <a href="./qtqml-typesystem-objecttypes.htm" translate="no">QML object type</a> to be made available by the module.<ul>
<li><code translate="no">[singleton]</code> Optional. Used to declare a singleton type.</li>
<li><code translate="no">&lt;TypeName&gt;</code> is the type being made available</li>
<li><code translate="no">&lt;InitialVersion&gt;</code> is the module version for which the type is to be made available</li>
<li><code translate="no">&lt;File&gt;</code> is the (relative) file name of the QML file that defines the type</li>
</ul>
<p>Zero or more object type declarations may exist in the <code translate="no">qmldir</code> file, however each object type must have a unique type name within any particular version of the module.</p>
<div class="admonition note">
<p><b>Note: </b>To declare a <code translate="no">singleton</code> type, the QML file defining the type must include the <code translate="no">pragma Singleton</code> statement.</p>
</div>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">//Style.qml with custom singleton type definition</span>
pragma Singleton
import <span class="type"><a href="./qtquick-module.htm" translate="no">QtQuick</a></span> <span class="number">2.0</span>

<span class="type"><a href="./qml-qtqml-qtobject.htm" translate="no">QtObject</a></span> {
    property <span class="type">int</span> textSize: <span class="number">20</span>
    property color textColor: <span class="string">"green"</span>
}

<span class="comment">// qmldir declaring the singleton type</span>
module CustomStyles
singleton Style <span class="number">1.0</span> Style<span class="operator">.</span>qml

<span class="comment">// singleton type in use</span>
import <span class="type"><a href="./qtquick-module.htm" translate="no">QtQuick</a></span> <span class="number">2.0</span>
import CustomStyles <span class="number">1.0</span>

Text {
    font<span class="operator">.</span>pixelSize: Style<span class="operator">.</span>textSize
    color: Style<span class="operator">.</span>textColor
    text: <span class="string">"Hello World"</span>
}</pre></div>
</td></tr>
<tr class="odd" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no">internal <span class="operator">&lt;</span>TypeName<span class="operator">&gt;</span> <span class="operator">&lt;</span>File<span class="operator">&gt;</span></pre></div>
</td><td>Declares an object type that is in the module but should not be made available to users of the module.<p>Zero or more internal object type declarations may exist in the <code translate="no">qmldir</code> file.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp" translate="no">internal MyPrivateType MyPrivateType<span class="operator">.</span>qml</pre></div>
<p>This is necessary if the module may be imported remotely (see <a href="./qtqml-modules-identifiedmodules.htm#remotely-installed-identified-modules" translate="no">Remotely Installed Identified Modules</a>) because if an exported type depends on an non-exported type within the module, the engine must also load the non-exported type.</p>
</td></tr>
<tr class="even" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no"><span class="operator">&lt;</span>ResourceIdentifier<span class="operator">&gt;</span> <span class="operator">&lt;</span>InitialVersion<span class="operator">&gt;</span> <span class="operator">&lt;</span>File<span class="operator">&gt;</span></pre></div>
</td><td>Declares a JavaScript file to be made available by the module. The resource will be made available via the specified identifier with the specified version number.<p>Zero or more JavaScript resource declarations may exist in the <code translate="no">qmldir</code> file, however each JavaScript resource must have a unique identifier within any particular version of the module.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp" translate="no">MyScript <span class="number">1.0</span> MyScript<span class="operator">.</span>js</pre></div>
<p>See the documentation about <a href="./qtqml-javascript-resources.htm" translate="no">defining JavaScript resources</a> and <a href="./qtqml-javascript-imports.htm" translate="no">Importing JavaScript Resources In QML</a> for more information.</p>
</td></tr>
<tr class="odd" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no">plugin <span class="operator">&lt;</span>Name<span class="operator">&gt;</span> <span class="operator">[</span><span class="operator">&lt;</span>Path<span class="operator">&gt;</span><span class="operator">]</span></pre></div>
</td><td>Declares a plugin to be made available by the module.<ul>
<li><code translate="no">&lt;Name&gt;</code> is the plugin library name. This is usually not the same as the file name of the plugin binary, which is platform dependent; e.g. the library <code translate="no">MyAppTypes</code> would produce <code translate="no">libMyAppTypes.so</code> on Linux and <code translate="no">MyAppTypes.dll</code> on Windows.</li>
<li><code translate="no">&lt;Path&gt;</code> (optional) specifies either:<ul>
<li>an absolute path to the directory containing the plugin file, or</li>
<li>a relative path from the directory containing the <code translate="no">qmldir</code> file to the directory containing the plugin file.</li>
</ul>
<p>By default the engine searches for the plugin library in the directory that contains the <code translate="no">qmldir</code> file. (The plugin search path can be queried with <a href="./qqmlengine.htm#pluginPathList" translate="no">QQmlEngine::pluginPathList</a>() and modified using <a href="./qqmlengine.htm#addPluginPath" translate="no">QQmlEngine::addPluginPath</a>().)</p>
</li>
</ul>
<p>Zero or more C++ plugin declarations may exist in the <code translate="no">qmldir</code> file, however since plugin loading is a relatively expensive operation, clients are advised to specify at most a single plugin.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp" translate="no">plugin MyPluginLibrary</pre></div>
</td></tr>
<tr class="even" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no">classname <span class="operator">&lt;</span>C<span class="operator">+</span><span class="operator">+</span> plugin <span class="keyword">class</span><span class="operator">&gt;</span></pre></div>
</td><td>Provides the class name of the C++ plugin used by the module.<p>This information is required for all the QML modules that depend on a C++ plugin for additional functionality. Qt Quick applications built with static linking cannot resolve the module imports without this information.</p>
</td></tr>
<tr class="odd" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no">typeinfo <span class="operator">&lt;</span>File<span class="operator">&gt;</span></pre></div>
</td><td>Declares a <a href="./qtqml-modules-qmldir.htm#writing-a-qmltypes-file" translate="no">type description file</a> for the module that can be read by QML tools such as Qt Creator to access information about the types defined by the module's plugins. <code translate="no">&lt;File&gt;</code> is the (relative) file name of a <code translate="no">.qmltypes</code> file.<p>Example:</p>
<div class="pre"><pre class="cpp" translate="no">typeinfo mymodule<span class="operator">.</span>qmltypes</pre></div>
<p>Without such a file, QML tools may be unable to offer features such as code completion for the types defined in your plugins.</p>
</td></tr>
<tr class="even" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no">depends <span class="operator">&lt;</span>ModuleIdentifier<span class="operator">&gt;</span> <span class="operator">&lt;</span>InitialVersion<span class="operator">&gt;</span></pre></div>
</td><td>Declares that this module depends on another.<p>Example:</p>
<div class="pre"><pre class="cpp" translate="no">depends MyOtherModule <span class="number">1.0</span></pre></div>
<p>This declaration is necessary only in cases when the dependency is hidden: for example, when the C++ code for one module is used to load QML (perhaps conditionally) which then depends on other modules. In such cases, the <code translate="no">depends</code> declaration is necessary to include the other modules in application packages.</p>
</td></tr>
<tr class="odd" valign="top"><td><div class="pre"><pre class="cpp prettyprint" translate="no"><span class="preprocessor"># &lt;Comment&gt;</span></pre></div>
</td><td>Declares a comment. These are ignored by the engine.<p>Example:</p>
<div class="pre"><pre class="cpp" translate="no"><span class="preprocessor"># this is a comment</span></pre></div>
</td></tr>
<tr class="even" valign="top"><td><div class="pre"><pre class="cpp" translate="no">designersupported</pre></div>
</td><td>Set this property if the plugin is supported by Qt Quick Designer. By default, the plugin will not be supported.<p>A plugin that is supported by Qt Quick Designer has to be properly tested. This means that the plugin does not crash when running inside the qml2puppet that is used by Qt Quick Designer to execute QML. Generally the plugin should work well in the Qt Quick Designer and not cause any show stoppers, like taking huge amounts of memory, slowing down the qml2puppet heavily or anything else that renders the plugin effectively unusable in the Qt Quick Designer.</p>
<p>The items of an unsupported plugin are not painted in the Qt Quick Designer, but they are still available as empty boxes and the properties can be edited.</p>
</td></tr>
</tbody></table></div>
<p>Each command in a <code translate="no">qmldir</code> file must be on a separate line.</p>
<a name="versioning-semantics"></a>
<h2 id="versioning-semantics">Versioning Semantics<a class="plink" href="#versioning-semantics" title="Direct link to this headline"></a></h2>
<p>All QML types that are exported for a particular major version are available with the latest version of the same major version. For example, if a module provides a <code translate="no">MyButton</code> type in version 1.0 and <code translate="no">MyWindow</code> type in version 1.1, clients importing version <code translate="no">1.1</code> of the module get to use the <code translate="no">MyButton</code> and <code translate="no">MyWindow</code> types. However, the reverse is not true: a type exported for a particular minor version cannot be used by importing an older or earlier minor version. In the example mentioned earlier, if the client had imported version <code translate="no">1.0</code> of the module, they can use the <code translate="no">MyButton</code> type only but not the <code translate="no">MyWindow</code> type.</p>
<p>A module can offer multiple major versions but the clients have access to one major version only at a time. For example, importing <code translate="no">MyExampleModule 2.0</code> provides access to that major version only and not the previous major version. Although you can organize the artifacts that belong to different major versions under a sigle directory and a <code translate="no">qmldir</code> file, it is recommended to use different directories for each major version. If you choose to go with the earlier approach (one directory and a <code translate="no">qmldir</code> file), try to use the version suffix for the file names. For example, artifacts that belong to <code translate="no">MyExampleModule 2.0</code> can use <code translate="no">.2</code> suffix in their file name.</p>
<p>A version cannot be imported if no types have been explicitly exported for that version. If a module provides a <code translate="no">MyButton</code> type in version 1.0 and a <code translate="no">MyWindow</code> type in version 1.1, you cannot import version 1.2 or version 2.0 of that module.</p>
<p>A type can be defined by different files in different minor versions. In this case, the most closely matching version is used when imported by clients. For example, if a module had specified the following types via its <code translate="no">qmldir</code> file:</p>
<div class="pre"><pre class="cpp" translate="no">module ExampleModule
MyButton <span class="number">1.0</span> MyButton<span class="operator">.</span>qml
MyButton <span class="number">1.1</span> MyButton11<span class="operator">.</span>qml
MyButton <span class="number">1.3</span> MyButton13<span class="operator">.</span>qml
MyRectangle <span class="number">1.2</span> MyRectangle12<span class="operator">.</span>qml</pre></div>
<p>a client who imports version <code translate="no">1.2</code> of <code translate="no">ExampleModule</code> can use the <code translate="no">MyButton</code> type definition provided by <code translate="no">MyButton11.qml</code> as it is the latest version of that type, and the <code translate="no">MyRectangle</code> type definition provided by <code translate="no">MyRectangle12.qml</code>.</p>
<p>The version system ensures that a given QML file works regardless of the version of installed software, as a versioned import only imports types for that version, leaving other identifiers available, even if the actual installed version might otherwise provide those identifiers.</p>
<a name="example-of-a-qmldir-file"></a>
<h2 id="example-of-a-qmldir-file">Example of a qmldir File<a class="plink" href="#example-of-a-qmldir-file" title="Direct link to this headline"></a></h2>
<p>One example of a <code translate="no">qmldir</code> file follows:</p>
<div class="pre"><pre class="cpp" translate="no">module ExampleModule
CustomButton <span class="number">2.0</span> CustomButton20<span class="operator">.</span>qml
CustomButton <span class="number">2.1</span> CustomButton21<span class="operator">.</span>qml
plugin examplemodule
MathFunctions <span class="number">2.0</span> mathfuncs<span class="operator">.</span>js</pre></div>
<p>The above <code translate="no">qmldir</code> file defines a module called "ExampleModule". It defines the <code translate="no">CustomButton</code> QML object type in versions 2.0 and 2.1 of the module, with different implementations for each version. It specifies a plugin that must be loaded by the engine when the module is imported by clients, and that plugin may register various C++-defined types with the QML type system. On Unix-like systems the QML engine attempts to load <code translate="no">libexamplemodule.so</code> as a QQmlExtensionPlugin, and on Windows it loads <code translate="no">examplemodule.dll</code> as a QQmlExtensionPlugin. Finally, the <code translate="no">qmldir</code> file specifies a <a href="./qtqml-javascript-resources.htm" translate="no">JavaScript resource</a>, which is only available if version 2.0 or a later version (under the same major version) of the module is imported.</p>
<p>If the module is <a href="./qtqml-modules-identifiedmodules.htm" translate="no">installed</a> into the QML import path, clients could import and use the module in the following manner:</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick 2.0
import ExampleModule 2.1

<span class="type"><a href="./qml-qtquick-rectangle.htm" translate="no">Rectangle</a></span> {
    <span class="name">width</span>: <span class="number">400</span>
    <span class="name">height</span>: <span class="number">400</span>
    <span class="name">color</span>: <span class="string">"lightsteelblue"</span>

    <span class="type">CustomButton</span> {
        <span class="name">color</span>: <span class="string">"gray"</span>
        <span class="name">text</span>: <span class="string">"Click Me!"</span>
        <span class="name">onClicked</span>: <span class="name">MathFunctions</span>.<span class="name">generateRandom</span>() <span class="operator">&gt;</span> <span class="number">10</span> ? <span class="name">color</span> <span class="operator">=</span> <span class="string">"red"</span> : <span class="name">color</span> <span class="operator">=</span> <span class="string">"gray"</span>;
    }
}</pre></div>
<p>The <code translate="no">CustomButton</code> type used above would come from the definition specified in the <code translate="no">CustomButton21.qml</code> file, and the JavaScript resource identified by the <code translate="no">MathFunctions</code> identifier would be defined in the <code translate="no">mathfuncs.js</code> file.</p>
<a name="writing-a-qmltypes-file"></a>
<h2 id="writing-a-qmltypes-file">Writing a qmltypes File<a class="plink" href="#writing-a-qmltypes-file" title="Direct link to this headline"></a></h2>
<p>QML modules may refer to one or more type information files in their <code translate="no">qmldir</code> file. These usually have the <code translate="no">.qmltypes</code> extension and are read by external tools to gain information about types defined in plugins.</p>
<p>As such qmltypes files have no effect on the functionality of a QML module. Their only use is to allow tools such as Qt Creator to provide code completion, error checking and other functionality to users of your module.</p>
<p>Any module that uses plugins should also ship a type description file.</p>
<p>The best way to create a qmltypes file for your module is to generate it using the <code translate="no">qmlplugindump</code> tool that is provided with Qt.</p>
<p>Example: If your module is in <code translate="no">/tmp/imports/My/Module</code>, you could run</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">qmlplugindump My<span class="operator">.</span>Module <span class="number">1.0</span> <span class="operator">/</span>tmp<span class="operator">/</span>imports <span class="operator">&gt;</span> <span class="operator">/</span>tmp<span class="operator">/</span>imports<span class="operator">/</span>My<span class="operator">/</span>Module<span class="operator">/</span>mymodule<span class="operator">.</span>qmltypes</pre></div>
<p>to generate type information for your module. Afterwards, add the line</p>
<div class="pre"><pre class="cpp" translate="no">typeinfo mymodule<span class="operator">.</span>qmltypes</pre></div>
<p>to <code translate="no">/tmp/imports/My/Module/qmldir</code> to register it.</p>
<p>While the qmldump tool covers most cases, it does not work if:</p>
<ul>
<li>The plugin uses a <code translate="no">QQmlCustomParser</code>. The component that uses the custom parser will not get its members documented.</li>
<li>The plugin can not be loaded. In particular if you cross-compiled the plugin for a different architecture, qmldump will not be able to load it.</li>
</ul>
<p>In case you have to create a qmltypes file manually or need to adjust an existing one, this is the file format:</p>
<div class="pre"><pre class="qml prettyprint" translate="no">import QtQuick.tooling 1.1

<span class="comment">// There always is a single Module object that contains all</span>
<span class="comment">// Component objects.</span>
<span class="type">Module</span> {
    <span class="comment">// A Component object directly corresponds to a type exported</span>
    <span class="comment">// using the QML_ELEMENT or QML_NAMED_ELEMENT macros.</span>
    <span class="type"><a href="./qml-qtqml-component.htm" translate="no">Component</a></span> {

        <span class="comment">// The name is a unique identifier used to refer to this type.</span>
        <span class="comment">// It is recommended you simply use the C++ type name.</span>
        <span class="name">name</span>: <span class="string">"QQuickAbstractAnimation"</span>

        <span class="comment">// The name of the prototype Component.</span>
        <span class="name">prototype</span>: <span class="string">"QObject"</span>

        <span class="comment">// The name of the default property.</span>
        <span class="name">defaultProperty</span>: <span class="string">"animations"</span>

        <span class="comment">// The name of the type containing attached properties</span>
        <span class="comment">// and methods.</span>
        <span class="name">attachedType</span>: <span class="string">"QQuickAnimationAttached"</span>

        <span class="comment">// The list of exports determines how a type can be imported.</span>
        <span class="comment">// Each string has the format "URI/Name version". The URI is</span>
        <span class="comment">// the import name given via the build system, for example as</span>
        <span class="comment">// QML_IMPORT_NAME in qmake. The name is either the C++ class</span>
        <span class="comment">// name or, in case of QML_NAMED_ELEMENT(), an explicitly given</span>
        <span class="comment">// name. The version is constructed from the major version</span>
        <span class="comment">// given via the build system, as QML_IMPORT_MAJOR_VERSION in</span>
        <span class="comment">// qmake, and any revisions given in the class or its base</span>
        <span class="comment">// classes by Q_REVISION(), the REVISION argument to Q_PROPERTY,</span>
        <span class="comment">// or QML_ADDED_IN_MINOR_VERSION(). Usually types are only</span>
        <span class="comment">// exported once, if at all. The following tells us that there</span>
        <span class="comment">// are two variants of Animation, and that 'import QtQuick 2.0'</span>
        <span class="comment">// will expose a different revision than imports of later</span>
        <span class="comment">// versions.</span>
        <span class="name">exports</span>: [
            <span class="string">"QtQuick/Animation 2.0"</span>,
            <span class="string">"QtQuick/Animation 2.1"</span>
        ]

        <span class="comment">// The meta object revisions for the exports specified in 'exports'.</span>
        <span class="comment">// Each meta object revision may add additional properties or methods,</span>
        <span class="comment">// relative to the previous one. Those will only be visible when the</span>
        <span class="comment">// module is imported with at least the corresponding version as</span>
        <span class="comment">// specified in the 'exports' list.</span>
        <span class="comment">// The exportMetaObjectRevisions list must have exactly the same</span>
        <span class="comment">// length as the 'exports' list. For example, the 'animations' property</span>
        <span class="comment">// described below will only be available through the QtQuick/Animation</span>
        <span class="comment">// 2.1 export. Usually the revisions will match the versions in the</span>
        <span class="comment">// 'exports' list.</span>
        <span class="name">exportMetaObjectRevisions</span>: [<span class="number">0</span>, <span class="number">1</span>]

        <span class="type">Property</span> {
            <span class="name">name</span>: <span class="string">"animations"</span>;
            <span class="name">type</span>: <span class="string">"QQuickAbstractAnimation"</span>
            <span class="comment">// defaults to false, whether this property is read only</span>
            <span class="name">isReadonly</span>: <span class="number">true</span>
            <span class="comment">// defaults to false, whether the type of this property was a pointer in C++</span>
            <span class="name">isPointer</span>: <span class="number">true</span>
            <span class="comment">// defaults to false: whether the type actually is a QQmlListProperty&lt;type&gt;</span>
            <span class="name">isList</span>: <span class="number">true</span>
            <span class="comment">// defaults to 0: the meta object revision that introduced this property</span>
            <span class="name">revision</span>: <span class="number">1</span>
        }
        <span class="type">Property</span> { <span class="name">name</span>: <span class="string">"loops"</span>; <span class="name">type</span>: <span class="string">"int"</span> }
        <span class="type">Property</span> { <span class="name">name</span>: <span class="string">"name"</span>; <span class="name">type</span>: <span class="string">"string"</span> }
        <span class="type">Property</span> { <span class="name">name</span>: <span class="string">"loopsEnum"</span>; <span class="name">type</span>: <span class="string">"Loops"</span> }

        <span class="type">Enum</span> {
            <span class="name">name</span>: <span class="string">"Loops"</span>
            <span class="name">values</span>: [ <span class="string">"Infinite"</span>, <span class="string">"OnceOnly"</span> ]
        }

        <span class="comment">// Signal and Method work the same way. The inner Parameter</span>
        <span class="comment">// declarations also support the isReadonly, isPointer and isList</span>
        <span class="comment">// attributes which mean the same as for Property</span>
        <span class="type">Method</span> { <span class="name">name</span>: <span class="string">"restart"</span> }
        <span class="type">Signal</span> { <span class="name">name</span>: <span class="string">"started"</span>; <span class="name">revision</span>: <span class="number">1</span> }
        <span class="type">Signal</span> {
            <span class="name">name</span>: <span class="string">"runningChanged"</span>
            <span class="type">Parameter</span> { <span class="name">type</span>: <span class="string">"bool"</span> }
            <span class="type">Parameter</span> { <span class="name">name</span>: <span class="string">"foo"</span>; <span class="name">type</span>: <span class="string">"bool"</span> }
        }
    }
}</pre></div>
</div>
<!-- @@@qtqml-modules-qmldir.html -->
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>