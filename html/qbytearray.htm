<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QByteArray | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qbytearray.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QByteArray</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QByteArray Class</h1>
<!-- $$$QByteArray-brief -->
<p>The QByteArray class provides an array of bytes. <a href="#details">More...</a></p>
<!-- @@@QByteArray -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QByteArray&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr></tbody></table></div><ul>
<li><a href="./qbytearray-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qbytearray-obsolete.htm">Obsolete members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray-frombase64result.htm" translate="no">FromBase64Result</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#Base64Option-enum" translate="no">Base64Option</a></b> { Base64Encoding, Base64UrlEncoding, KeepTrailingEquals, OmitTrailingEquals, IgnoreBase64DecodingErrors, AbortOnBase64DecodingErrors }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#Base64Option-enum" translate="no">Base64Options</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#const_iterator-typedef" translate="no">const_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#const_reverse_iterator-typedef" translate="no">const_reverse_iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#iterator-typedef" translate="no">iterator</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> typedef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#reverse_iterator-typedef" translate="no">reverse_iterator</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#QByteArray-3" translate="no">QByteArray</a></b>(QByteArray &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#QByteArray-2" translate="no">QByteArray</a></b>(int <i>size</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#QByteArray-1" translate="no">QByteArray</a></b>(const char *<i>data</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-eq-2" translate="no">operator=</a></b>(QByteArray &amp;&amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-eq" translate="no">operator=</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#dtor.QByteArray" translate="no">~QByteArray</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#append" translate="no">append</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#append-1" translate="no">append</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#append-2" translate="no">append</a></b>(int <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#append-3" translate="no">append</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#append-4" translate="no">append</a></b>(const char *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#at" translate="no">at</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#back" translate="no">back</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#back-1" translate="no">back</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#begin" translate="no">begin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#begin-1" translate="no">begin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#capacity" translate="no">capacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#cbegin" translate="no">cbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#cend" translate="no">cend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#chop" translate="no">chop</a></b>(int <i>n</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#chopped" translate="no">chopped</a></b>(int <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#clear" translate="no">clear</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#compare" translate="no">compare</a></b>(const char *<i>c</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#compare-1" translate="no">compare</a></b>(const QByteArray &amp;<i>a</i>, Qt::CaseSensitivity <i>cs</i> = Qt::CaseSensitive) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#constBegin" translate="no">constBegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#constData" translate="no">constData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#constEnd" translate="no">constEnd</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#contains" translate="no">contains</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#contains-1" translate="no">contains</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#contains-2" translate="no">contains</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#count" translate="no">count</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#count-1" translate="no">count</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#count-2" translate="no">count</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#count-3" translate="no">count</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#crbegin" translate="no">crbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#crend" translate="no">crend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#data" translate="no">data</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#data-1" translate="no">data</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#end" translate="no">end</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#end-1" translate="no">end</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#endsWith" translate="no">endsWith</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#endsWith-1" translate="no">endsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#endsWith-2" translate="no">endsWith</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fill" translate="no">fill</a></b>(char <i>ch</i>, int <i>size</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#front" translate="no">front</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#front-1" translate="no">front</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#indexOf" translate="no">indexOf</a></b>(const QByteArray &amp;<i>ba</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#indexOf-1" translate="no">indexOf</a></b>(char <i>ch</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#indexOf-2" translate="no">indexOf</a></b>(const char *<i>str</i>, int <i>from</i> = 0) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#insert" translate="no">insert</a></b>(int <i>i</i>, const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#insert-1" translate="no">insert</a></b>(int <i>i</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#insert-2" translate="no">insert</a></b>(int <i>i</i>, int <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#insert-3" translate="no">insert</a></b>(int <i>i</i>, const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#insert-4" translate="no">insert</a></b>(int <i>i</i>, const char *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#isEmpty" translate="no">isEmpty</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#isLower" translate="no">isLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#isNull" translate="no">isNull</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#isUpper" translate="no">isUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#lastIndexOf" translate="no">lastIndexOf</a></b>(const QByteArray &amp;<i>ba</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#lastIndexOf-1" translate="no">lastIndexOf</a></b>(char <i>ch</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#lastIndexOf-2" translate="no">lastIndexOf</a></b>(const char *<i>str</i>, int <i>from</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#left" translate="no">left</a></b>(int <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#leftJustified" translate="no">leftJustified</a></b>(int <i>width</i>, char <i>fill</i> = ' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#length" translate="no">length</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#mid" translate="no">mid</a></b>(int <i>pos</i>, int <i>len</i> = -1) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#prepend" translate="no">prepend</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#prepend-1" translate="no">prepend</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#prepend-2" translate="no">prepend</a></b>(int <i>count</i>, char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#prepend-3" translate="no">prepend</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#prepend-4" translate="no">prepend</a></b>(const char *<i>str</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#push_back" translate="no">push_back</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#push_back-1" translate="no">push_back</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#push_back-2" translate="no">push_back</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#push_front" translate="no">push_front</a></b>(const QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#push_front-1" translate="no">push_front</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#push_front-2" translate="no">push_front</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#rbegin" translate="no">rbegin</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#rbegin-1" translate="no">rbegin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#remove" translate="no">remove</a></b>(int <i>pos</i>, int <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#rend" translate="no">rend</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::const_reverse_iterator </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#rend-1" translate="no">rend</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#repeated" translate="no">repeated</a></b>(int <i>times</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace" translate="no">replace</a></b>(int <i>pos</i>, int <i>len</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-1" translate="no">replace</a></b>(int <i>pos</i>, int <i>len</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-2" translate="no">replace</a></b>(int <i>pos</i>, int <i>len</i>, const char *<i>after</i>, int <i>alen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-3" translate="no">replace</a></b>(char <i>before</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-4" translate="no">replace</a></b>(char <i>before</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-5" translate="no">replace</a></b>(const char *<i>before</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-6" translate="no">replace</a></b>(const char *<i>before</i>, int <i>bsize</i>, const char *<i>after</i>, int <i>asize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-7" translate="no">replace</a></b>(const QByteArray &amp;<i>before</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-8" translate="no">replace</a></b>(const QByteArray &amp;<i>before</i>, const char *<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-9" translate="no">replace</a></b>(const char *<i>before</i>, const QByteArray &amp;<i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#replace-10" translate="no">replace</a></b>(char <i>before</i>, char <i>after</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#reserve" translate="no">reserve</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#resize" translate="no">resize</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#right" translate="no">right</a></b>(int <i>len</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#rightJustified" translate="no">rightJustified</a></b>(int <i>width</i>, char <i>fill</i> = ' ', bool <i>truncate</i> = false) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum" translate="no">setNum</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum-1" translate="no">setNum</a></b>(short <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum-2" translate="no">setNum</a></b>(ushort <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum-3" translate="no">setNum</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum-4" translate="no">setNum</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum-5" translate="no">setNum</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum-6" translate="no">setNum</a></b>(float <i>n</i>, char <i>f</i> = 'g', int <i>prec</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setNum-7" translate="no">setNum</a></b>(double <i>n</i>, char <i>f</i> = 'g', int <i>prec</i> = 6)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#setRawData" translate="no">setRawData</a></b>(const char *<i>data</i>, uint <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#shrink_to_fit" translate="no">shrink_to_fit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#simplified" translate="no">simplified</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#size" translate="no">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QByteArray&gt; </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#split" translate="no">split</a></b>(char <i>sep</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#squeeze" translate="no">squeeze</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#startsWith" translate="no">startsWith</a></b>(const QByteArray &amp;<i>ba</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#startsWith-1" translate="no">startsWith</a></b>(char <i>ch</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#startsWith-2" translate="no">startsWith</a></b>(const char *<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#swap" translate="no">swap</a></b>(QByteArray &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toBase64" translate="no">toBase64</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toBase64-1" translate="no">toBase64</a></b>(QByteArray::Base64Options <i>options</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFDataRef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toCFData" translate="no">toCFData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> double </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toDouble" translate="no">toDouble</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> float </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toFloat" translate="no">toFloat</a></b>(bool *<i>ok</i> = nullptr) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toHex" translate="no">toHex</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toHex-1" translate="no">toHex</a></b>(char <i>separator</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toInt" translate="no">toInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> long </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toLong" translate="no">toLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qlonglong </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toLongLong" translate="no">toLongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toLower" translate="no">toLower</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSData *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toNSData" translate="no">toNSData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toPercentEncoding" translate="no">toPercentEncoding</a></b>(const QByteArray &amp;<i>exclude</i> = QByteArray(), const QByteArray &amp;<i>include</i> = QByteArray(), char <i>percent</i> = '%') const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> CFDataRef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toRawCFData" translate="no">toRawCFData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> NSData *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toRawNSData" translate="no">toRawNSData</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> short </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toShort" translate="no">toShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toStdString" translate="no">toStdString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toUInt" translate="no">toUInt</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ulong </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toULong" translate="no">toULong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qulonglong </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toULongLong" translate="no">toULongLong</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> ushort </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toUShort" translate="no">toUShort</a></b>(bool *<i>ok</i> = nullptr, int <i>base</i> = 10) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#toUpper" translate="no">toUpper</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#trimmed" translate="no">trimmed</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#truncate" translate="no">truncate</a></b>(int <i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const char *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-const-char--2a" translate="no">operator const char *</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const void *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-const-void--2a" translate="no">operator const void *</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-not-eq" translate="no">operator!=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b-eq" translate="no">operator+=</a></b>(const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b-eq-1" translate="no">operator+=</a></b>(char <i>ch</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b-eq-2" translate="no">operator+=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt" translate="no">operator&lt;</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-eq" translate="no">operator&lt;=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-eq-1" translate="no">operator=</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-eq-eq" translate="no">operator==</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt" translate="no">operator&gt;</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-eq" translate="no">operator&gt;=</a></b>(const QString &amp;<i>str</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a></b>(int <i>i</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-5b-5d-1" translate="no">operator[]</a></b>(int <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-5b-5d-2" translate="no">operator[]</a></b>(uint <i>i</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteRef </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-5b-5d-3" translate="no">operator[]</a></b>(uint <i>i</i>)</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromBase64" translate="no">fromBase64</a></b>(const QByteArray &amp;<i>base64</i>, QByteArray::Base64Options <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromBase64-1" translate="no">fromBase64</a></b>(const QByteArray &amp;<i>base64</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::FromBase64Result </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromBase64Encoding" translate="no">fromBase64Encoding</a></b>(QByteArray &amp;&amp;<i>base64</i>, QByteArray::Base64Options <i>options</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray::FromBase64Result </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromBase64Encoding-1" translate="no">fromBase64Encoding</a></b>(const QByteArray &amp;<i>base64</i>, QByteArray::Base64Options <i>options</i> = Base64Encoding)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromCFData" translate="no">fromCFData</a></b>(CFDataRef <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromHex" translate="no">fromHex</a></b>(const QByteArray &amp;<i>hexEncoded</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromNSData" translate="no">fromNSData</a></b>(const NSData *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromPercentEncoding" translate="no">fromPercentEncoding</a></b>(const QByteArray &amp;<i>input</i>, char <i>percent</i> = '%')</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromRawCFData" translate="no">fromRawCFData</a></b>(CFDataRef <i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a></b>(const char *<i>data</i>, int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromRawNSData" translate="no">fromRawNSData</a></b>(const NSData *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#fromStdString" translate="no">fromStdString</a></b>(const int &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#number" translate="no">number</a></b>(int <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#number-1" translate="no">number</a></b>(uint <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#number-2" translate="no">number</a></b>(qlonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#number-3" translate="no">number</a></b>(qulonglong <i>n</i>, int <i>base</i> = 10)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#number-4" translate="no">number</a></b>(double <i>n</i>, char <i>f</i> = 'g', int <i>prec</i> = 6)</td></tr>
</tbody></table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members<a class="plink" href="#related-non-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qChecksum" translate="no">qChecksum</a></b>(const char *<i>data</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> quint16 </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qChecksum-1" translate="no">qChecksum</a></b>(const char *<i>data</i>, uint <i>len</i>, Qt::ChecksumType <i>standard</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qCompress" translate="no">qCompress</a></b>(const QByteArray &amp;<i>data</i>, int <i>compressionLevel</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qCompress-1" translate="no">qCompress</a></b>(const uchar *<i>data</i>, int <i>nbytes</i>, int <i>compressionLevel</i> = -1)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qUncompress" translate="no">qUncompress</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qUncompress-1" translate="no">qUncompress</a></b>(const uchar *<i>data</i>, int <i>nbytes</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrcmp" translate="no">qstrcmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrcpy" translate="no">qstrcpy</a></b>(char *<i>dst</i>, const char *<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrdup" translate="no">qstrdup</a></b>(const char *<i>src</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstricmp" translate="no">qstricmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrlen" translate="no">qstrlen</a></b>(const char *<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrncmp" translate="no">qstrncmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> char *</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrncpy" translate="no">qstrncpy</a></b>(char *<i>dst</i>, const char *<i>src</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrnicmp" translate="no">qstrnicmp</a></b>(const char *<i>str1</i>, const char *<i>str2</i>, uint <i>len</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#qstrnlen" translate="no">qstrnlen</a></b>(const char *<i>str</i>, uint <i>maxlen</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-not-eq-3" translate="no">operator!=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-not-eq-4" translate="no">operator!=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-not-eq-5" translate="no">operator!=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b" translate="no">operator+</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b-1" translate="no">operator+</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b-2" translate="no">operator+</a></b>(const QByteArray &amp;<i>a1</i>, char <i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b-3" translate="no">operator+</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QByteArray </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-2b-4" translate="no">operator+</a></b>(char <i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-3" translate="no">operator&lt;</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-4" translate="no">operator&lt;</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-5" translate="no">operator&lt;</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QByteArray &amp;<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-eq-3" translate="no">operator&lt;=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-eq-4" translate="no">operator&lt;=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-lt-eq-5" translate="no">operator&lt;=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-eq-eq-3" translate="no">operator==</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-eq-eq-4" translate="no">operator==</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-eq-eq-5" translate="no">operator==</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-3" translate="no">operator&gt;</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-4" translate="no">operator&gt;</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-5" translate="no">operator&gt;</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-eq-3" translate="no">operator&gt;=</a></b>(const QByteArray &amp;<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-eq-4" translate="no">operator&gt;=</a></b>(const QByteArray &amp;<i>a1</i>, const char *<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-eq-5" translate="no">operator&gt;=</a></b>(const char *<i>a1</i>, const QByteArray &amp;<i>a2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#operator-gt-gt" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QByteArray &amp;<i>ba</i>)</td></tr>
</tbody></table></div>
<a name="macros"></a>
<h2 id="macros">Macros<a class="plink" href="#macros" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#QByteArrayLiteral" translate="no">QByteArrayLiteral</a></b>(<i>ba</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qbytearray.htm#QT_NO_CAST_FROM_BYTEARRAY" translate="no">QT_NO_CAST_FROM_BYTEARRAY</a></b></td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QByteArray-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QByteArray can be used to store both raw bytes (including '\0's) and traditional 8-bit '\0'-terminated strings. Using QByteArray is much more convenient than using <code translate="no">const char *</code>. Behind the scenes, it always ensures that the data is followed by a '\0' terminator, and uses <a href="./implicit-sharing.htm" translate="no">implicit sharing</a> (copy-on-write) to reduce memory usage and avoid needless copying of data.</p>
<p>In addition to QByteArray, Qt also provides the <a href="./qstring.htm" translate="no">QString</a> class to store string data. For most purposes, <a href="./qstring.htm" translate="no">QString</a> is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, <a href="./qstring.htm" translate="no">QString</a> is used throughout in the Qt API. The two main cases where QByteArray is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</p>
<p>One way to initialize a QByteArray is simply to pass a <code translate="no">const char *</code> to its constructor. For example, the following code creates a byte array of size 5 containing the data "Hello":</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Hello"</span>);</pre></div>
<p>Although the <a href="./qbytearray.htm#size" translate="no">size</a>() is 5, the byte array also maintains an extra '\0' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to <a href="./qbytearray.htm#data" translate="no">data</a>()), the data pointed to is guaranteed to be '\0'-terminated.</p>
<p>QByteArray makes a deep copy of the <code translate="no">const char *</code> data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use <a href="./qbytearray.htm#fromRawData" translate="no">QByteArray::fromRawData</a>() instead.)</p>
<p>Another approach is to set the size of the array using <a href="./qbytearray.htm#resize" translate="no">resize</a>() and to initialize the data byte per byte. QByteArray uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba;
ba<span class="operator">.</span>resize(<span class="number">5</span>);
ba<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x3c</span>;
ba<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xb8</span>;
ba<span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x64</span>;
ba<span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0x18</span>;
ba<span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">0xca</span>;</pre></div>
<p>For read-only access, an alternative syntax is to use <a href="./qbytearray.htm#at" translate="no">at</a>():</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">for</span> (<span class="type">int</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> ba<span class="operator">.</span>size(); <span class="operator">+</span><span class="operator">+</span>i) {
    <span class="keyword">if</span> (ba<span class="operator">.</span>at(i) <span class="operator">&gt;</span><span class="operator">=</span> <span class="char">'a'</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> ba<span class="operator">.</span>at(i) <span class="operator">&lt;</span><span class="operator">=</span> <span class="char">'f'</span>)
        cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Found character in range [a-f]"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
}</pre></div>
<p><a href="./qbytearray.htm#at" translate="no">at</a>() can be faster than operator[](), because it never causes a <a href="./implicit-sharing.htm#deep-copy" translate="no">deep copy</a> to occur.</p>
<p>To extract many bytes at a time, use <a href="./qbytearray.htm#left" translate="no">left</a>(), <a href="./qbytearray.htm#right" translate="no">right</a>(), or <a href="./qbytearray.htm#mid" translate="no">mid</a>().</p>
<p>A QByteArray can embed '\0' bytes. The <a href="./qbytearray.htm#size" translate="no">size</a>() function always returns the size of the whole array, including embedded '\0' bytes, but excluding the terminating '\0' added by QByteArray. For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba1(<span class="string">"ca\0r\0t"</span>);
ba1<span class="operator">.</span>size();                     <span class="comment">// Returns 2.</span>
ba1<span class="operator">.</span>constData();                <span class="comment">// Returns "ca" with terminating \0.</span>

<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba2(<span class="string">"ca\0r\0t"</span><span class="operator">,</span> <span class="number">3</span>);
ba2<span class="operator">.</span>size();                     <span class="comment">// Returns 3.</span>
ba2<span class="operator">.</span>constData();                <span class="comment">// Returns "ca\0" with terminating \0.</span>

<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba3(<span class="string">"ca\0r\0t"</span><span class="operator">,</span> <span class="number">4</span>);
ba3<span class="operator">.</span>size();                     <span class="comment">// Returns 4.</span>
ba3<span class="operator">.</span>constData();                <span class="comment">// Returns "ca\0r" with terminating \0.</span>

<span class="keyword">const</span> <span class="type">char</span> cart<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {<span class="char">'c'</span><span class="operator">,</span> <span class="char">'a'</span><span class="operator">,</span> <span class="char">'\0'</span><span class="operator">,</span> <span class="char">'r'</span><span class="operator">,</span> <span class="char">'\0'</span><span class="operator">,</span> <span class="char">'t'</span>};
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba4(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromRawData(cart<span class="operator">,</span> <span class="number">6</span>));
ba4<span class="operator">.</span>size();                     <span class="comment">// Returns 6.</span>
ba4<span class="operator">.</span>constData();                <span class="comment">// Returns "ca\0r\0t" without terminating \0.</span></pre></div>
<p>If you want to obtain the length of the data up to and excluding the first '\0' character, call <a href="./qbytearray.htm#qstrlen" translate="no">qstrlen</a>() on the byte array.</p>
<p>After a call to <a href="./qbytearray.htm#resize" translate="no">resize</a>(), newly allocated bytes have undefined values. To set all the bytes to a particular value, call <a href="./qbytearray.htm#fill" translate="no">fill</a>().</p>
<p>To obtain a pointer to the actual character data, call <a href="./qbytearray.htm#data" translate="no">data</a>() or <a href="./qbytearray.htm#constData" translate="no">constData</a>(). These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the QByteArray. It is also guaranteed that the data ends with a '\0' byte unless the QByteArray was created from a <a href="./qbytearray.htm#fromRawData" translate="no">raw data</a>. This '\0' byte is automatically provided by QByteArray and is not counted in <a href="./qbytearray.htm#size" translate="no">size</a>().</p>
<p>QByteArray provides the following basic functions for modifying the byte data: <a href="./qbytearray.htm#append" translate="no">append</a>(), <a href="./qbytearray.htm#prepend" translate="no">prepend</a>(), <a href="./qbytearray.htm#insert" translate="no">insert</a>(), <a href="./qbytearray.htm#replace" translate="no">replace</a>(), and <a href="./qbytearray.htm#remove" translate="no">remove</a>(). For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"and"</span>);
x<span class="operator">.</span>prepend(<span class="string">"rock "</span>);         <span class="comment">// x == "rock and"</span>
x<span class="operator">.</span>append(<span class="string">" roll"</span>);          <span class="comment">// x == "rock and roll"</span>
x<span class="operator">.</span>replace(<span class="number">5</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="string">"&amp;"</span>);       <span class="comment">// x == "rock &amp; roll"</span></pre></div>
<p>The <a href="./qbytearray.htm#replace" translate="no">replace</a>() and <a href="./qbytearray.htm#remove" translate="no">remove</a>() functions' first two arguments are the position from which to start erasing and the number of bytes that should be erased.</p>
<p>When you <a href="./qbytearray.htm#append" translate="no">append</a>() data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling <a href="./qbytearray.htm#reserve" translate="no">reserve</a>(), which preallocates a certain amount of memory. You can also call <a href="./qbytearray.htm#capacity" translate="no">capacity</a>() to find out how much memory QByteArray actually allocated. Data appended to an empty array is not copied.</p>
<p>A frequent requirement is to remove whitespace characters from a byte array ('\n', '\t', ' ', etc.). If you want to remove whitespace from both ends of a QByteArray, use <a href="./qbytearray.htm#trimmed" translate="no">trimmed</a>(). If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the byte array, use <a href="./qbytearray.htm#simplified" translate="no">simplified</a>().</p>
<p>If you want to find all occurrences of a particular character or substring in a QByteArray, use <a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>() or <a href="./qbytearray.htm#lastIndexOf" translate="no">lastIndexOf</a>(). The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;"</span>);
<span class="type">int</span> j <span class="operator">=</span> <span class="number">0</span>;
<span class="keyword">while</span> ((j <span class="operator">=</span> ba<span class="operator">.</span>indexOf(<span class="string">"&lt;b&gt;"</span><span class="operator">,</span> j)) <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"Found &lt;b&gt; tag at index position "</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> j <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
    <span class="operator">+</span><span class="operator">+</span>j;
}</pre></div>
<p>If you simply want to check whether a QByteArray contains a particular character or substring, use <a href="./qbytearray.htm#contains" translate="no">contains</a>(). If you want to find out how many times a particular character or substring occurs in the byte array, use <a href="./qbytearray.htm#count-3" translate="no">count</a>(). If you want to replace all occurrences of a particular value with another, use one of the two-parameter <a href="./qbytearray.htm#replace" translate="no">replace</a>() overloads.</p>
<p><a href="./qbytearray.htm" translate="no">QByteArray</a>s can be compared using overloaded operators such as operator&lt;(), operator&lt;=(), operator==(), operator&gt;=(), and so on. The comparison is based exclusively on the numeric values of the characters and is very fast, but is not what a human would expect. <a href="./qstring.htm#localeAwareCompare" translate="no">QString::localeAwareCompare</a>() is a better choice for sorting user-interface strings.</p>
<p>For historical reasons, QByteArray distinguishes between a null byte array and an empty byte array. A <i>null</i> byte array is a byte array that is initialized using QByteArray's default constructor or by passing (const char *)0 to the constructor. An <i>empty</i> byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn't necessarily null:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>

<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">""</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">""</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>

<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">"abc"</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">"abc"</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span></pre></div>
<p>All functions except <a href="./qbytearray.htm#isNull" translate="no">isNull</a>() treat null byte arrays the same as empty byte arrays. For example, <a href="./qbytearray.htm#data" translate="no">data</a>() returns a valid pointer (<i>not</i> nullptr) to a '\0' character for a byte array and QByteArray() compares equal to QByteArray(""). We recommend that you always use <a href="./qbytearray.htm#isEmpty" translate="no">isEmpty</a>() and avoid <a href="./qbytearray.htm#isNull" translate="no">isNull</a>().</p>
<a name="maximum-size-and-out-of-memory-conditions"></a>
<h3 id="maximum-size-and-out-of-memory-conditions">Maximum size and out-of-memory conditions<a class="plink" href="#maximum-size-and-out-of-memory-conditions" title="Direct link to this headline"></a></h3>
<p>The current version of QByteArray is limited to just under 2 GB (2^31 bytes) in size. The exact value is architecture-dependent, since it depends on the overhead required for managing the data block, but is no more than 32 bytes. Raw data blocks are also limited by the use of <code translate="no">int</code> type in the current version to 2 GB minus 1 byte.</p>
<p>In case memory allocation fails, QByteArray will throw a <code translate="no">std::bad_alloc</code> exception. Out of memory conditions in the Qt containers are the only case where Qt will throw exceptions.</p>
<p>Note that the operating system may impose further limits on applications holding a lot of allocated memory, especially large, contiguous blocks. Such considerations, the configuration of such behavior or any mitigation are outside the scope of the QByteArray API.</p>
<a name="notes-on-locale"></a>
<h3 id="notes-on-locale">Notes on Locale<a class="plink" href="#notes-on-locale" title="Direct link to this headline"></a></h3>
<a name="number-string-conversions"></a>
<h4 id="number-string-conversions">Number-String Conversions<a class="plink" href="#number-string-conversions" title="Direct link to this headline"></a></h4>
<p>Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user's locale settings. Use <a href="./qstring.htm" translate="no">QString</a> to perform locale-aware conversions between numbers and strings.</p>
<a name="8-bit-character-comparisons"></a>
<h4 id="8-bit-character-comparisons">8-bit Character Comparisons<a class="plink" href="#8-bit-character-comparisons" title="Direct link to this headline"></a></h4>
<p>In QByteArray, the notion of uppercase and lowercase and of which character is greater than or less than another character is done in the Latin-1 locale. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only Latin-1 characters. Functions that this affects include <a href="./qbytearray.htm#contains" translate="no">contains</a>(), <a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>(), <a href="./qbytearray.htm#lastIndexOf" translate="no">lastIndexOf</a>(), operator&lt;(), operator&lt;=(), operator&gt;(), operator&gt;=(), <a href="./qbytearray.htm#isLower" translate="no">isLower</a>(), <a href="./qbytearray.htm#isUpper" translate="no">isUpper</a>(), <a href="./qbytearray.htm#toLower" translate="no">toLower</a>() and <a href="./qbytearray.htm#toUpper" translate="no">toUpper</a>().</p>
<p>This issue does not apply to <a href="./qstring.htm" translate="no">QString</a>s since they represent characters using Unicode.</p>
</div>
<p><b>See also </b><a href="./qstring.htm" translate="no">QString</a> and <a href="./qbitarray.htm" translate="no">QBitArray</a>.</p>
<!-- @@@QByteArray -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Base64Option$$$Base64Encoding$$$Base64UrlEncoding$$$KeepTrailingEquals$$$OmitTrailingEquals$$$IgnoreBase64DecodingErrors$$$AbortOnBase64DecodingErrors -->
<h3 class="flags" id="Base64Option-enum"><a name="Base64Option-enum"></a>enum QByteArray::<span class="name">Base64Option</span><br>flags QByteArray::<span class="name">Base64Options</span><a class="plink" href="#Base64Option-enum" title="Direct link to this headline"></a></h3>
<p>This enum contains the options available for encoding and decoding Base64. Base64 is defined by <a href="http://www.ietf.org/rfc/rfc4648.txt" translate="no">RFC 4648</a>, with the following options:</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QByteArray::Base64Encoding</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">(default) The regular Base64 alphabet, called simply "base64"</td></tr>
<tr><td class="topAlign"><code translate="no">QByteArray::Base64UrlEncoding</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">An alternate alphabet, called "base64url", which replaces two characters in the alphabet to be more friendly to URLs.</td></tr>
<tr><td class="topAlign"><code translate="no">QByteArray::KeepTrailingEquals</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">(default) Keeps the trailing padding equal signs at the end of the encoded data, so the data is always a size multiple of four.</td></tr>
<tr><td class="topAlign"><code translate="no">QByteArray::OmitTrailingEquals</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">Omits adding the padding equal signs at the end of the encoded data.</td></tr>
<tr><td class="topAlign"><code translate="no">QByteArray::IgnoreBase64DecodingErrors</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">When decoding Base64-encoded data, ignores errors in the input; invalid characters are simply skipped. This enum value has been added in Qt 5.15.</td></tr>
<tr><td class="topAlign"><code translate="no">QByteArray::AbortOnBase64DecodingErrors</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">When decoding Base64-encoded data, stops at the first decoding error. This enum value has been added in Qt 5.15.</td></tr>
</tbody></table></div>
<p><a href="./qbytearray.htm#fromBase64Encoding" translate="no">QByteArray::fromBase64Encoding</a>() and <a href="./qbytearray.htm#fromBase64" translate="no">QByteArray::fromBase64</a>() ignore the KeepTrailingEquals and OmitTrailingEquals options. If the IgnoreBase64DecodingErrors option is specified, they will not flag errors in case trailing equal signs are missing or if there are too many of them. If instead the AbortOnBase64DecodingErrors is specified, then the input must either have no padding or have the correct amount of equal signs.</p>
<p>This enum was introduced or modified in Qt 5.2.</p>
<p>The Base64Options type is a typedef for <a href="./qflags.htm">QFlags</a>&lt;Base64Option&gt;. It stores an OR combination of Base64Option values.</p>
<!-- @@@Base64Option -->
<!-- $$$const_iterator -->
<h3 class="fn" id="const_iterator-typedef" translate="no"><a name="const_iterator-typedef"></a>typedef QByteArray::<span class="name">const_iterator</span><a class="plink" href="#const_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>This typedef provides an STL-style const iterator for <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p><b>See also </b><a href="./qbytearray.htm#const_reverse_iterator-typedef" translate="no">QByteArray::const_reverse_iterator</a> and <a href="./qbytearray.htm#iterator-typedef" translate="no">QByteArray::iterator</a>.</p>
<!-- @@@const_iterator -->
<!-- $$$const_reverse_iterator -->
<h3 class="fn" id="const_reverse_iterator-typedef" translate="no"><a name="const_reverse_iterator-typedef"></a>typedef QByteArray::<span class="name">const_reverse_iterator</span><a class="plink" href="#const_reverse_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>This typedef provides an STL-style const reverse iterator for <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qbytearray.htm#reverse_iterator-typedef" translate="no">QByteArray::reverse_iterator</a> and <a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a>.</p>
<!-- @@@const_reverse_iterator -->
<!-- $$$iterator -->
<h3 class="fn" id="iterator-typedef" translate="no"><a name="iterator-typedef"></a>typedef QByteArray::<span class="name">iterator</span><a class="plink" href="#iterator-typedef" title="Direct link to this headline"></a></h3>
<p>This typedef provides an STL-style non-const iterator for <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p><b>See also </b><a href="./qbytearray.htm#reverse_iterator-typedef" translate="no">QByteArray::reverse_iterator</a> and <a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a>.</p>
<!-- @@@iterator -->
<!-- $$$reverse_iterator -->
<h3 class="fn" id="reverse_iterator-typedef" translate="no"><a name="reverse_iterator-typedef"></a>typedef QByteArray::<span class="name">reverse_iterator</span><a class="plink" href="#reverse_iterator-typedef" title="Direct link to this headline"></a></h3>
<p>This typedef provides an STL-style non-const reverse iterator for <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p>This typedef was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qbytearray.htm#const_reverse_iterator-typedef" translate="no">QByteArray::const_reverse_iterator</a> and <a href="./qbytearray.htm#iterator-typedef" translate="no">QByteArray::iterator</a>.</p>
<!-- @@@reverse_iterator -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$ -->
<div class="fngroup">
<h3 class="fn fngroupitem" id="fromBase64Encoding" translate="no"><a name="fromBase64Encoding"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray-frombase64result.htm" translate="no">QByteArray::FromBase64Result</a></span> QByteArray::<span class="name">fromBase64Encoding</span>(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;&amp;<i>base64</i>, <span class="type"><a href="./qbytearray.htm#Base64Option-enum" translate="no">QByteArray::Base64Options</a></span> <i>options</i> = ...)<a class="plink" href="#fromBase64Encoding" title="Direct link to this headline"></a></h3><h3 class="fn fngroupitem" id="fromBase64Encoding-1" translate="no"><a name="fromBase64Encoding-1"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray-frombase64result.htm" translate="no">QByteArray::FromBase64Result</a></span> QByteArray::<span class="name">fromBase64Encoding</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>base64</i>, <span class="type"><a href="./qbytearray.htm#Base64Option-enum" translate="no">QByteArray::Base64Options</a></span> <i>options</i> = Base64Encoding)<a class="plink" href="#fromBase64Encoding-1" title="Direct link to this headline"></a></h3></div>
<p>This is an overloaded function.</p>
<p>Decodes the Base64 array <i translate="no">base64</i>, using the options defined by <i translate="no">options</i>. If <i translate="no">options</i> contains <code translate="no">IgnoreBase64DecodingErrors</code> (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If <i translate="no">options</i> contains <code translate="no">AbortOnBase64DecodingErrors</code>, then decoding will stop at the first invalid character.</p>
<p>For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">void</span> process(<span class="keyword">const</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="operator">&amp;</span>);

<span class="keyword">if</span> (<span class="keyword">auto</span> result <span class="operator">=</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromBase64Encoding(encodedData))
    process(<span class="operator">*</span>result);</pre></div>
<p>The algorithm used to decode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt" translate="no">RFC 4648</a>.</p>
<p>Returns a QByteArrayFromBase64Result object, containing the decoded data and a flag telling whether decoding was successful. If the <code translate="no">AbortOnBase64DecodingErrors</code> option was passed and the input data was invalid, it is unspecified what the decoded data contains.</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qbytearray.htm#toBase64" translate="no">toBase64</a>().</p>
<!-- @@@ -->
<!-- $$$QByteArray$$$QByteArrayQByteArray&& -->
<h3 class="fn" id="QByteArray-3" translate="no"><a name="QByteArray-3"></a>QByteArray::<span class="name">QByteArray</span>(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;&amp;<i>other</i>)<a class="plink" href="#QByteArray-3" title="Direct link to this headline"></a></h3>
<p>Move-constructs a QByteArray instance, making it point at the same object that <i translate="no">other</i> was pointing to.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray[overload1]$$$QByteArrayconstQByteArray& -->
<h3 class="fn" id="QByteArray" translate="no"><a name="QByteArray"></a>QByteArray::<span class="name">QByteArray</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>other</i>)<a class="plink" href="#QByteArray" title="Direct link to this headline"></a></h3>
<p>Constructs a copy of <i translate="no">other</i>.</p>
<p>This operation takes <a href="./containers.htm#constant-time" translate="no">constant time</a>, because QByteArray is <a href="./implicit-sharing.htm" translate="no">implicitly shared</a>. This makes returning a QByteArray from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="./qbytearray.htm#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayintchar -->
<h3 class="fn" id="QByteArray-2" translate="no"><a name="QByteArray-2"></a>QByteArray::<span class="name">QByteArray</span>(<span class="type">int</span> <i>size</i>, <span class="type">char</span> <i>ch</i>)<a class="plink" href="#QByteArray-2" title="Direct link to this headline"></a></h3>
<p>Constructs a byte array of size <i translate="no">size</i> with every byte set to character <i translate="no">ch</i>.</p>
<p><b>See also </b><a href="./qbytearray.htm#fill" translate="no">fill</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray$$$QByteArrayconstchar*int -->
<h3 class="fn" id="QByteArray-1" translate="no"><a name="QByteArray-1"></a>QByteArray::<span class="name">QByteArray</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">int</span> <i>size</i> = -1)<a class="plink" href="#QByteArray-1" title="Direct link to this headline"></a></h3>
<p>Constructs a byte array containing the first <i translate="no">size</i> bytes of array <i translate="no">data</i>.</p>
<p>If <i translate="no">data</i> is 0, a null byte array is constructed.</p>
<p>If <i translate="no">size</i> is negative, <i translate="no">data</i> is assumed to point to a '\0'-terminated string and its length is determined dynamically. The terminating \0 character is not considered part of the byte array.</p>
<p>QByteArray makes a deep copy of the string data.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$QByteArray[overload1]$$$QByteArray -->
<h3 class="fn" id="QByteArray" translate="no"><a name="QByteArray"></a>QByteArray::<span class="name">QByteArray</span>()<a class="plink" href="#QByteArray" title="Direct link to this headline"></a></h3>
<p>Constructs an empty byte array.</p>
<p><b>See also </b><a href="./qbytearray.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@QByteArray -->
<!-- $$$operator=$$$operator=QByteArray&& -->
<h3 class="fn" id="operator-eq-2" translate="no"><a name="operator-eq-2"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;&amp;<i>other</i>)<a class="plink" href="#operator-eq-2" title="Direct link to this headline"></a></h3>
<p>Move-assigns <i translate="no">other</i> to this <a href="./qbytearray.htm" translate="no">QByteArray</a> instance.</p>
<p>This function was introduced in Qt 5.2.</p>
<!-- @@@operator= -->
<!-- $$$operator=[overload1]$$$operator=constQByteArray& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>other</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns <i translate="no">other</i> to this byte array and returns a reference to this byte array.</p>
<!-- @@@operator= -->
<!-- $$$~QByteArray[overload1]$$$~QByteArray -->
<h3 class="fn" id="dtor.QByteArray" translate="no"><a name="dtor.QByteArray"></a>QByteArray::<span class="name">~QByteArray</span>()<a class="plink" href="#dtor.QByteArray" title="Direct link to this headline"></a></h3>
<p>Destroys the byte array.</p>
<!-- @@@~QByteArray -->
<!-- $$$append[overload1]$$$appendconstQByteArray& -->
<h3 class="fn" id="append" translate="no"><a name="append"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>)<a class="plink" href="#append" title="Direct link to this headline"></a></h3>
<p>Appends the byte array <i translate="no">ba</i> onto the end of this byte array.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"free"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y(<span class="string">"dom"</span>);
x<span class="operator">.</span>append(y);
<span class="comment">// x == "freedom"</span></pre></div>
<p>This is the same as insert(<a href="./qbytearray.htm#size" translate="no">size</a>(), <i translate="no">ba</i>).</p>
<p>Note: <a href="./qbytearray.htm" translate="no">QByteArray</a> is an <a href="./implicit-sharing.htm" translate="no">implicitly shared</a> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <i translate="no">ba</i>. In this case, no copying of data is done, taking <a href="./containers.htm#constant-time" translate="no">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p>This operation typically does not suffer from allocation overhead, because <a href="./qbytearray.htm" translate="no">QByteArray</a> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</p>
<p><b>See also </b><a href="./qbytearray.htm#operator-2b-eq" translate="no">operator+=</a>(), <a href="./qbytearray.htm#prepend" translate="no">prepend</a>(), and <a href="./qbytearray.htm#insert" translate="no">insert</a>().</p>
<!-- @@@append -->
<!-- $$$append$$$appendchar -->
<h3 class="fn" id="append-1" translate="no"><a name="append-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(<span class="type">char</span> <i>ch</i>)<a class="plink" href="#append-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends the character <i translate="no">ch</i> to this byte array.</p>
<!-- @@@append -->
<!-- $$$append$$$appendintchar -->
<h3 class="fn" id="append-2" translate="no"><a name="append-2"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(<span class="type">int</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)<a class="plink" href="#append-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends <i translate="no">count</i> copies of character <i translate="no">ch</i> to this byte array and returns a reference to this byte array.</p>
<p>If <i translate="no">count</i> is negative or zero nothing is appended to the byte array.</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar* -->
<h3 class="fn" id="append-3" translate="no"><a name="append-3"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#append-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends the string <i translate="no">str</i> to this byte array.</p>
<!-- @@@append -->
<!-- $$$append$$$appendconstchar*int -->
<h3 class="fn" id="append-4" translate="no"><a name="append-4"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">append</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>len</i>)<a class="plink" href="#append-4" title="Direct link to this headline"></a></h3>
<p>This function overloads append().</p>
<p>Appends the first <i translate="no">len</i> characters of the string <i translate="no">str</i> to this byte array and returns a reference to this byte array.</p>
<p>If <i translate="no">len</i> is negative, the length of the string will be determined automatically using <a href="./qbytearray.htm#qstrlen" translate="no">qstrlen</a>(). If <i translate="no">len</i> is zero or <i translate="no">str</i> is null, nothing is appended to the byte array. Ensure that <i translate="no">len</i> is <i>not</i> longer than <i translate="no">str</i>.</p>
<!-- @@@append -->
<!-- $$$at[overload1]$$$atint -->
<h3 class="fn" id="at" translate="no"><a name="at"></a><span class="type">char</span> QByteArray::<span class="name">at</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#at" title="Direct link to this headline"></a></h3>
<p>Returns the character at index position <i translate="no">i</i> in the byte array.</p>
<p><i translate="no">i</i> must be a valid index position in the byte array (i.e., 0 &lt;= <i translate="no">i</i> &lt; <a href="./qbytearray.htm#size" translate="no">size</a>()).</p>
<p><b>See also </b><a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@at -->
<!-- $$$back[overload1]$$$back -->
<h3 class="fn" id="back" translate="no"><a name="back"></a><span class="type">char</span> QByteArray::<span class="name">back</span>() const<a class="plink" href="#back" title="Direct link to this headline"></a></h3>
<p>Returns the last character in the byte array. Same as <code translate="no">at(size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qbytearray.htm#front" translate="no">front</a>(), <a href="./qbytearray.htm#at" translate="no">at</a>(), and <a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$back$$$back -->
<h3 class="fn" id="back-1" translate="no"><a name="back-1"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a></span> QByteArray::<span class="name">back</span>()<a class="plink" href="#back-1" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the last character in the byte array. Same as <code translate="no">operator[](size() - 1)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qbytearray.htm#front" translate="no">front</a>(), <a href="./qbytearray.htm#at" translate="no">at</a>(), and <a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@back -->
<!-- $$$begin[overload1]$$$begin -->
<h3 class="fn" id="begin" translate="no"><a name="begin"></a><span class="type"><a href="./qbytearray.htm#iterator-typedef" translate="no">QByteArray::iterator</a></span> QByteArray::<span class="name">begin</span>()<a class="plink" href="#begin" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first character in the byte-array.</p>
<p><b>See also </b><a href="./qbytearray.htm#constBegin" translate="no">constBegin</a>() and <a href="./qbytearray.htm#end" translate="no">end</a>().</p>
<!-- @@@begin -->
<!-- $$$begin$$$begin -->
<h3 class="fn" id="begin-1" translate="no"><a name="begin-1"></a><span class="type"><a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a></span> QByteArray::<span class="name">begin</span>() const<a class="plink" href="#begin-1" title="Direct link to this headline"></a></h3>
<p>This function overloads begin().</p>
<!-- @@@begin -->
<!-- $$$capacity[overload1]$$$capacity -->
<h3 class="fn" id="capacity" translate="no"><a name="capacity"></a><span class="type">int</span> QByteArray::<span class="name">capacity</span>() const<a class="plink" href="#capacity" title="Direct link to this headline"></a></h3>
<p>Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="./qbytearray.htm" translate="no">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call <a href="./qbytearray.htm#size" translate="no">size</a>().</p>
<p><b>See also </b><a href="./qbytearray.htm#reserve" translate="no">reserve</a>() and <a href="./qbytearray.htm#squeeze" translate="no">squeeze</a>().</p>
<!-- @@@capacity -->
<!-- $$$cbegin[overload1]$$$cbegin -->
<h3 class="fn" id="cbegin" translate="no"><a name="cbegin"></a><span class="type"><a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a></span> QByteArray::<span class="name">cbegin</span>() const<a class="plink" href="#cbegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first character in the byte-array.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qbytearray.htm#begin" translate="no">begin</a>() and <a href="./qbytearray.htm#cend" translate="no">cend</a>().</p>
<!-- @@@cbegin -->
<!-- $$$cend[overload1]$$$cend -->
<h3 class="fn" id="cend" translate="no"><a name="cend"></a><span class="type"><a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a></span> QByteArray::<span class="name">cend</span>() const<a class="plink" href="#cend" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary character after the last character in the list.</p>
<p>This function was introduced in Qt 5.0.</p>
<p><b>See also </b><a href="./qbytearray.htm#cbegin" translate="no">cbegin</a>() and <a href="./qbytearray.htm#end" translate="no">end</a>().</p>
<!-- @@@cend -->
<!-- $$$chop[overload1]$$$chopint -->
<h3 class="fn" id="chop" translate="no"><a name="chop"></a><span class="type">void</span> QByteArray::<span class="name">chop</span>(<span class="type">int</span> <i>n</i>)<a class="plink" href="#chop" title="Direct link to this headline"></a></h3>
<p>Removes <i translate="no">n</i> bytes from the end of the byte array.</p>
<p>If <i translate="no">n</i> is greater than <a href="./qbytearray.htm#size" translate="no">size</a>(), the result is an empty byte array.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"STARTTLS\r\n"</span>);
ba<span class="operator">.</span>chop(<span class="number">2</span>);                 <span class="comment">// ba == "STARTTLS"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#truncate" translate="no">truncate</a>(), <a href="./qbytearray.htm#resize" translate="no">resize</a>(), and <a href="./qbytearray.htm#left" translate="no">left</a>().</p>
<!-- @@@chop -->
<!-- $$$chopped[overload1]$$$choppedint -->
<h3 class="fn" id="chopped" translate="no"><a name="chopped"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">chopped</span>(<span class="type">int</span> <i>len</i>) const<a class="plink" href="#chopped" title="Direct link to this headline"></a></h3>
<p>Returns a byte array that contains the leftmost <a href="./qbytearray.htm#size" translate="no">size</a>() - <i translate="no">len</i> bytes of this byte array.</p>
<div class="admonition note">
<p><b>Note: </b>The behavior is undefined if <i translate="no">len</i> is negative or greater than <a href="./qbytearray.htm#size" translate="no">size</a>().</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qbytearray.htm#endsWith" translate="no">endsWith</a>(), <a href="./qbytearray.htm#left" translate="no">left</a>(), <a href="./qbytearray.htm#right" translate="no">right</a>(), <a href="./qbytearray.htm#mid" translate="no">mid</a>(), <a href="./qbytearray.htm#chop" translate="no">chop</a>(), and <a href="./qbytearray.htm#truncate" translate="no">truncate</a>().</p>
<!-- @@@chopped -->
<!-- $$$clear[overload1]$$$clear -->
<h3 class="fn" id="clear" translate="no"><a name="clear"></a><span class="type">void</span> QByteArray::<span class="name">clear</span>()<a class="plink" href="#clear" title="Direct link to this headline"></a></h3>
<p>Clears the contents of the byte array and makes it null.</p>
<p><b>See also </b><a href="./qbytearray.htm#resize" translate="no">resize</a>() and <a href="./qbytearray.htm#isNull" translate="no">isNull</a>().</p>
<!-- @@@clear -->
<!-- $$$compare[overload1]$$$compareconstchar*Qt::CaseSensitivity -->
<h3 class="fn" id="compare" translate="no"><a name="compare"></a><span class="type">int</span> QByteArray::<span class="name">compare</span>(const <span class="type">char</span> *<i>c</i>, <span class="type"><a href="./qt.htm#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const<a class="plink" href="#compare" title="Direct link to this headline"></a></h3>
<p>Returns an integer less than, equal to, or greater than zero depending on whether this <a href="./qbytearray.htm" translate="no">QByteArray</a> sorts before, at the same position, or after the string pointed to by <i translate="no">c</i>. The comparison is performed according to case sensitivity <i translate="no">cs</i>.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="./qbytearray.htm#operator-eq-eq" translate="no">operator==</a>.</p>
<!-- @@@compare -->
<!-- $$$compare$$$compareconstQByteArray&Qt::CaseSensitivity -->
<h3 class="fn" id="compare-1" translate="no"><a name="compare-1"></a><span class="type">int</span> QByteArray::<span class="name">compare</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a</i>, <span class="type"><a href="./qt.htm#CaseSensitivity-enum" translate="no">Qt::CaseSensitivity</a></span> <i>cs</i> = Qt::CaseSensitive) const<a class="plink" href="#compare-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns an integer less than, equal to, or greater than zero depending on whether this <a href="./qbytearray.htm" translate="no">QByteArray</a> sorts before, at the same position, or after the <a href="./qbytearray.htm" translate="no">QByteArray</a> <i translate="no">a</i>. The comparison is performed according to case sensitivity <i translate="no">cs</i>.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="./qbytearray.htm#operator-eq-eq" translate="no">operator==</a>.</p>
<!-- @@@compare -->
<!-- $$$constBegin[overload1]$$$constBegin -->
<h3 class="fn" id="constBegin" translate="no"><a name="constBegin"></a><span class="type"><a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a></span> QByteArray::<span class="name">constBegin</span>() const<a class="plink" href="#constBegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the first character in the byte-array.</p>
<p><b>See also </b><a href="./qbytearray.htm#begin" translate="no">begin</a>() and <a href="./qbytearray.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@constBegin -->
<!-- $$$constData[overload1]$$$constData -->
<h3 class="fn" id="constData" translate="no"><a name="constData"></a>const <span class="type">char</span> *QByteArray::<span class="name">constData</span>() const<a class="plink" href="#constData" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated unless the <a href="./qbytearray.htm" translate="no">QByteArray</a> object was created from raw data. The pointer remains valid as long as the byte array isn't reallocated or destroyed.</p>
<p>This function is mostly useful to pass a byte array to a function that accepts a <code translate="no">const char *</code>.</p>
<p>Note: A <a href="./qbytearray.htm" translate="no">QByteArray</a> can store any byte values including '\0's, but most functions that take <code translate="no">char *</code> arguments assume that the data ends at the first '\0' they encounter.</p>
<p><b>See also </b><a href="./qbytearray.htm#data" translate="no">data</a>(), <a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a>(), and <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@constData -->
<!-- $$$constEnd[overload1]$$$constEnd -->
<h3 class="fn" id="constEnd" translate="no"><a name="constEnd"></a><span class="type"><a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a></span> QByteArray::<span class="name">constEnd</span>() const<a class="plink" href="#constEnd" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary character after the last character in the list.</p>
<p><b>See also </b><a href="./qbytearray.htm#constBegin" translate="no">constBegin</a>() and <a href="./qbytearray.htm#end" translate="no">end</a>().</p>
<!-- @@@constEnd -->
<!-- $$$contains[overload1]$$$containsconstQByteArray& -->
<h3 class="fn" id="contains" translate="no"><a name="contains"></a><span class="type">bool</span> QByteArray::<span class="name">contains</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>) const<a class="plink" href="#contains" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the byte array contains an occurrence of the byte array <i translate="no">ba</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>() and <a href="./qbytearray.htm#count-3" translate="no">count</a>().</p>
<!-- @@@contains -->
<!-- $$$contains$$$containschar -->
<h3 class="fn" id="contains-1" translate="no"><a name="contains-1"></a><span class="type">bool</span> QByteArray::<span class="name">contains</span>(<span class="type">char</span> <i>ch</i>) const<a class="plink" href="#contains-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if the byte array contains the character <i translate="no">ch</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@contains -->
<!-- $$$contains$$$containsconstchar* -->
<h3 class="fn" id="contains-2" translate="no"><a name="contains-2"></a><span class="type">bool</span> QByteArray::<span class="name">contains</span>(const <span class="type">char</span> *<i>str</i>) const<a class="plink" href="#contains-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if the byte array contains the string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@contains -->
<!-- $$$count[overload1]$$$countconstQByteArray& -->
<h3 class="fn" id="count" translate="no"><a name="count"></a><span class="type">int</span> QByteArray::<span class="name">count</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>) const<a class="plink" href="#count" title="Direct link to this headline"></a></h3>
<p>Returns the number of (potentially overlapping) occurrences of byte array <i translate="no">ba</i> in this byte array.</p>
<p><b>See also </b><a href="./qbytearray.htm#contains" translate="no">contains</a>() and <a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countchar -->
<h3 class="fn" id="count-1" translate="no"><a name="count-1"></a><span class="type">int</span> QByteArray::<span class="name">count</span>(<span class="type">char</span> <i>ch</i>) const<a class="plink" href="#count-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the number of occurrences of character <i translate="no">ch</i> in the byte array.</p>
<p><b>See also </b><a href="./qbytearray.htm#contains" translate="no">contains</a>() and <a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>().</p>
<!-- @@@count -->
<!-- $$$count$$$countconstchar* -->
<h3 class="fn" id="count-2" translate="no"><a name="count-2"></a><span class="type">int</span> QByteArray::<span class="name">count</span>(const <span class="type">char</span> *<i>str</i>) const<a class="plink" href="#count-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the number of (potentially overlapping) occurrences of string <i translate="no">str</i> in the byte array.</p>
<!-- @@@count -->
<!-- $$$count$$$count -->
<h3 class="fn" id="count-3" translate="no"><a name="count-3"></a><span class="type">int</span> QByteArray::<span class="name">count</span>() const<a class="plink" href="#count-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as <a href="./qbytearray.htm#size" translate="no">size</a>().</p>
<!-- @@@count -->
<!-- $$$crbegin[overload1]$$$crbegin -->
<h3 class="fn" id="crbegin" translate="no"><a name="crbegin"></a><span class="type"><a href="./qbytearray.htm#const_reverse_iterator-typedef" translate="no">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">crbegin</span>() const<a class="plink" href="#crbegin" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first character in the byte-array, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qbytearray.htm#begin" translate="no">begin</a>(), <a href="./qbytearray.htm#rbegin" translate="no">rbegin</a>(), and <a href="./qbytearray.htm#rend" translate="no">rend</a>().</p>
<!-- @@@crbegin -->
<!-- $$$crend[overload1]$$$crend -->
<h3 class="fn" id="crend" translate="no"><a name="crend"></a><span class="type"><a href="./qbytearray.htm#const_reverse_iterator-typedef" translate="no">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">crend</span>() const<a class="plink" href="#crend" title="Direct link to this headline"></a></h3>
<p>Returns a const <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qbytearray.htm#end" translate="no">end</a>(), <a href="./qbytearray.htm#rend" translate="no">rend</a>(), and <a href="./qbytearray.htm#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@crend -->
<!-- $$$data[overload1]$$$data -->
<h3 class="fn" id="data" translate="no"><a name="data"></a><span class="type">char</span> *QByteArray::<span class="name">data</span>()<a class="plink" href="#data" title="Direct link to this headline"></a></h3>
<p>Returns a pointer to the data stored in the byte array. The pointer can be used to access and modify the bytes that compose the array. The data is '\0'-terminated, i.e. the number of bytes in the returned character string is <a href="./qbytearray.htm#size" translate="no">size</a>() + 1 for the '\0' terminator.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Hello world"</span>);
<span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> ba<span class="operator">.</span>data();
<span class="keyword">while</span> (<span class="operator">*</span>data) {
    cout <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"["</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="operator">*</span>data <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"]"</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="type">Qt</span><span class="operator">::</span>endl;
    <span class="operator">+</span><span class="operator">+</span>data;
}</pre></div>
<p>The pointer remains valid as long as the byte array isn't reallocated or destroyed. For read-only access, <a href="./qbytearray.htm#constData" translate="no">constData</a>() is faster because it never causes a <a href="./implicit-sharing.htm#deep-copy" translate="no">deep copy</a> to occur.</p>
<p>This function is mostly useful to pass a byte array to a function that accepts a <code translate="no">const char *</code>.</p>
<p>The following example makes a copy of the char* returned by data(), but it will corrupt the heap and cause a crash because it does not allocate a byte for the '\0' at the end:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> tmp <span class="operator">=</span> <span class="string">"test"</span>;
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
<span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size()<span class="operator">]</span>;
strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
<span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;</pre></div>
<p>This one allocates the correct amount of space:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> tmp <span class="operator">=</span> <span class="string">"test"</span>;
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text <span class="operator">=</span> tmp<span class="operator">.</span>toLocal8Bit();
<span class="type">char</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="keyword">new</span> <span class="type">char</span><span class="operator">[</span>text<span class="operator">.</span>size() <span class="operator">+</span> <span class="number">1</span><span class="operator">]</span>;
strcpy(data<span class="operator">,</span> text<span class="operator">.</span>data());
<span class="keyword">delete</span> <span class="operator">[</span><span class="operator">]</span> data;</pre></div>
<p>Note: A <a href="./qbytearray.htm" translate="no">QByteArray</a> can store any byte values including '\0's, but most functions that take <code translate="no">char *</code> arguments assume that the data ends at the first '\0' they encounter.</p>
<p><b>See also </b><a href="./qbytearray.htm#constData" translate="no">constData</a>() and <a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@data -->
<!-- $$$data$$$data -->
<h3 class="fn" id="data-1" translate="no"><a name="data-1"></a>const <span class="type">char</span> *QByteArray::<span class="name">data</span>() const<a class="plink" href="#data-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@data -->
<!-- $$$end[overload1]$$$end -->
<h3 class="fn" id="end" translate="no"><a name="end"></a><span class="type"><a href="./qbytearray.htm#iterator-typedef" translate="no">QByteArray::iterator</a></span> QByteArray::<span class="name">end</span>()<a class="plink" href="#end" title="Direct link to this headline"></a></h3>
<p>Returns an <a href="./containers.htm#stl-style-iterators" translate="no">STL-style iterator</a> pointing to the imaginary character after the last character in the byte-array.</p>
<p><b>See also </b><a href="./qbytearray.htm#begin" translate="no">begin</a>() and <a href="./qbytearray.htm#constEnd" translate="no">constEnd</a>().</p>
<!-- @@@end -->
<!-- $$$end$$$end -->
<h3 class="fn" id="end-1" translate="no"><a name="end-1"></a><span class="type"><a href="./qbytearray.htm#const_iterator-typedef" translate="no">QByteArray::const_iterator</a></span> QByteArray::<span class="name">end</span>() const<a class="plink" href="#end-1" title="Direct link to this headline"></a></h3>
<p>This function overloads end().</p>
<!-- @@@end -->
<!-- $$$endsWith[overload1]$$$endsWithconstQByteArray& -->
<h3 class="fn" id="endsWith" translate="no"><a name="endsWith"></a><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>) const<a class="plink" href="#endsWith" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array ends with byte array <i translate="no">ba</i>; otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> url(<span class="string">"http://qt-project.org/doc/qt-5.0/qtdoc/index.html"</span>);
<span class="keyword">if</span> (url<span class="operator">.</span>endsWith(<span class="string">".html"</span>))
    <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#startsWith" translate="no">startsWith</a>() and <a href="./qbytearray.htm#right" translate="no">right</a>().</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithchar -->
<h3 class="fn" id="endsWith-1" translate="no"><a name="endsWith-1"></a><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(<span class="type">char</span> <i>ch</i>) const<a class="plink" href="#endsWith-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if this byte array ends with character <i translate="no">ch</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@endsWith -->
<!-- $$$endsWith$$$endsWithconstchar* -->
<h3 class="fn" id="endsWith-2" translate="no"><a name="endsWith-2"></a><span class="type">bool</span> QByteArray::<span class="name">endsWith</span>(const <span class="type">char</span> *<i>str</i>) const<a class="plink" href="#endsWith-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if this byte array ends with string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@endsWith -->
<!-- $$$fill[overload1]$$$fillcharint -->
<h3 class="fn" id="fill" translate="no"><a name="fill"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">fill</span>(<span class="type">char</span> <i>ch</i>, <span class="type">int</span> <i>size</i> = -1)<a class="plink" href="#fill" title="Direct link to this headline"></a></h3>
<p>Sets every byte in the byte array to character <i translate="no">ch</i>. If <i translate="no">size</i> is different from -1 (the default), the byte array is resized to size <i translate="no">size</i> beforehand.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Istambul"</span>);
ba<span class="operator">.</span>fill(<span class="char">'o'</span>);
<span class="comment">// ba == "oooooooo"</span>

ba<span class="operator">.</span>fill(<span class="char">'X'</span><span class="operator">,</span> <span class="number">2</span>);
<span class="comment">// ba == "XX"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#resize" translate="no">resize</a>().</p>
<!-- @@@fill -->
<!-- $$$fromBase64[overload1]$$$fromBase64constQByteArray&QByteArray::Base64Options -->
<h3 class="fn" id="fromBase64" translate="no"><a name="fromBase64"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromBase64</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>base64</i>, <span class="type"><a href="./qbytearray.htm#Base64Option-enum" translate="no">QByteArray::Base64Options</a></span> <i>options</i>)<a class="plink" href="#fromBase64" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a decoded copy of the Base64 array <i translate="no">base64</i>, using the options defined by <i translate="no">options</i>. If <i translate="no">options</i> contains <code translate="no">IgnoreBase64DecodingErrors</code> (the default), the input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters. If <i translate="no">options</i> contains <code translate="no">AbortOnBase64DecodingErrors</code>, then decoding will stop at the first invalid character.</p>
<p>For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">"PHA+SGVsbG8/PC9wPg=="</span><span class="operator">,</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>Base64Encoding); <span class="comment">// returns "&lt;p&gt;Hello?&lt;/p&gt;"</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">"PHA-SGVsbG8_PC9wPg=="</span><span class="operator">,</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding); <span class="comment">// returns "&lt;p&gt;Hello?&lt;/p&gt;"</span></pre></div>
<p>The algorithm used to decode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt" translate="no">RFC 4648</a>.</p>
<p>Returns the decoded data, or, if the <code translate="no">AbortOnBase64DecodingErrors</code> option was passed and the input data was invalid, an empty byte array.</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="./qbytearray.htm#fromBase64Encoding" translate="no">fromBase64Encoding</a>() function is recommended in new code.</p>
</div>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qbytearray.htm#toBase64" translate="no">toBase64</a>() and <a href="./qbytearray.htm#fromBase64Encoding" translate="no">fromBase64Encoding</a>().</p>
<!-- @@@fromBase64 -->
<!-- $$$fromBase64$$$fromBase64constQByteArray& -->
<h3 class="fn" id="fromBase64-1" translate="no"><a name="fromBase64-1"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromBase64</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>base64</i>)<a class="plink" href="#fromBase64-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a decoded copy of the Base64 array <i translate="no">base64</i>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</p>
<p>For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromBase64(<span class="string">"UXQgaXMgZ3JlYXQh"</span>);
text<span class="operator">.</span>data();            <span class="comment">// returns "Qt is great!"</span></pre></div>
<p>The algorithm used to decode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt" translate="no">RFC 4648</a>.</p>
<div class="admonition note">
<p><b>Note: </b>The <a href="./qbytearray.htm#fromBase64Encoding" translate="no">fromBase64Encoding</a>() function is recommended in new code.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#toBase64" translate="no">toBase64</a>() and <a href="./qbytearray.htm#fromBase64Encoding" translate="no">fromBase64Encoding</a>().</p>
<!-- @@@fromBase64 -->
<!-- $$$fromCFData[overload1]$$$fromCFDataCFDataRef -->
<h3 class="fn" id="fromCFData" translate="no"><a name="fromCFData"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromCFData</span>(<span class="type">CFDataRef</span> <i>data</i>)<a class="plink" href="#fromCFData" title="Direct link to this headline"></a></h3>
<p>Constructs a new <a href="./qbytearray.htm" translate="no">QByteArray</a> containing a copy of the CFData <i translate="no">data</i>.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromRawCFData" translate="no">fromRawCFData</a>(), <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>(), <a href="./qbytearray.htm#toRawCFData" translate="no">toRawCFData</a>(), and <a href="./qbytearray.htm#toCFData" translate="no">toCFData</a>().</p>
<!-- @@@fromCFData -->
<!-- $$$fromHex[overload1]$$$fromHexconstQByteArray& -->
<h3 class="fn" id="fromHex" translate="no"><a name="fromHex"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromHex</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>hexEncoded</i>)<a class="plink" href="#fromHex" title="Direct link to this headline"></a></h3>
<p>Returns a decoded copy of the hex encoded array <i translate="no">hexEncoded</i>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</p>
<p>For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromHex(<span class="string">"517420697320677265617421"</span>);
text<span class="operator">.</span>data();            <span class="comment">// returns "Qt is great!"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#toHex" translate="no">toHex</a>().</p>
<!-- @@@fromHex -->
<!-- $$$fromNSData[overload1]$$$fromNSDataconstNSData* -->
<h3 class="fn" id="fromNSData" translate="no"><a name="fromNSData"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromNSData</span>(const <span class="type">NSData</span> *<i>data</i>)<a class="plink" href="#fromNSData" title="Direct link to this headline"></a></h3>
<p>Constructs a new <a href="./qbytearray.htm" translate="no">QByteArray</a> containing a copy of the NSData <i translate="no">data</i>.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromRawNSData" translate="no">fromRawNSData</a>(), <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>(), <a href="./qbytearray.htm#toNSData" translate="no">toNSData</a>(), and <a href="./qbytearray.htm#toRawNSData" translate="no">toRawNSData</a>().</p>
<!-- @@@fromNSData -->
<!-- $$$fromPercentEncoding[overload1]$$$fromPercentEncodingconstQByteArray&char -->
<h3 class="fn" id="fromPercentEncoding" translate="no"><a name="fromPercentEncoding"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromPercentEncoding</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>input</i>, <span class="type">char</span> <i>percent</i> = '%')<a class="plink" href="#fromPercentEncoding" title="Direct link to this headline"></a></h3>
<p>Returns a decoded copy of the URI/URL-style percent-encoded <i translate="no">input</i>. The <i translate="no">percent</i> parameter allows you to replace the '%' character for another (for instance, '_' or '=').</p>
<p>For example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text <span class="operator">=</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromPercentEncoding(<span class="string">"Qt%20is%20great%33"</span>);
text<span class="operator">.</span>data();            <span class="comment">// returns "Qt is great!"</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>Given invalid input (such as a string containing the sequence "%G5", which is not a valid hexadecimal number) the output will be invalid as well. As an example: the sequence "%G5" could be decoded to 'W'.</p>
</div>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qbytearray.htm#toPercentEncoding" translate="no">toPercentEncoding</a>() and <a href="./qurl.htm#fromPercentEncoding" translate="no">QUrl::fromPercentEncoding</a>().</p>
<!-- @@@fromPercentEncoding -->
<!-- $$$fromRawCFData[overload1]$$$fromRawCFDataCFDataRef -->
<h3 class="fn" id="fromRawCFData" translate="no"><a name="fromRawCFData"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromRawCFData</span>(<span class="type">CFDataRef</span> <i>data</i>)<a class="plink" href="#fromRawCFData" title="Direct link to this headline"></a></h3>
<p>Constructs a <a href="./qbytearray.htm" translate="no">QByteArray</a> that uses the bytes of the CFData <i translate="no">data</i>.</p>
<p>The <i translate="no">data</i>'s bytes are not copied.</p>
<p>The caller guarantees that the CFData will not be deleted or modified as long as this <a href="./qbytearray.htm" translate="no">QByteArray</a> object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromCFData" translate="no">fromCFData</a>(), <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>(), <a href="./qbytearray.htm#toRawCFData" translate="no">toRawCFData</a>(), and <a href="./qbytearray.htm#toCFData" translate="no">toCFData</a>().</p>
<!-- @@@fromRawCFData -->
<!-- $$$fromRawData[overload1]$$$fromRawDataconstchar*int -->
<h3 class="fn" id="fromRawData" translate="no"><a name="fromRawData"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromRawData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type">int</span> <i>size</i>)<a class="plink" href="#fromRawData" title="Direct link to this headline"></a></h3>
<p>Constructs a <a href="./qbytearray.htm" translate="no">QByteArray</a> that uses the first <i translate="no">size</i> bytes of the <i translate="no">data</i> array. The bytes are <i>not</i> copied. The <a href="./qbytearray.htm" translate="no">QByteArray</a> will contain the <i translate="no">data</i> pointer. The caller guarantees that <i translate="no">data</i> will not be deleted or modified as long as this <a href="./qbytearray.htm" translate="no">QByteArray</a> and any copies of it exist that have not been modified. In other words, because <a href="./qbytearray.htm" translate="no">QByteArray</a> is an <a href="./implicit-sharing.htm" translate="no">implicitly shared</a> class and the instance returned by this function contains the <i translate="no">data</i> pointer, the caller must not delete <i translate="no">data</i> or modify it directly as long as the returned <a href="./qbytearray.htm" translate="no">QByteArray</a> and any copies exist. However, <a href="./qbytearray.htm" translate="no">QByteArray</a> does not take ownership of <i translate="no">data</i>, so the <a href="./qbytearray.htm" translate="no">QByteArray</a> destructor will never delete the raw <i translate="no">data</i>, even when the last <a href="./qbytearray.htm" translate="no">QByteArray</a> referring to <i translate="no">data</i> is destroyed.</p>
<p>A subsequent attempt to modify the contents of the returned <a href="./qbytearray.htm" translate="no">QByteArray</a> or any copy made from it will cause it to create a deep copy of the <i translate="no">data</i> array before doing the modification. This ensures that the raw <i translate="no">data</i> array itself will never be modified by <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p>Here is an example of how to read data using a <a href="./qdatastream.htm" translate="no">QDataStream</a> on raw data in memory without copying the raw data into a <a href="./qbytearray.htm" translate="no">QByteArray</a>:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">char</span> mydata<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> {
    <span class="char">'\x00'</span><span class="operator">,</span> <span class="char">'\x00'</span><span class="operator">,</span> <span class="char">'\x03'</span><span class="operator">,</span> <span class="char">'\x84'</span><span class="operator">,</span> <span class="char">'\x78'</span><span class="operator">,</span> <span class="char">'\x9c'</span><span class="operator">,</span> <span class="char">'\x3b'</span><span class="operator">,</span> <span class="char">'\x76'</span><span class="operator">,</span>
    <span class="char">'\xec'</span><span class="operator">,</span> <span class="char">'\x18'</span><span class="operator">,</span> <span class="char">'\xc3'</span><span class="operator">,</span> <span class="char">'\x31'</span><span class="operator">,</span> <span class="char">'\x0a'</span><span class="operator">,</span> <span class="char">'\xf1'</span><span class="operator">,</span> <span class="char">'\xcc'</span><span class="operator">,</span> <span class="char">'\x99'</span><span class="operator">,</span>
    <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
    <span class="char">'\x6d'</span><span class="operator">,</span> <span class="char">'\x5b'</span>
};

<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> data <span class="operator">=</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromRawData(mydata<span class="operator">,</span> <span class="keyword">sizeof</span>(mydata));
<span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> in(<span class="operator">&amp;</span>data<span class="operator">,</span> <span class="type"><a href="./qiodevice.htm" translate="no">QIODevice</a></span><span class="operator">::</span>ReadOnly);
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span></pre></div>
<div class="admonition warning">
<p><b>Warning: </b>A byte array created with fromRawData() is <i>not</i> '\0'-terminated, unless the raw data contains a 0 character at position <i translate="no">size</i>. While that does not matter for <a href="./qdatastream.htm" translate="no">QDataStream</a> or functions like <a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>(), passing the byte array to a function accepting a <code translate="no">const char *</code> expected to be '\0'-terminated will fail.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#setRawData" translate="no">setRawData</a>(), <a href="./qbytearray.htm#data" translate="no">data</a>(), and <a href="./qbytearray.htm#constData" translate="no">constData</a>().</p>
<!-- @@@fromRawData -->
<!-- $$$fromRawNSData[overload1]$$$fromRawNSDataconstNSData* -->
<h3 class="fn" id="fromRawNSData" translate="no"><a name="fromRawNSData"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromRawNSData</span>(const <span class="type">NSData</span> *<i>data</i>)<a class="plink" href="#fromRawNSData" title="Direct link to this headline"></a></h3>
<p>Constructs a <a href="./qbytearray.htm" translate="no">QByteArray</a> that uses the bytes of the NSData <i translate="no">data</i>.</p>
<p>The <i translate="no">data</i>'s bytes are not copied.</p>
<p>The caller guarantees that the NSData will not be deleted or modified as long as this <a href="./qbytearray.htm" translate="no">QByteArray</a> object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromNSData" translate="no">fromNSData</a>(), <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>(), <a href="./qbytearray.htm#toRawNSData" translate="no">toRawNSData</a>(), and <a href="./qbytearray.htm#toNSData" translate="no">toNSData</a>().</p>
<!-- @@@fromRawNSData -->
<!-- $$$fromStdString[overload1]$$$fromStdStringconstint& -->
<h3 class="fn" id="fromStdString" translate="no"><a name="fromStdString"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">fromStdString</span>(const <span class="type">int</span> &amp;<i>str</i>)<a class="plink" href="#fromStdString" title="Direct link to this headline"></a></h3>
<p>Returns a copy of the <i translate="no">str</i> string as a <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qbytearray.htm#toStdString" translate="no">toStdString</a>() and <a href="./qstring.htm#fromStdString" translate="no">QString::fromStdString</a>().</p>
<!-- @@@fromStdString -->
<!-- $$$front[overload1]$$$front -->
<h3 class="fn" id="front" translate="no"><a name="front"></a><span class="type">char</span> QByteArray::<span class="name">front</span>() const<a class="plink" href="#front" title="Direct link to this headline"></a></h3>
<p>Returns the first character in the byte array. Same as <code translate="no">at(0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qbytearray.htm#back" translate="no">back</a>(), <a href="./qbytearray.htm#at" translate="no">at</a>(), and <a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$front$$$front -->
<h3 class="fn" id="front-1" translate="no"><a name="front-1"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a></span> QByteArray::<span class="name">front</span>()<a class="plink" href="#front-1" title="Direct link to this headline"></a></h3>
<p>Returns a reference to the first character in the byte array. Same as <code translate="no">operator[](0)</code>.</p>
<p>This function is provided for STL compatibility.</p>
<div class="admonition warning">
<p><b>Warning: </b>Calling this function on an empty byte array constitutes undefined behavior.</p>
</div>
<p>This function was introduced in Qt 5.10.</p>
<p><b>See also </b><a href="./qbytearray.htm#back" translate="no">back</a>(), <a href="./qbytearray.htm#at" translate="no">at</a>(), and <a href="./qbytearray.htm#operator-5b-5d" translate="no">operator[]</a>().</p>
<!-- @@@front -->
<!-- $$$indexOf[overload1]$$$indexOfconstQByteArray&int -->
<h3 class="fn" id="indexOf" translate="no"><a name="indexOf"></a><span class="type">int</span> QByteArray::<span class="name">indexOf</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>, <span class="type">int</span> <i>from</i> = 0) const<a class="plink" href="#indexOf" title="Direct link to this headline"></a></h3>
<p>Returns the index position of the first occurrence of the byte array <i translate="no">ba</i> in this byte array, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">ba</i> could not be found.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"sticky question"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y(<span class="string">"sti"</span>);
x<span class="operator">.</span>indexOf(y);               <span class="comment">// returns 0</span>
x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">1</span>);            <span class="comment">// returns 10</span>
x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">10</span>);           <span class="comment">// returns 10</span>
x<span class="operator">.</span>indexOf(y<span class="operator">,</span> <span class="number">11</span>);           <span class="comment">// returns -1</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#lastIndexOf" translate="no">lastIndexOf</a>(), <a href="./qbytearray.htm#contains" translate="no">contains</a>(), and <a href="./qbytearray.htm#count-3" translate="no">count</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfcharint -->
<h3 class="fn" id="indexOf-1" translate="no"><a name="indexOf-1"></a><span class="type">int</span> QByteArray::<span class="name">indexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">int</span> <i>from</i> = 0) const<a class="plink" href="#indexOf-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the first occurrence of the character <i translate="no">ch</i> in the byte array, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">ch</i> could not be found.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"ABCBA"</span>);
ba<span class="operator">.</span>indexOf(<span class="string">"B"</span>);            <span class="comment">// returns 1</span>
ba<span class="operator">.</span>indexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">1</span>);         <span class="comment">// returns 1</span>
ba<span class="operator">.</span>indexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">2</span>);         <span class="comment">// returns 3</span>
ba<span class="operator">.</span>indexOf(<span class="string">"X"</span>);            <span class="comment">// returns -1</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#lastIndexOf" translate="no">lastIndexOf</a>() and <a href="./qbytearray.htm#contains" translate="no">contains</a>().</p>
<!-- @@@indexOf -->
<!-- $$$indexOf$$$indexOfconstchar*int -->
<h3 class="fn" id="indexOf-2" translate="no"><a name="indexOf-2"></a><span class="type">int</span> QByteArray::<span class="name">indexOf</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>from</i> = 0) const<a class="plink" href="#indexOf-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the first occurrence of the string <i translate="no">str</i> in the byte array, searching forward from index position <i translate="no">from</i>. Returns -1 if <i translate="no">str</i> could not be found.</p>
<!-- @@@indexOf -->
<!-- $$$insert[overload1]$$$insertintconstQByteArray& -->
<h3 class="fn" id="insert" translate="no"><a name="insert"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>)<a class="plink" href="#insert" title="Direct link to this headline"></a></h3>
<p>Inserts the byte array <i translate="no">ba</i> at index position <i translate="no">i</i> and returns a reference to this byte array.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Meal"</span>);
ba<span class="operator">.</span>insert(<span class="number">1</span><span class="operator">,</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">"ontr"</span>));
<span class="comment">// ba == "Montreal"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#append" translate="no">append</a>(), <a href="./qbytearray.htm#prepend" translate="no">prepend</a>(), <a href="./qbytearray.htm#replace" translate="no">replace</a>(), and <a href="./qbytearray.htm#remove" translate="no">remove</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintchar -->
<h3 class="fn" id="insert-1" translate="no"><a name="insert-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">char</span> <i>ch</i>)<a class="plink" href="#insert-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts character <i translate="no">ch</i> at index position <i translate="no">i</i> in the byte array. If <i translate="no">i</i> is greater than <a href="./qbytearray.htm#size" translate="no">size</a>(), the array is first extended using <a href="./qbytearray.htm#resize" translate="no">resize</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintintchar -->
<h3 class="fn" id="insert-2" translate="no"><a name="insert-2"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, <span class="type">int</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)<a class="plink" href="#insert-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts <i translate="no">count</i> copies of character <i translate="no">ch</i> at index position <i translate="no">i</i> in the byte array.</p>
<p>If <i translate="no">i</i> is greater than <a href="./qbytearray.htm#size" translate="no">size</a>(), the array is first extended using <a href="./qbytearray.htm#resize" translate="no">resize</a>().</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstchar* -->
<h3 class="fn" id="insert-3" translate="no"><a name="insert-3"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#insert-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts the string <i translate="no">str</i> at position <i translate="no">i</i> in the byte array.</p>
<p>If <i translate="no">i</i> is greater than <a href="./qbytearray.htm#size" translate="no">size</a>(), the array is first extended using <a href="./qbytearray.htm#resize" translate="no">resize</a>().</p>
<!-- @@@insert -->
<!-- $$$insert$$$insertintconstchar*int -->
<h3 class="fn" id="insert-4" translate="no"><a name="insert-4"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">insert</span>(<span class="type">int</span> <i>i</i>, const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>len</i>)<a class="plink" href="#insert-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Inserts <i translate="no">len</i> bytes of the string <i translate="no">str</i> at position <i translate="no">i</i> in the byte array.</p>
<p>If <i translate="no">i</i> is greater than <a href="./qbytearray.htm#size" translate="no">size</a>(), the array is first extended using <a href="./qbytearray.htm#resize" translate="no">resize</a>().</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@insert -->
<!-- $$$isEmpty[overload1]$$$isEmpty -->
<h3 class="fn" id="isEmpty" translate="no"><a name="isEmpty"></a><span class="type">bool</span> QByteArray::<span class="name">isEmpty</span>() const<a class="plink" href="#isEmpty" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the byte array has size 0; otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>()<span class="operator">.</span>isEmpty();         <span class="comment">// returns true</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">""</span>)<span class="operator">.</span>isEmpty();       <span class="comment">// returns true</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">"abc"</span>)<span class="operator">.</span>isEmpty();    <span class="comment">// returns false</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#size" translate="no">size</a>().</p>
<!-- @@@isEmpty -->
<!-- $$$isLower[overload1]$$$isLower -->
<h3 class="fn" id="isLower" translate="no"><a name="isLower"></a><span class="type">bool</span> QByteArray::<span class="name">isLower</span>() const<a class="plink" href="#isLower" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array contains only lowercase letters, otherwise returns <code translate="no">false</code>. The byte array is interpreted as a Latin-1 encoded string.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="./qbytearray.htm#isUpper" translate="no">isUpper</a>() and <a href="./qbytearray.htm#toLower" translate="no">toLower</a>().</p>
<!-- @@@isLower -->
<!-- $$$isNull[overload1]$$$isNull -->
<h3 class="fn" id="isNull" translate="no"><a name="isNull"></a><span class="type">bool</span> QByteArray::<span class="name">isNull</span>() const<a class="plink" href="#isNull" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array is null; otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>()<span class="operator">.</span>isNull();          <span class="comment">// returns true</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">""</span>)<span class="operator">.</span>isNull();        <span class="comment">// returns false</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">"abc"</span>)<span class="operator">.</span>isNull();     <span class="comment">// returns false</span></pre></div>
<p>Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using <a href="./qbytearray.htm#isEmpty" translate="no">isEmpty</a>().</p>
<p><b>See also </b><a href="./qbytearray.htm#isEmpty" translate="no">isEmpty</a>().</p>
<!-- @@@isNull -->
<!-- $$$isUpper[overload1]$$$isUpper -->
<h3 class="fn" id="isUpper" translate="no"><a name="isUpper"></a><span class="type">bool</span> QByteArray::<span class="name">isUpper</span>() const<a class="plink" href="#isUpper" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array contains only uppercase letters, otherwise returns <code translate="no">false</code>. The byte array is interpreted as a Latin-1 encoded string.</p>
<p>This function was introduced in Qt 5.12.</p>
<p><b>See also </b><a href="./qbytearray.htm#isLower" translate="no">isLower</a>() and <a href="./qbytearray.htm#toUpper" translate="no">toUpper</a>().</p>
<!-- @@@isUpper -->
<!-- $$$lastIndexOf[overload1]$$$lastIndexOfconstQByteArray&int -->
<h3 class="fn" id="lastIndexOf" translate="no"><a name="lastIndexOf"></a><span class="type">int</span> QByteArray::<span class="name">lastIndexOf</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>, <span class="type">int</span> <i>from</i> = -1) const<a class="plink" href="#lastIndexOf" title="Direct link to this headline"></a></h3>
<p>Returns the index position of the last occurrence of the byte array <i translate="no">ba</i> in this byte array, searching backward from index position <i translate="no">from</i>. If <i translate="no">from</i> is -1 (the default), the search starts at the last byte. Returns -1 if <i translate="no">ba</i> could not be found.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"crazy azimuths"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y(<span class="string">"az"</span>);
x<span class="operator">.</span>lastIndexOf(y);           <span class="comment">// returns 6</span>
x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">6</span>);        <span class="comment">// returns 6</span>
x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">5</span>);        <span class="comment">// returns 2</span>
x<span class="operator">.</span>lastIndexOf(y<span class="operator">,</span> <span class="number">1</span>);        <span class="comment">// returns -1</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>(), <a href="./qbytearray.htm#contains" translate="no">contains</a>(), and <a href="./qbytearray.htm#count-3" translate="no">count</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfcharint -->
<h3 class="fn" id="lastIndexOf-1" translate="no"><a name="lastIndexOf-1"></a><span class="type">int</span> QByteArray::<span class="name">lastIndexOf</span>(<span class="type">char</span> <i>ch</i>, <span class="type">int</span> <i>from</i> = -1) const<a class="plink" href="#lastIndexOf-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the last occurrence of character <i translate="no">ch</i> in the byte array, searching backward from index position <i translate="no">from</i>. If <i translate="no">from</i> is -1 (the default), the search starts at the last (<a href="./qbytearray.htm#size" translate="no">size</a>() - 1) byte. Returns -1 if <i translate="no">ch</i> could not be found.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"ABCBA"</span>);
ba<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span>);        <span class="comment">// returns 3</span>
ba<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">3</span>);     <span class="comment">// returns 3</span>
ba<span class="operator">.</span>lastIndexOf(<span class="string">"B"</span><span class="operator">,</span> <span class="number">2</span>);     <span class="comment">// returns 1</span>
ba<span class="operator">.</span>lastIndexOf(<span class="string">"X"</span>);        <span class="comment">// returns -1</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#indexOf" translate="no">indexOf</a>() and <a href="./qbytearray.htm#contains" translate="no">contains</a>().</p>
<!-- @@@lastIndexOf -->
<!-- $$$lastIndexOf$$$lastIndexOfconstchar*int -->
<h3 class="fn" id="lastIndexOf-2" translate="no"><a name="lastIndexOf-2"></a><span class="type">int</span> QByteArray::<span class="name">lastIndexOf</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>from</i> = -1) const<a class="plink" href="#lastIndexOf-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns the index position of the last occurrence of the string <i translate="no">str</i> in the byte array, searching backward from index position <i translate="no">from</i>. If <i translate="no">from</i> is -1 (the default), the search starts at the last (<a href="./qbytearray.htm#size" translate="no">size</a>() - 1) byte. Returns -1 if <i translate="no">str</i> could not be found.</p>
<!-- @@@lastIndexOf -->
<!-- $$$left[overload1]$$$leftint -->
<h3 class="fn" id="left" translate="no"><a name="left"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">left</span>(<span class="type">int</span> <i>len</i>) const<a class="plink" href="#left" title="Direct link to this headline"></a></h3>
<p>Returns a byte array that contains the leftmost <i translate="no">len</i> bytes of this byte array.</p>
<p>The entire byte array is returned if <i translate="no">len</i> is greater than <a href="./qbytearray.htm#size" translate="no">size</a>().</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"Pineapple"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>left(<span class="number">4</span>);
<span class="comment">// y == "Pine"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#startsWith" translate="no">startsWith</a>(), <a href="./qbytearray.htm#right" translate="no">right</a>(), <a href="./qbytearray.htm#mid" translate="no">mid</a>(), <a href="./qbytearray.htm#chopped" translate="no">chopped</a>(), <a href="./qbytearray.htm#chop" translate="no">chop</a>(), and <a href="./qbytearray.htm#truncate" translate="no">truncate</a>().</p>
<!-- @@@left -->
<!-- $$$leftJustified[overload1]$$$leftJustifiedintcharbool -->
<h3 class="fn" id="leftJustified" translate="no"><a name="leftJustified"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">leftJustified</span>(<span class="type">int</span> <i>width</i>, <span class="type">char</span> <i>fill</i> = ' ', <span class="type">bool</span> <i>truncate</i> = false) const<a class="plink" href="#leftJustified" title="Direct link to this headline"></a></h3>
<p>Returns a byte array of size <i translate="no">width</i> that contains this byte array padded by the <i translate="no">fill</i> character.</p>
<p>If <i translate="no">truncate</i> is false and the <a href="./qbytearray.htm#size" translate="no">size</a>() of the byte array is more than <i translate="no">width</i>, then the returned byte array is a copy of this byte array.</p>
<p>If <i translate="no">truncate</i> is true and the <a href="./qbytearray.htm#size" translate="no">size</a>() of the byte array is more than <i translate="no">width</i>, then any bytes in a copy of the byte array after position <i translate="no">width</i> are removed, and the copy is returned.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"apple"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>leftJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);   <span class="comment">// y == "apple..."</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#rightJustified" translate="no">rightJustified</a>().</p>
<!-- @@@leftJustified -->
<!-- $$$length[overload1]$$$length -->
<h3 class="fn" id="length" translate="no"><a name="length"></a><span class="type">int</span> QByteArray::<span class="name">length</span>() const<a class="plink" href="#length" title="Direct link to this headline"></a></h3>
<p>Same as <a href="./qbytearray.htm#size" translate="no">size</a>().</p>
<!-- @@@length -->
<!-- $$$mid[overload1]$$$midintint -->
<h3 class="fn" id="mid" translate="no"><a name="mid"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">mid</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i> = -1) const<a class="plink" href="#mid" title="Direct link to this headline"></a></h3>
<p>Returns a byte array containing <i translate="no">len</i> bytes from this byte array, starting at position <i translate="no">pos</i>.</p>
<p>If <i translate="no">len</i> is -1 (the default), or <i translate="no">pos</i> + <i translate="no">len</i> &gt;= <a href="./qbytearray.htm#size" translate="no">size</a>(), returns a byte array containing all bytes starting at position <i translate="no">pos</i> until the end of the byte array.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"Five pineapples"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span><span class="operator">,</span> <span class="number">4</span>);     <span class="comment">// y == "pine"</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> z <span class="operator">=</span> x<span class="operator">.</span>mid(<span class="number">5</span>);        <span class="comment">// z == "pineapples"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#left" translate="no">left</a>(), <a href="./qbytearray.htm#right" translate="no">right</a>(), <a href="./qbytearray.htm#chopped" translate="no">chopped</a>(), <a href="./qbytearray.htm#chop" translate="no">chop</a>(), and <a href="./qbytearray.htm#truncate" translate="no">truncate</a>().</p>
<!-- @@@mid -->
<!-- $$$number[overload1]$$$numberintint -->
<h3 class="fn" id="number" translate="no"><a name="number"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#number" title="Direct link to this headline"></a></h3>
<p>Returns a byte array containing the string equivalent of the number <i translate="no">n</i> to base <i translate="no">base</i> (10 by default). The <i translate="no">base</i> can be any value between 2 and 36.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>number(n);              <span class="comment">// returns "63"</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>number(n<span class="operator">,</span> <span class="number">16</span>);          <span class="comment">// returns "3f"</span>
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>number(n<span class="operator">,</span> <span class="number">16</span>)<span class="operator">.</span>toUpper();  <span class="comment">// returns "3F"</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#setNum" translate="no">setNum</a>() and <a href="./qbytearray.htm#toInt" translate="no">toInt</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberuintint -->
<h3 class="fn" id="number-1" translate="no"><a name="number-1"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#number-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toUInt" translate="no">toUInt</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberqlonglongint -->
<h3 class="fn" id="number-2" translate="no"><a name="number-2"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="./qtglobal.htm#qlonglong-typedef" translate="no">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#number-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toLongLong" translate="no">toLongLong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberqulonglongint -->
<h3 class="fn" id="number-3" translate="no"><a name="number-3"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type"><a href="./qtglobal.htm#qulonglong-typedef" translate="no">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#number-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toULongLong" translate="no">toULongLong</a>().</p>
<!-- @@@number -->
<!-- $$$number$$$numberdoublecharint -->
<h3 class="fn" id="number-4" translate="no"><a name="number-4"></a><code translate="no">[static] </code><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">number</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>f</i> = 'g', <span class="type">int</span> <i>prec</i> = 6)<a class="plink" href="#number-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that contains the printed value of <i translate="no">n</i>, formatted in format <i translate="no">f</i> with precision <i translate="no">prec</i>.</p>
<p>Argument <i translate="no">n</i> is formatted according to the <i translate="no">f</i> format specified, which is <code translate="no">g</code> by default, and can be any of the following:</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Format</th><th>Meaning</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">e</code></td><td>format as [-]9.9e[+|-]999</td></tr>
<tr class="even" valign="top"><td><code translate="no">E</code></td><td>format as [-]9.9E[+|-]999</td></tr>
<tr class="odd" valign="top"><td><code translate="no">f</code></td><td>format as [-]9.9</td></tr>
<tr class="even" valign="top"><td><code translate="no">g</code></td><td>use <code translate="no">e</code> or <code translate="no">f</code> format, whichever is the most concise</td></tr>
<tr class="odd" valign="top"><td><code translate="no">G</code></td><td>use <code translate="no">E</code> or <code translate="no">f</code> format, whichever is the most concise</td></tr>
</tbody></table></div>
<p>With 'e', 'E', and 'f', <i translate="no">prec</i> is the number of digits after the decimal point. With 'g' and 'G', <i translate="no">prec</i> is the maximum number of significant digits (trailing zeroes are omitted).</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba <span class="operator">=</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>number(<span class="number">12.3456</span><span class="operator">,</span> <span class="char">'E'</span><span class="operator">,</span> <span class="number">3</span>);
<span class="comment">// ba == 1.235E+01</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#toDouble" translate="no">toDouble</a>().</p>
<!-- @@@number -->
<!-- $$$prepend[overload1]$$$prependconstQByteArray& -->
<h3 class="fn" id="prepend" translate="no"><a name="prepend"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>)<a class="plink" href="#prepend" title="Direct link to this headline"></a></h3>
<p>Prepends the byte array <i translate="no">ba</i> to this byte array and returns a reference to this byte array.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"ship"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y(<span class="string">"air"</span>);
x<span class="operator">.</span>prepend(y);
<span class="comment">// x == "airship"</span></pre></div>
<p>This is the same as insert(0, <i translate="no">ba</i>).</p>
<p>Note: <a href="./qbytearray.htm" translate="no">QByteArray</a> is an <a href="./implicit-sharing.htm" translate="no">implicitly shared</a> class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in <i translate="no">ba</i>. In this case, no copying of data is done, taking <a href="./containers.htm#constant-time" translate="no">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p>If the byte array being prepended to is not empty, a deep copy of the data is performed, taking <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p><b>See also </b><a href="./qbytearray.htm#append" translate="no">append</a>() and <a href="./qbytearray.htm#insert" translate="no">insert</a>().</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependchar -->
<h3 class="fn" id="prepend-1" translate="no"><a name="prepend-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(<span class="type">char</span> <i>ch</i>)<a class="plink" href="#prepend-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Prepends the character <i translate="no">ch</i> to this byte array.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependintchar -->
<h3 class="fn" id="prepend-2" translate="no"><a name="prepend-2"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(<span class="type">int</span> <i>count</i>, <span class="type">char</span> <i>ch</i>)<a class="plink" href="#prepend-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Prepends <i translate="no">count</i> copies of character <i translate="no">ch</i> to this byte array.</p>
<p>This function was introduced in Qt 5.7.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar* -->
<h3 class="fn" id="prepend-3" translate="no"><a name="prepend-3"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#prepend-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Prepends the string <i translate="no">str</i> to this byte array.</p>
<!-- @@@prepend -->
<!-- $$$prepend$$$prependconstchar*int -->
<h3 class="fn" id="prepend-4" translate="no"><a name="prepend-4"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">prepend</span>(const <span class="type">char</span> *<i>str</i>, <span class="type">int</span> <i>len</i>)<a class="plink" href="#prepend-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Prepends <i translate="no">len</i> bytes of the string <i translate="no">str</i> to this byte array.</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@prepend -->
<!-- $$$push_back[overload1]$$$push_backconstQByteArray& -->
<h3 class="fn" id="push_back" translate="no"><a name="push_back"></a><span class="type">void</span> QByteArray::<span class="name">push_back</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>other</i>)<a class="plink" href="#push_back" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to append(<i translate="no">other</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backchar -->
<h3 class="fn" id="push_back-1" translate="no"><a name="push_back-1"></a><span class="type">void</span> QByteArray::<span class="name">push_back</span>(<span class="type">char</span> <i>ch</i>)<a class="plink" href="#push_back-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as append(<i translate="no">ch</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_back$$$push_backconstchar* -->
<h3 class="fn" id="push_back-2" translate="no"><a name="push_back-2"></a><span class="type">void</span> QByteArray::<span class="name">push_back</span>(const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#push_back-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as append(<i translate="no">str</i>).</p>
<!-- @@@push_back -->
<!-- $$$push_front[overload1]$$$push_frontconstQByteArray& -->
<h3 class="fn" id="push_front" translate="no"><a name="push_front"></a><span class="type">void</span> QByteArray::<span class="name">push_front</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>other</i>)<a class="plink" href="#push_front" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to prepend(<i translate="no">other</i>).</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontchar -->
<h3 class="fn" id="push_front-1" translate="no"><a name="push_front-1"></a><span class="type">void</span> QByteArray::<span class="name">push_front</span>(<span class="type">char</span> <i>ch</i>)<a class="plink" href="#push_front-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as prepend(<i translate="no">ch</i>).</p>
<!-- @@@push_front -->
<!-- $$$push_front$$$push_frontconstchar* -->
<h3 class="fn" id="push_front-2" translate="no"><a name="push_front-2"></a><span class="type">void</span> QByteArray::<span class="name">push_front</span>(const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#push_front-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as prepend(<i translate="no">str</i>).</p>
<!-- @@@push_front -->
<!-- $$$rbegin[overload1]$$$rbegin -->
<h3 class="fn" id="rbegin" translate="no"><a name="rbegin"></a><span class="type"><a href="./qbytearray.htm#reverse_iterator-typedef" translate="no">QByteArray::reverse_iterator</a></span> QByteArray::<span class="name">rbegin</span>()<a class="plink" href="#rbegin" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to the first character in the byte-array, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qbytearray.htm#begin" translate="no">begin</a>(), <a href="./qbytearray.htm#crbegin" translate="no">crbegin</a>(), and <a href="./qbytearray.htm#rend" translate="no">rend</a>().</p>
<!-- @@@rbegin -->
<!-- $$$rbegin$$$rbegin -->
<h3 class="fn" id="rbegin-1" translate="no"><a name="rbegin-1"></a><span class="type"><a href="./qbytearray.htm#const_reverse_iterator-typedef" translate="no">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">rbegin</span>() const<a class="plink" href="#rbegin-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rbegin -->
<!-- $$$remove[overload1]$$$removeintint -->
<h3 class="fn" id="remove" translate="no"><a name="remove"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">remove</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>)<a class="plink" href="#remove" title="Direct link to this headline"></a></h3>
<p>Removes <i translate="no">len</i> bytes from the array, starting at index position <i translate="no">pos</i>, and returns a reference to the array.</p>
<p>If <i translate="no">pos</i> is out of range, nothing happens. If <i translate="no">pos</i> is valid, but <i translate="no">pos</i> + <i translate="no">len</i> is larger than the size of the array, the array is truncated at position <i translate="no">pos</i>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Montreal"</span>);
ba<span class="operator">.</span>remove(<span class="number">1</span><span class="operator">,</span> <span class="number">4</span>);
<span class="comment">// ba == "Meal"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#insert" translate="no">insert</a>() and <a href="./qbytearray.htm#replace" translate="no">replace</a>().</p>
<!-- @@@remove -->
<!-- $$$rend[overload1]$$$rend -->
<h3 class="fn" id="rend" translate="no"><a name="rend"></a><span class="type"><a href="./qbytearray.htm#reverse_iterator-typedef" translate="no">QByteArray::reverse_iterator</a></span> QByteArray::<span class="name">rend</span>()<a class="plink" href="#rend" title="Direct link to this headline"></a></h3>
<p>Returns a <a href="./containers.htm#stl-style-iterators" translate="no">STL-style</a> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</p>
<p>This function was introduced in Qt 5.6.</p>
<p><b>See also </b><a href="./qbytearray.htm#end" translate="no">end</a>(), <a href="./qbytearray.htm#crend" translate="no">crend</a>(), and <a href="./qbytearray.htm#rbegin" translate="no">rbegin</a>().</p>
<!-- @@@rend -->
<!-- $$$rend$$$rend -->
<h3 class="fn" id="rend-1" translate="no"><a name="rend-1"></a><span class="type"><a href="./qbytearray.htm#const_reverse_iterator-typedef" translate="no">QByteArray::const_reverse_iterator</a></span> QByteArray::<span class="name">rend</span>() const<a class="plink" href="#rend-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@rend -->
<!-- $$$repeated[overload1]$$$repeatedint -->
<h3 class="fn" id="repeated" translate="no"><a name="repeated"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">repeated</span>(<span class="type">int</span> <i>times</i>) const<a class="plink" href="#repeated" title="Direct link to this headline"></a></h3>
<p>Returns a copy of this byte array repeated the specified number of <i translate="no">times</i>.</p>
<p>If <i translate="no">times</i> is less than 1, an empty byte array is returned.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"ab"</span>);
ba<span class="operator">.</span>repeated(<span class="number">4</span>);             <span class="comment">// returns "abababab"</span></pre></div>
<p>This function was introduced in Qt 4.5.</p>
<!-- @@@repeated -->
<!-- $$$replace[overload1]$$$replaceintintconstQByteArray& -->
<h3 class="fn" id="replace" translate="no"><a name="replace"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>after</i>)<a class="plink" href="#replace" title="Direct link to this headline"></a></h3>
<p>Replaces <i translate="no">len</i> bytes from index position <i translate="no">pos</i> with the byte array <i translate="no">after</i>, and returns a reference to this byte array.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"Say yes!"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y(<span class="string">"no"</span>);
x<span class="operator">.</span>replace(<span class="number">4</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> y);
<span class="comment">// x == "Say no!"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#insert" translate="no">insert</a>() and <a href="./qbytearray.htm#remove" translate="no">remove</a>().</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceintintconstchar* -->
<h3 class="fn" id="replace-1" translate="no"><a name="replace-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>, const <span class="type">char</span> *<i>after</i>)<a class="plink" href="#replace-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces <i translate="no">len</i> bytes from index position <i translate="no">pos</i> with the '\0'-terminated string <i translate="no">after</i>.</p>
<p>Notice: this can change the length of the byte array.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceintintconstchar*int -->
<h3 class="fn" id="replace-2" translate="no"><a name="replace-2"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">int</span> <i>pos</i>, <span class="type">int</span> <i>len</i>, const <span class="type">char</span> *<i>after</i>, <span class="type">int</span> <i>alen</i>)<a class="plink" href="#replace-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces <i translate="no">len</i> bytes from index position <i translate="no">pos</i> with <i translate="no">alen</i> bytes from the string <i translate="no">after</i>. <i translate="no">after</i> is allowed to have '\0' characters.</p>
<p>This function was introduced in Qt 4.7.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharconstchar* -->
<h3 class="fn" id="replace-3" translate="no"><a name="replace-3"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, const <span class="type">char</span> *<i>after</i>)<a class="plink" href="#replace-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the character <i translate="no">before</i> with the string <i translate="no">after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharconstQByteArray& -->
<h3 class="fn" id="replace-4" translate="no"><a name="replace-4"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>after</i>)<a class="plink" href="#replace-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the character <i translate="no">before</i> with the byte array <i translate="no">after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstchar*constchar* -->
<h3 class="fn" id="replace-5" translate="no"><a name="replace-5"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type">char</span> *<i>before</i>, const <span class="type">char</span> *<i>after</i>)<a class="plink" href="#replace-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i translate="no">before</i> with the string <i translate="no">after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstchar*intconstchar*int -->
<h3 class="fn" id="replace-6" translate="no"><a name="replace-6"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type">char</span> *<i>before</i>, <span class="type">int</span> <i>bsize</i>, const <span class="type">char</span> *<i>after</i>, <span class="type">int</span> <i>asize</i>)<a class="plink" href="#replace-6" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i translate="no">before</i> with the string <i translate="no">after</i>. Since the sizes of the strings are given by <i translate="no">bsize</i> and <i translate="no">asize</i>, they may contain zero characters and do not need to be '\0'-terminated.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQByteArray&constQByteArray& -->
<h3 class="fn" id="replace-7" translate="no"><a name="replace-7"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>before</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>after</i>)<a class="plink" href="#replace-7" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the byte array <i translate="no">before</i> with the byte array <i translate="no">after</i>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"colour behaviour flavour neighbour"</span>);
ba<span class="operator">.</span>replace(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">"ou"</span>)<span class="operator">,</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>(<span class="string">"o"</span>));
<span class="comment">// ba == "color behavior flavor neighbor"</span></pre></div>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstQByteArray&constchar* -->
<h3 class="fn" id="replace-8" translate="no"><a name="replace-8"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>before</i>, const <span class="type">char</span> *<i>after</i>)<a class="plink" href="#replace-8" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the byte array <i translate="no">before</i> with the string <i translate="no">after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replaceconstchar*constQByteArray& -->
<h3 class="fn" id="replace-9" translate="no"><a name="replace-9"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(const <span class="type">char</span> *<i>before</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>after</i>)<a class="plink" href="#replace-9" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the string <i translate="no">before</i> with the byte array <i translate="no">after</i>.</p>
<!-- @@@replace -->
<!-- $$$replace$$$replacecharchar -->
<h3 class="fn" id="replace-10" translate="no"><a name="replace-10"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">replace</span>(<span class="type">char</span> <i>before</i>, <span class="type">char</span> <i>after</i>)<a class="plink" href="#replace-10" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Replaces every occurrence of the character <i translate="no">before</i> with the character <i translate="no">after</i>.</p>
<!-- @@@replace -->
<!-- $$$reserve[overload1]$$$reserveint -->
<h3 class="fn" id="reserve" translate="no"><a name="reserve"></a><span class="type">void</span> QByteArray::<span class="name">reserve</span>(<span class="type">int</span> <i>size</i>)<a class="plink" href="#reserve" title="Direct link to this headline"></a></h3>
<p>Attempts to allocate memory for at least <i translate="no">size</i> bytes. If you know in advance how large the byte array will be, you can call this function, and if you call <a href="./qbytearray.htm#resize" translate="no">resize</a>() often you are likely to get better performance. If <i translate="no">size</i> is an underestimate, the worst that will happen is that the <a href="./qbytearray.htm" translate="no">QByteArray</a> will be a bit slower.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="./qbytearray.htm" translate="no">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the byte array, call <a href="./qbytearray.htm#resize" translate="no">resize</a>().</p>
<p><b>See also </b><a href="./qbytearray.htm#squeeze" translate="no">squeeze</a>() and <a href="./qbytearray.htm#capacity" translate="no">capacity</a>().</p>
<!-- @@@reserve -->
<!-- $$$resize[overload1]$$$resizeint -->
<h3 class="fn" id="resize" translate="no"><a name="resize"></a><span class="type">void</span> QByteArray::<span class="name">resize</span>(<span class="type">int</span> <i>size</i>)<a class="plink" href="#resize" title="Direct link to this headline"></a></h3>
<p>Sets the size of the byte array to <i translate="no">size</i> bytes.</p>
<p>If <i translate="no">size</i> is greater than the current size, the byte array is extended to make it <i translate="no">size</i> bytes with the extra bytes added to the end. The new bytes are uninitialized.</p>
<p>If <i translate="no">size</i> is less than the current size, bytes are removed from the end.</p>
<p><b>See also </b><a href="./qbytearray.htm#size" translate="no">size</a>() and <a href="./qbytearray.htm#truncate" translate="no">truncate</a>().</p>
<!-- @@@resize -->
<!-- $$$right[overload1]$$$rightint -->
<h3 class="fn" id="right" translate="no"><a name="right"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">right</span>(<span class="type">int</span> <i>len</i>) const<a class="plink" href="#right" title="Direct link to this headline"></a></h3>
<p>Returns a byte array that contains the rightmost <i translate="no">len</i> bytes of this byte array.</p>
<p>The entire byte array is returned if <i translate="no">len</i> is greater than <a href="./qbytearray.htm#size" translate="no">size</a>().</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"Pineapple"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>right(<span class="number">5</span>);
<span class="comment">// y == "apple"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#endsWith" translate="no">endsWith</a>(), <a href="./qbytearray.htm#left" translate="no">left</a>(), <a href="./qbytearray.htm#mid" translate="no">mid</a>(), <a href="./qbytearray.htm#chopped" translate="no">chopped</a>(), <a href="./qbytearray.htm#chop" translate="no">chop</a>(), and <a href="./qbytearray.htm#truncate" translate="no">truncate</a>().</p>
<!-- @@@right -->
<!-- $$$rightJustified[overload1]$$$rightJustifiedintcharbool -->
<h3 class="fn" id="rightJustified" translate="no"><a name="rightJustified"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">rightJustified</span>(<span class="type">int</span> <i>width</i>, <span class="type">char</span> <i>fill</i> = ' ', <span class="type">bool</span> <i>truncate</i> = false) const<a class="plink" href="#rightJustified" title="Direct link to this headline"></a></h3>
<p>Returns a byte array of size <i translate="no">width</i> that contains the <i translate="no">fill</i> character followed by this byte array.</p>
<p>If <i translate="no">truncate</i> is false and the size of the byte array is more than <i translate="no">width</i>, then the returned byte array is a copy of this byte array.</p>
<p>If <i translate="no">truncate</i> is true and the size of the byte array is more than <i translate="no">width</i>, then the resulting byte array is truncated at position <i translate="no">width</i>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"apple"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>rightJustified(<span class="number">8</span><span class="operator">,</span> <span class="char">'.'</span>);    <span class="comment">// y == "...apple"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#leftJustified" translate="no">leftJustified</a>().</p>
<!-- @@@rightJustified -->
<!-- $$$setNum[overload1]$$$setNumintint -->
<h3 class="fn" id="setNum" translate="no"><a name="setNum"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">int</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#setNum" title="Direct link to this headline"></a></h3>
<p>Sets the byte array to the printed value of <i translate="no">n</i> in base <i translate="no">base</i> (10 by default) and returns a reference to the byte array. The <i translate="no">base</i> can be any value between 2 and 36. For bases other than 10, n is treated as an unsigned integer.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba;
<span class="type">int</span> n <span class="operator">=</span> <span class="number">63</span>;
ba<span class="operator">.</span>setNum(n);           <span class="comment">// ba == "63"</span>
ba<span class="operator">.</span>setNum(n<span class="operator">,</span> <span class="number">16</span>);       <span class="comment">// ba == "3f"</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>() and <a href="./qbytearray.htm#toInt" translate="no">toInt</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumshortint -->
<h3 class="fn" id="setNum-1" translate="no"><a name="setNum-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">short</span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#setNum-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toShort" translate="no">toShort</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumushortint -->
<h3 class="fn" id="setNum-2" translate="no"><a name="setNum-2"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="./qtglobal.htm#ushort-typedef" translate="no">ushort</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#setNum-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toUShort" translate="no">toUShort</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumuintint -->
<h3 class="fn" id="setNum-3" translate="no"><a name="setNum-3"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#setNum-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toUInt" translate="no">toUInt</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqlonglongint -->
<h3 class="fn" id="setNum-4" translate="no"><a name="setNum-4"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="./qtglobal.htm#qlonglong-typedef" translate="no">qlonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#setNum-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toLongLong" translate="no">toLongLong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumqulonglongint -->
<h3 class="fn" id="setNum-5" translate="no"><a name="setNum-5"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type"><a href="./qtglobal.htm#qulonglong-typedef" translate="no">qulonglong</a></span> <i>n</i>, <span class="type">int</span> <i>base</i> = 10)<a class="plink" href="#setNum-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><b>See also </b><a href="./qbytearray.htm#toULongLong" translate="no">toULongLong</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumfloatcharint -->
<h3 class="fn" id="setNum-6" translate="no"><a name="setNum-6"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">float</span> <i>n</i>, <span class="type">char</span> <i>f</i> = 'g', <span class="type">int</span> <i>prec</i> = 6)<a class="plink" href="#setNum-6" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Sets the byte array to the printed value of <i translate="no">n</i>, formatted in format <i translate="no">f</i> with precision <i translate="no">prec</i>, and returns a reference to the byte array.</p>
<div class="admonition note">
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#toFloat" translate="no">toFloat</a>().</p>
<!-- @@@setNum -->
<!-- $$$setNum$$$setNumdoublecharint -->
<h3 class="fn" id="setNum-7" translate="no"><a name="setNum-7"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setNum</span>(<span class="type">double</span> <i>n</i>, <span class="type">char</span> <i>f</i> = 'g', <span class="type">int</span> <i>prec</i> = 6)<a class="plink" href="#setNum-7" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Sets the byte array to the printed value of <i translate="no">n</i>, formatted in format <i translate="no">f</i> with precision <i translate="no">prec</i>, and returns a reference to the byte array.</p>
<p>The format <i translate="no">f</i> can be any of the following:</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th>Format</th><th>Meaning</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">e</code></td><td>format as [-]9.9e[+|-]999</td></tr>
<tr class="even" valign="top"><td><code translate="no">E</code></td><td>format as [-]9.9E[+|-]999</td></tr>
<tr class="odd" valign="top"><td><code translate="no">f</code></td><td>format as [-]9.9</td></tr>
<tr class="even" valign="top"><td><code translate="no">g</code></td><td>use <code translate="no">e</code> or <code translate="no">f</code> format, whichever is the most concise</td></tr>
<tr class="odd" valign="top"><td><code translate="no">G</code></td><td>use <code translate="no">E</code> or <code translate="no">f</code> format, whichever is the most concise</td></tr>
</tbody></table></div>
<p>With 'e', 'E', and 'f', <i translate="no">prec</i> is the number of digits after the decimal point. With 'g' and 'G', <i translate="no">prec</i> is the maximum number of significant digits (trailing zeroes are omitted).</p>
<div class="admonition note">
<p><b>Note: </b>The format of the number is not localized; the default C locale is used irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#toDouble" translate="no">toDouble</a>().</p>
<!-- @@@setNum -->
<!-- $$$setRawData[overload1]$$$setRawDataconstchar*uint -->
<h3 class="fn" id="setRawData" translate="no"><a name="setRawData"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">setRawData</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>size</i>)<a class="plink" href="#setRawData" title="Direct link to this headline"></a></h3>
<p>Resets the <a href="./qbytearray.htm" translate="no">QByteArray</a> to use the first <i translate="no">size</i> bytes of the <i translate="no">data</i> array. The bytes are <i>not</i> copied. The <a href="./qbytearray.htm" translate="no">QByteArray</a> will contain the <i translate="no">data</i> pointer. The caller guarantees that <i translate="no">data</i> will not be deleted or modified as long as this <a href="./qbytearray.htm" translate="no">QByteArray</a> and any copies of it exist that have not been modified.</p>
<p>This function can be used instead of <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>() to re-use existing <a href="./qbytearray.htm" translate="no">QByteArray</a> objects to save memory re-allocations.</p>
<p>This function was introduced in Qt 4.7.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>(), <a href="./qbytearray.htm#data" translate="no">data</a>(), and <a href="./qbytearray.htm#constData" translate="no">constData</a>().</p>
<!-- @@@setRawData -->
<!-- $$$shrink_to_fit[overload1]$$$shrink_to_fit -->
<h3 class="fn" id="shrink_to_fit" translate="no"><a name="shrink_to_fit"></a><span class="type">void</span> QByteArray::<span class="name">shrink_to_fit</span>()<a class="plink" href="#shrink_to_fit" title="Direct link to this headline"></a></h3>
<p>This function is provided for STL compatibility. It is equivalent to <a href="./qbytearray.htm#squeeze" translate="no">squeeze</a>().</p>
<p>This function was introduced in Qt 5.10.</p>
<!-- @@@shrink_to_fit -->
<!-- $$$simplified[overload1]$$$simplified -->
<h3 class="fn" id="simplified" translate="no"><a name="simplified"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">simplified</span>() const<a class="plink" href="#simplified" title="Direct link to this headline"></a></h3>
<p>Returns a byte array that has whitespace removed from the start and the end, and which has each sequence of internal whitespace replaced with a single space.</p>
<p>Whitespace means any character for which the standard C++ <code translate="no">isspace()</code> function returns <code translate="no">true</code> in the C locale. This includes the ASCII isspace() function returns <code translate="no">true</code> in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"  lots\t of\nwhitespace\r\n "</span>);
ba <span class="operator">=</span> ba<span class="operator">.</span>simplified();
<span class="comment">// ba == "lots of whitespace";</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#trimmed" translate="no">trimmed</a>().</p>
<!-- @@@simplified -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size" translate="no"><a name="size"></a><span class="type">int</span> QByteArray::<span class="name">size</span>() const<a class="plink" href="#size" title="Direct link to this headline"></a></h3>
<p>Returns the number of bytes in this byte array.</p>
<p>The last byte in the byte array is at position size() - 1. In addition, <a href="./qbytearray.htm" translate="no">QByteArray</a> ensures that the byte at position size() is always '\0', so that you can use the return value of <a href="./qbytearray.htm#data" translate="no">data</a>() and <a href="./qbytearray.htm#constData" translate="no">constData</a>() as arguments to functions that expect '\0'-terminated strings. If the <a href="./qbytearray.htm" translate="no">QByteArray</a> object was created from a <a href="./qbytearray.htm#fromRawData" translate="no">raw data</a> that didn't include the trailing null-termination character then <a href="./qbytearray.htm" translate="no">QByteArray</a> doesn't add it automatically unless the <a href="./implicit-sharing.htm#deep-copy" translate="no">deep copy</a> is created.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Hello"</span>);
<span class="type">int</span> n <span class="operator">=</span> ba<span class="operator">.</span>size();          <span class="comment">// n == 5</span>
ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>;               <span class="comment">// returns 'H'</span>
ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">4</span><span class="operator">]</span>;               <span class="comment">// returns 'o'</span>
ba<span class="operator">.</span>data()<span class="operator">[</span><span class="number">5</span><span class="operator">]</span>;               <span class="comment">// returns '\0'</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#isEmpty" translate="no">isEmpty</a>() and <a href="./qbytearray.htm#resize" translate="no">resize</a>().</p>
<!-- @@@size -->
<!-- $$$split[overload1]$$$splitchar -->
<h3 class="fn" id="split" translate="no"><a name="split"></a><span class="type"><a href="./qlist.htm" translate="no">QList</a></span>&lt;<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span>&gt; QByteArray::<span class="name">split</span>(<span class="type">char</span> <i>sep</i>) const<a class="plink" href="#split" title="Direct link to this headline"></a></h3>
<p>Splits the byte array into subarrays wherever <i translate="no">sep</i> occurs, and returns the list of those arrays. If <i translate="no">sep</i> does not match anywhere in the byte array, split() returns a single-element list containing this byte array.</p>
<!-- @@@split -->
<!-- $$$squeeze[overload1]$$$squeeze -->
<h3 class="fn" id="squeeze" translate="no"><a name="squeeze"></a><span class="type">void</span> QByteArray::<span class="name">squeeze</span>()<a class="plink" href="#squeeze" title="Direct link to this headline"></a></h3>
<p>Releases any memory not required to store the array's data.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="./qbytearray.htm" translate="no">QByteArray</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p><b>See also </b><a href="./qbytearray.htm#reserve" translate="no">reserve</a>() and <a href="./qbytearray.htm#capacity" translate="no">capacity</a>().</p>
<!-- @@@squeeze -->
<!-- $$$startsWith[overload1]$$$startsWithconstQByteArray& -->
<h3 class="fn" id="startsWith" translate="no"><a name="startsWith"></a><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>) const<a class="plink" href="#startsWith" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array starts with byte array <i translate="no">ba</i>; otherwise returns <code translate="no">false</code>.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> url(<span class="string">"ftp://ftp.qt-project.org/"</span>);
<span class="keyword">if</span> (url<span class="operator">.</span>startsWith(<span class="string">"ftp:"</span>))
    <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#endsWith" translate="no">endsWith</a>() and <a href="./qbytearray.htm#left" translate="no">left</a>().</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithchar -->
<h3 class="fn" id="startsWith-1" translate="no"><a name="startsWith-1"></a><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(<span class="type">char</span> <i>ch</i>) const<a class="plink" href="#startsWith-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if this byte array starts with character <i translate="no">ch</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@startsWith -->
<!-- $$$startsWith$$$startsWithconstchar* -->
<h3 class="fn" id="startsWith-2" translate="no"><a name="startsWith-2"></a><span class="type">bool</span> QByteArray::<span class="name">startsWith</span>(const <span class="type">char</span> *<i>str</i>) const<a class="plink" href="#startsWith-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if this byte array starts with string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<!-- @@@startsWith -->
<!-- $$$swap[overload1]$$$swapQByteArray& -->
<h3 class="fn" id="swap" translate="no"><a name="swap"></a><span class="type">void</span> QByteArray::<span class="name">swap</span>(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>other</i>)<a class="plink" href="#swap" title="Direct link to this headline"></a></h3>
<p>Swaps byte array <i translate="no">other</i> with this byte array. This operation is very fast and never fails.</p>
<p>This function was introduced in Qt 4.8.</p>
<!-- @@@swap -->
<!-- $$$toBase64[overload1]$$$toBase64 -->
<h3 class="fn" id="toBase64" translate="no"><a name="toBase64"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">toBase64</span>() const<a class="plink" href="#toBase64" title="Direct link to this headline"></a></h3>
<p>Returns a copy of the byte array, encoded as Base64.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text(<span class="string">"Qt is great!"</span>);
text<span class="operator">.</span>toBase64();        <span class="comment">// returns "UXQgaXMgZ3JlYXQh"</span></pre></div>
<p>The algorithm used to encode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt" translate="no">RFC 4648</a>.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromBase64" translate="no">fromBase64</a>().</p>
<!-- @@@toBase64 -->
<!-- $$$toBase64$$$toBase64QByteArray::Base64Options -->
<h3 class="fn" id="toBase64-1" translate="no"><a name="toBase64-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">toBase64</span>(<span class="type"><a href="./qbytearray.htm#Base64Option-enum" translate="no">QByteArray::Base64Options</a></span> <i>options</i>) const<a class="plink" href="#toBase64-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a copy of the byte array, encoded using the options <i translate="no">options</i>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text(<span class="string">"&lt;p&gt;Hello?&lt;/p&gt;"</span>);
text<span class="operator">.</span>toBase64(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>Base64Encoding <span class="operator">|</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>OmitTrailingEquals);      <span class="comment">// returns "PHA+SGVsbG8/PC9wPg"</span>
text<span class="operator">.</span>toBase64(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>Base64Encoding);                                       <span class="comment">// returns "PHA+SGVsbG8/PC9wPg=="</span>
text<span class="operator">.</span>toBase64(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding);                                    <span class="comment">// returns "PHA-SGVsbG8_PC9wPg=="</span>
text<span class="operator">.</span>toBase64(<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>Base64UrlEncoding <span class="operator">|</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>OmitTrailingEquals);   <span class="comment">// returns "PHA-SGVsbG8_PC9wPg"</span></pre></div>
<p>The algorithm used to encode Base64-encoded data is defined in <a href="http://www.ietf.org/rfc/rfc4648.txt" translate="no">RFC 4648</a>.</p>
<p>This function was introduced in Qt 5.2.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromBase64" translate="no">fromBase64</a>().</p>
<!-- @@@toBase64 -->
<!-- $$$toCFData[overload1]$$$toCFData -->
<h3 class="fn" id="toCFData" translate="no"><a name="toCFData"></a><span class="type">CFDataRef</span> QByteArray::<span class="name">toCFData</span>() const<a class="plink" href="#toCFData" title="Direct link to this headline"></a></h3>
<p>Creates a CFData from a <a href="./qbytearray.htm" translate="no">QByteArray</a>. The caller owns the CFData object and is responsible for releasing it.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#toRawCFData" translate="no">toRawCFData</a>(), <a href="./qbytearray.htm#fromCFData" translate="no">fromCFData</a>(), <a href="./qbytearray.htm#fromRawCFData" translate="no">fromRawCFData</a>(), and <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@toCFData -->
<!-- $$$toDouble[overload1]$$$toDoublebool* -->
<h3 class="fn" id="toDouble" translate="no"><a name="toDouble"></a><span class="type">double</span> QByteArray::<span class="name">toDouble</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const<a class="plink" href="#toDouble" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to a <code translate="no">double</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> string(<span class="string">"1234.56"</span>);
bool ok;
<span class="type">double</span> a <span class="operator">=</span> string<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok);   <span class="comment">// a == 1234.56, ok == true</span>

string <span class="operator">=</span> <span class="string">"1234.56 Volt"</span>;
a <span class="operator">=</span> str<span class="operator">.</span>toDouble(<span class="operator">&amp;</span>ok);             <span class="comment">// a == 0, ok == false</span></pre></div>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="./qbytearray.htm" translate="no">QByteArray</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p>This function ignores leading and trailing whitespace.</p>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toDouble -->
<!-- $$$toFloat[overload1]$$$toFloatbool* -->
<h3 class="fn" id="toFloat" translate="no"><a name="toFloat"></a><span class="type">float</span> QByteArray::<span class="name">toFloat</span>(<span class="type">bool</span> *<i>ok</i> = nullptr) const<a class="plink" href="#toFloat" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to a <code translate="no">float</code> value.</p>
<p>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> string(<span class="string">"1234.56"</span>);
bool ok;
<span class="type">float</span> a <span class="operator">=</span> string<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);    <span class="comment">// a == 1234.56, ok == true</span>

string <span class="operator">=</span> <span class="string">"1234.56 Volt"</span>;
a <span class="operator">=</span> str<span class="operator">.</span>toFloat(<span class="operator">&amp;</span>ok);              <span class="comment">// a == 0, ok == false</span></pre></div>
<div class="admonition warning">
<p><b>Warning: </b>The <a href="./qbytearray.htm" translate="no">QByteArray</a> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p>This function ignores leading and trailing whitespace.</p>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toFloat -->
<!-- $$$toHex[overload1]$$$toHex -->
<h3 class="fn" id="toHex" translate="no"><a name="toHex"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">toHex</span>() const<a class="plink" href="#toHex" title="Direct link to this headline"></a></h3>
<p>Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromHex" translate="no">fromHex</a>().</p>
<!-- @@@toHex -->
<!-- $$$toHex$$$toHexchar -->
<h3 class="fn" id="toHex-1" translate="no"><a name="toHex-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">toHex</span>(<span class="type">char</span> <i>separator</i>) const<a class="plink" href="#toHex-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.</p>
<p>If <i translate="no">separator</i> is not '\0', the separator character is inserted between the hex bytes.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> macAddress <span class="operator">=</span> <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span><span class="operator">::</span>fromHex(<span class="string">"123456abcdef"</span>);
macAddress<span class="operator">.</span>toHex(<span class="char">':'</span>); <span class="comment">// returns "12:34:56:ab:cd:ef"</span>
macAddress<span class="operator">.</span>toHex(<span class="number">0</span>);   <span class="comment">// returns "123456abcdef"</span></pre></div>
<p>This function was introduced in Qt 5.9.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromHex" translate="no">fromHex</a>().</p>
<!-- @@@toHex -->
<!-- $$$toInt[overload1]$$$toIntbool*int -->
<h3 class="fn" id="toInt" translate="no"><a name="toInt"></a><span class="type">int</span> QByteArray::<span class="name">toInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toInt" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to an <code translate="no">int</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> str(<span class="string">"FF"</span>);
bool ok;
<span class="type">int</span> hex <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);     <span class="comment">// hex == 255, ok == true</span>
<span class="type">int</span> dec <span class="operator">=</span> str<span class="operator">.</span>toInt(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);     <span class="comment">// dec == 0, ok == false</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toInt -->
<!-- $$$toLong[overload1]$$$toLongbool*int -->
<h3 class="fn" id="toLong" translate="no"><a name="toLong"></a><span class="type">long</span> QByteArray::<span class="name">toLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toLong" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to a <code translate="no">long</code> int using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> str(<span class="string">"FF"</span>);
bool ok;
<span class="type">long</span> hex <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">16</span>);   <span class="comment">// hex == 255, ok == true</span>
<span class="type">long</span> dec <span class="operator">=</span> str<span class="operator">.</span>toLong(<span class="operator">&amp;</span>ok<span class="operator">,</span> <span class="number">10</span>);   <span class="comment">// dec == 0, ok == false</span></pre></div>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toLong -->
<!-- $$$toLongLong[overload1]$$$toLongLongbool*int -->
<h3 class="fn" id="toLongLong" translate="no"><a name="toLongLong"></a><span class="type"><a href="./qtglobal.htm#qlonglong-typedef" translate="no">qlonglong</a></span> QByteArray::<span class="name">toLongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toLongLong" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to a <code translate="no">long long</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toLongLong -->
<!-- $$$toLower[overload1]$$$toLower -->
<h3 class="fn" id="toLower" translate="no"><a name="toLower"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">toLower</span>() const<a class="plink" href="#toLower" title="Direct link to this headline"></a></h3>
<p>Returns a lowercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"Qt by THE QT COMPANY"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toLower();
<span class="comment">// y == "qt by the qt company"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#isLower" translate="no">isLower</a>(), <a href="./qbytearray.htm#toUpper" translate="no">toUpper</a>(), and <a href="./qbytearray.htm#8-bit-character-comparisons" translate="no">8-bit Character Comparisons</a>.</p>
<!-- @@@toLower -->
<!-- $$$toNSData[overload1]$$$toNSData -->
<h3 class="fn" id="toNSData" translate="no"><a name="toNSData"></a><span class="type">NSData</span> *QByteArray::<span class="name">toNSData</span>() const<a class="plink" href="#toNSData" title="Direct link to this headline"></a></h3>
<p>Creates a NSData from a <a href="./qbytearray.htm" translate="no">QByteArray</a>. The NSData object is autoreleased.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromNSData" translate="no">fromNSData</a>(), <a href="./qbytearray.htm#fromRawNSData" translate="no">fromRawNSData</a>(), <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>(), and <a href="./qbytearray.htm#toRawNSData" translate="no">toRawNSData</a>().</p>
<!-- @@@toNSData -->
<!-- $$$toPercentEncoding[overload1]$$$toPercentEncodingconstQByteArray&constQByteArray&char -->
<h3 class="fn" id="toPercentEncoding" translate="no"><a name="toPercentEncoding"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">toPercentEncoding</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>exclude</i> = QByteArray(), const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>include</i> = QByteArray(), <span class="type">char</span> <i>percent</i> = '%') const<a class="plink" href="#toPercentEncoding" title="Direct link to this headline"></a></h3>
<p>Returns a URI/URL-style percent-encoded copy of this byte array. The <i translate="no">percent</i> parameter allows you to override the default '%' character for another.</p>
<p>By default, this function will encode all characters that are not one of the following:</p>
<p>ALPHA ("a" to "z" and "A" to "Z") / DIGIT (0 to 9) / "-" / "." / "_" / "~"</p>
<p>To prevent characters from being encoded pass them to <i translate="no">exclude</i>. To force characters to be encoded pass them to <i translate="no">include</i>. The <i translate="no">percent</i> character is always encoded.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> text <span class="operator">=</span> <span class="string">"{a fishy string?}"</span>;
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba <span class="operator">=</span> text<span class="operator">.</span>toPercentEncoding(<span class="string">"{}"</span><span class="operator">,</span> <span class="string">"s"</span>);
<a href="./qtglobal.htm#qDebug" translate="no">qDebug</a>(ba<span class="operator">.</span>constData());
<span class="comment">// prints "{a fi%73hy %73tring%3F}"</span></pre></div>
<p>The hex encoding uses the numbers 0-9 and the uppercase letters A-F.</p>
<p>This function was introduced in Qt 4.4.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromPercentEncoding" translate="no">fromPercentEncoding</a>() and <a href="./qurl.htm#toPercentEncoding" translate="no">QUrl::toPercentEncoding</a>().</p>
<!-- @@@toPercentEncoding -->
<!-- $$$toRawCFData[overload1]$$$toRawCFData -->
<h3 class="fn" id="toRawCFData" translate="no"><a name="toRawCFData"></a><span class="type">CFDataRef</span> QByteArray::<span class="name">toRawCFData</span>() const<a class="plink" href="#toRawCFData" title="Direct link to this headline"></a></h3>
<p>Constructs a CFData that uses the bytes of the <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p>The <a href="./qbytearray.htm" translate="no">QByteArray</a>'s bytes are not copied.</p>
<p>The caller guarantees that the <a href="./qbytearray.htm" translate="no">QByteArray</a> will not be deleted or modified as long as this CFData object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#toCFData" translate="no">toCFData</a>(), <a href="./qbytearray.htm#fromRawCFData" translate="no">fromRawCFData</a>(), <a href="./qbytearray.htm#fromCFData" translate="no">fromCFData</a>(), and <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>().</p>
<!-- @@@toRawCFData -->
<!-- $$$toRawNSData[overload1]$$$toRawNSData -->
<h3 class="fn" id="toRawNSData" translate="no"><a name="toRawNSData"></a><span class="type">NSData</span> *QByteArray::<span class="name">toRawNSData</span>() const<a class="plink" href="#toRawNSData" title="Direct link to this headline"></a></h3>
<p>Constructs a NSData that uses the bytes of the <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p>The <a href="./qbytearray.htm" translate="no">QByteArray</a>'s bytes are not copied.</p>
<p>The caller guarantees that the <a href="./qbytearray.htm" translate="no">QByteArray</a> will not be deleted or modified as long as this NSData object exists.</p>
<p>This function was introduced in Qt 5.3.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromRawNSData" translate="no">fromRawNSData</a>(), <a href="./qbytearray.htm#fromNSData" translate="no">fromNSData</a>(), <a href="./qbytearray.htm#fromRawData" translate="no">fromRawData</a>(), and <a href="./qbytearray.htm#toNSData" translate="no">toNSData</a>().</p>
<!-- @@@toRawNSData -->
<!-- $$$toShort[overload1]$$$toShortbool*int -->
<h3 class="fn" id="toShort" translate="no"><a name="toShort"></a><span class="type">short</span> QByteArray::<span class="name">toShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toShort" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to a <code translate="no">short</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toShort -->
<!-- $$$toStdString[overload1]$$$toStdString -->
<h3 class="fn" id="toStdString" translate="no"><a name="toStdString"></a><span class="type">int</span> QByteArray::<span class="name">toStdString</span>() const<a class="plink" href="#toStdString" title="Direct link to this headline"></a></h3>
<p>Returns a std::string object with the data contained in this <a href="./qbytearray.htm" translate="no">QByteArray</a>.</p>
<p>This operator is mostly useful to pass a <a href="./qbytearray.htm" translate="no">QByteArray</a> to a function that accepts a std::string object.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qbytearray.htm#fromStdString" translate="no">fromStdString</a>() and <a href="./qstring.htm#toStdString" translate="no">QString::toStdString</a>().</p>
<!-- @@@toStdString -->
<!-- $$$toUInt[overload1]$$$toUIntbool*int -->
<h3 class="fn" id="toUInt" translate="no"><a name="toUInt"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> QByteArray::<span class="name">toUInt</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toUInt" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to an <code translate="no">unsigned int</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toUInt -->
<!-- $$$toULong[overload1]$$$toULongbool*int -->
<h3 class="fn" id="toULong" translate="no"><a name="toULong"></a><span class="type"><a href="./qtglobal.htm#ulong-typedef" translate="no">ulong</a></span> QByteArray::<span class="name">toULong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toULong" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to an <code translate="no">unsigned long int</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p>This function was introduced in Qt 4.1.</p>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toULong -->
<!-- $$$toULongLong[overload1]$$$toULongLongbool*int -->
<h3 class="fn" id="toULongLong" translate="no"><a name="toULongLong"></a><span class="type"><a href="./qtglobal.htm#qulonglong-typedef" translate="no">qulonglong</a></span> QByteArray::<span class="name">toULongLong</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toULongLong" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to an <code translate="no">unsigned long long</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toULongLong -->
<!-- $$$toUShort[overload1]$$$toUShortbool*int -->
<h3 class="fn" id="toUShort" translate="no"><a name="toUShort"></a><span class="type"><a href="./qtglobal.htm#ushort-typedef" translate="no">ushort</a></span> QByteArray::<span class="name">toUShort</span>(<span class="type">bool</span> *<i>ok</i> = nullptr, <span class="type">int</span> <i>base</i> = 10) const<a class="plink" href="#toUShort" title="Direct link to this headline"></a></h3>
<p>Returns the byte array converted to an <code translate="no">unsigned short</code> using base <i translate="no">base</i>, which is 10 by default and must be between 2 and 36, or 0.</p>
<p>If <i translate="no">base</i> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</p>
<p>Returns 0 if the conversion fails.</p>
<p>If <i translate="no">ok</i> is not <code translate="no">nullptr</code>, failure is reported by setting *<i translate="no">ok</i> to <code translate="no">false</code>, and success by setting *<i translate="no">ok</i> to <code translate="no">true</code>.</p>
<div class="admonition note">
<p><b>Note: </b>The conversion of the number is performed in the default C locale, irrespective of the user's locale.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#number" translate="no">number</a>().</p>
<!-- @@@toUShort -->
<!-- $$$toUpper[overload1]$$$toUpper -->
<h3 class="fn" id="toUpper" translate="no"><a name="toUpper"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">toUpper</span>() const<a class="plink" href="#toUpper" title="Direct link to this headline"></a></h3>
<p>Returns an uppercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"Qt by THE QT COMPANY"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y <span class="operator">=</span> x<span class="operator">.</span>toUpper();
<span class="comment">// y == "QT BY THE QT COMPANY"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#isUpper" translate="no">isUpper</a>(), <a href="./qbytearray.htm#toLower" translate="no">toLower</a>(), and <a href="./qbytearray.htm#8-bit-character-comparisons" translate="no">8-bit Character Comparisons</a>.</p>
<!-- @@@toUpper -->
<!-- $$$trimmed[overload1]$$$trimmed -->
<h3 class="fn" id="trimmed" translate="no"><a name="trimmed"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> QByteArray::<span class="name">trimmed</span>() const<a class="plink" href="#trimmed" title="Direct link to this headline"></a></h3>
<p>Returns a byte array that has whitespace removed from the start and the end.</p>
<p>Whitespace means any character for which the standard C++ <code translate="no">isspace()</code> function returns <code translate="no">true</code> in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"  lots\t of\nwhitespace\r\n "</span>);
ba <span class="operator">=</span> ba<span class="operator">.</span>trimmed();
<span class="comment">// ba == "lots\t of\nwhitespace";</span></pre></div>
<p>Unlike <a href="./qbytearray.htm#simplified" translate="no">simplified</a>(), trimmed() leaves internal whitespace alone.</p>
<p><b>See also </b><a href="./qbytearray.htm#simplified" translate="no">simplified</a>().</p>
<!-- @@@trimmed -->
<!-- $$$truncate[overload1]$$$truncateint -->
<h3 class="fn" id="truncate" translate="no"><a name="truncate"></a><span class="type">void</span> QByteArray::<span class="name">truncate</span>(<span class="type">int</span> <i>pos</i>)<a class="plink" href="#truncate" title="Direct link to this headline"></a></h3>
<p>Truncates the byte array at index position <i translate="no">pos</i>.</p>
<p>If <i translate="no">pos</i> is beyond the end of the array, nothing happens.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Stockholm"</span>);
ba<span class="operator">.</span>truncate(<span class="number">5</span>);             <span class="comment">// ba == "Stock"</span></pre></div>
<p><b>See also </b><a href="./qbytearray.htm#chop" translate="no">chop</a>(), <a href="./qbytearray.htm#resize" translate="no">resize</a>(), and <a href="./qbytearray.htm#left" translate="no">left</a>().</p>
<!-- @@@truncate -->
<!-- $$$operator!=[overload1]$$$operator!=constQString& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator!=</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array is not equal to string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="./qstring.htm#toUtf8" translate="no">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code translate="no">QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="./qstring.htm#fromUtf8" translate="no">QString::fromUtf8</a>(), <a href="./qstring.htm#fromLatin1" translate="no">QString::fromLatin1</a>(), or <a href="./qstring.htm#fromLocal8Bit" translate="no">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="./qstring.htm" translate="no">QString</a> before doing the comparison.</p>
<!-- @@@operator!= -->
<!-- $$$operator+=[overload1]$$$operator+=constQByteArray& -->
<h3 class="fn" id="operator-2b-eq" translate="no"><a name="operator-2b-eq"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>)<a class="plink" href="#operator-2b-eq" title="Direct link to this headline"></a></h3>
<p>Appends the byte array <i translate="no">ba</i> onto the end of this byte array and returns a reference to this byte array.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> x(<span class="string">"free"</span>);
<span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> y(<span class="string">"dom"</span>);
x <span class="operator">+</span><span class="operator">=</span> y;
<span class="comment">// x == "freedom"</span></pre></div>
<p>Note: <a href="./qbytearray.htm" translate="no">QByteArray</a> is an <a href="./implicit-sharing.htm" translate="no">implicitly shared</a> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <i translate="no">ba</i>. In this case, no copying of data is done, taking <a href="./containers.htm#constant-time" translate="no">constant time</a>. If a shared instance is modified, it will be copied (copy-on-write), taking <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <a href="./containers.htm#linear-time" translate="no">linear time</a>.</p>
<p>This operation typically does not suffer from allocation overhead, because <a href="./qbytearray.htm" translate="no">QByteArray</a> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</p>
<p><b>See also </b><a href="./qbytearray.htm#append" translate="no">append</a>() and <a href="./qbytearray.htm#prepend" translate="no">prepend</a>().</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=char -->
<h3 class="fn" id="operator-2b-eq-1" translate="no"><a name="operator-2b-eq-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(<span class="type">char</span> <i>ch</i>)<a class="plink" href="#operator-2b-eq-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends the character <i translate="no">ch</i> onto the end of this byte array and returns a reference to this byte array.</p>
<!-- @@@operator+= -->
<!-- $$$operator+=$$$operator+=constchar* -->
<h3 class="fn" id="operator-2b-eq-2" translate="no"><a name="operator-2b-eq-2"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">operator+=</span>(const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#operator-2b-eq-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Appends the string <i translate="no">str</i> onto the end of this byte array and returns a reference to this byte array.</p>
<!-- @@@operator+= -->
<!-- $$$operator<[overload1]$$$operator<constQString& -->
<h3 class="fn" id="operator-lt" translate="no"><a name="operator-lt"></a><span class="type">bool</span> QByteArray::<span class="name">operator&lt;</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>) const<a class="plink" href="#operator-lt" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array is lexically less than string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="./qstring.htm#toUtf8" translate="no">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code translate="no">QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="./qstring.htm#fromUtf8" translate="no">QString::fromUtf8</a>(), <a href="./qstring.htm#fromLatin1" translate="no">QString::fromLatin1</a>(), or <a href="./qstring.htm#fromLocal8Bit" translate="no">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="./qstring.htm" translate="no">QString</a> before doing the comparison.</p>
<!-- @@@operator< -->
<!-- $$$operator<=[overload1]$$$operator<=constQString& -->
<h3 class="fn" id="operator-lt-eq" translate="no"><a name="operator-lt-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator&lt;=</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>) const<a class="plink" href="#operator-lt-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array is lexically less than or equal to string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="./qstring.htm#toUtf8" translate="no">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code translate="no">QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="./qstring.htm#fromUtf8" translate="no">QString::fromUtf8</a>(), <a href="./qstring.htm#fromLatin1" translate="no">QString::fromLatin1</a>(), or <a href="./qstring.htm#fromLocal8Bit" translate="no">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="./qstring.htm" translate="no">QString</a> before doing the comparison.</p>
<!-- @@@operator<= -->
<!-- $$$operator=$$$operator=constchar* -->
<h3 class="fn" id="operator-eq-1" translate="no"><a name="operator-eq-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;QByteArray::<span class="name">operator=</span>(const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#operator-eq-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Assigns <i translate="no">str</i> to this byte array.</p>
<!-- @@@operator= -->
<!-- $$$operator==[overload1]$$$operator==constQString& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator==</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array is equal to string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="./qstring.htm#toUtf8" translate="no">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code translate="no">QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="./qstring.htm#fromUtf8" translate="no">QString::fromUtf8</a>(), <a href="./qstring.htm#fromLatin1" translate="no">QString::fromLatin1</a>(), or <a href="./qstring.htm#fromLocal8Bit" translate="no">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="./qstring.htm" translate="no">QString</a> before doing the comparison.</p>
<!-- @@@operator== -->
<!-- $$$operator>[overload1]$$$operator>constQString& -->
<h3 class="fn" id="operator-gt" translate="no"><a name="operator-gt"></a><span class="type">bool</span> QByteArray::<span class="name">operator&gt;</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>) const<a class="plink" href="#operator-gt" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array is lexically greater than string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="./qstring.htm#toUtf8" translate="no">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code translate="no">QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="./qstring.htm#fromUtf8" translate="no">QString::fromUtf8</a>(), <a href="./qstring.htm#fromLatin1" translate="no">QString::fromLatin1</a>(), or <a href="./qstring.htm#fromLocal8Bit" translate="no">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="./qstring.htm" translate="no">QString</a> before doing the comparison.</p>
<!-- @@@operator> -->
<!-- $$$operator>=[overload1]$$$operator>=constQString& -->
<h3 class="fn" id="operator-gt-eq" translate="no"><a name="operator-gt-eq"></a><span class="type">bool</span> QByteArray::<span class="name">operator&gt;=</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>) const<a class="plink" href="#operator-gt-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this byte array is greater than or equal to string <i translate="no">str</i>; otherwise returns <code translate="no">false</code>.</p>
<p>The Unicode data is converted into 8-bit characters using <a href="./qstring.htm#toUtf8" translate="no">QString::toUtf8</a>().</p>
<p>The comparison is case sensitive.</p>
<p>You can disable this operator by defining <code translate="no">QT_NO_CAST_FROM_ASCII</code> when you compile your applications. You then need to call <a href="./qstring.htm#fromUtf8" translate="no">QString::fromUtf8</a>(), <a href="./qstring.htm#fromLatin1" translate="no">QString::fromLatin1</a>(), or <a href="./qstring.htm#fromLocal8Bit" translate="no">QString::fromLocal8Bit</a>() explicitly if you want to convert the byte array to a <a href="./qstring.htm" translate="no">QString</a> before doing the comparison.</p>
<!-- @@@operator>= -->
<!-- $$$operator[][overload1]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d" translate="no"><a name="operator-5b-5d"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a></span> QByteArray::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>)<a class="plink" href="#operator-5b-5d" title="Direct link to this headline"></a></h3>
<p>Returns the byte at index position <i translate="no">i</i> as a modifiable reference.</p>
<p>If an assignment is made beyond the end of the byte array, the array is extended with <a href="./qbytearray.htm#resize" translate="no">resize</a>() before the assignment takes place.</p>
<p>Example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba(<span class="string">"Hello, world"</span>);
cout <span class="operator">&lt;</span><span class="operator">&lt;</span> ba<span class="operator">[</span><span class="number">0</span><span class="operator">]</span>; <span class="comment">// prints H</span>
ba<span class="operator">[</span><span class="number">7</span><span class="operator">]</span> <span class="operator">=</span> <span class="char">'W'</span>;
<span class="comment">// ba == "Hello, World"</span></pre></div>
<p>The return value is of type <a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a>, a helper class for <a href="./qbytearray.htm" translate="no">QByteArray</a>. When you get an object of type <a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a>, you can use it as if it were a char &amp;. If you assign to it, the assignment will apply to the character in the <a href="./qbytearray.htm" translate="no">QByteArray</a> from which you got the reference.</p>
<div class="admonition note">
<p><b>Note: </b>Before Qt 5.14 it was possible to use this operator to access a character at an out-of-bounds position in the byte array, and then assign to such a position, causing the byte array to be automatically resized. Furthermore, assigning a value to the returned <a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a> would cause a detach of the byte array, even if the byte array has been copied in the meanwhile (and the <a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a> kept alive while the copy was taken). These behaviors are deprecated, and will be changed in a future version of Qt.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#at" translate="no">at</a>().</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]int -->
<h3 class="fn" id="operator-5b-5d-1" translate="no"><a name="operator-5b-5d-1"></a><span class="type">char</span> QByteArray::<span class="name">operator[]</span>(<span class="type">int</span> <i>i</i>) const<a class="plink" href="#operator-5b-5d-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Same as at(<i translate="no">i</i>).</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]uint -->
<h3 class="fn" id="operator-5b-5d-2" translate="no"><a name="operator-5b-5d-2"></a><span class="type">char</span> QByteArray::<span class="name">operator[]</span>(<span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>i</i>) const<a class="plink" href="#operator-5b-5d-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@operator[] -->
<!-- $$$operator[]$$$operator[]uint -->
<h3 class="fn" id="operator-5b-5d-3" translate="no"><a name="operator-5b-5d-3"></a><span class="type"><a href="https://doc.qt.io/archives/qt-5.15/qbyteref.html" translate="no">QByteRef</a></span> QByteArray::<span class="name">operator[]</span>(<span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>i</i>)<a class="plink" href="#operator-5b-5d-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@operator[] -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qChecksum[overload1]$$$qChecksumconstchar*uint -->
<h3 class="fn" id="qChecksum" translate="no"><a name="qChecksum"></a><span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <span class="name">qChecksum</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>len</i>)<a class="plink" href="#qChecksum" title="Direct link to this headline"></a></h3>
<p>Returns the CRC-16 checksum of the first <i translate="no">len</i> bytes of <i translate="no">data</i>.</p>
<p>The checksum is independent of the byte order (endianness) and will be calculated accorded to the algorithm published in ISO 3309 (<a href="./qt.htm#ChecksumType-enum" translate="no">Qt::ChecksumIso3309</a>).</p>
<div class="admonition note">
<p><b>Note: </b>This function is a 16-bit cache conserving (16 entry table) implementation of the CRC-16-CCITT algorithm.</p>
</div>
<!-- @@@qChecksum -->
<!-- $$$qChecksum$$$qChecksumconstchar*uintQt::ChecksumType -->
<h3 class="fn" id="qChecksum-1" translate="no"><a name="qChecksum-1"></a><span class="type"><a href="./qtglobal.htm#quint16-typedef" translate="no">quint16</a></span> <span class="name">qChecksum</span>(const <span class="type">char</span> *<i>data</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>len</i>, <span class="type"><a href="./qt.htm#ChecksumType-enum" translate="no">Qt::ChecksumType</a></span> <i>standard</i>)<a class="plink" href="#qChecksum-1" title="Direct link to this headline"></a></h3>
<p>Returns the CRC-16 checksum of the first <i translate="no">len</i> bytes of <i translate="no">data</i>.</p>
<p>The checksum is independent of the byte order (endianness) and will be calculated accorded to the algorithm published in <i translate="no">standard</i>.</p>
<div class="admonition note">
<p><b>Note: </b>This function is a 16-bit cache conserving (16 entry table) implementation of the CRC-16-CCITT algorithm.</p>
</div>
<p>This function was introduced in Qt 5.9.</p>
<!-- @@@qChecksum -->
<!-- $$$qCompress[overload1]$$$qCompressconstQByteArray&int -->
<h3 class="fn" id="qCompress" translate="no"><a name="qCompress"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">qCompress</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>data</i>, <span class="type">int</span> <i>compressionLevel</i> = -1)<a class="plink" href="#qCompress" title="Direct link to this headline"></a></h3>
<p>Compresses the <i translate="no">data</i> byte array and returns the compressed data in a new byte array.</p>
<p>The <i translate="no">compressionLevel</i> parameter specifies how much compression should be used. Valid values are between 0 and 9, with 9 corresponding to the greatest compression (i.e. smaller compressed data) at the cost of using a slower algorithm. Smaller values (8, 7, ..., 1) provide successively less compression at slightly faster speeds. The value 0 corresponds to no compression at all. The default value is -1, which specifies zlib's default compression.</p>
<p><b>See also </b><a href="./qbytearray.htm#qUncompress" translate="no">qUncompress</a>().</p>
<!-- @@@qCompress -->
<!-- $$$qCompress$$$qCompressconstuchar*intint -->
<h3 class="fn" id="qCompress-1" translate="no"><a name="qCompress-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">qCompress</span>(const <span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>nbytes</i>, <span class="type">int</span> <i>compressionLevel</i> = -1)<a class="plink" href="#qCompress-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Compresses the first <i translate="no">nbytes</i> of <i translate="no">data</i> at compression level <i translate="no">compressionLevel</i> and returns the compressed data in a new byte array.</p>
<!-- @@@qCompress -->
<!-- $$$qUncompress[overload1]$$$qUncompressconstQByteArray& -->
<h3 class="fn" id="qUncompress" translate="no"><a name="qUncompress"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">qUncompress</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>data</i>)<a class="plink" href="#qUncompress" title="Direct link to this headline"></a></h3>
<p>Uncompresses the <i translate="no">data</i> byte array and returns a new byte array with the uncompressed data.</p>
<p>Returns an empty <a href="./qbytearray.htm" translate="no">QByteArray</a> if the input data was corrupt.</p>
<p>This function will uncompress data compressed with <a href="./qbytearray.htm#qCompress" translate="no">qCompress</a>() from this and any earlier Qt version, back to Qt 3.1 when this feature was added.</p>
<p><b>Note:</b> If you want to use this function to uncompress external data that was compressed using zlib, you first need to prepend a four byte header to the byte array containing the data. The header must contain the expected length (in bytes) of the uncompressed data, expressed as an unsigned, big-endian, 32-bit integer.</p>
<p><b>See also </b><a href="./qbytearray.htm#qCompress" translate="no">qCompress</a>().</p>
<!-- @@@qUncompress -->
<!-- $$$qUncompress$$$qUncompressconstuchar*int -->
<h3 class="fn" id="qUncompress-1" translate="no"><a name="qUncompress-1"></a><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">qUncompress</span>(const <span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *<i>data</i>, <span class="type">int</span> <i>nbytes</i>)<a class="plink" href="#qUncompress-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Uncompresses the first <i translate="no">nbytes</i> of <i translate="no">data</i> and returns a new byte array with the uncompressed data.</p>
<!-- @@@qUncompress -->
<!-- $$$qstrcmp[overload1]$$$qstrcmpconstchar*constchar* -->
<h3 class="fn" id="qstrcmp" translate="no"><a name="qstrcmp"></a><span class="type">int</span> <span class="name">qstrcmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>)<a class="plink" href="#qstrcmp" title="Direct link to this headline"></a></h3>
<p>A safe <code translate="no">strcmp()</code> function.</p>
<p>Compares <i translate="no">str1</i> and <i translate="no">str2</i>. Returns a negative value if <i translate="no">str1</i> is less than <i translate="no">str2</i>, 0 if <i translate="no">str1</i> is equal to <i translate="no">str2</i> or a positive value if <i translate="no">str1</i> is greater than <i translate="no">str2</i>.</p>
<p>Special case 1: Returns 0 if <i translate="no">str1</i> and <i translate="no">str2</i> are both <code translate="no">nullptr</code>.</p>
<p>Special case 2: Returns an arbitrary non-zero value if <i translate="no">str1</i> is <code translate="no">nullptr</code> or <i translate="no">str2</i> is <code translate="no">nullptr</code> (but not both).</p>
<p><b>See also </b><a href="./qbytearray.htm#qstrncmp" translate="no">qstrncmp</a>(), <a href="./qbytearray.htm#qstricmp" translate="no">qstricmp</a>(), <a href="./qbytearray.htm#qstrnicmp" translate="no">qstrnicmp</a>(), <a href="./qbytearray.htm#8-bit-character-comparisons" translate="no">8-bit Character Comparisons</a>, and <a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@qstrcmp -->
<!-- $$$qstrcpy[overload1]$$$qstrcpychar*constchar* -->
<h3 class="fn" id="qstrcpy" translate="no"><a name="qstrcpy"></a><span class="type">char</span> *<span class="name">qstrcpy</span>(<span class="type">char</span> *<i>dst</i>, const <span class="type">char</span> *<i>src</i>)<a class="plink" href="#qstrcpy" title="Direct link to this headline"></a></h3>
<p>Copies all the characters up to and including the '\0' from <i translate="no">src</i> into <i translate="no">dst</i> and returns a pointer to <i translate="no">dst</i>. If <i translate="no">src</i> is <code translate="no">nullptr</code>, it immediately returns <code translate="no">nullptr</code>.</p>
<p>This function assumes that <i translate="no">dst</i> is large enough to hold the contents of <i translate="no">src</i>.</p>
<div class="admonition note">
<p><b>Note: </b>If <i translate="no">dst</i> and <i translate="no">src</i> overlap, the behavior is undefined.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#qstrncpy" translate="no">qstrncpy</a>().</p>
<!-- @@@qstrcpy -->
<!-- $$$qstrdup[overload1]$$$qstrdupconstchar* -->
<h3 class="fn" id="qstrdup" translate="no"><a name="qstrdup"></a><span class="type">char</span> *<span class="name">qstrdup</span>(const <span class="type">char</span> *<i>src</i>)<a class="plink" href="#qstrdup" title="Direct link to this headline"></a></h3>
<p>Returns a duplicate string.</p>
<p>Allocates space for a copy of <i translate="no">src</i>, copies it, and returns a pointer to the copy. If <i translate="no">src</i> is <code translate="no">nullptr</code>, it immediately returns <code translate="no">nullptr</code>.</p>
<p>Ownership is passed to the caller, so the returned string must be deleted using <code translate="no">delete[]</code>.</p>
<!-- @@@qstrdup -->
<!-- $$$qstricmp[overload1]$$$qstricmpconstchar*constchar* -->
<h3 class="fn" id="qstricmp" translate="no"><a name="qstricmp"></a><span class="type">int</span> <span class="name">qstricmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>)<a class="plink" href="#qstricmp" title="Direct link to this headline"></a></h3>
<p>A safe <code translate="no">stricmp()</code> function.</p>
<p>Compares <i translate="no">str1</i> and <i translate="no">str2</i> ignoring the case of the characters. The encoding of the strings is assumed to be Latin-1.</p>
<p>Returns a negative value if <i translate="no">str1</i> is less than <i translate="no">str2</i>, 0 if <i translate="no">str1</i> is equal to <i translate="no">str2</i> or a positive value if <i translate="no">str1</i> is greater than <i translate="no">str2</i>.</p>
<p>Special case 1: Returns 0 if <i translate="no">str1</i> and <i translate="no">str2</i> are both <code translate="no">nullptr</code>.</p>
<p>Special case 2: Returns a random non-zero value if <i translate="no">str1</i> is <code translate="no">nullptr</code> or <i translate="no">str2</i> is <code translate="no">nullptr</code> (but not both).</p>
<p><b>See also </b><a href="./qbytearray.htm#qstrcmp" translate="no">qstrcmp</a>(), <a href="./qbytearray.htm#qstrncmp" translate="no">qstrncmp</a>(), <a href="./qbytearray.htm#qstrnicmp" translate="no">qstrnicmp</a>(), <a href="./qbytearray.htm#8-bit-character-comparisons" translate="no">8-bit Character Comparisons</a>, and <a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@qstricmp -->
<!-- $$$qstrlen[overload1]$$$qstrlenconstchar* -->
<h3 class="fn" id="qstrlen" translate="no"><a name="qstrlen"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qstrlen</span>(const <span class="type">char</span> *<i>str</i>)<a class="plink" href="#qstrlen" title="Direct link to this headline"></a></h3>
<p>A safe <code translate="no">strlen()</code> function.</p>
<p>Returns the number of characters that precede the terminating '\0', or 0 if <i translate="no">str</i> is <code translate="no">nullptr</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#qstrnlen" translate="no">qstrnlen</a>().</p>
<!-- @@@qstrlen -->
<!-- $$$qstrncmp[overload1]$$$qstrncmpconstchar*constchar*uint -->
<h3 class="fn" id="qstrncmp" translate="no"><a name="qstrncmp"></a><span class="type">int</span> <span class="name">qstrncmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>len</i>)<a class="plink" href="#qstrncmp" title="Direct link to this headline"></a></h3>
<p>A safe <code translate="no">strncmp()</code> function.</p>
<p>Compares at most <i translate="no">len</i> bytes of <i translate="no">str1</i> and <i translate="no">str2</i>.</p>
<p>Returns a negative value if <i translate="no">str1</i> is less than <i translate="no">str2</i>, 0 if <i translate="no">str1</i> is equal to <i translate="no">str2</i> or a positive value if <i translate="no">str1</i> is greater than <i translate="no">str2</i>.</p>
<p>Special case 1: Returns 0 if <i translate="no">str1</i> and <i translate="no">str2</i> are both <code translate="no">nullptr</code>.</p>
<p>Special case 2: Returns a random non-zero value if <i translate="no">str1</i> is <code translate="no">nullptr</code> or <i translate="no">str2</i> is <code translate="no">nullptr</code> (but not both).</p>
<p><b>See also </b><a href="./qbytearray.htm#qstrcmp" translate="no">qstrcmp</a>(), <a href="./qbytearray.htm#qstricmp" translate="no">qstricmp</a>(), <a href="./qbytearray.htm#qstrnicmp" translate="no">qstrnicmp</a>(), <a href="./qbytearray.htm#8-bit-character-comparisons" translate="no">8-bit Character Comparisons</a>, and <a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@qstrncmp -->
<!-- $$$qstrncpy[overload1]$$$qstrncpychar*constchar*uint -->
<h3 class="fn" id="qstrncpy" translate="no"><a name="qstrncpy"></a><span class="type">char</span> *<span class="name">qstrncpy</span>(<span class="type">char</span> *<i>dst</i>, const <span class="type">char</span> *<i>src</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>len</i>)<a class="plink" href="#qstrncpy" title="Direct link to this headline"></a></h3>
<p>A safe <code translate="no">strncpy()</code> function.</p>
<p>Copies at most <i translate="no">len</i> bytes from <i translate="no">src</i> (stopping at <i translate="no">len</i> or the terminating '\0' whichever comes first) into <i translate="no">dst</i>. Guarantees that <i translate="no">dst</i> is '\0'-terminated, except when <i translate="no">dst</i> is <code translate="no">nullptr</code> or <i translate="no">len</i> is 0. If <i translate="no">src</i> is <code translate="no">nullptr</code>, returns <code translate="no">nullptr</code>, otherwise returns <i translate="no">dst</i>.</p>
<p>This function assumes that <i translate="no">dst</i> is at least <i translate="no">len</i> characters long.</p>
<div class="admonition note">
<p><b>Note: </b>If <i translate="no">dst</i> and <i translate="no">src</i> overlap, the behavior is undefined.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>Unlike strncpy(), this function does <i>not</i> write '\0' to all <i translate="no">len</i> bytes of <i translate="no">dst</i>, but stops after the terminating '\0'. In this sense, it's similar to C11's strncpy_s().</p>
</div>
<div class="admonition note">
<p><b>Note: </b>When compiling with Visual C++ compiler version 14.00 (Visual C++ 2005) or later, internally the function strncpy_s will be used.</p>
</div>
<p><b>See also </b><a href="./qbytearray.htm#qstrcpy" translate="no">qstrcpy</a>().</p>
<!-- @@@qstrncpy -->
<!-- $$$qstrnicmp[overload1]$$$qstrnicmpconstchar*constchar*uint -->
<h3 class="fn" id="qstrnicmp" translate="no"><a name="qstrnicmp"></a><span class="type">int</span> <span class="name">qstrnicmp</span>(const <span class="type">char</span> *<i>str1</i>, const <span class="type">char</span> *<i>str2</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>len</i>)<a class="plink" href="#qstrnicmp" title="Direct link to this headline"></a></h3>
<p>A safe <code translate="no">strnicmp()</code> function.</p>
<p>Compares at most <i translate="no">len</i> bytes of <i translate="no">str1</i> and <i translate="no">str2</i> ignoring the case of the characters. The encoding of the strings is assumed to be Latin-1.</p>
<p>Returns a negative value if <i translate="no">str1</i> is less than <i translate="no">str2</i>, 0 if <i translate="no">str1</i> is equal to <i translate="no">str2</i> or a positive value if <i translate="no">str1</i> is greater than <i translate="no">str2</i>.</p>
<p>Special case 1: Returns 0 if <i translate="no">str1</i> and <i translate="no">str2</i> are both <code translate="no">nullptr</code>.</p>
<p>Special case 2: Returns a random non-zero value if <i translate="no">str1</i> is <code translate="no">nullptr</code> or <i translate="no">str2</i> is <code translate="no">nullptr</code> (but not both).</p>
<p><b>See also </b><a href="./qbytearray.htm#qstrcmp" translate="no">qstrcmp</a>(), <a href="./qbytearray.htm#qstrncmp" translate="no">qstrncmp</a>(), <a href="./qbytearray.htm#qstricmp" translate="no">qstricmp</a>(), <a href="./qbytearray.htm#8-bit-character-comparisons" translate="no">8-bit Character Comparisons</a>, and <a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@qstrnicmp -->
<!-- $$$qstrnlen[overload1]$$$qstrnlenconstchar*uint -->
<h3 class="fn" id="qstrnlen" translate="no"><a name="qstrnlen"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qstrnlen</span>(const <span class="type">char</span> *<i>str</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>maxlen</i>)<a class="plink" href="#qstrnlen" title="Direct link to this headline"></a></h3>
<p>A safe <code translate="no">strnlen()</code> function.</p>
<p>Returns the number of characters that precede the terminating '\0', but at most <i translate="no">maxlen</i>. If <i translate="no">str</i> is <code translate="no">nullptr</code>, returns 0.</p>
<p>This function was introduced in Qt 4.2.</p>
<p><b>See also </b><a href="./qbytearray.htm#qstrlen" translate="no">qstrlen</a>().</p>
<!-- @@@qstrnlen -->
<!-- $$$operator!=$$$operator!=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-not-eq-3" translate="no"><a name="operator-not-eq-3"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-not-eq-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is not equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constQByteArray&constchar* -->
<h3 class="fn" id="operator-not-eq-4" translate="no"><a name="operator-not-eq-4"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)<a class="plink" href="#operator-not-eq-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is not equal to string <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator!=$$$operator!=constchar*constQByteArray& -->
<h3 class="fn" id="operator-not-eq-5" translate="no"><a name="operator-not-eq-5"></a><span class="type">bool</span> <span class="name">operator!=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-not-eq-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">a1</i> is not equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator+[overload1]$$$operator+constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-2b" translate="no"><a name="operator-2b"></a>const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-2b" title="Direct link to this headline"></a></h3>
<p>Returns a byte array that is the result of concatenating byte array <i translate="no">a1</i> and byte array <i translate="no">a2</i>.</p>
<p><b>See also </b><a href="./qbytearray.htm#operator-2b-eq" translate="no">QByteArray::operator+=</a>().</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQByteArray&constchar* -->
<h3 class="fn" id="operator-2b-1" translate="no"><a name="operator-2b-1"></a>const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)<a class="plink" href="#operator-2b-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating byte array <i translate="no">a1</i> and string <i translate="no">a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constQByteArray&char -->
<h3 class="fn" id="operator-2b-2" translate="no"><a name="operator-2b-2"></a>const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, <span class="type">char</span> <i>a2</i>)<a class="plink" href="#operator-2b-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating byte array <i translate="no">a1</i> and character <i translate="no">a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+constchar*constQByteArray& -->
<h3 class="fn" id="operator-2b-3" translate="no"><a name="operator-2b-3"></a>const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">operator+</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-2b-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating string <i translate="no">a1</i> and byte array <i translate="no">a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator+$$$operator+charconstQByteArray& -->
<h3 class="fn" id="operator-2b-4" translate="no"><a name="operator-2b-4"></a>const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> <span class="name">operator+</span>(<span class="type">char</span> <i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-2b-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns a byte array that is the result of concatenating character <i translate="no">a1</i> and byte array <i translate="no">a2</i>.</p>
<!-- @@@operator+ -->
<!-- $$$operator<$$$operator<constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-lt-3" translate="no"><a name="operator-lt-3"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-lt-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically less than byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constQByteArray&constchar* -->
<h3 class="fn" id="operator-lt-4" translate="no"><a name="operator-lt-4"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)<a class="plink" href="#operator-lt-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically less than string <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<$$$operator<constchar*constQByteArray& -->
<h3 class="fn" id="operator-lt-5" translate="no"><a name="operator-lt-5"></a><span class="type">bool</span> <span class="name">operator&lt;</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-lt-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">a1</i> is lexically less than byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator< -->
<!-- $$$operator<<[overload1]$$$operator<<QDataStream&constQByteArray& -->
<h3 class="fn" id="operator-lt-lt" translate="no"><a name="operator-lt-lt"></a><span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>)<a class="plink" href="#operator-lt-lt" title="Direct link to this headline"></a></h3>
<p>Writes byte array <i translate="no">ba</i> to the stream <i translate="no">out</i> and returns a reference to the stream.</p>
<p><b>See also </b><a href="./datastreamformat.htm" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<=$$$operator<=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-lt-eq-3" translate="no"><a name="operator-lt-eq-3"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-lt-eq-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically less than or equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constQByteArray&constchar* -->
<h3 class="fn" id="operator-lt-eq-4" translate="no"><a name="operator-lt-eq-4"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)<a class="plink" href="#operator-lt-eq-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically less than or equal to string <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator<=$$$operator<=constchar*constQByteArray& -->
<h3 class="fn" id="operator-lt-eq-5" translate="no"><a name="operator-lt-eq-5"></a><span class="type">bool</span> <span class="name">operator&lt;=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-lt-eq-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">a1</i> is lexically less than or equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator<= -->
<!-- $$$operator==$$$operator==constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-eq-eq-3" translate="no"><a name="operator-eq-eq-3"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-eq-eq-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constQByteArray&constchar* -->
<h3 class="fn" id="operator-eq-eq-4" translate="no"><a name="operator-eq-eq-4"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)<a class="plink" href="#operator-eq-eq-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is equal to string <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator==$$$operator==constchar*constQByteArray& -->
<h3 class="fn" id="operator-eq-eq-5" translate="no"><a name="operator-eq-eq-5"></a><span class="type">bool</span> <span class="name">operator==</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-eq-eq-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">a1</i> is equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator== -->
<!-- $$$operator>$$$operator>constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-gt-3" translate="no"><a name="operator-gt-3"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-gt-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically greater than byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constQByteArray&constchar* -->
<h3 class="fn" id="operator-gt-4" translate="no"><a name="operator-gt-4"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)<a class="plink" href="#operator-gt-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically greater than string <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>$$$operator>constchar*constQByteArray& -->
<h3 class="fn" id="operator-gt-5" translate="no"><a name="operator-gt-5"></a><span class="type">bool</span> <span class="name">operator&gt;</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-gt-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">a1</i> is lexically greater than byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator> -->
<!-- $$$operator>=$$$operator>=constQByteArray&constQByteArray& -->
<h3 class="fn" id="operator-gt-eq-3" translate="no"><a name="operator-gt-eq-3"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-gt-eq-3" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically greater than or equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constQByteArray&constchar* -->
<h3 class="fn" id="operator-gt-eq-4" translate="no"><a name="operator-gt-eq-4"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a1</i>, const <span class="type">char</span> *<i>a2</i>)<a class="plink" href="#operator-gt-eq-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if byte array <i translate="no">a1</i> is lexically greater than or equal to string <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>=$$$operator>=constchar*constQByteArray& -->
<h3 class="fn" id="operator-gt-eq-5" translate="no"><a name="operator-gt-eq-5"></a><span class="type">bool</span> <span class="name">operator&gt;=</span>(const <span class="type">char</span> *<i>a1</i>, const <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>a2</i>)<a class="plink" href="#operator-gt-eq-5" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Returns <code translate="no">true</code> if string <i translate="no">a1</i> is lexically greater than or equal to byte array <i translate="no">a2</i>; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qbytearray.htm#compare" translate="no">QByteArray::compare</a>().</p>
<!-- @@@operator>= -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QByteArray& -->
<h3 class="fn" id="operator-gt-gt" translate="no"><a name="operator-gt-gt"></a><span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> &amp;<i>ba</i>)<a class="plink" href="#operator-gt-gt" title="Direct link to this headline"></a></h3>
<p>Reads a byte array into <i translate="no">ba</i> from the stream <i translate="no">in</i> and returns a reference to the stream.</p>
<p><b>See also </b><a href="./datastreamformat.htm" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QByteArrayLiteral[overload1]$$$QByteArrayLiteral -->
<h3 class="fn" id="QByteArrayLiteral" translate="no"><a name="QByteArrayLiteral"></a><span class="name">QByteArrayLiteral</span>(<i>ba</i>)<a class="plink" href="#QByteArrayLiteral" title="Direct link to this headline"></a></h3>
<p>The macro generates the data for a <a href="./qbytearray.htm" translate="no">QByteArray</a> out of the string literal <i translate="no">ba</i> at compile time. Creating a <a href="./qbytearray.htm" translate="no">QByteArray</a> from it is free in this case, and the generated byte array data is stored in the read-only segment of the compiled object file.</p>
<p>For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qbytearray.htm#QByteArray" translate="no">QByteArray</a></span> ba <span class="operator">=</span> <span class="type">QByteArrayLiteral</span>(<span class="string">"byte array contents"</span>);</pre></div>
<p>Using QByteArrayLiteral instead of a double quoted plain C++ string literal can significantly speed up creation of <a href="./qbytearray.htm" translate="no">QByteArray</a> instances from data known at compile time.</p>
<p><b>See also </b><a href="./qstring.htm#QStringLiteral" translate="no">QStringLiteral</a>.</p>
<!-- @@@QByteArrayLiteral -->
<!-- $$$QT_NO_CAST_FROM_BYTEARRAY[overload1]$$$QT_NO_CAST_FROM_BYTEARRAY -->
<h3 class="fn" id="QT_NO_CAST_FROM_BYTEARRAY" translate="no"><a name="QT_NO_CAST_FROM_BYTEARRAY"></a><span class="name">QT_NO_CAST_FROM_BYTEARRAY</span><a class="plink" href="#QT_NO_CAST_FROM_BYTEARRAY" title="Direct link to this headline"></a></h3>
<p>Disables automatic conversions from <a href="./qbytearray.htm" translate="no">QByteArray</a> to const char * or const void *.</p>
<p><b>See also </b><a href="./qstring.htm#QT_NO_CAST_TO_ASCII" translate="no">QT_NO_CAST_TO_ASCII</a> and <a href="./qstring.htm#QT_NO_CAST_FROM_ASCII" translate="no">QT_NO_CAST_FROM_ASCII</a>.</p>
<!-- @@@QT_NO_CAST_FROM_BYTEARRAY -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>