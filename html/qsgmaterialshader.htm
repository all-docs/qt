<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QSGMaterialShader | Qt Quick</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qsgmaterialshader.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a href="./qtquick-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QSGMaterialShader</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QSGMaterialShader Class</h1>
<!-- $$$QSGMaterialShader-brief -->
<p>The QSGMaterialShader class represents an OpenGL shader program in the renderer. <a href="#details">More...</a></p>
<!-- @@@QSGMaterialShader -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QSGMaterialShader&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qsgmaterialrhishader.htm" translate="no">QSGMaterialRhiShader</a> and <a class="obsolete" href="./qsgsimplematerialshader.htm" translate="no">QSGSimpleMaterialShader</a></p>
</td></tr></tbody></table></div><ul>
<li><a href="./qsgmaterialshader-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader-renderstate.htm" translate="no">RenderState</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#QSGMaterialShader" translate="no">QSGMaterialShader</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#activate" translate="no">activate</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual const char *const *</td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#attributeNames" translate="no">attributeNames</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#deactivate" translate="no">deactivate</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLShaderProgram *</td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#program" translate="no">program</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#updateState" translate="no">updateState</a></b>(const QSGMaterialShader::RenderState &amp;<i>state</i>, QSGMaterial *<i>newMaterial</i>, QSGMaterial *<i>oldMaterial</i>)</td></tr>
</tbody></table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions<a class="plink" href="#protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#compile" translate="no">compile</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual const char *</td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#initialize" translate="no">initialize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#setShaderSourceFile" translate="no">setShaderSourceFile</a></b>(QOpenGLShader::ShaderType <i>type</i>, const QString &amp;<i>sourceFile</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#setShaderSourceFiles" translate="no">setShaderSourceFiles</a></b>(QOpenGLShader::ShaderType <i>type</i>, const QStringList &amp;<i>sourceFiles</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual const char *</td><td class="memItemRight bottomAlign"><b><a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a></b>() const</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QSGMaterialShader-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>The QSGMaterialShader API is relatively low-level. A more convenient API, which provides almost all the same features, is available through QSGSimpleMaterialShader.</p>
<div class="admonition warning">
<p><b>Warning: </b>This class is only functional when running with the legacy OpenGL renderer of the Qt Quick scenegraph.</p>
</div>
<p>The <a href="./qsgmaterial.htm" translate="no">QSGMaterial</a> and QSGMaterialShader form a tight relationship. For one scene graph (including nested graphs), there is one unique QSGMaterialShader instance which encapsulates the <a href="./qopenglshaderprogram.htm" translate="no">QOpenGLShaderProgram</a> the scene graph uses to render that material, such as a shader to flat coloring of geometry. Each <a href="./qsggeometrynode.htm" translate="no">QSGGeometryNode</a> can have a unique <a href="./qsgmaterial.htm" translate="no">QSGMaterial</a> containing the how the shader should be configured when drawing that node, such as the actual color used to render the geometry.</p>
<p>An instance of QSGMaterialShader is never created explicitly by the user, it will be created on demand by the scene graph through <a href="./qsgmaterial.htm#createShader" translate="no">QSGMaterial::createShader</a>(). The scene graph will make sure that there is only one instance of each shader implementation through a scene graph.</p>
<p>The source code returned from <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>() is used to control what the material does with the vertiex data that comes in from the geometry. The source code returned from the <a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a>() is used to control what how the material should fill each individual pixel in the geometry. The vertex and fragment source code is queried once during initialization, changing what is returned from these functions later will not have any effect.</p>
<p>The <a href="./qsgmaterialshader.htm#activate" translate="no">activate</a>() function is called by the scene graph when a shader is is starting to be used. The deactivate function is called by the scene graph when the shader is no longer going to be used. While active, the scene graph may make one or more calls to <a href="./qsgmaterialshader.htm#updateState" translate="no">updateState</a>() which will update the state of the shader for each individual geometry to render.</p>
<p>The <a href="./qsgmaterialshader.htm#attributeNames" translate="no">attributeNames</a>() returns the name of the attributes used in the <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>(). These are used in the default implementation of <a href="./qsgmaterialshader.htm#activate" translate="no">activate</a>() and <a href="./qsgmaterialshader.htm#deactivate" translate="no">deactivate</a>() to decide whice vertex registers are enabled.</p>
<p>The <a href="./qsgmaterialshader.htm#initialize" translate="no">initialize</a>() function is called during program creation to allow subclasses to prepare for use, such as resolve uniform names in the <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>() and <a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a>().</p>
<p>A minimal example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> Shader : <span class="keyword">public</span> <span class="type"><a href="./qsgmaterialshader.htm#QSGMaterialShader" translate="no">QSGMaterialShader</a></span>
{
<span class="keyword">public</span>:
    <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>vertexShader() <span class="keyword">const</span> {
        <span class="keyword">return</span>
        <span class="string">"attribute highp vec4 vertex;          \n"</span>
        <span class="string">"uniform highp mat4 matrix;            \n"</span>
        <span class="string">"void main() {                         \n"</span>
        <span class="string">"    gl_Position = matrix * vertex;    \n"</span>
        <span class="string">"}"</span>;
    }

    <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>fragmentShader() <span class="keyword">const</span> {
        <span class="keyword">return</span>
        <span class="string">"uniform lowp float opacity;                            \n"</span>
        <span class="string">"void main() {                                          \n"</span>
                <span class="string">"    gl_FragColor = vec4(1, 0, 0, 1) * opacity; \n"</span>
        <span class="string">"}"</span>;
    }

    <span class="type">char</span> <span class="keyword">const</span> <span class="operator">*</span><span class="keyword">const</span> <span class="operator">*</span>attributeNames() <span class="keyword">const</span>
    {
        <span class="keyword">static</span> <span class="type">char</span> <span class="keyword">const</span> <span class="operator">*</span><span class="keyword">const</span> names<span class="operator">[</span><span class="operator">]</span> <span class="operator">=</span> { <span class="string">"vertex"</span><span class="operator">,</span> <span class="number">0</span> };
        <span class="keyword">return</span> names;
    }

    <span class="type">void</span> initialize()
    {
        <span class="type"><a href="./qsgmaterialshader.htm#QSGMaterialShader" translate="no">QSGMaterialShader</a></span><span class="operator">::</span>initialize();
        m_id_matrix <span class="operator">=</span> program()<span class="operator">-</span><span class="operator">&gt;</span>uniformLocation(<span class="string">"matrix"</span>);
        m_id_opacity <span class="operator">=</span> program()<span class="operator">-</span><span class="operator">&gt;</span>uniformLocation(<span class="string">"opacity"</span>);
    }

    <span class="type">void</span> updateState(<span class="keyword">const</span> RenderState <span class="operator">&amp;</span>state<span class="operator">,</span> <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> <span class="operator">*</span>newMaterial<span class="operator">,</span> <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> <span class="operator">*</span>oldMaterial)
    {
        Q_ASSERT(program()<span class="operator">-</span><span class="operator">&gt;</span>isLinked());
        <span class="keyword">if</span> (state<span class="operator">.</span>isMatrixDirty())
            program()<span class="operator">-</span><span class="operator">&gt;</span>setUniformValue(m_id_matrix<span class="operator">,</span> state<span class="operator">.</span>combinedMatrix());
        <span class="keyword">if</span> (state<span class="operator">.</span>isOpacityDirty())
            program()<span class="operator">-</span><span class="operator">&gt;</span>setUniformValue(m_id_opacity<span class="operator">,</span> state<span class="operator">.</span>opacity());
    }

<span class="keyword">private</span>:
    <span class="type">int</span> m_id_matrix;
    <span class="type">int</span> m_id_opacity;
};</pre></div>
<div class="admonition note">
<p><b>Note: </b>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <a href="./qtquick-visualcanvas-scenegraph.htm#scene-graph-and-rendering" translate="no">Scene Graph and Rendering</a> for more information.</p>
</div>
</div>
<!-- @@@QSGMaterialShader -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QSGMaterialShader[overload1]$$$QSGMaterialShader -->
<h3 class="fn" id="QSGMaterialShader" translate="no"><a name="QSGMaterialShader"></a>QSGMaterialShader::<span class="name">QSGMaterialShader</span>()<a class="plink" href="#QSGMaterialShader" title="Direct link to this headline"></a></h3>
<p>Creates a new QSGMaterialShader.</p>
<!-- @@@QSGMaterialShader -->
<!-- $$$activate[overload1]$$$activate -->
<h3 class="fn" id="activate" translate="no"><a name="activate"></a><code translate="no">[virtual] </code><span class="type">void</span> QSGMaterialShader::<span class="name">activate</span>()<a class="plink" href="#activate" title="Direct link to this headline"></a></h3>
<p>This function is called by the scene graph to indicate that geometry is about to be rendered using this shader.</p>
<p>State that is global for all uses of the shader, independent of the geometry that is being drawn, can be setup in this function.</p>
<!-- @@@activate -->
<!-- $$$attributeNames[overload1]$$$attributeNames -->
<h3 class="fn" id="attributeNames" translate="no"><a name="attributeNames"></a><code translate="no">[pure virtual] </code>const <span class="type">char</span> *const *QSGMaterialShader::<span class="name">attributeNames</span>() const<a class="plink" href="#attributeNames" title="Direct link to this headline"></a></h3>
<p>Returns a zero-terminated array describing the names of the attributes used in the vertex shader.</p>
<p>This function is called when the shader is compiled to specify which attributes exist. The order of the attribute names defines the attribute register position in the vertex shader.</p>
<!-- @@@attributeNames -->
<!-- $$$compile[overload1]$$$compile -->
<h3 class="fn" id="compile" translate="no"><a name="compile"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QSGMaterialShader::<span class="name">compile</span>()<a class="plink" href="#compile" title="Direct link to this headline"></a></h3>
<p>This function is called when the shader is initialized to compile the actual <a href="./qopenglshaderprogram.htm" translate="no">QOpenGLShaderProgram</a>. Do not call it explicitly.</p>
<p>The default implementation will extract the <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>() and <a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a>() and bind the names returned from <a href="./qsgmaterialshader.htm#attributeNames" translate="no">attributeNames</a>() to consecutive vertex attribute registers starting at 0.</p>
<!-- @@@compile -->
<!-- $$$deactivate[overload1]$$$deactivate -->
<h3 class="fn" id="deactivate" translate="no"><a name="deactivate"></a><code translate="no">[virtual] </code><span class="type">void</span> QSGMaterialShader::<span class="name">deactivate</span>()<a class="plink" href="#deactivate" title="Direct link to this headline"></a></h3>
<p>This function is called by the scene graph to indicate that geometry will no longer to be rendered using this shader.</p>
<!-- @@@deactivate -->
<!-- $$$fragmentShader[overload1]$$$fragmentShader -->
<h3 class="fn" id="fragmentShader" translate="no"><a name="fragmentShader"></a><code translate="no">[virtual protected] </code>const <span class="type">char</span> *QSGMaterialShader::<span class="name">fragmentShader</span>() const<a class="plink" href="#fragmentShader" title="Direct link to this headline"></a></h3>
<p>Called when the shader is being initialized to get the fragment shader source code.</p>
<p>The contents returned from this function should never change.</p>
<!-- @@@fragmentShader -->
<!-- $$$initialize[overload1]$$$initialize -->
<h3 class="fn" id="initialize" translate="no"><a name="initialize"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QSGMaterialShader::<span class="name">initialize</span>()<a class="plink" href="#initialize" title="Direct link to this headline"></a></h3>
<p>Reimplement this function to do one-time initialization when the shader program is compiled. The OpenGL shader program is compiled and linked, but not bound, when this function is called.</p>
<!-- @@@initialize -->
<!-- $$$program[overload1]$$$program -->
<h3 class="fn" id="program" translate="no"><a name="program"></a><span class="type"><a href="./qopenglshaderprogram.htm" translate="no">QOpenGLShaderProgram</a></span> *QSGMaterialShader::<span class="name">program</span>()<a class="plink" href="#program" title="Direct link to this headline"></a></h3>
<p>Returns the shader program used by this <a href="./qsgmaterialshader.htm" translate="no">QSGMaterialShader</a>.</p>
<!-- @@@program -->
<!-- $$$setShaderSourceFile[overload1]$$$setShaderSourceFileQOpenGLShader::ShaderTypeconstQString& -->
<h3 class="fn" id="setShaderSourceFile" translate="no"><a name="setShaderSourceFile"></a><code translate="no">[protected] </code><span class="type">void</span> QSGMaterialShader::<span class="name">setShaderSourceFile</span>(<span class="type"><a href="./qopenglshader.htm#ShaderTypeBit-enum" translate="no">QOpenGLShader::ShaderType</a></span> <i>type</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>sourceFile</i>)<a class="plink" href="#setShaderSourceFile" title="Direct link to this headline"></a></h3>
<p>Sets the GLSL source file for the shader stage <i translate="no">type</i> to <i translate="no">sourceFile</i>. The default implementation of the <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>() and <a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a>() functions will load the source files set by this function.</p>
<p>This function is useful when you have a single source file for a given shader stage. If your shader consists of multiple source files then use <a href="./qsgmaterialshader.htm#setShaderSourceFiles" translate="no">setShaderSourceFiles</a>()</p>
<p><b>See also </b><a href="./qsgmaterialshader.htm#setShaderSourceFiles" translate="no">setShaderSourceFiles</a>(), <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>(), and <a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a>().</p>
<!-- @@@setShaderSourceFile -->
<!-- $$$setShaderSourceFiles[overload1]$$$setShaderSourceFilesQOpenGLShader::ShaderTypeconstQStringList& -->
<h3 class="fn" id="setShaderSourceFiles" translate="no"><a name="setShaderSourceFiles"></a><code translate="no">[protected] </code><span class="type">void</span> QSGMaterialShader::<span class="name">setShaderSourceFiles</span>(<span class="type"><a href="./qopenglshader.htm#ShaderTypeBit-enum" translate="no">QOpenGLShader::ShaderType</a></span> <i>type</i>, const <span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> &amp;<i>sourceFiles</i>)<a class="plink" href="#setShaderSourceFiles" title="Direct link to this headline"></a></h3>
<p>Sets the GLSL source files for the shader stage <i translate="no">type</i> to <i translate="no">sourceFiles</i>. The default implementation of the <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>() and <a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a>() functions will load the source files set by this function in the order given.</p>
<p><b>See also </b><a href="./qsgmaterialshader.htm#setShaderSourceFile" translate="no">setShaderSourceFile</a>(), <a href="./qsgmaterialshader.htm#vertexShader" translate="no">vertexShader</a>(), and <a href="./qsgmaterialshader.htm#fragmentShader" translate="no">fragmentShader</a>().</p>
<!-- @@@setShaderSourceFiles -->
<!-- $$$updateState[overload1]$$$updateStateconstQSGMaterialShader::RenderState&QSGMaterial*QSGMaterial* -->
<h3 class="fn" id="updateState" translate="no"><a name="updateState"></a><code translate="no">[virtual] </code><span class="type">void</span> QSGMaterialShader::<span class="name">updateState</span>(const <span class="type"><a href="./qsgmaterialshader-renderstate.htm" translate="no">QSGMaterialShader::RenderState</a></span> &amp;<i>state</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>newMaterial</i>, <span class="type"><a href="./qsgmaterial.htm" translate="no">QSGMaterial</a></span> *<i>oldMaterial</i>)<a class="plink" href="#updateState" title="Direct link to this headline"></a></h3>
<p>This function is called by the scene graph before geometry is rendered to make sure the shader is in the right state.</p>
<p>The current rendering <i translate="no">state</i> is passed from the scene graph. If the state indicates that any state is dirty, the updateState implementation must update accordingly for the geometry to render correctly.</p>
<p>The subclass specific state, such as the color of a flat color material, should be extracted from <i translate="no">newMaterial</i> to update the color uniforms accordingly.</p>
<p>The <i translate="no">oldMaterial</i> can be used to minimze state changes when updating material states. The <i translate="no">oldMaterial</i> is 0 if this shader was just activated.</p>
<p><b>See also </b><a href="./qsgmaterialshader.htm#activate" translate="no">activate</a>() and <a href="./qsgmaterialshader.htm#deactivate" translate="no">deactivate</a>().</p>
<!-- @@@updateState -->
<!-- $$$vertexShader[overload1]$$$vertexShader -->
<h3 class="fn" id="vertexShader" translate="no"><a name="vertexShader"></a><code translate="no">[virtual protected] </code>const <span class="type">char</span> *QSGMaterialShader::<span class="name">vertexShader</span>() const<a class="plink" href="#vertexShader" title="Direct link to this headline"></a></h3>
<p>Called when the shader is being initialized to get the vertex shader source code.</p>
<p>The contents returned from this function should never change.</p>
<!-- @@@vertexShader -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>