<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QGLWidget | Qt OpenGL</title>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtopengl-index.htm" translate="no">Qt OpenGL</a></li>
                            <li><a href="./qtopengl-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QGLWidget</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QGLWidget Class</h1>
<!-- $$$QGLWidget-brief -->
<p>The QGLWidget class is a widget for rendering OpenGL graphics. <a href="#details">More...</a></p>
<!-- @@@QGLWidget -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QGLWidget&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += opengl</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qwidget.htm" translate="no">QWidget</a></td></tr></tbody></table></div><p><b>This class is obsolete.</b> It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<ul>
<li><a href="./qglwidget-members.htm">List of all members, including inherited members</a></li>
<li><a href="./qglwidget-obsolete.htm">Obsolete members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#QGLWidget-2" translate="no">QGLWidget</a></b>(const QGLFormat &amp;<i>format</i>, QWidget *<i>parent</i> = nullptr, const QGLWidget *<i>shareWidget</i> = nullptr, Qt::WindowFlags <i>f</i> = Qt::WindowFlags())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#QGLWidget-1" translate="no">QGLWidget</a></b>(QGLContext *<i>context</i>, QWidget *<i>parent</i> = nullptr, const QGLWidget *<i>shareWidget</i> = nullptr, Qt::WindowFlags <i>f</i> = Qt::WindowFlags())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#QGLWidget" translate="no">QGLWidget</a></b>(QWidget *<i>parent</i> = nullptr, const QGLWidget *<i>shareWidget</i> = nullptr, Qt::WindowFlags <i>f</i> = Qt::WindowFlags())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#dtor.QGLWidget" translate="no">~QGLWidget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#bindTexture" translate="no">bindTexture</a></b>(const QImage &amp;<i>image</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#bindTexture-1" translate="no">bindTexture</a></b>(const QImage &amp;<i>image</i>, GLenum <i>target</i>, GLint <i>format</i>, QGLContext::BindOptions <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#bindTexture-2" translate="no">bindTexture</a></b>(const QPixmap &amp;<i>pixmap</i>, GLenum <i>target</i>, GLint <i>format</i>, QGLContext::BindOptions <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#bindTexture-3" translate="no">bindTexture</a></b>(const QPixmap &amp;<i>pixmap</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#bindTexture-4" translate="no">bindTexture</a></b>(const QString &amp;<i>fileName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QGLColormap &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#colormap" translate="no">colormap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLContext *</td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#context" translate="no">context</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#deleteTexture" translate="no">deleteTexture</a></b>(GLuint <i>id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#doneCurrent" translate="no">doneCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#doubleBuffer" translate="no">doubleBuffer</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#drawTexture" translate="no">drawTexture</a></b>(const QRectF &amp;<i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#drawTexture-1" translate="no">drawTexture</a></b>(const QPointF &amp;<i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFormat </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#format" translate="no">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#grabFrameBuffer" translate="no">grabFrameBuffer</a></b>(bool <i>withAlpha</i> = false)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#isSharing" translate="no">isSharing</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#makeCurrent" translate="no">makeCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#makeOverlayCurrent" translate="no">makeOverlayCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QGLContext *</td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#overlayContext" translate="no">overlayContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#qglClearColor" translate="no">qglClearColor</a></b>(const QColor &amp;<i>c</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#qglColor" translate="no">qglColor</a></b>(const QColor &amp;<i>c</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#renderPixmap" translate="no">renderPixmap</a></b>(int <i>w</i> = 0, int <i>h</i> = 0, bool <i>useContext</i> = false)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#renderText" translate="no">renderText</a></b>(int <i>x</i>, int <i>y</i>, const QString &amp;<i>str</i>, const QFont &amp;<i>font</i> = QFont())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#renderText-1" translate="no">renderText</a></b>(double <i>x</i>, double <i>y</i>, double <i>z</i>, const QString &amp;<i>str</i>, const QFont &amp;<i>font</i> = QFont())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#setColormap" translate="no">setColormap</a></b>(const QGLColormap &amp;<i>cmap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#swapBuffers" translate="no">swapBuffers</a></b>()</td></tr>
</tbody></table></div>
<a name="public-slots"></a>
<h2 id="public-slots">Public Slots<a class="plink" href="#public-slots" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#updateGL" translate="no">updateGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#updateOverlayGL" translate="no">updateOverlayGL</a></b>()</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QImage </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#convertToGLFormat" translate="no">convertToGLFormat</a></b>(const QImage &amp;<i>img</i>)</td></tr>
</tbody></table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions<a class="plink" href="#protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#autoBufferSwap" translate="no">autoBufferSwap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#glDraw" translate="no">glDraw</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#glInit" translate="no">glInit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#initializeOverlayGL" translate="no">initializeOverlayGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#paintGL" translate="no">paintGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#paintOverlayGL" translate="no">paintOverlayGL</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a></b>(int <i>width</i>, int <i>height</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#resizeOverlayGL" translate="no">resizeOverlayGL</a></b>(int <i>width</i>, int <i>height</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#setAutoBufferSwap" translate="no">setAutoBufferSwap</a></b>(bool <i>on</i>)</td></tr>
</tbody></table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">Reimplemented Protected Functions<a class="plink" href="#reimplemented-protected-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#event" translate="no">event</a></b>(QEvent *<i>e</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#paintEvent" translate="no">paintEvent</a></b>(QPaintEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qglwidget.htm#resizeEvent" translate="no">resizeEvent</a></b>(QResizeEvent *<i>event</i>) override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QGLWidget-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QGLWidget provides functionality for displaying OpenGL graphics integrated into a Qt application. It is very simple to use. You inherit from it and use the subclass like any other <a href="./qwidget.htm" translate="no">QWidget</a>, except that you have the choice between using <a href="./qpainter.htm" translate="no">QPainter</a> and standard OpenGL rendering commands.</p>
<div class="admonition note">
<p><b>Note: </b>This class is part of the legacy <a href="./qtopengl-index.htm" translate="no">Qt OpenGL</a> module and, like the other <code translate="no">QGL</code> classes, should be avoided in the new applications. Instead, starting from Qt 5.4, prefer using <a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a> and the <code translate="no">QOpenGL</code> classes.</p>
</div>
<p>QGLWidget provides three convenient virtual functions that you can reimplement in your subclass to perform the typical OpenGL tasks:</p>
<ul>
<li><a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() - Renders the OpenGL scene. Gets called whenever the widget needs to be updated.</li>
<li><a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a>() - Sets up the OpenGL viewport, projection, etc. Gets called whenever the widget has been resized (and also when it is shown for the first time because all newly created widgets get a resize event automatically).</li>
<li><a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() - Sets up the OpenGL rendering context, defines display lists, etc. Gets called once before the first time <a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a>() or <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() is called.</li>
</ul>
<p>Here is a rough outline of how a QGLWidget subclass might look:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> MyGLDrawer : <span class="keyword">public</span> <span class="type"><a href="./qglwidget.htm#QGLWidget" translate="no">QGLWidget</a></span>
{
    Q_OBJECT        <span class="comment">// must include this if you use Qt signals/slots</span>

<span class="keyword">public</span>:
    MyGLDrawer(<span class="type"><a href="./qwidget.htm#QWidget" translate="no">QWidget</a></span> <span class="operator">*</span>parent)
        : <span class="type"><a href="./qglwidget.htm#QGLWidget" translate="no">QGLWidget</a></span>(parent) {}

<span class="keyword">protected</span>:

    <span class="type">void</span> initializeGL() override
    {
        <span class="comment">// Set up the rendering context, define display lists etc.:</span>
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        glClearColor(<span class="number">0.0</span><span class="operator">,</span> <span class="number">0.0</span><span class="operator">,</span> <span class="number">0.0</span><span class="operator">,</span> <span class="number">0.0</span>);
        glEnable(GL_DEPTH_TEST);
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
    }

    <span class="type">void</span> resizeGL(<span class="type">int</span> w<span class="operator">,</span> <span class="type">int</span> h) override
    {
        <span class="comment">// setup viewport, projection etc.:</span>
        glViewport(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> (GLint)w<span class="operator">,</span> (GLint)h);
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        glFrustum(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
    }

    <span class="type">void</span> paintGL() override
    {
        <span class="comment">// draw the scene:</span>
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        glRotatef(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
        glMaterialfv(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
        glBegin(GL_QUADS);
        glVertex3f(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
        glVertex3f(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
        glEnd();
        <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
    }

};</pre></div>
<p>If you need to trigger a repaint from places other than <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() (a typical example is when using <a href="./qtimer.htm" translate="no">timers</a> to animate scenes), you should call the widget's <a href="./qglwidget.htm#updateGL" translate="no">updateGL</a>() function.</p>
<p>Your widget's OpenGL rendering context is made current when <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>(), <a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a>(), or <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() is called. If you need to call the standard OpenGL API functions from other places (e.g. in your widget's constructor or in your own paint functions), you must call <a href="./qglwidget.htm#makeCurrent" translate="no">makeCurrent</a>() first.</p>
<p>QGLWidget provides functions for requesting a new display <a href="./qglformat.htm" translate="no">format</a> and you can also create widgets with customized rendering <a href="./qglcontext.htm" translate="no">contexts</a>.</p>
<p>You can also share OpenGL display lists between QGLWidget objects (see the documentation of the QGLWidget constructors for details).</p>
<p>Note that under Windows, the <a href="./qglcontext.htm" translate="no">QGLContext</a> belonging to a QGLWidget has to be recreated when the QGLWidget is reparented. This is necessary due to limitations on the Windows platform. This will most likely cause problems for users that have subclassed and installed their own <a href="./qglcontext.htm" translate="no">QGLContext</a> on a QGLWidget. It is possible to work around this issue by putting the QGLWidget inside a dummy widget and then reparenting the dummy widget, instead of the QGLWidget. This will side-step the issue altogether, and is what we recommend for users that need this kind of functionality.</p>
<p>On macOS, when Qt is built with Cocoa support, a QGLWidget can't have any sibling widgets placed ontop of itself. This is due to limitations in the Cocoa API and is not supported by Apple.</p>
<a name="overlays"></a>
<h3 id="overlays">Overlays<a class="plink" href="#overlays" title="Direct link to this headline"></a></h3>
<p>The QGLWidget creates a GL overlay context in addition to the normal context if overlays are supported by the underlying system.</p>
<p>If you want to use overlays, you specify it in the <a href="./qglformat.htm" translate="no">format</a>. (Note: Overlay must be requested in the format passed to the QGLWidget constructor.) Your GL widget should also implement some or all of these virtual methods:</p>
<ul>
<li><a href="./qglwidget.htm#paintOverlayGL" translate="no">paintOverlayGL</a>()</li>
<li><a href="./qglwidget.htm#resizeOverlayGL" translate="no">resizeOverlayGL</a>()</li>
<li><a href="./qglwidget.htm#initializeOverlayGL" translate="no">initializeOverlayGL</a>()</li>
</ul>
<p>These methods work in the same way as the normal <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() etc. functions, except that they will be called when the overlay context is made current. You can explicitly make the overlay context current by using <a href="./qglwidget.htm#makeOverlayCurrent" translate="no">makeOverlayCurrent</a>(), and you can access the overlay context directly (e.g. to ask for its transparent color) by calling <a href="./qglwidget.htm#overlayContext" translate="no">overlayContext</a>().</p>
<p>On X servers in which the default visual is in an overlay plane, non-GL Qt windows can also be used for overlays.</p>
<a name="painting-techniques"></a>
<h3 id="painting-techniques">Painting Techniques<a class="plink" href="#painting-techniques" title="Direct link to this headline"></a></h3>
<p>As described above, subclass QGLWidget to render pure 3D content in the following way:</p>
<ul>
<li>Reimplement the <a href="./qglwidget.htm#initializeGL" translate="no">QGLWidget::initializeGL</a>() and <a href="./qglwidget.htm#resizeGL" translate="no">QGLWidget::resizeGL</a>() to set up the OpenGL state and provide a perspective transformation.</li>
<li>Reimplement <a href="./qglwidget.htm#paintGL" translate="no">QGLWidget::paintGL</a>() to paint the 3D scene, calling only OpenGL functions to draw on the widget.</li>
</ul>
<p>It is also possible to draw 2D graphics onto a QGLWidget subclass, it is necessary to reimplement <a href="./qglwidget.htm#paintEvent" translate="no">QGLWidget::paintEvent</a>() and do the following:</p>
<ul>
<li>Construct a <a href="./qpainter.htm" translate="no">QPainter</a> object.</li>
<li>Initialize it for use on the widget with the <a href="./qpainter.htm#begin" translate="no">QPainter::begin</a>() function.</li>
<li>Draw primitives using <a href="./qpainter.htm" translate="no">QPainter</a>'s member functions.</li>
<li>Call <a href="./qpainter.htm#end" translate="no">QPainter::end</a>() to finish painting.</li>
</ul>
<a name="threading"></a>
<h3 id="threading">Threading<a class="plink" href="#threading" title="Direct link to this headline"></a></h3>
<p>As of Qt version 4.8, support for doing threaded GL rendering has been improved. There are three scenarios that we currently support:</p>
<ul>
<li>1. Buffer swapping in a thread.<p>Swapping buffers in a double buffered context may be a synchronous, locking call that may be a costly operation in some GL implementations. Especially so on embedded devices. It's not optimal to have the CPU idling while the GPU is doing a buffer swap. In those cases it is possible to do the rendering in the main thread and do the actual buffer swap in a separate thread. This can be done with the following steps:</p>
<p>1. Call <a href="./qglwidget.htm#doneCurrent" translate="no">doneCurrent</a>() in the main thread when the rendering is finished.</p>
<p>2. Call <a href="./qglcontext.htm#moveToThread" translate="no">QGLContext::moveToThread</a>(swapThread) to transfer ownership of the context to the swapping thread.</p>
<p>3. Notify the swapping thread that it can grab the context.</p>
<p>4. Make the rendering context current in the swapping thread with <a href="./qglwidget.htm#makeCurrent" translate="no">makeCurrent</a>() and then call <a href="./qglwidget.htm#swapBuffers" translate="no">swapBuffers</a>().</p>
<p>5. Call <a href="./qglwidget.htm#doneCurrent" translate="no">doneCurrent</a>() in the swapping thread.</p>
<p>6. Call <a href="./qglcontext.htm#moveToThread" translate="no">QGLContext::moveToThread</a>(<a href="./qapplication.htm#qApp" translate="no">qApp</a>-&gt;<a href="./qobject.htm#thread" translate="no">thread</a>()) and notify the main thread that swapping is done.</p>
<p>Doing this will free up the main thread so that it can continue with, for example, handling UI events or network requests. Even if there is a context swap involved, it may be preferable compared to having the main thread wait while the GPU finishes the swap operation. Note that this is highly implementation dependent.</p>
</li>
<li>2. Texture uploading in a thread.<p>Doing texture uploads in a thread may be very useful for applications handling large amounts of images that needs to be displayed, like for instance a photo gallery application. This is supported in Qt through the existing <a href="./qglwidget.htm#bindTexture" translate="no">bindTexture</a>() API. A simple way of doing this is to create two sharing QGLWidgets. One is made current in the main GUI thread, while the other is made current in the texture upload thread. The widget in the uploading thread is never shown, it is only used for sharing textures with the main thread. For each texture that is bound via <a href="./qglwidget.htm#bindTexture" translate="no">bindTexture</a>(), notify the main thread so that it can start using the texture.</p>
</li>
<li>3. Using <a href="./qpainter.htm" translate="no">QPainter</a> to draw into a QGLWidget in a thread.<p>In Qt 4.8, it is possible to draw into a QGLWidget using a <a href="./qpainter.htm" translate="no">QPainter</a> in a separate thread. Note that this is also possible for QGLPixelBuffers and QGLFramebufferObjects. Since this is only supported in the GL 2 paint engine, OpenGL 2.0 or OpenGL ES 2.0 is required.</p>
<p>QGLWidgets can only be created in the main GUI thread. This means a call to <a href="./qglwidget.htm#doneCurrent" translate="no">doneCurrent</a>() is necessary to release the GL context from the main thread, before the widget can be drawn into by another thread. You then need to call <a href="./qglcontext.htm#moveToThread" translate="no">QGLContext::moveToThread</a>() to transfer ownership of the context to the thread in which you want to make it current. Also, the main GUI thread will dispatch resize and paint events to a QGLWidget when the widget is resized, or parts of it becomes exposed or needs redrawing. It is therefore necessary to handle those events because the default implementations inside QGLWidget will try to make the QGLWidget's context current, which again will interfere with any threads rendering into the widget. Reimplement <a href="./qglwidget.htm#paintEvent" translate="no">QGLWidget::paintEvent</a>() and <a href="./qglwidget.htm#resizeEvent" translate="no">QGLWidget::resizeEvent</a>() to notify the rendering thread that a resize or update is necessary, and be careful not to call the base class implementation. If you are rendering an animation, it might not be necessary to handle the paint event at all since the rendering thread is doing regular updates. Then it would be enough to reimplement <a href="./qglwidget.htm#paintEvent" translate="no">QGLWidget::paintEvent</a>() to do nothing.</p>
</li>
</ul>
<p>As a general rule when doing threaded rendering: be aware that binding and releasing contexts in different threads have to be synchronized by the user. A GL rendering context can only be current in one thread at any time. If you try to open a <a href="./qpainter.htm" translate="no">QPainter</a> on a QGLWidget and the widget's rendering context is current in another thread, it will fail.</p>
<p>In addition to this, rendering using raw GL calls in a separate thread is supported.</p>
<p><i>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</i></p>
</div>
<p><b>See also </b><a href="./qopenglwidget.htm" translate="no">QOpenGLWidget</a> and <a href="./qglpixelbuffer.htm" translate="no">QGLPixelBuffer</a>.</p>
<!-- @@@QGLWidget -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QGLWidget$$$QGLWidgetconstQGLFormat&QWidget*constQGLWidget*Qt::WindowFlags -->
<h3 class="fn" id="QGLWidget-2" translate="no"><a name="QGLWidget-2"></a>QGLWidget::<span class="name">QGLWidget</span>(const <span class="type"><a href="./qglformat.htm" translate="no">QGLFormat</a></span> &amp;<i>format</i>, <span class="type"><a href="./qwidget.htm#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr, const <span class="type"><a href="./qglwidget.htm#QGLWidget" translate="no">QGLWidget</a></span> *<i>shareWidget</i> = nullptr, <span class="type"><a href="./qt.htm#WindowType-enum" translate="no">Qt::WindowFlags</a></span> <i>f</i> = Qt::WindowFlags())<a class="plink" href="#QGLWidget-2" title="Direct link to this headline"></a></h3>
<p>Constructs an OpenGL widget with parent <i translate="no">parent</i>.</p>
<p>The <i translate="no">format</i> argument specifies the desired <a href="./qglformat.htm" translate="no">rendering options</a>. If the underlying OpenGL/Window system cannot satisfy all the features requested in <i translate="no">format</i>, the nearest subset of features will be used. After creation, the <a href="./qglwidget.htm#format" translate="no">format</a>() method will return the actual format obtained.</p>
<p>The widget will be <a href="./qglwidget.htm#isValid" translate="no">invalid</a> if the system has no <a href="./qglformat.htm#hasOpenGL" translate="no">OpenGL support</a>.</p>
<p>The <i translate="no">parent</i> and widget flag, <i translate="no">f</i>, arguments are passed to the <a href="./qwidget.htm" translate="no">QWidget</a> constructor.</p>
<p>If <i translate="no">shareWidget</i> is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with <i translate="no">shareWidget</i>. But if <i translate="no">shareWidget</i> and this widget have different <a href="./qglwidget.htm#format" translate="no">formats</a>, sharing might not be possible. You can check whether sharing is in effect by calling <a href="./qglwidget.htm#isSharing" translate="no">isSharing</a>().</p>
<p>The initialization of OpenGL rendering state, etc. should be done by overriding the <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() function, rather than in the constructor of your QGLWidget subclass.</p>
<p><b>See also </b><a href="./qglformat.htm#defaultFormat" translate="no">QGLFormat::defaultFormat</a>() and <a href="./qglwidget.htm#isValid" translate="no">isValid</a>().</p>
<!-- @@@QGLWidget -->
<!-- $$$QGLWidget$$$QGLWidgetQGLContext*QWidget*constQGLWidget*Qt::WindowFlags -->
<h3 class="fn" id="QGLWidget-1" translate="no"><a name="QGLWidget-1"></a>QGLWidget::<span class="name">QGLWidget</span>(<span class="type"><a href="./qglcontext.htm" translate="no">QGLContext</a></span> *<i>context</i>, <span class="type"><a href="./qwidget.htm#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr, const <span class="type"><a href="./qglwidget.htm#QGLWidget" translate="no">QGLWidget</a></span> *<i>shareWidget</i> = nullptr, <span class="type"><a href="./qt.htm#WindowType-enum" translate="no">Qt::WindowFlags</a></span> <i>f</i> = Qt::WindowFlags())<a class="plink" href="#QGLWidget-1" title="Direct link to this headline"></a></h3>
<p>Constructs an OpenGL widget with parent <i translate="no">parent</i>.</p>
<p>The <i translate="no">context</i> argument is a pointer to the QGLContext that you wish to be bound to this widget. This allows you to pass in your own QGLContext sub-classes.</p>
<p>The widget will be <a href="./qglwidget.htm#isValid" translate="no">invalid</a> if the system has no <a href="./qglformat.htm#hasOpenGL" translate="no">OpenGL support</a>.</p>
<p>The <i translate="no">parent</i> and widget flag, <i translate="no">f</i>, arguments are passed to the <a href="./qwidget.htm" translate="no">QWidget</a> constructor.</p>
<p>If <i translate="no">shareWidget</i> is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with <i translate="no">shareWidget</i>. But if <i translate="no">shareWidget</i> and this widget have different <a href="./qglwidget.htm#format" translate="no">formats</a>, sharing might not be possible. You can check whether sharing is in effect by calling <a href="./qglwidget.htm#isSharing" translate="no">isSharing</a>().</p>
<p>The initialization of OpenGL rendering state, etc. should be done by overriding the <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() function, rather than in the constructor of your QGLWidget subclass.</p>
<p><b>See also </b><a href="./qglformat.htm#defaultFormat" translate="no">QGLFormat::defaultFormat</a>() and <a href="./qglwidget.htm#isValid" translate="no">isValid</a>().</p>
<!-- @@@QGLWidget -->
<!-- $$$QGLWidget[overload1]$$$QGLWidgetQWidget*constQGLWidget*Qt::WindowFlags -->
<h3 class="fn" id="QGLWidget" translate="no"><a name="QGLWidget"></a>QGLWidget::<span class="name">QGLWidget</span>(<span class="type"><a href="./qwidget.htm#QWidget" translate="no">QWidget</a></span> *<i>parent</i> = nullptr, const <span class="type"><a href="./qglwidget.htm#QGLWidget" translate="no">QGLWidget</a></span> *<i>shareWidget</i> = nullptr, <span class="type"><a href="./qt.htm#WindowType-enum" translate="no">Qt::WindowFlags</a></span> <i>f</i> = Qt::WindowFlags())<a class="plink" href="#QGLWidget" title="Direct link to this headline"></a></h3>
<p>Constructs an OpenGL widget with a <i translate="no">parent</i> widget.</p>
<p>The <a href="./qglformat.htm#defaultFormat" translate="no">default format</a> is used. The widget will be <a href="./qglwidget.htm#isValid" translate="no">invalid</a> if the system has no <a href="./qglformat.htm#hasOpenGL" translate="no">OpenGL support</a>.</p>
<p>The <i translate="no">parent</i> and widget flag, <i translate="no">f</i>, arguments are passed to the <a href="./qwidget.htm" translate="no">QWidget</a> constructor.</p>
<p>If <i translate="no">shareWidget</i> is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with <i translate="no">shareWidget</i>. But if <i translate="no">shareWidget</i> and this widget have different <a href="./qglwidget.htm#format" translate="no">formats</a>, sharing might not be possible. You can check whether sharing is in effect by calling <a href="./qglwidget.htm#isSharing" translate="no">isSharing</a>().</p>
<p>The initialization of OpenGL rendering state, etc. should be done by overriding the <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() function, rather than in the constructor of your QGLWidget subclass.</p>
<p><b>See also </b><a href="./qglformat.htm#defaultFormat" translate="no">QGLFormat::defaultFormat</a>() and <a href="./qtopengl-textures-example.htm" translate="no">Textures Example</a>.</p>
<!-- @@@QGLWidget -->
<!-- $$$updateGL[overload1]$$$updateGL -->
<h3 class="fn" id="updateGL" translate="no"><a name="updateGL"></a><code translate="no">[virtual slot] </code><span class="type">void</span> QGLWidget::<span class="name">updateGL</span>()<a class="plink" href="#updateGL" title="Direct link to this headline"></a></h3>
<p>Updates the widget by calling <a href="./qglwidget.htm#glDraw" translate="no">glDraw</a>().</p>
<!-- @@@updateGL -->
<!-- $$$updateOverlayGL[overload1]$$$updateOverlayGL -->
<h3 class="fn" id="updateOverlayGL" translate="no"><a name="updateOverlayGL"></a><code translate="no">[virtual slot] </code><span class="type">void</span> QGLWidget::<span class="name">updateOverlayGL</span>()<a class="plink" href="#updateOverlayGL" title="Direct link to this headline"></a></h3>
<p>Updates the widget's overlay (if any). Will cause the virtual function <a href="./qglwidget.htm#paintOverlayGL" translate="no">paintOverlayGL</a>() to be executed.</p>
<p>The widget's rendering context will become the current context and <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() will be called if it hasn't already been called.</p>
<!-- @@@updateOverlayGL -->
<!-- $$$~QGLWidget[overload1]$$$~QGLWidget -->
<h3 class="fn" id="dtor.QGLWidget" translate="no"><a name="dtor.QGLWidget"></a><code translate="no">[virtual] </code>QGLWidget::<span class="name">~QGLWidget</span>()<a class="plink" href="#dtor.QGLWidget" title="Direct link to this headline"></a></h3>
<p>Destroys the widget.</p>
<!-- @@@~QGLWidget -->
<!-- $$$autoBufferSwap[overload1]$$$autoBufferSwap -->
<h3 class="fn" id="autoBufferSwap" translate="no"><a name="autoBufferSwap"></a><code translate="no">[protected] </code><span class="type">bool</span> QGLWidget::<span class="name">autoBufferSwap</span>() const<a class="plink" href="#autoBufferSwap" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the widget is doing automatic GL buffer swapping; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qglwidget.htm#setAutoBufferSwap" translate="no">setAutoBufferSwap</a>().</p>
<!-- @@@autoBufferSwap -->
<!-- $$$bindTexture[overload1]$$$bindTextureconstQImage&GLenumGLint -->
<h3 class="fn" id="bindTexture" translate="no"><a name="bindTexture"></a><span class="type">GLuint</span> QGLWidget::<span class="name">bindTexture</span>(const <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D, <span class="type">GLint</span> <i>format</i> = GL_RGBA)<a class="plink" href="#bindTexture" title="Direct link to this headline"></a></h3>
<p>Calls QGLContext:::bindTexture(<i translate="no">image</i>, <i translate="no">target</i>, <i translate="no">format</i>) on the currently set context.</p>
<p><b>See also </b><a href="./qglwidget.htm#deleteTexture" translate="no">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQImage&GLenumGLintQGLContext::BindOptions -->
<h3 class="fn" id="bindTexture-1" translate="no"><a name="bindTexture-1"></a><span class="type">GLuint</span> QGLWidget::<span class="name">bindTexture</span>(const <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> &amp;<i>image</i>, <span class="type">GLenum</span> <i>target</i>, <span class="type">GLint</span> <i>format</i>, <span class="type"><a href="./qglcontext.htm#BindOption-enum" translate="no">QGLContext::BindOptions</a></span> <i>options</i>)<a class="plink" href="#bindTexture-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>The binding <i translate="no">options</i> are a set of options used to decide how to bind the texture to the context.</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQPixmap&GLenumGLintQGLContext::BindOptions -->
<h3 class="fn" id="bindTexture-2" translate="no"><a name="bindTexture-2"></a><span class="type">GLuint</span> QGLWidget::<span class="name">bindTexture</span>(const <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> &amp;<i>pixmap</i>, <span class="type">GLenum</span> <i>target</i>, <span class="type">GLint</span> <i>format</i>, <span class="type"><a href="./qglcontext.htm#BindOption-enum" translate="no">QGLContext::BindOptions</a></span> <i>options</i>)<a class="plink" href="#bindTexture-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture to the current context, based on <i translate="no">pixmap</i>. The generated texture id is returned and can be used in</p>
<p>The binding <i translate="no">options</i> are a set of options used to decide how to bind the texture to the context.</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQPixmap&GLenumGLint -->
<h3 class="fn" id="bindTexture-3" translate="no"><a name="bindTexture-3"></a><span class="type">GLuint</span> QGLWidget::<span class="name">bindTexture</span>(const <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> &amp;<i>pixmap</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D, <span class="type">GLint</span> <i>format</i> = GL_RGBA)<a class="plink" href="#bindTexture-3" title="Direct link to this headline"></a></h3>
<p>Calls QGLContext:::bindTexture(<i translate="no">pixmap</i>, <i translate="no">target</i>, <i translate="no">format</i>) on the currently set context.</p>
<p><b>See also </b><a href="./qglwidget.htm#deleteTexture" translate="no">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQString& -->
<h3 class="fn" id="bindTexture-4" translate="no"><a name="bindTexture-4"></a><span class="type">GLuint</span> QGLWidget::<span class="name">bindTexture</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>fileName</i>)<a class="plink" href="#bindTexture-4" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Calls <a href="./qglcontext.htm#bindTexture" translate="no">QGLContext::bindTexture</a>(<i translate="no">fileName</i>) on the currently set context.</p>
<p><b>See also </b><a href="./qglwidget.htm#deleteTexture" translate="no">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$colormap[overload1]$$$colormap -->
<h3 class="fn" id="colormap" translate="no"><a name="colormap"></a>const <span class="type"><a href="./qglcolormap.htm" translate="no">QGLColormap</a></span> &amp;QGLWidget::<span class="name">colormap</span>() const<a class="plink" href="#colormap" title="Direct link to this headline"></a></h3>
<p>Returns the colormap for this widget.</p>
<p>Usually it is only top-level widgets that can have different colormaps installed. Asking for the colormap of a child widget will return the colormap for the child's top-level widget.</p>
<p>If no colormap has been set for this widget, the QGLColormap returned will be empty.</p>
<p><b>See also </b><a href="./qglwidget.htm#setColormap" translate="no">setColormap</a>() and <a href="./qglcolormap.htm#isEmpty" translate="no">QGLColormap::isEmpty</a>().</p>
<!-- @@@colormap -->
<!-- $$$context[overload1]$$$context -->
<h3 class="fn" id="context" translate="no"><a name="context"></a><span class="type"><a href="./qglcontext.htm" translate="no">QGLContext</a></span> *QGLWidget::<span class="name">context</span>() const<a class="plink" href="#context" title="Direct link to this headline"></a></h3>
<p>Returns the context of this widget.</p>
<p>It is possible that the context is not valid (see <a href="./qglwidget.htm#isValid" translate="no">isValid</a>()), for example, if the underlying hardware does not support the format attributes that were requested.</p>
<p><b>See also </b><a href="./qglwidget-obsolete.htm#setContext" translate="no">setContext</a>().</p>
<!-- @@@context -->
<!-- $$$convertToGLFormat[overload1]$$$convertToGLFormatconstQImage& -->
<h3 class="fn" id="convertToGLFormat" translate="no"><a name="convertToGLFormat"></a><code translate="no">[static] </code><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QGLWidget::<span class="name">convertToGLFormat</span>(const <span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> &amp;<i>img</i>)<a class="plink" href="#convertToGLFormat" title="Direct link to this headline"></a></h3>
<p>Converts the image <i translate="no">img</i> into the unnamed format expected by OpenGL functions such as glTexImage2D(). The returned image is not usable as a <a href="./qimage.htm" translate="no">QImage</a>, but <a href="./qimage.htm#width" translate="no">QImage::width</a>(), <a href="./qimage.htm#height" translate="no">QImage::height</a>() and <a href="./qimage.htm#bits" translate="no">QImage::bits</a>() may be used with OpenGL. The GL format used is <code translate="no">GL_RGBA</code>.</p>
<!-- @@@convertToGLFormat -->
<!-- $$$deleteTexture[overload1]$$$deleteTextureGLuint -->
<h3 class="fn" id="deleteTexture" translate="no"><a name="deleteTexture"></a><span class="type">void</span> QGLWidget::<span class="name">deleteTexture</span>(<span class="type">GLuint</span> <i>id</i>)<a class="plink" href="#deleteTexture" title="Direct link to this headline"></a></h3>
<p>Calls <a href="./qglcontext.htm#deleteTexture" translate="no">QGLContext::deleteTexture</a>(<i translate="no">id</i>) on the currently set context.</p>
<p><b>See also </b><a href="./qglwidget.htm#bindTexture" translate="no">bindTexture</a>().</p>
<!-- @@@deleteTexture -->
<!-- $$$doneCurrent[overload1]$$$doneCurrent -->
<h3 class="fn" id="doneCurrent" translate="no"><a name="doneCurrent"></a><span class="type">void</span> QGLWidget::<span class="name">doneCurrent</span>()<a class="plink" href="#doneCurrent" title="Direct link to this headline"></a></h3>
<p>Makes no GL context the current context. Normally, you do not need to call this function; QGLContext calls it as necessary. However, it may be useful in multithreaded environments.</p>
<!-- @@@doneCurrent -->
<!-- $$$doubleBuffer[overload1]$$$doubleBuffer -->
<h3 class="fn" id="doubleBuffer" translate="no"><a name="doubleBuffer"></a><span class="type">bool</span> QGLWidget::<span class="name">doubleBuffer</span>() const<a class="plink" href="#doubleBuffer" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the contained GL rendering context has double buffering; otherwise returns <code translate="no">false</code>.</p>
<p><b>See also </b><a href="./qglformat.htm#doubleBuffer" translate="no">QGLFormat::doubleBuffer</a>().</p>
<!-- @@@doubleBuffer -->
<!-- $$$drawTexture[overload1]$$$drawTextureconstQRectF&GLuintGLenum -->
<h3 class="fn" id="drawTexture" translate="no"><a name="drawTexture"></a><span class="type">void</span> QGLWidget::<span class="name">drawTexture</span>(const <span class="type"><a href="./qrectf.htm" translate="no">QRectF</a></span> &amp;<i>target</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)<a class="plink" href="#drawTexture" title="Direct link to this headline"></a></h3>
<p>Calls the corresponding <a href="./qglcontext.htm#drawTexture" translate="no">QGLContext::drawTexture</a>() with <i translate="no">target</i>, <i translate="no">textureId</i>, and <i translate="no">textureTarget</i> for this widget's context.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$drawTexture$$$drawTextureconstQPointF&GLuintGLenum -->
<h3 class="fn" id="drawTexture-1" translate="no"><a name="drawTexture-1"></a><span class="type">void</span> QGLWidget::<span class="name">drawTexture</span>(const <span class="type"><a href="./qpointf.htm" translate="no">QPointF</a></span> &amp;<i>point</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)<a class="plink" href="#drawTexture-1" title="Direct link to this headline"></a></h3>
<p>Calls the corresponding <a href="./qglcontext.htm#drawTexture" translate="no">QGLContext::drawTexture</a>() with <i translate="no">point</i>, <i translate="no">textureId</i>, and <i translate="no">textureTarget</i> for this widget's context.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event" translate="no"><a name="event"></a><code translate="no">[override virtual protected] </code><span class="type">bool</span> QGLWidget::<span class="name">event</span>(<span class="type"><a href="./qevent.htm" translate="no">QEvent</a></span> *<i>e</i>)<a class="plink" href="#event" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwidget.htm#event" translate="no">QWidget::event</a>(QEvent *event).</p>
<!-- @@@event -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format" translate="no"><a name="format"></a><span class="type"><a href="./qglformat.htm" translate="no">QGLFormat</a></span> QGLWidget::<span class="name">format</span>() const<a class="plink" href="#format" title="Direct link to this headline"></a></h3>
<p>Returns the format of the contained GL rendering context.</p>
<p><b>See also </b><a href="./qglwidget-obsolete.htm#setFormat" translate="no">setFormat</a>().</p>
<!-- @@@format -->
<!-- $$$glDraw[overload1]$$$glDraw -->
<h3 class="fn" id="glDraw" translate="no"><a name="glDraw"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">glDraw</span>()<a class="plink" href="#glDraw" title="Direct link to this headline"></a></h3>
<p>Executes the virtual function <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>().</p>
<p>The widget's rendering context will become the current context and <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() will be called if it hasn't already been called.</p>
<!-- @@@glDraw -->
<!-- $$$glInit[overload1]$$$glInit -->
<h3 class="fn" id="glInit" translate="no"><a name="glInit"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">glInit</span>()<a class="plink" href="#glInit" title="Direct link to this headline"></a></h3>
<p>Initializes OpenGL for this widget's context. Calls the virtual function <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>().</p>
<!-- @@@glInit -->
<!-- $$$grabFrameBuffer[overload1]$$$grabFrameBufferbool -->
<h3 class="fn" id="grabFrameBuffer" translate="no"><a name="grabFrameBuffer"></a><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QGLWidget::<span class="name">grabFrameBuffer</span>(<span class="type">bool</span> <i>withAlpha</i> = false)<a class="plink" href="#grabFrameBuffer" title="Direct link to this headline"></a></h3>
<p>Returns an image of the frame buffer. If <i translate="no">withAlpha</i> is true the alpha channel is included.</p>
<p>Depending on your hardware, you can explicitly select which color buffer to grab with a glReadBuffer() call before calling this function.</p>
<p>On QNX the back buffer is not preserved when <a href="./qglwidget.htm#swapBuffers" translate="no">swapBuffers</a>() is called. The back buffer where this function reads from, might thus not contain the same content as the front buffer. In order to retrieve what is currently visible on the screen, <a href="./qglwidget.htm#swapBuffers" translate="no">swapBuffers</a>() has to be executed prior to this function call.</p>
<!-- @@@grabFrameBuffer -->
<!-- $$$initializeGL[overload1]$$$initializeGL -->
<h3 class="fn" id="initializeGL" translate="no"><a name="initializeGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">initializeGL</span>()<a class="plink" href="#initializeGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is called once before the first call to <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() or <a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a>(), and then once whenever the widget has been assigned a new QGLContext. Reimplement it in a subclass.</p>
<p>This function should set up any required OpenGL context rendering flags, defining display lists, etc.</p>
<p>There is no need to call <a href="./qglwidget.htm#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called.</p>
<!-- @@@initializeGL -->
<!-- $$$initializeOverlayGL[overload1]$$$initializeOverlayGL -->
<h3 class="fn" id="initializeOverlayGL" translate="no"><a name="initializeOverlayGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">initializeOverlayGL</span>()<a class="plink" href="#initializeOverlayGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is used in the same manner as <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() except that it operates on the widget's overlay context instead of the widget's main context. This means that initializeOverlayGL() is called once before the first call to <a href="./qglwidget.htm#paintOverlayGL" translate="no">paintOverlayGL</a>() or <a href="./qglwidget.htm#resizeOverlayGL" translate="no">resizeOverlayGL</a>(). Reimplement it in a subclass.</p>
<p>This function should set up any required OpenGL context rendering flags, defining display lists, etc. for the overlay context.</p>
<p>There is no need to call <a href="./qglwidget.htm#makeOverlayCurrent" translate="no">makeOverlayCurrent</a>() because this has already been done when this function is called.</p>
<!-- @@@initializeOverlayGL -->
<!-- $$$isSharing[overload1]$$$isSharing -->
<h3 class="fn" id="isSharing" translate="no"><a name="isSharing"></a><span class="type">bool</span> QGLWidget::<span class="name">isSharing</span>() const<a class="plink" href="#isSharing" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if this widget's GL context is shared with another GL context, otherwise false is returned. Context sharing might not be possible if the widgets use different formats.</p>
<p><b>See also </b><a href="./qglwidget.htm#format" translate="no">format</a>().</p>
<!-- @@@isSharing -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QGLWidget::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the widget has a valid GL rendering context; otherwise returns <code translate="no">false</code>. A widget will be invalid if the system has no <a href="./qglformat.htm#hasOpenGL" translate="no">OpenGL support</a>.</p>
<!-- @@@isValid -->
<!-- $$$makeCurrent[overload1]$$$makeCurrent -->
<h3 class="fn" id="makeCurrent" translate="no"><a name="makeCurrent"></a><span class="type">void</span> QGLWidget::<span class="name">makeCurrent</span>()<a class="plink" href="#makeCurrent" title="Direct link to this headline"></a></h3>
<p>Makes this widget the current widget for OpenGL operations, i.e. makes the widget's rendering context the current OpenGL rendering context.</p>
<!-- @@@makeCurrent -->
<!-- $$$makeOverlayCurrent[overload1]$$$makeOverlayCurrent -->
<h3 class="fn" id="makeOverlayCurrent" translate="no"><a name="makeOverlayCurrent"></a><span class="type">void</span> QGLWidget::<span class="name">makeOverlayCurrent</span>()<a class="plink" href="#makeOverlayCurrent" title="Direct link to this headline"></a></h3>
<p>Makes the overlay context of this widget current. Use this if you need to issue OpenGL commands to the overlay context outside of <a href="./qglwidget.htm#initializeOverlayGL" translate="no">initializeOverlayGL</a>(), <a href="./qglwidget.htm#resizeOverlayGL" translate="no">resizeOverlayGL</a>(), and <a href="./qglwidget.htm#paintOverlayGL" translate="no">paintOverlayGL</a>().</p>
<p>Does nothing if this widget has no overlay.</p>
<p><b>See also </b><a href="./qglwidget.htm#makeCurrent" translate="no">makeCurrent</a>().</p>
<!-- @@@makeOverlayCurrent -->
<!-- $$$overlayContext[overload1]$$$overlayContext -->
<h3 class="fn" id="overlayContext" translate="no"><a name="overlayContext"></a>const <span class="type"><a href="./qglcontext.htm" translate="no">QGLContext</a></span> *QGLWidget::<span class="name">overlayContext</span>() const<a class="plink" href="#overlayContext" title="Direct link to this headline"></a></h3>
<p>Returns the overlay context of this widget, or <code translate="no">nullptr</code> if this widget has no overlay.</p>
<p><b>See also </b><a href="./qglwidget.htm#context" translate="no">context</a>().</p>
<!-- @@@overlayContext -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" id="paintEvent" translate="no"><a name="paintEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">paintEvent</span>(<span class="type"><a href="./qpaintevent.htm" translate="no">QPaintEvent</a></span> *<i>event</i>)<a class="plink" href="#paintEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwidget.htm#paintEvent" translate="no">QWidget::paintEvent</a>(QPaintEvent *event).</p>
<p>Handles paint events passed in the <i translate="no">event</i> parameter. Will cause the virtual <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() function to be called.</p>
<p>The widget's rendering context will become the current context and <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() will be called if it hasn't already been called.</p>
<!-- @@@paintEvent -->
<!-- $$$paintGL[overload1]$$$paintGL -->
<h3 class="fn" id="paintGL" translate="no"><a name="paintGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">paintGL</span>()<a class="plink" href="#paintGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is called whenever the widget needs to be painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="./qglwidget.htm#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called.</p>
<!-- @@@paintGL -->
<!-- $$$paintOverlayGL[overload1]$$$paintOverlayGL -->
<h3 class="fn" id="paintOverlayGL" translate="no"><a name="paintOverlayGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">paintOverlayGL</span>()<a class="plink" href="#paintOverlayGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is used in the same manner as <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() except that it operates on the widget's overlay context instead of the widget's main context. This means that paintOverlayGL() is called whenever the widget's overlay needs to be painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="./qglwidget.htm#makeOverlayCurrent" translate="no">makeOverlayCurrent</a>() because this has already been done when this function is called.</p>
<!-- @@@paintOverlayGL -->
<!-- $$$qglClearColor[overload1]$$$qglClearColorconstQColor& -->
<h3 class="fn" id="qglClearColor" translate="no"><a name="qglClearColor"></a><span class="type">void</span> QGLWidget::<span class="name">qglClearColor</span>(const <span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span> &amp;<i>c</i>) const<a class="plink" href="#qglClearColor" title="Direct link to this headline"></a></h3>
<p>Convenience function for specifying the clearing color to OpenGL. Calls glClearColor (in RGBA mode) or glClearIndex (in color-index mode) with the color <i translate="no">c</i>. Applies to this widgets GL context.</p>
<p><b>See also </b><a href="./qglwidget.htm#qglColor" translate="no">qglColor</a>(), <a href="./qglcontext.htm#currentContext" translate="no">QGLContext::currentContext</a>(), and <a href="./qcolor.htm" translate="no">QColor</a>.</p>
<!-- @@@qglClearColor -->
<!-- $$$qglColor[overload1]$$$qglColorconstQColor& -->
<h3 class="fn" id="qglColor" translate="no"><a name="qglColor"></a><span class="type">void</span> QGLWidget::<span class="name">qglColor</span>(const <span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span> &amp;<i>c</i>) const<a class="plink" href="#qglColor" title="Direct link to this headline"></a></h3>
<p>Convenience function for specifying a drawing color to OpenGL. Calls glColor4 (in RGBA mode) or glIndex (in color-index mode) with the color <i translate="no">c</i>. Applies to this widgets GL context.</p>
<div class="admonition note">
<p><b>Note: </b>This function is not supported on OpenGL/ES 2.0 systems.</p>
</div>
<p><b>See also </b><a href="./qglwidget.htm#qglClearColor" translate="no">qglClearColor</a>(), <a href="./qglcontext.htm#currentContext" translate="no">QGLContext::currentContext</a>(), and <a href="./qcolor.htm" translate="no">QColor</a>.</p>
<!-- @@@qglColor -->
<!-- $$$renderPixmap[overload1]$$$renderPixmapintintbool -->
<h3 class="fn" id="renderPixmap" translate="no"><a name="renderPixmap"></a><span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> QGLWidget::<span class="name">renderPixmap</span>(<span class="type">int</span> <i>w</i> = 0, <span class="type">int</span> <i>h</i> = 0, <span class="type">bool</span> <i>useContext</i> = false)<a class="plink" href="#renderPixmap" title="Direct link to this headline"></a></h3>
<p>Renders the current scene on a pixmap and returns the pixmap.</p>
<p>You can use this method on both visible and invisible <a class="obsolete" href="./qglwidget.htm" translate="no">QGLWidget</a> objects.</p>
<p>Internally the function renders into a framebuffer object and performs pixel readback. This has a performance penalty, meaning that this function is not suitable to be called at a high frequency.</p>
<p>After creating and binding the framebuffer object, the function will call <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>(), <a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a>(), and <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>(). On the next normal update <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>() and <a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a>() will be triggered again since the size of the destination pixmap and the <a class="obsolete" href="./qglwidget.htm" translate="no">QGLWidget</a>'s size may differ.</p>
<p>The size of the pixmap will be <i translate="no">w</i> pixels wide and <i translate="no">h</i> pixels high unless one of these parameters is 0 (the default), in which case the pixmap will have the same size as the widget.</p>
<p>Care must be taken when using framebuffer objects in <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() in combination with this function. To switch back to the default framebuffer, use <a href="./qglframebufferobject.htm#bindDefault" translate="no">QGLFramebufferObject::bindDefault</a>(). Binding FBO 0 is wrong since renderPixmap() uses a custom framebuffer instead of the one provided by the windowing system.</p>
<p><i translate="no">useContext</i> is ignored. Historically this parameter enabled the usage of the existing GL context. This is not supported anymore since additional contexts are never created.</p>
<p>Overlays are not rendered onto the pixmap.</p>
<p>If the GL rendering context and the desktop have different bit depths, the result will most likely look surprising.</p>
<p>Note that the creation of display lists, modifications of the view frustum etc. should be done from within <a href="./qglwidget.htm#initializeGL" translate="no">initializeGL</a>(). If this is not done, the temporary QGLContext will not be initialized properly, and the rendered pixmap may be incomplete/corrupted.</p>
<!-- @@@renderPixmap -->
<!-- $$$renderText[overload1]$$$renderTextintintconstQString&constQFont& -->
<h3 class="fn" id="renderText" translate="no"><a name="renderText"></a><span class="type">void</span> QGLWidget::<span class="name">renderText</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>, const <span class="type"><a href="./qfont.htm" translate="no">QFont</a></span> &amp;<i>font</i> = QFont())<a class="plink" href="#renderText" title="Direct link to this headline"></a></h3>
<p>Renders the string <i translate="no">str</i> into the GL context of this widget.</p>
<p><i translate="no">x</i> and <i translate="no">y</i> are specified in window coordinates, with the origin in the upper left-hand corner of the window. If <i translate="no">font</i> is not specified, the currently set application font will be used to render the string. To change the color of the rendered text you can use the glColor() call (or the <a href="./qglwidget.htm#qglColor" translate="no">qglColor</a>() convenience function), just before the renderText() call.</p>
<div class="admonition note">
<p><b>Note: </b>This function clears the stencil buffer.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function is not supported on OpenGL/ES systems.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function temporarily disables depth-testing when the text is drawn.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be used inside a <a href="./qpainter.htm#beginNativePainting" translate="no">QPainter::beginNativePainting</a>()/<a href="./qpainter.htm#endNativePainting" translate="no">QPainter::endNativePainting</a>() block if a painter is active on the <a class="obsolete" href="./qglwidget.htm" translate="no">QGLWidget</a>.</p>
</div>
<!-- @@@renderText -->
<!-- $$$renderText$$$renderTextdoubledoubledoubleconstQString&constQFont& -->
<h3 class="fn" id="renderText-1" translate="no"><a name="renderText-1"></a><span class="type">void</span> QGLWidget::<span class="name">renderText</span>(<span class="type">double</span> <i>x</i>, <span class="type">double</span> <i>y</i>, <span class="type">double</span> <i>z</i>, const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>, const <span class="type"><a href="./qfont.htm" translate="no">QFont</a></span> &amp;<i>font</i> = QFont())<a class="plink" href="#renderText-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p><i translate="no">x</i>, <i translate="no">y</i> and <i translate="no">z</i> are specified in scene or object coordinates relative to the currently set projection and model matrices. This can be useful if you want to annotate models with text labels and have the labels move with the model as it is rotated etc.</p>
<div class="admonition note">
<p><b>Note: </b>This function is not supported on OpenGL/ES systems.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>If depth testing is enabled before this function is called, then the drawn text will be depth-tested against the models that have already been drawn in the scene. Use <code translate="no">glDisable(GL_DEPTH_TEST)</code> before calling this function to annotate the models without depth-testing the text.</p>
</div>
<div class="admonition note">
<p><b>Note: </b>This function can only be used inside a <a href="./qpainter.htm#beginNativePainting" translate="no">QPainter::beginNativePainting</a>()/<a href="./qpainter.htm#endNativePainting" translate="no">QPainter::endNativePainting</a>() block if a painter is active on the <a class="obsolete" href="./qglwidget.htm" translate="no">QGLWidget</a>.</p>
</div>
<!-- @@@renderText -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" id="resizeEvent" translate="no"><a name="resizeEvent"></a><code translate="no">[override virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">resizeEvent</span>(<span class="type"><a href="./qresizeevent.htm" translate="no">QResizeEvent</a></span> *<i>event</i>)<a class="plink" href="#resizeEvent" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qwidget.htm#resizeEvent" translate="no">QWidget::resizeEvent</a>(QResizeEvent *event).</p>
<p>Handles resize events that are passed in the <i translate="no">event</i> parameter. Calls the virtual function <a href="./qglwidget.htm#resizeGL" translate="no">resizeGL</a>().</p>
<!-- @@@resizeEvent -->
<!-- $$$resizeGL[overload1]$$$resizeGLintint -->
<h3 class="fn" id="resizeGL" translate="no"><a name="resizeGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">resizeGL</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>)<a class="plink" href="#resizeGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is called whenever the widget has been resized. The new size is passed in <i translate="no">width</i> and <i translate="no">height</i>. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="./qglwidget.htm#makeCurrent" translate="no">makeCurrent</a>() because this has already been done when this function is called.</p>
<!-- @@@resizeGL -->
<!-- $$$resizeOverlayGL[overload1]$$$resizeOverlayGLintint -->
<h3 class="fn" id="resizeOverlayGL" translate="no"><a name="resizeOverlayGL"></a><code translate="no">[virtual protected] </code><span class="type">void</span> QGLWidget::<span class="name">resizeOverlayGL</span>(<span class="type">int</span> <i>width</i>, <span class="type">int</span> <i>height</i>)<a class="plink" href="#resizeOverlayGL" title="Direct link to this headline"></a></h3>
<p>This virtual function is used in the same manner as <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() except that it operates on the widget's overlay context instead of the widget's main context. This means that resizeOverlayGL() is called whenever the widget has been resized. The new size is passed in <i translate="no">width</i> and <i translate="no">height</i>. Reimplement it in a subclass.</p>
<p>There is no need to call <a href="./qglwidget.htm#makeOverlayCurrent" translate="no">makeOverlayCurrent</a>() because this has already been done when this function is called.</p>
<!-- @@@resizeOverlayGL -->
<!-- $$$setAutoBufferSwap[overload1]$$$setAutoBufferSwapbool -->
<h3 class="fn" id="setAutoBufferSwap" translate="no"><a name="setAutoBufferSwap"></a><code translate="no">[protected] </code><span class="type">void</span> QGLWidget::<span class="name">setAutoBufferSwap</span>(<span class="type">bool</span> <i>on</i>)<a class="plink" href="#setAutoBufferSwap" title="Direct link to this headline"></a></h3>
<p>If <i translate="no">on</i> is true automatic GL buffer swapping is switched on; otherwise it is switched off.</p>
<p>If <i translate="no">on</i> is true and the widget is using a double-buffered format, the background and foreground GL buffers will automatically be swapped after each <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() call.</p>
<p>The buffer auto-swapping is on by default.</p>
<p><b>See also </b><a href="./qglwidget.htm#autoBufferSwap" translate="no">autoBufferSwap</a>(), <a href="./qglwidget.htm#doubleBuffer" translate="no">doubleBuffer</a>(), and <a href="./qglwidget.htm#swapBuffers" translate="no">swapBuffers</a>().</p>
<!-- @@@setAutoBufferSwap -->
<!-- $$$setColormap[overload1]$$$setColormapconstQGLColormap& -->
<h3 class="fn" id="setColormap" translate="no"><a name="setColormap"></a><span class="type">void</span> QGLWidget::<span class="name">setColormap</span>(const <span class="type"><a href="./qglcolormap.htm" translate="no">QGLColormap</a></span> &amp;<i>cmap</i>)<a class="plink" href="#setColormap" title="Direct link to this headline"></a></h3>
<p>Set the colormap for this widget to <i translate="no">cmap</i>. Usually it is only top-level widgets that can have colormaps installed.</p>
<p><b>See also </b><a href="./qglwidget.htm#colormap" translate="no">colormap</a>().</p>
<!-- @@@setColormap -->
<!-- $$$swapBuffers[overload1]$$$swapBuffers -->
<h3 class="fn" id="swapBuffers" translate="no"><a name="swapBuffers"></a><span class="type">void</span> QGLWidget::<span class="name">swapBuffers</span>()<a class="plink" href="#swapBuffers" title="Direct link to this headline"></a></h3>
<p>Swaps the screen contents with an off-screen buffer. This only works if the widget's format specifies double buffer mode.</p>
<p>Normally, there is no need to explicitly call this function because it is done automatically after each widget repaint, i.e. each time after <a href="./qglwidget.htm#paintGL" translate="no">paintGL</a>() has been executed.</p>
<p><b>See also </b><a href="./qglwidget.htm#doubleBuffer" translate="no">doubleBuffer</a>(), <a href="./qglwidget.htm#setAutoBufferSwap" translate="no">setAutoBufferSwap</a>(), and <a href="./qglformat.htm#setDoubleBuffer" translate="no">QGLFormat::setDoubleBuffer</a>().</p>
<!-- @@@swapBuffers -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright"></acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>