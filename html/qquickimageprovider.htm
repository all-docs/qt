<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QQuickImageProvider | Qt Quick</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qquickimageprovider.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtquick-index.htm" translate="no">Qt Quick</a></li>
                            <li><a href="./qtquick-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QQuickImageProvider</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QQuickImageProvider Class</h1>
<!-- $$$QQuickImageProvider-brief -->
<p>The QQuickImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML. <a href="#details">More...</a></p>
<!-- @@@QQuickImageProvider -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QQuickImageProvider&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="./qqmlimageproviderbase.htm" translate="no">QQmlImageProviderBase</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qquickasyncimageprovider.htm" translate="no">QQuickAsyncImageProvider</a></p>
</td></tr></tbody></table></div><p>This class was introduced in Qt 5.0.</p>
<ul>
<li><a href="./qquickimageprovider-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qquickimageprovider.htm#QQuickImageProvider" translate="no">QQuickImageProvider</a></b>(QQmlImageProviderBase::ImageType <i>type</i>, QQmlImageProviderBase::Flags <i>flags</i> = Flags())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qquickimageprovider.htm#dtor.QQuickImageProvider" translate="no">~QQuickImageProvider</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QImage </td><td class="memItemRight bottomAlign"><b><a href="./qquickimageprovider.htm#requestImage" translate="no">requestImage</a></b>(const QString &amp;<i>id</i>, QSize *<i>size</i>, const QSize &amp;<i>requestedSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QPixmap </td><td class="memItemRight bottomAlign"><b><a href="./qquickimageprovider.htm#requestPixmap" translate="no">requestPixmap</a></b>(const QString &amp;<i>id</i>, QSize *<i>size</i>, const QSize &amp;<i>requestedSize</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QQuickTextureFactory *</td><td class="memItemRight bottomAlign"><b><a href="./qquickimageprovider.htm#requestTexture" translate="no">requestTexture</a></b>(const QString &amp;<i>id</i>, QSize *<i>size</i>, const QSize &amp;<i>requestedSize</i>)</td></tr>
</tbody></table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions">Reimplemented Public Functions<a class="plink" href="#reimplemented-public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> virtual QQmlImageProviderBase::Flags </td><td class="memItemRight bottomAlign"><b><a href="./qquickimageprovider.htm#flags" translate="no">flags</a></b>() const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QQmlImageProviderBase::ImageType </td><td class="memItemRight bottomAlign"><b><a href="./qquickimageprovider.htm#imageType" translate="no">imageType</a></b>() const override</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QQuickImageProvider-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>QQuickImageProvider is used to provide advanced image loading features in QML applications. It allows images in QML to be:</p>
<ul>
<li>Loaded using QPixmaps rather than actual image files</li>
<li>Loaded asynchronously in a separate thread</li>
</ul>
<p>To specify that an image should be loaded by an image provider, use the <b>"image:"</b> scheme for the URL source of the image, followed by the identifiers of the image provider and the requested image. For example:</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="type"><a href="./qml-qtquick-image.htm" translate="no">Image</a></span> { <span class="name">source</span>: <span class="string">"image://myimageprovider/image.png"</span> }</pre></div>
<p>This specifies that the image should be loaded by the image provider named "myimageprovider", and the image to be loaded is named "image.png". The QML engine invokes the appropriate image provider according to the providers that have been registered through <a href="./qqmlengine.htm#addImageProvider" translate="no">QQmlEngine::addImageProvider</a>().</p>
<p>Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with preserved case. For example, the below snippet would still specify that the image is loaded by the image provider named "myimageprovider", but it would request a different image than the above snippet ("Image.png" instead of "image.png").</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="type"><a href="./qml-qtquick-image.htm" translate="no">Image</a></span> { <span class="name">source</span>: <span class="string">"image://MyImageProvider/Image.png"</span> }</pre></div>
<p>If you want the rest of the URL to be case insensitive, you will have to take care of that yourself inside your image provider.</p>
<a name="an-example"></a>
<h4 id="an-example">An Example<a class="plink" href="#an-example" title="Direct link to this headline"></a></h4>
<p>Here are two images. Their <code translate="no">source</code> values indicate they should be loaded by an image provider named "colors", and the images to be loaded are "yellow" and "red", respectively:</p>
<div class="pre"><pre class="qml prettyprint" translate="no"><span class="type"><a href="./qml-qtquick-column.htm" translate="no">Column</a></span> {
    <span class="type"><a href="./qml-qtquick-image.htm" translate="no">Image</a></span> { <span class="name">source</span>: <span class="string">"image://colors/yellow"</span> }
    <span class="type"><a href="./qml-qtquick-image.htm" translate="no">Image</a></span> { <span class="name">source</span>: <span class="string">"image://colors/red"</span> }
}</pre></div>
<p>When these images are loaded by QML, it looks for a matching image provider and calls its <a href="./qquickimageprovider.htm#requestImage" translate="no">requestImage</a>() or <a href="./qquickimageprovider.htm#requestPixmap" translate="no">requestPixmap</a>() method (depending on its <a href="./qquickimageprovider.htm#imageType" translate="no">imageType</a>()) to load the image. The method is called with the <code translate="no">id</code> parameter set to "yellow" for the first image, and "red" for the second.</p>
<p>Here is an image provider implementation that can load the images requested by the above QML. This implementation dynamically generates <a href="./qpixmap.htm" translate="no">QPixmap</a> images that are filled with the requested color:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="keyword">class</span> ColorImageProvider : <span class="keyword">public</span> <span class="type"><a href="./qquickimageprovider.htm#QQuickImageProvider" translate="no">QQuickImageProvider</a></span>
{
<span class="keyword">public</span>:
    ColorImageProvider()
               : <span class="type"><a href="./qquickimageprovider.htm#QQuickImageProvider" translate="no">QQuickImageProvider</a></span>(<span class="type"><a href="./qquickimageprovider.htm#QQuickImageProvider" translate="no">QQuickImageProvider</a></span><span class="operator">::</span>Pixmap)
    {
    }

    <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> requestPixmap(<span class="keyword">const</span> <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> <span class="operator">&amp;</span>id<span class="operator">,</span> <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> <span class="operator">*</span>size<span class="operator">,</span> <span class="keyword">const</span> <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> <span class="operator">&amp;</span>requestedSize) override
    {
       <span class="type">int</span> width <span class="operator">=</span> <span class="number">100</span>;
       <span class="type">int</span> height <span class="operator">=</span> <span class="number">50</span>;

       <span class="keyword">if</span> (size)
          <span class="operator">*</span>size <span class="operator">=</span> <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span>(width<span class="operator">,</span> height);
       <span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> pixmap(requestedSize<span class="operator">.</span>width() <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">?</span> requestedSize<span class="operator">.</span>width() : width<span class="operator">,</span>
                      requestedSize<span class="operator">.</span>height() <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">?</span> requestedSize<span class="operator">.</span>height() : height);
       pixmap<span class="operator">.</span>fill(<span class="type"><a href="./qcolor.htm" translate="no">QColor</a></span>(id)<span class="operator">.</span>rgba());
       <span class="keyword">return</span> pixmap;
    }
};</pre></div>
<p>To make this provider accessible to QML, it is registered with the QML engine with a "colors" identifier:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type">int</span> main(<span class="type">int</span> argc<span class="operator">,</span> <span class="type">char</span> <span class="operator">*</span>argv<span class="operator">[</span><span class="operator">]</span>)
{

    <span class="type"><a href="./qquickview.htm" translate="no">QQuickView</a></span> view;
    <span class="type"><a href="./qqmlengine.htm" translate="no">QQmlEngine</a></span> <span class="operator">*</span>engine <span class="operator">=</span> view<span class="operator">.</span>engine();
    engine<span class="operator">-</span><span class="operator">&gt;</span>addImageProvider(QLatin1String(<span class="string">"colors"</span>)<span class="operator">,</span> <span class="keyword">new</span> ColorImageProvider);
    view<span class="operator">.</span>setSource(<span class="type"><a href="./qurl.htm" translate="no">QUrl</a></span><span class="operator">::</span>fromLocalFile(<span class="type"><a href="./qstring.htm#QStringLiteral" translate="no">QStringLiteral</a></span>(<span class="string">"imageprovider-example.qml"</span>)));
    view<span class="operator">.</span>show();
    <span class="keyword">return</span> app<span class="operator">.</span>exec();
}</pre></div>
<p>Now the images can be successfully loaded in QML:</p>
<p class="centerAlign"><img alt="" src="./images/imageprovider.png"></p><p>See the <a href="./qtquick-imageprovider-example.htm" translate="no">Image Provider Example</a> for the complete implementation. Note that the example registers the provider via a <a href="./qqmlengineextensionplugin.htm" translate="no">plugin</a> instead of registering it in the application <code translate="no">main()</code> function as shown above.</p>
<a name="asynchronous-image-loading"></a>
<h4 id="asynchronous-image-loading">Asynchronous Image Loading<a class="plink" href="#asynchronous-image-loading" title="Direct link to this headline"></a></h4>
<p>Image providers that support <a href="./qimage.htm" translate="no">QImage</a> or Texture loading automatically include support for asychronous loading of images. To enable asynchronous loading for an image source, set the <code translate="no">asynchronous</code> property to <code translate="no">true</code> for the relevant <a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">Image</a> or <a href="./qml-qtquick-borderimage.htm" translate="no">BorderImage</a> object. When this is enabled, the image request to the provider is run in a low priority thread, allowing image loading to be executed in the background, and reducing the performance impact on the user interface.</p>
<p>To force asynchronous image loading, even for image sources that do not have the <code translate="no">asynchronous</code> property set to <code translate="no">true</code>, you may pass the <code translate="no">QQmlImageProviderBase::ForceAsynchronousImageLoading</code> flag to the image provider constructor. This ensures that all image requests for the provider are handled in a separate thread.</p>
<p>Asynchronous loading for image providers that provide <a href="./qpixmap.htm" translate="no">QPixmap</a> is only supported in platforms that have the ThreadedPixmaps feature, in platforms where pixmaps can only be created in the main thread (i.e. ThreadedPixmaps is not supported) if <a href="./qml-qtquick-image.htm#asynchronous-prop" translate="no">asynchronous</a> is set to <code translate="no">true</code>, the value is ignored and the image is loaded synchronously.</p>
<p>Asynchronous image loading for providers of type other than <a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">ImageResponse</a> are executed on a single thread per engine basis. That means that a slow image provider will block the loading of any other request. To avoid that we suggest using <a href="./qquickasyncimageprovider.htm" translate="no">QQuickAsyncImageProvider</a> and implement threading on the provider side via a <code translate="no">QThreadPool</code> or similar. See the <a href="./qtquick-imageresponseprovider-example.htm" translate="no">Image Response Provider Example</a> for a complete implementation.</p>
<a name="image-caching"></a>
<h4 id="image-caching">Image Caching<a class="plink" href="#image-caching" title="Direct link to this headline"></a></h4>
<p>Images returned by a QQuickImageProvider are automatically cached, similar to any image loaded by the QML engine. When an image with a "image://" prefix is loaded from cache, <a href="./qquickimageprovider.htm#requestImage" translate="no">requestImage</a>() and <a href="./qquickimageprovider.htm#requestPixmap" translate="no">requestPixmap</a>() will not be called for the relevant image provider. If an image should always be fetched from the image provider, and should not be cached at all, set the <code translate="no">cache</code> property to <code translate="no">false</code> for the relevant <a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">Image</a> or <a href="./qml-qtquick-borderimage.htm" translate="no">BorderImage</a> object.</p>
</div>
<p><b>See also </b><a href="./qqmlengine.htm#addImageProvider" translate="no">QQmlEngine::addImageProvider</a>().</p>
<!-- @@@QQuickImageProvider -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QQuickImageProvider[overload1]$$$QQuickImageProviderQQmlImageProviderBase::ImageTypeQQmlImageProviderBase::Flags -->
<h3 class="fn" id="QQuickImageProvider" translate="no"><a name="QQuickImageProvider"></a>QQuickImageProvider::<span class="name">QQuickImageProvider</span>(<span class="type"><a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">QQmlImageProviderBase::ImageType</a></span> <i>type</i>, <span class="type"><a href="./qqmlimageproviderbase.htm#Flag-enum" translate="no">QQmlImageProviderBase::Flags</a></span> <i>flags</i> = Flags())<a class="plink" href="#QQuickImageProvider" title="Direct link to this headline"></a></h3>
<p>Creates an image provider that will provide images of the given <i translate="no">type</i> and behave according to the given <i translate="no">flags</i>.</p>
<!-- @@@QQuickImageProvider -->
<!-- $$$~QQuickImageProvider[overload1]$$$~QQuickImageProvider -->
<h3 class="fn" id="dtor.QQuickImageProvider" translate="no"><a name="dtor.QQuickImageProvider"></a><code translate="no">[override virtual] </code>QQuickImageProvider::<span class="name">~QQuickImageProvider</span>()<a class="plink" href="#dtor.QQuickImageProvider" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qquickimageprovider.htm" translate="no">QQuickImageProvider</a></p>
<div class="admonition note">
<p><b>Note: </b>The destructor of your derived class need to be thread safe.</p>
</div>
<!-- @@@~QQuickImageProvider -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" id="flags" translate="no"><a name="flags"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qqmlimageproviderbase.htm#Flag-enum" translate="no">QQmlImageProviderBase::Flags</a></span> QQuickImageProvider::<span class="name">flags</span>() const<a class="plink" href="#flags" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qqmlimageproviderbase.htm#flags" translate="no">QQmlImageProviderBase::flags</a>() const.</p>
<p>Returns the flags set for this provider.</p>
<!-- @@@flags -->
<!-- $$$imageType[overload1]$$$imageType -->
<h3 class="fn" id="imageType" translate="no"><a name="imageType"></a><code translate="no">[override virtual] </code><span class="type"><a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">QQmlImageProviderBase::ImageType</a></span> QQuickImageProvider::<span class="name">imageType</span>() const<a class="plink" href="#imageType" title="Direct link to this headline"></a></h3>
<p>Reimplements: <a href="./qqmlimageproviderbase.htm#imageType" translate="no">QQmlImageProviderBase::imageType</a>() const.</p>
<p>Returns the image type supported by this provider.</p>
<!-- @@@imageType -->
<!-- $$$requestImage[overload1]$$$requestImageconstQString&QSize*constQSize& -->
<h3 class="fn" id="requestImage" translate="no"><a name="requestImage"></a><code translate="no">[virtual] </code><span class="type"><a href="./qimage.htm" translate="no">QImage</a></span> QQuickImageProvider::<span class="name">requestImage</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>id</i>, <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> *<i>size</i>, const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>requestedSize</i>)<a class="plink" href="#requestImage" title="Direct link to this headline"></a></h3>
<p>Implement this method to return the image with <i translate="no">id</i>. The default implementation returns an empty image.</p>
<p>The <i translate="no">id</i> is the requested image source, with the "image:" scheme and provider identifier removed. For example, if the image <a href="./qml-qtquick-image.htm#source-prop" translate="no">source</a> was "image://myprovider/icons/home", the given <i translate="no">id</i> would be "icons/home".</p>
<p>The <i translate="no">requestedSize</i> corresponds to the <a href="./qml-qtquick-image.htm#sourceSize-prop" translate="no">Image::sourceSize</a> requested by an Image item. If <i translate="no">requestedSize</i> is a valid size, the image returned should be of that size.</p>
<p>In all cases, <i translate="no">size</i> must be set to the original size of the image. This is used to set the <a href="./qml-qtquick-item.htm#width-prop" translate="no">width</a> and <a href="./qml-qtquick-item.htm#height-prop" translate="no">height</a> of the relevant <a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">Image</a> if these values have not been set explicitly.</p>
<div class="admonition note">
<p><b>Note: </b>this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</p>
</div>
<!-- @@@requestImage -->
<!-- $$$requestPixmap[overload1]$$$requestPixmapconstQString&QSize*constQSize& -->
<h3 class="fn" id="requestPixmap" translate="no"><a name="requestPixmap"></a><code translate="no">[virtual] </code><span class="type"><a href="./qpixmap.htm" translate="no">QPixmap</a></span> QQuickImageProvider::<span class="name">requestPixmap</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>id</i>, <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> *<i>size</i>, const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>requestedSize</i>)<a class="plink" href="#requestPixmap" title="Direct link to this headline"></a></h3>
<p>Implement this method to return the pixmap with <i translate="no">id</i>. The default implementation returns an empty pixmap.</p>
<p>The <i translate="no">id</i> is the requested image source, with the "image:" scheme and provider identifier removed. For example, if the image <a href="./qml-qtquick-image.htm#source-prop" translate="no">source</a> was "image://myprovider/icons/home", the given <i translate="no">id</i> would be "icons/home".</p>
<p>The <i translate="no">requestedSize</i> corresponds to the <a href="./qml-qtquick-image.htm#sourceSize-prop" translate="no">Image::sourceSize</a> requested by an Image item. If <i translate="no">requestedSize</i> is a valid size, the image returned should be of that size.</p>
<p>In all cases, <i translate="no">size</i> must be set to the original size of the image. This is used to set the <a href="./qml-qtquick-item.htm#width-prop" translate="no">width</a> and <a href="./qml-qtquick-item.htm#height-prop" translate="no">height</a> of the relevant <a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">Image</a> if these values have not been set explicitly.</p>
<div class="admonition note">
<p><b>Note: </b>this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</p>
</div>
<!-- @@@requestPixmap -->
<!-- $$$requestTexture[overload1]$$$requestTextureconstQString&QSize*constQSize& -->
<h3 class="fn" id="requestTexture" translate="no"><a name="requestTexture"></a><code translate="no">[virtual] </code><span class="type"><a href="./qquicktexturefactory.htm" translate="no">QQuickTextureFactory</a></span> *QQuickImageProvider::<span class="name">requestTexture</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>id</i>, <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> *<i>size</i>, const <span class="type"><a href="./qsize.htm" translate="no">QSize</a></span> &amp;<i>requestedSize</i>)<a class="plink" href="#requestTexture" title="Direct link to this headline"></a></h3>
<p>Implement this method to return the texture with <i translate="no">id</i>. The default implementation returns <code translate="no">nullptr</code>.</p>
<p>The <i translate="no">id</i> is the requested image source, with the "image:" scheme and provider identifier removed. For example, if the image <a href="./qml-qtquick-image.htm#source-prop" translate="no">source</a> was "image://myprovider/icons/home", the given <i translate="no">id</i> would be "icons/home".</p>
<p>The <i translate="no">requestedSize</i> corresponds to the <a href="./qml-qtquick-image.htm#sourceSize-prop" translate="no">Image::sourceSize</a> requested by an Image item. If <i translate="no">requestedSize</i> is a valid size, the image returned should be of that size.</p>
<p>In all cases, <i translate="no">size</i> must be set to the original size of the image. This is used to set the <a href="./qml-qtquick-item.htm#width-prop" translate="no">width</a> and <a href="./qml-qtquick-item.htm#height-prop" translate="no">height</a> of the relevant <a href="./qqmlimageproviderbase.htm#ImageType-enum" translate="no">Image</a> if these values have not been set explicitly.</p>
<div class="admonition note">
<p><b>Note: </b>this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</p>
</div>
<!-- @@@requestTexture -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>