<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QAbstractVideoBuffer | Qt Multimedia</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qabstractvideobuffer.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtmultimedia-index.htm" translate="no">Qt Multimedia</a></li>
                            <li><a href="./qtmultimedia-modules.htm" translate="no">C++ Classes</a></li>
                            <li><a>QAbstractVideoBuffer</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QAbstractVideoBuffer Class</h1>
<!-- $$$QAbstractVideoBuffer-brief -->
<p>The QAbstractVideoBuffer class is an abstraction for video data. <a href="#details">More...</a></p>
<!-- @@@QAbstractVideoBuffer -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QAbstractVideoBuffer&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += multimedia</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="./qabstractplanarvideobuffer.htm" translate="no">QAbstractPlanarVideoBuffer</a></p>
</td></tr></tbody></table></div><ul>
<li><a href="./qabstractvideobuffer-members.htm">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#HandleType-enum" translate="no">HandleType</a></b> { NoHandle, GLTextureHandle, XvShmImageHandle, CoreImageHandle, QPixmapHandle, …, GLTextureRectangleHandle }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">MapMode</a></b> { NotMapped, ReadOnly, WriteOnly, ReadWrite }</td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#QAbstractVideoBuffer" translate="no">QAbstractVideoBuffer</a></b>(QAbstractVideoBuffer::HandleType <i>type</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#dtor.QAbstractVideoBuffer" translate="no">~QAbstractVideoBuffer</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#handle" translate="no">handle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QAbstractVideoBuffer::HandleType </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#handleType" translate="no">handleType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual uchar *</td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#map" translate="no">map</a></b>(QAbstractVideoBuffer::MapMode <i>mode</i>, int *<i>numBytes</i>, int *<i>bytesPerLine</i>) = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QAbstractVideoBuffer::MapMode </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#mapMode" translate="no">mapMode</a></b>() const = 0</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#mapPlanes" translate="no">mapPlanes</a></b>(QAbstractVideoBuffer::MapMode <i>mode</i>, int *<i>numBytes</i>, int [4] <i>bytesPerLine</i> = 4, uchar *[4] <i>data</i> = 4)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#release" translate="no">release</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="./qabstractvideobuffer.htm#unmap" translate="no">unmap</a></b>() = 0</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QAbstractVideoBuffer-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>The <a href="./qvideoframe.htm" translate="no">QVideoFrame</a> class makes use of a QAbstractVideoBuffer internally to reference a buffer of video data. Quite often video data buffers may reside in video memory rather than system memory, and this class provides an abstraction of the location.</p>
<p>In addition, creating a subclass of QAbstractVideoBuffer will allow you to construct video frames from preallocated or static buffers, in cases where the <a href="./qvideoframe.htm" translate="no">QVideoFrame</a> constructors taking a <a href="./qbytearray.htm" translate="no">QByteArray</a> or a <a href="./qimage.htm" translate="no">QImage</a> do not suffice. This may be necessary when implementing a new hardware accelerated video system, for example.</p>
<p>The contents of a buffer can be accessed by mapping the buffer to memory using the <a href="./qabstractvideobuffer.htm#map" translate="no">map</a>() function, which returns a pointer to memory containing the contents of the video buffer. The memory returned by <a href="./qabstractvideobuffer.htm#map" translate="no">map</a>() is released by calling the <a href="./qabstractvideobuffer.htm#unmap" translate="no">unmap</a>() function.</p>
<p>The <a href="./qabstractvideobuffer.htm#handle" translate="no">handle</a>() of a buffer may also be used to manipulate its contents using type specific APIs. The type of a buffer's handle is given by the <a href="./qabstractvideobuffer.htm#handleType" translate="no">handleType</a>() function.</p>
</div>
<p><b>See also </b><a href="./qvideoframe.htm" translate="no">QVideoFrame</a>.</p>
<!-- @@@QAbstractVideoBuffer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$HandleType$$$NoHandle$$$GLTextureHandle$$$XvShmImageHandle$$$CoreImageHandle$$$QPixmapHandle$$$EGLImageHandle$$$GLTextureRectangleHandle$$$UserHandle -->
<h3 class="fn" id="HandleType-enum" translate="no"><a name="HandleType-enum"></a>enum QAbstractVideoBuffer::<span class="name">HandleType</span><a class="plink" href="#HandleType-enum" title="Direct link to this headline"></a></h3>
<p>Identifies the type of a video buffers handle.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::NoHandle</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">The buffer has no handle, its data can only be accessed by mapping the buffer.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::GLTextureHandle</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The handle of the buffer is an OpenGL texture ID of an undefined and platform dependent target type.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::XvShmImageHandle</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The handle contains pointer to shared memory XVideo image.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::CoreImageHandle</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">The handle contains pointer to macOS CIImage.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::QPixmapHandle</code></td><td class="topAlign tblval"><code translate="no">4</code></td><td class="topAlign">The handle of the buffer is a <a href="./qpixmap.htm" translate="no">QPixmap</a>.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::EGLImageHandle</code></td><td class="topAlign tblval"><code translate="no">5</code></td><td class="topAlign">The handle of the buffer is an EGLImageKHR.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::UserHandle</code></td><td class="topAlign tblval"><code translate="no">1000</code></td><td class="topAlign">Start value for user defined handle types.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::GLTextureRectangleHandle</code></td><td class="topAlign tblval"><code translate="no">6</code></td><td class="topAlign">The handle of the buffer is an OpenGL texture ID of target type <code translate="no">GL_TEXTURE_RECTANGLE</code>.</td></tr>
</tbody></table></div>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#handleType" translate="no">handleType</a>().</p>
<!-- @@@HandleType -->
<!-- $$$MapMode$$$NotMapped$$$ReadOnly$$$WriteOnly$$$ReadWrite -->
<h3 class="fn" id="MapMode-enum" translate="no"><a name="MapMode-enum"></a>enum QAbstractVideoBuffer::<span class="name">MapMode</span><a class="plink" href="#MapMode-enum" title="Direct link to this headline"></a></h3>
<p>Enumerates how a video buffer's data is mapped to system memory.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::NotMapped</code></td><td class="topAlign tblval"><code translate="no">0x00</code></td><td class="topAlign">The video buffer is not mapped to memory.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::ReadOnly</code></td><td class="topAlign tblval"><code translate="no">0x01</code></td><td class="topAlign">The mapped memory is populated with data from the video buffer when mapped, but the content of the mapped memory may be discarded when unmapped.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::WriteOnly</code></td><td class="topAlign tblval"><code translate="no">0x02</code></td><td class="topAlign">The mapped memory is uninitialized when mapped, but the possibly modified content will be used to populate the video buffer when unmapped.</td></tr>
<tr><td class="topAlign"><code translate="no">QAbstractVideoBuffer::ReadWrite</code></td><td class="topAlign tblval"><code translate="no">ReadOnly | WriteOnly</code></td><td class="topAlign">The mapped memory is populated with data from the video buffer, and the video buffer is repopulated with the content of the mapped memory when it is unmapped.</td></tr>
</tbody></table></div>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#mapMode" translate="no">mapMode</a>() and <a href="./qabstractvideobuffer.htm#map" translate="no">map</a>().</p>
<!-- @@@MapMode -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QAbstractVideoBuffer[overload1]$$$QAbstractVideoBufferQAbstractVideoBuffer::HandleType -->
<h3 class="fn" id="QAbstractVideoBuffer" translate="no"><a name="QAbstractVideoBuffer"></a>QAbstractVideoBuffer::<span class="name">QAbstractVideoBuffer</span>(<span class="type"><a href="./qabstractvideobuffer.htm#HandleType-enum" translate="no">QAbstractVideoBuffer::HandleType</a></span> <i>type</i>)<a class="plink" href="#QAbstractVideoBuffer" title="Direct link to this headline"></a></h3>
<p>Constructs an abstract video buffer of the given <i translate="no">type</i>.</p>
<!-- @@@QAbstractVideoBuffer -->
<!-- $$$~QAbstractVideoBuffer[overload1]$$$~QAbstractVideoBuffer -->
<h3 class="fn" id="dtor.QAbstractVideoBuffer" translate="no"><a name="dtor.QAbstractVideoBuffer"></a><code translate="no">[virtual] </code>QAbstractVideoBuffer::<span class="name">~QAbstractVideoBuffer</span>()<a class="plink" href="#dtor.QAbstractVideoBuffer" title="Direct link to this headline"></a></h3>
<p>Destroys an abstract video buffer.</p>
<!-- @@@~QAbstractVideoBuffer -->
<!-- $$$handle[overload1]$$$handle -->
<h3 class="fn" id="handle" translate="no"><a name="handle"></a><code translate="no">[virtual] </code><span class="type"><a href="./qvariant.htm" translate="no">QVariant</a></span> QAbstractVideoBuffer::<span class="name">handle</span>() const<a class="plink" href="#handle" title="Direct link to this headline"></a></h3>
<p>Returns a type specific handle to the data buffer.</p>
<p>The type of the handle is given by <a href="./qabstractvideobuffer.htm#handleType" translate="no">handleType</a>() function.</p>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#handleType" translate="no">handleType</a>().</p>
<!-- @@@handle -->
<!-- $$$handleType[overload1]$$$handleType -->
<h3 class="fn" id="handleType" translate="no"><a name="handleType"></a><span class="type"><a href="./qabstractvideobuffer.htm#HandleType-enum" translate="no">QAbstractVideoBuffer::HandleType</a></span> QAbstractVideoBuffer::<span class="name">handleType</span>() const<a class="plink" href="#handleType" title="Direct link to this headline"></a></h3>
<p>Returns the type of a video buffer's handle.</p>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#handle" translate="no">handle</a>().</p>
<!-- @@@handleType -->
<!-- $$$map[overload1]$$$mapQAbstractVideoBuffer::MapModeint*int* -->
<h3 class="fn" id="map" translate="no"><a name="map"></a><code translate="no">[pure virtual] </code><span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *QAbstractVideoBuffer::<span class="name">map</span>(<span class="type"><a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a></span> <i>mode</i>, <span class="type">int</span> *<i>numBytes</i>, <span class="type">int</span> *<i>bytesPerLine</i>)<a class="plink" href="#map" title="Direct link to this headline"></a></h3>
<p>Maps the contents of a video buffer to memory.</p>
<p>In some cases the video buffer might be stored in video memory or otherwise inaccessible memory, so it is necessary to map the buffer before accessing the pixel data. This may involve copying the contents around, so avoid mapping and unmapping unless required.</p>
<p>The map <i translate="no">mode</i> indicates whether the contents of the mapped memory should be read from and/or written to the buffer. If the map mode includes the <code translate="no">QAbstractVideoBuffer::ReadOnly</code> flag the mapped memory will be populated with the content of the buffer when initially mapped. If the map mode includes the <code translate="no">QAbstractVideoBuffer::WriteOnly</code> flag the content of the possibly modified mapped memory will be written back to the buffer when unmapped.</p>
<p>When access to the data is no longer needed be sure to call the <a href="./qabstractvideobuffer.htm#unmap" translate="no">unmap</a>() function to release the mapped memory and possibly update the buffer contents.</p>
<p>Returns a pointer to the mapped memory region, or a null pointer if the mapping failed. The size in bytes of the mapped memory region is returned in <i translate="no">numBytes</i>, and the line stride in <i translate="no">bytesPerLine</i>.</p>
<div class="admonition note">
<p><b>Note: </b>Writing to memory that is mapped as read-only is undefined, and may result in changes to shared data or crashes.</p>
</div>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#unmap" translate="no">unmap</a>() and <a href="./qabstractvideobuffer.htm#mapMode" translate="no">mapMode</a>().</p>
<!-- @@@map -->
<!-- $$$mapMode[overload1]$$$mapMode -->
<h3 class="fn" id="mapMode" translate="no"><a name="mapMode"></a><code translate="no">[pure virtual] </code><span class="type"><a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a></span> QAbstractVideoBuffer::<span class="name">mapMode</span>() const<a class="plink" href="#mapMode" title="Direct link to this headline"></a></h3>
<p>Returns the mode a video buffer is mapped in.</p>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#map" translate="no">map</a>().</p>
<!-- @@@mapMode -->
<!-- $$$mapPlanes[overload1]$$$mapPlanesQAbstractVideoBuffer::MapModeint*int[4]uchar*[4] -->
<h3 class="fn" id="mapPlanes" translate="no"><a name="mapPlanes"></a><span class="type">int</span> QAbstractVideoBuffer::<span class="name">mapPlanes</span>(<span class="type"><a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">QAbstractVideoBuffer::MapMode</a></span> <i>mode</i>, <span class="type">int</span> *<i>numBytes</i>, <span class="type">int</span> [<span class="type">4</span>] <i>bytesPerLine</i> = 4, <span class="type"><a href="./qtglobal.htm#uchar-typedef" translate="no">uchar</a></span> *[<span class="type">4</span>] <i>data</i> = 4)<a class="plink" href="#mapPlanes" title="Direct link to this headline"></a></h3>
<p>Independently maps the planes of a video buffer to memory.</p>
<p>The map <i translate="no">mode</i> indicates whether the contents of the mapped memory should be read from and/or written to the buffer. If the map mode includes the <code translate="no">QAbstractVideoBuffer::ReadOnly</code> flag the mapped memory will be populated with the content of the buffer when initially mapped. If the map mode includes the <code translate="no">QAbstractVideoBuffer::WriteOnly</code> flag the content of the possibly modified mapped memory will be written back to the buffer when unmapped.</p>
<p>When access to the data is no longer needed be sure to call the <a href="./qabstractvideobuffer.htm#unmap" translate="no">unmap</a>() function to release the mapped memory and possibly update the buffer contents.</p>
<p>Returns the number of planes in the mapped video data. For each plane the line stride of that plane will be returned in <i translate="no">bytesPerLine</i>, and a pointer to the plane data will be returned in <i translate="no">data</i>. The accumulative size of the mapped data is returned in <i translate="no">numBytes</i>.</p>
<p>Not all buffer implementations will map more than the first plane, if this returns a single plane for a planar format the additional planes will have to be calculated from the line stride of the first plane and the frame height. Mapping a buffer with <a href="./qvideoframe.htm" translate="no">QVideoFrame</a> will do this for you.</p>
<p>To implement this function create a derivative of <a href="./qabstractplanarvideobuffer.htm" translate="no">QAbstractPlanarVideoBuffer</a> and implement its map function instance instead.</p>
<p>This function was introduced in Qt 5.4.</p>
<!-- @@@mapPlanes -->
<!-- $$$release[overload1]$$$release -->
<h3 class="fn" id="release" translate="no"><a name="release"></a><code translate="no">[virtual] </code><span class="type">void</span> QAbstractVideoBuffer::<span class="name">release</span>()<a class="plink" href="#release" title="Direct link to this headline"></a></h3>
<p>Releases the video buffer.</p>
<p><a href="./qvideoframe.htm" translate="no">QVideoFrame</a> calls QAbstractVideoBuffer::release when the buffer is not used any more and can be destroyed or returned to the buffer pool.</p>
<p>The default implementation deletes the buffer instance.</p>
<!-- @@@release -->
<!-- $$$unmap[overload1]$$$unmap -->
<h3 class="fn" id="unmap" translate="no"><a name="unmap"></a><code translate="no">[pure virtual] </code><span class="type">void</span> QAbstractVideoBuffer::<span class="name">unmap</span>()<a class="plink" href="#unmap" title="Direct link to this headline"></a></h3>
<p>Releases the memory mapped by the <a href="./qabstractvideobuffer.htm#map" translate="no">map</a>() function.</p>
<p>If the <a href="./qabstractvideobuffer.htm#MapMode-enum" translate="no">MapMode</a> included the <code translate="no">QAbstractVideoBuffer::WriteOnly</code> flag this will write the current content of the mapped memory back to the video frame.</p>
<p><b>See also </b><a href="./qabstractvideobuffer.htm#map" translate="no">map</a>().</p>
<!-- @@@unmap -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>