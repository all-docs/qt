<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>QRegularExpression | Qt Core</title>
<link rel="canonical" href="https://doc.qt.io/qt-6/qregularexpression.html">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <!-- Google Tag Manager -->
    
  <!-- End Google Tag Manager -->
  
  
</head>
<body class="qt-design-system" style="background:var(--content-bg-color)" onload="prettyPrint()">

<div data-global-resource-path="qt-design-system/components/b-sidebar.html">
    <div class="b-sidebar b-sidebar--full-width">
        
        <div class="b-sidebar__content">
            <div class="b-sidebar__topbar" data-margin-bottom="sm">
                <div class="b-topbar">
                                        <div class="b-topbar__breadcrump" translate="no">
                        <ul class="c-breadcrump">
                            <li><a href="./index.htm" translate="no">Qt 5.15</a></li>
                            <li><a href="./qtcore-index.htm" translate="no">Qt Core</a></li>
                            <li><a href="./qtcore-module.htm" translate="no">C++ Classes</a></li>
                            <li><a>QRegularExpression</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="b-sidebar__content__wrapper">
                <article class="b-sidebar__content__left">
                    <div class="context mainContent" style="margin: 0;padding: 0; background: 0;">
                    

<div class="context">
<h1 class="title" translate="no">QRegularExpression Class</h1>
<!-- $$$QRegularExpression-brief -->
<p>The QRegularExpression class provides pattern matching using regular expressions. <a href="#details">More...</a></p>
<!-- @@@QRegularExpression -->
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign"> <span class="preprocessor">#include &lt;QRegularExpression&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += core</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.0</td></tr></tbody></table></div><p>This class was introduced in Qt 5.0.</p>
<ul>
<li><a href="./qregularexpression-members.htm">List of all members, including inherited members</a></li>
</ul>
<p><b>Note:</b> All functions in this class are <a href="./threads-reentrancy.htm" translate="no">reentrant</a>.</p>
<a name="public-types"></a>
<h2 id="public-types">Public Types<a class="plink" href="#public-types" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#MatchOption-enum" translate="no">MatchOption</a></b> { NoMatchOption, AnchoredMatchOption, DontCheckSubjectStringMatchOption }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#MatchOption-enum" translate="no">MatchOptions</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#MatchType-enum" translate="no">MatchType</a></b> { NormalMatch, PartialPreferCompleteMatch, PartialPreferFirstMatch, NoMatch }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#PatternOption-enum" translate="no">PatternOption</a></b> { NoPatternOption, CaseInsensitiveOption, DotMatchesEverythingOption, MultilineOption, ExtendedPatternSyntaxOption, â€¦, DontAutomaticallyOptimizeOption }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#PatternOption-enum" translate="no">PatternOptions</a></b></td></tr>
</tbody></table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions<a class="plink" href="#public-functions" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#QRegularExpression-2" translate="no">QRegularExpression</a></b>(const QRegularExpression &amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#QRegularExpression-1" translate="no">QRegularExpression</a></b>(const QString &amp;<i>pattern</i>, QRegularExpression::PatternOptions <i>options</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpression &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-eq-1" translate="no">operator=</a></b>(QRegularExpression &amp;&amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpression &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-eq" translate="no">operator=</a></b>(const QRegularExpression &amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#dtor.QRegularExpression" translate="no">~QRegularExpression</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#captureCount" translate="no">captureCount</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#errorString" translate="no">errorString</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatchIterator </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#globalMatch" translate="no">globalMatch</a></b>(const QString &amp;<i>subject</i>, int <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatchIterator </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#globalMatch-1" translate="no">globalMatch</a></b>(const QStringRef &amp;<i>subjectRef</i>, int <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatchIterator </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#globalMatch-2" translate="no">globalMatch</a></b>(QStringView <i>subject</i>, int <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#isValid" translate="no">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatch </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#match" translate="no">match</a></b>(const QString &amp;<i>subject</i>, int <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = ...) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatch </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#match-1" translate="no">match</a></b>(const QStringRef &amp;<i>subjectRef</i>, int <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpressionMatch </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#match-2" translate="no">match</a></b>(QStringView <i>subject</i>, int <i>offset</i> = 0, QRegularExpression::MatchType <i>matchType</i> = NormalMatch, QRegularExpression::MatchOptions <i>matchOptions</i> = NoMatchOption) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#namedCaptureGroups" translate="no">namedCaptureGroups</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#optimize" translate="no">optimize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#pattern" translate="no">pattern</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#patternErrorOffset" translate="no">patternErrorOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegularExpression::PatternOptions </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#patternOptions" translate="no">patternOptions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#setPattern" translate="no">setPattern</a></b>(const QString &amp;<i>pattern</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#setPatternOptions" translate="no">setPatternOptions</a></b>(QRegularExpression::PatternOptions <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#swap" translate="no">swap</a></b>(QRegularExpression &amp;<i>other</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-not-eq" translate="no">operator!=</a></b>(const QRegularExpression &amp;<i>re</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-eq-eq" translate="no">operator==</a></b>(const QRegularExpression &amp;<i>re</i>) const</td></tr>
</tbody></table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members<a class="plink" href="#static-public-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#anchoredPattern" translate="no">anchoredPattern</a></b>(QStringView <i>expression</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#anchoredPattern-1" translate="no">anchoredPattern</a></b>(const QString &amp;<i>expression</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#escape" translate="no">escape</a></b>(QStringView <i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#escape-1" translate="no">escape</a></b>(const QString &amp;<i>str</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#wildcardToRegularExpression" translate="no">wildcardToRegularExpression</a></b>(QStringView <i>pattern</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#wildcardToRegularExpression-1" translate="no">wildcardToRegularExpression</a></b>(const QString &amp;<i>pattern</i>)</td></tr>
</tbody></table></div>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members<a class="plink" href="#related-non-members" title="Direct link to this headline"></a></h2>
<div class="table"><table class="alignedsummary" translate="no">
<tbody><tr><td class="memItemLeft rightAlign topAlign"> uint </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#qHash" translate="no">qHash</a></b>(const QRegularExpression &amp;<i>key</i>, uint <i>seed</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-lt-lt" translate="no">operator&lt;&lt;</a></b>(QDataStream &amp;<i>out</i>, const QRegularExpression &amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDebug </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-lt-lt-1" translate="no">operator&lt;&lt;</a></b>(QDebug <i>debug</i>, const QRegularExpression &amp;<i>re</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDebug </td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-lt-lt-2" translate="no">operator&lt;&lt;</a></b>(QDebug <i>debug</i>, QRegularExpression::PatternOptions <i>patternOptions</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QDataStream &amp;</td><td class="memItemRight bottomAlign"><b><a href="./qregularexpression.htm#operator-gt-gt" translate="no">operator&gt;&gt;</a></b>(QDataStream &amp;<i>in</i>, QRegularExpression &amp;<i>re</i>)</td></tr>
</tbody></table></div>
<a name="details"></a>
<!-- $$$QRegularExpression-description -->
<div class="descr">
<h2 id="details">Detailed Description<a class="plink" href="#details" title="Direct link to this headline"></a></h2>
<p>Regular expressions, or <i>regexps</i>, are a very powerful tool to handle strings and texts. This is useful in many contexts, e.g.,</p>
<div class="table"><table class="generic">
<tbody><tr class="odd" valign="top"><td>Validation</td><td>A regexp can test whether a substring meets some criteria, e.g. is an integer or contains no whitespace.</td></tr>
<tr class="even" valign="top"><td>Searching</td><td>A regexp provides more powerful pattern matching than simple substring matching, e.g., match one of the words <i>mail</i>, <i>letter</i> or <i>correspondence</i>, but none of the words <i>email</i>, <i>mailman</i>, <i>mailer</i>, <i>letterbox</i>, etc.</td></tr>
<tr class="odd" valign="top"><td>Search and Replace</td><td>A regexp can replace all occurrences of a substring with a different substring, e.g., replace all occurrences of <i>&amp;</i> with <i>&amp;amp;</i> except where the <i>&amp;</i> is already followed by an <i>amp;</i>.</td></tr>
<tr class="even" valign="top"><td>String Splitting</td><td>A regexp can be used to identify where a string should be split apart, e.g. splitting tab-delimited strings.</td></tr>
</tbody></table></div>
<p>This document is by no means a complete reference to pattern matching using regular expressions, and the following parts will require the reader to have some basic knowledge about Perl-like regular expressions and their pattern syntax.</p>
<p>Good references about regular expressions include:</p>
<ul>
<li><i>Mastering Regular Expressions</i> (Third Edition) by Jeffrey E. F. Friedl, ISBN 0-596-52812-4;</li>
<li>the <a href="http://pcre.org/pcre.txt" translate="no">pcrepattern</a>(3) man page, describing the pattern syntax supported by PCRE (the reference implementation of Perl-compatible regular expressions);</li>
<li>the <a href="http://perldoc.perl.org/perlre.html" translate="no">Perl's regular expression documentation</a> and the <a href="http://perldoc.perl.org/perlretut.html" translate="no">Perl's regular expression tutorial</a>.</li>
</ul>
<a name="introduction"></a>
<h3 id="introduction">Introduction<a class="plink" href="#introduction" title="Direct link to this headline"></a></h3>
<p>QRegularExpression implements Perl-compatible regular expressions. It fully supports Unicode. For an overview of the regular expression syntax supported by QRegularExpression, please refer to the aforementioned pcrepattern(3) man page. A regular expression is made up of two things: a <b>pattern string</b> and a set of <b>pattern options</b> that change the meaning of the pattern string.</p>
<p>You can set the pattern string by passing a string to the QRegularExpression constructor:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"a pattern"</span>);</pre></div>
<p>This sets the pattern string to <code translate="no">a pattern</code>. You can also use the <a href="./qregularexpression.htm#setPattern" translate="no">setPattern</a>() function to set a pattern on an existing QRegularExpression object:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re;
re<span class="operator">.</span>setPattern(<span class="string">"another pattern"</span>);</pre></div>
<p>Note that due to C++ literal strings rules, you must escape all backslashes inside the pattern string with another backslash:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// matches two digits followed by a space and a word</span>
<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"\\d\\d \\w+"</span>);

<span class="comment">// matches a backslash</span>
<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re2(<span class="string">"\\\\"</span>);</pre></div>
<p>The <a href="./qregularexpression.htm#pattern" translate="no">pattern</a>() function returns the pattern that is currently set for a QRegularExpression object:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"a third pattern"</span>);
<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> pattern <span class="operator">=</span> re<span class="operator">.</span>pattern(); <span class="comment">// pattern == "a third pattern"</span></pre></div>
<a name="pattern-options"></a>
<h3 id="pattern-options">Pattern Options<a class="plink" href="#pattern-options" title="Direct link to this headline"></a></h3>
<p>The meaning of the pattern string can be modified by setting one or more <i>pattern options</i>. For instance, it is possible to set a pattern to match case insensitively by setting the <a href="./qregularexpression.htm#PatternOption-enum" translate="no">QRegularExpression::CaseInsensitiveOption</a>.</p>
<p>You can set the options by passing them to the QRegularExpression constructor, as in:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// matches "Qt rocks", but also "QT rocks", "QT ROCKS", "qT rOcKs", etc.</span>
<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"Qt rocks"</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>CaseInsensitiveOption);</pre></div>
<p>Alternatively, you can use the <a href="./qregularexpression.htm#setPatternOptions" translate="no">setPatternOptions</a>() function on an existing QRegularExpressionObject:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"^\\d+$"</span>);
re<span class="operator">.</span>setPatternOptions(<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>MultilineOption);
<span class="comment">// re matches any line in the subject string that contains only digits (but at least one)</span></pre></div>
<p>It is possible to get the pattern options currently set on a QRegularExpression object by using the <a href="./qregularexpression.htm#patternOptions" translate="no">patternOptions</a>() function:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re <span class="operator">=</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span>(<span class="string">"^two.*words$"</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>MultilineOption
                                                           <span class="operator">|</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>DotMatchesEverythingOption);

<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PatternOptions options <span class="operator">=</span> re<span class="operator">.</span>patternOptions();
<span class="comment">// options == QRegularExpression::MultilineOption | QRegularExpression::DotMatchesEverythingOption</span></pre></div>
<p>Please refer to the <a href="./qregularexpression.htm#PatternOption-enum" translate="no">QRegularExpression::PatternOption</a> enum documentation for more information about each pattern option.</p>
<a name="match-type-and-match-options"></a>
<h3 id="match-type-and-match-options">Match Type and Match Options<a class="plink" href="#match-type-and-match-options" title="Direct link to this headline"></a></h3>
<p>The last two arguments of the <a href="./qregularexpression.htm#match" translate="no">match</a>() and the <a href="./qregularexpression.htm#globalMatch" translate="no">globalMatch</a>() functions set the match type and the match options. The match type is a value of the <a href="./qregularexpression.htm#MatchType-enum" translate="no">QRegularExpression::MatchType</a> enum; the "traditional" matching algorithm is chosen by using the <a href="./qregularexpression.htm#MatchType-enum" translate="no">NormalMatch</a> match type (the default). It is also possible to enable partial matching of the regular expression against a subject string: see the <a href="./qregularexpression.htm#partial-matching" translate="no">partial matching</a> section for more details.</p>
<p>The match options are a set of one or more <a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOption</a> values. They change the way a specific match of a regular expression against a subject string is done. Please refer to the <a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOption</a> enum documentation for more details.</p>
<a name="normal-matching"></a><a name="normal-matching"></a>
<h3 id="normal-matching">Normal Matching<a class="plink" href="#normal-matching" title="Direct link to this headline"></a></h3>
<p>In order to perform a match you can simply invoke the <a href="./qregularexpression.htm#match" translate="no">match</a>() function passing a string to match against. We refer to this string as the <i>subject string</i>. The result of the <a href="./qregularexpression.htm#match" translate="no">match</a>() function is a <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object that can be used to inspect the results of the match. For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="comment">// match two digits followed by a space and a word</span>
<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"\\d\\d \\w+"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"abc123 def"</span>);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// true</span></pre></div>
<p>If a match is successful, the (implicit) capturing group number 0 can be used to retrieve the substring matched by the entire pattern (see also the section about <a href="./qregularexpression.htm#extracting-captured-substrings" translate="no">extracting captured substrings</a>):</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"\\d\\d \\w+"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"abc123 def"</span>);
<span class="keyword">if</span> (match<span class="operator">.</span>hasMatch()) {
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> matched <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">0</span>); <span class="comment">// matched == "23 def"</span>
    <span class="comment">// ...</span>
}</pre></div>
<p>It's also possible to start a match at an arbitrary offset inside the subject string by passing the offset as an argument of the <a href="./qregularexpression.htm#match" translate="no">match</a>() function. In the following example <code translate="no">"12 abc"</code> is not matched because the match is started at offset 1:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"\\d\\d \\w+"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"12 abc 45 def"</span><span class="operator">,</span> <span class="number">1</span>);
<span class="keyword">if</span> (match<span class="operator">.</span>hasMatch()) {
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> matched <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">0</span>); <span class="comment">// matched == "45 def"</span>
    <span class="comment">// ...</span>
}</pre></div>
<a name="extracting-captured-substrings"></a><a name="extracting-captured-substrings"></a>
<h4 id="extracting-captured-substrings">Extracting captured substrings<a class="plink" href="#extracting-captured-substrings" title="Direct link to this headline"></a></h4>
<p>The <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object contains also information about the substrings captured by the capturing groups in the pattern string. The <a href="./qregularexpressionmatch.htm#captured" translate="no">captured()</a> function will return the string captured by the n-th capturing group:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"^(\\d\\d)/(\\d\\d)/(\\d\\d\\d\\d)$"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"08/12/1985"</span>);
<span class="keyword">if</span> (match<span class="operator">.</span>hasMatch()) {
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> day <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">1</span>); <span class="comment">// day == "08"</span>
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> month <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">2</span>); <span class="comment">// month == "12"</span>
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> year <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">3</span>); <span class="comment">// year == "1985"</span>
    <span class="comment">// ...</span>
}</pre></div>
<p>Capturing groups in the pattern are numbered starting from 1, and the implicit capturing group 0 is used to capture the substring that matched the entire pattern.</p>
<p>It's also possible to retrieve the starting and the ending offsets (inside the subject string) of each captured substring, by using the <a href="./qregularexpressionmatch.htm#capturedStart" translate="no">capturedStart()</a> and the <a href="./qregularexpressionmatch.htm#capturedEnd" translate="no">capturedEnd()</a> functions:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"abc(\\d+)def"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"XYZabc123defXYZ"</span>);
<span class="keyword">if</span> (match<span class="operator">.</span>hasMatch()) {
    <span class="type">int</span> startOffset <span class="operator">=</span> match<span class="operator">.</span>capturedStart(<span class="number">1</span>); <span class="comment">// startOffset == 6</span>
    <span class="type">int</span> endOffset <span class="operator">=</span> match<span class="operator">.</span>capturedEnd(<span class="number">1</span>); <span class="comment">// endOffset == 9</span>
    <span class="comment">// ...</span>
}</pre></div>
<p>All of these functions have an overload taking a <a href="./qstring.htm" translate="no">QString</a> as a parameter in order to extract <i>named</i> captured substrings. For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"^(?&lt;date&gt;\\d\\d)/(?&lt;month&gt;\\d\\d)/(?&lt;year&gt;\\d\\d\\d\\d)$"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"08/12/1985"</span>);
<span class="keyword">if</span> (match<span class="operator">.</span>hasMatch()) {
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> date <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="string">"date"</span>); <span class="comment">// date == "08"</span>
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> month <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="string">"month"</span>); <span class="comment">// month == "12"</span>
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> year <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="string">"year"</span>); <span class="comment">// year == 1985</span>
}</pre></div>
<a name="global-matching"></a><a name="global-matching"></a>
<h3 id="global-matching">Global Matching<a class="plink" href="#global-matching" title="Direct link to this headline"></a></h3>
<p><i>Global matching</i> is useful to find all the occurrences of a given regular expression inside a subject string. Suppose that we want to extract all the words from a given string, where a word is a substring matching the pattern <code translate="no">\w+</code>.</p>
<p><a href="./qregularexpression.htm#globalMatch" translate="no">QRegularExpression::globalMatch</a> returns a <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a>, which is a Java-like forward iterator that can be used to iterate over the results. For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"(\\w+)"</span>);
<span class="type"><a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a></span> i <span class="operator">=</span> re<span class="operator">.</span>globalMatch(<span class="string">"the quick fox"</span>);</pre></div>
<p>Since it's a Java-like iterator, the <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a> will point immediately before the first result. Every result is returned as a <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object. The <a href="./qregularexpressionmatchiterator.htm#hasNext" translate="no">hasNext()</a> function will return true if there's at least one more result, and <a href="./qregularexpressionmatchiterator.htm#next" translate="no">next()</a> will return the next result and advance the iterator. Continuing from the previous example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> words;
<span class="keyword">while</span> (i<span class="operator">.</span>hasNext()) {
    <span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> i<span class="operator">.</span>next();
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> word <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">1</span>);
    words <span class="operator">&lt;</span><span class="operator">&lt;</span> word;
}
<span class="comment">// words contains "the", "quick", "fox"</span></pre></div>
<p>You can also use <a href="./qregularexpressionmatchiterator.htm#peekNext" translate="no">peekNext()</a> to get the next result without advancing the iterator.</p>
<p>It is possible to pass a starting offset and one or more match options to the <a href="./qregularexpression.htm#globalMatch" translate="no">globalMatch</a>() function, exactly like normal matching with <a href="./qregularexpression.htm#match" translate="no">match</a>().</p>
<a name="partial-matching"></a><a name="partial-matching"></a>
<h3 id="partial-matching">Partial Matching<a class="plink" href="#partial-matching" title="Direct link to this headline"></a></h3>
<p>A <i>partial match</i> is obtained when the end of the subject string is reached, but more characters are needed to successfully complete the match. Note that a partial match is usually much more inefficient than a normal match because many optimizations of the matching algorithm cannot be employed.</p>
<p>A partial match must be explicitly requested by specifying a match type of <a href="./qregularexpression.htm#MatchType-enum" translate="no">PartialPreferCompleteMatch</a> or <a href="./qregularexpression.htm#MatchType-enum" translate="no">PartialPreferFirstMatch</a> when calling <a href="./qregularexpression.htm#match" translate="no">QRegularExpression::match</a> or <a href="./qregularexpression.htm#globalMatch" translate="no">QRegularExpression::globalMatch</a>. If a partial match is found, then calling the <a href="./qregularexpressionmatch.htm#hasMatch" translate="no">hasMatch()</a> function on the <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object returned by <a href="./qregularexpression.htm#match" translate="no">match</a>() will return <code translate="no">false</code>, but <a href="./qregularexpressionmatch.htm#hasPartialMatch" translate="no">hasPartialMatch()</a> will return <code translate="no">true</code>.</p>
<p>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</p>
<p>Note that asking for a partial match can still lead to a complete match, if one is found; in this case, <a href="./qregularexpressionmatch.htm#hasMatch" translate="no">hasMatch()</a> will return <code translate="no">true</code> and <a href="./qregularexpressionmatch.htm#hasPartialMatch" translate="no">hasPartialMatch()</a> <code translate="no">false</code>. It never happens that a <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> reports both a partial and a complete match.</p>
<p>Partial matching is mainly useful in two scenarios: validating user input in real time and incremental/multi-segment matching.</p>
<a name="validating-user-input"></a><a name="validating-user-input"></a>
<h4 id="validating-user-input">Validating user input<a class="plink" href="#validating-user-input" title="Direct link to this headline"></a></h4>
<p>Suppose that we would like the user to input a date in a specific format, for instance "MMM dd, yyyy". We can check the input validity with a pattern like:</p>
<p><code translate="no">^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \d\d?, \d\d\d\d$</code></p>
<p>(This pattern doesn't catch invalid days, but let's keep it for the example's purposes).</p>
<p>We would like to validate the input with this regular expression <i>while</i> the user is typing it, so that we can report an error in the input as soon as it is committed (for instance, the user typed the wrong key). In order to do so we must distinguish three cases:</p>
<ul>
<li>the input cannot possibly match the regular expression;</li>
<li>the input does match the regular expression;</li>
<li>the input does not match the regular expression right now, but it will if more characters will be added to it.</li>
</ul>
<p>Note that these three cases represent exactly the possible states of a <a href="./qvalidator.htm" translate="no">QValidator</a> (see the <a href="./qvalidator.htm#State-enum" translate="no">QValidator::State</a> enum).</p>
<p>In particular, in the last case we want the regular expression engine to report a partial match: we are successfully matching the pattern against the subject string but the matching cannot continue because the end of the subject is encountered. Notice, however, that the matching algorithm should continue and try all possibilities, and in case a complete (non-partial) match is found, then this one should be reported, and the input string accepted as fully valid.</p>
<p>This behavior is implemented by the <a href="./qregularexpression.htm#MatchType-enum" translate="no">PartialPreferCompleteMatch</a> match type. For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> pattern(<span class="string">"^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d\\d?, \\d\\d\\d\\d$"</span>);
<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(pattern);

<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> input(<span class="string">"Jan 21,"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(input<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PartialPreferCompleteMatch);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// false</span>
bool hasPartialMatch <span class="operator">=</span> match<span class="operator">.</span>hasPartialMatch(); <span class="comment">// true</span></pre></div>
<p>If matching the same regular expression against the subject string leads to a complete match, it is reported as usual:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> input(<span class="string">"Dec 8, 1985"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(input<span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PartialPreferCompleteMatch);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// true</span>
bool hasPartialMatch <span class="operator">=</span> match<span class="operator">.</span>hasPartialMatch(); <span class="comment">// false</span></pre></div>
<p>Another example with a different pattern, showing the behavior of preferring a complete match over a partial one:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"abc\\w+X|def"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"abcdef"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PartialPreferCompleteMatch);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// true</span>
bool hasPartialMatch <span class="operator">=</span> match<span class="operator">.</span>hasPartialMatch(); <span class="comment">// false</span>
<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> captured <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">0</span>); <span class="comment">// captured == "def"</span></pre></div>
<p>In this case, the subpattern <code translate="no">abc\\w+X</code> partially matches the subject string; however, the subpattern <code translate="no">def</code> matches the subject string completely, and therefore a complete match is reported.</p>
<p>If multiple partial matches are found when matching (but no complete match), then the <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object will report the first one that is found. For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"abc\\w+X|defY"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"abcdef"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PartialPreferCompleteMatch);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// false</span>
bool hasPartialMatch <span class="operator">=</span> match<span class="operator">.</span>hasPartialMatch(); <span class="comment">// true</span>
<span class="type"><a href="./qstring.htm" translate="no">QString</a></span> captured <span class="operator">=</span> match<span class="operator">.</span>captured(<span class="number">0</span>); <span class="comment">// captured == "abcdef"</span></pre></div>
<a name="incremental-multi-segment-matching"></a>
<h4 id="incremental-multi-segment-matching">Incremental/multi-segment matching<a class="plink" href="#incremental-multi-segment-matching" title="Direct link to this headline"></a></h4>
<p>Incremental matching is another use case of partial matching. Suppose that we want to find the occurrences of a regular expression inside a large text (that is, substrings matching the regular expression). In order to do so we would like to "feed" the large text to the regular expression engines in smaller chunks. The obvious problem is what happens if the substring that matches the regular expression spans across two or more chunks.</p>
<p>In this case, the regular expression engine should report a partial match, so that we can match again adding new data and (eventually) get a complete match. This implies that the regular expression engine may assume that there are other characters <i>beyond the end</i> of the subject string. This is not to be taken literally -- the engine will never try to access any character after the last one in the subject.</p>
<p>QRegularExpression implements this behavior when using the <a href="./qregularexpression.htm#MatchType-enum" translate="no">PartialPreferFirstMatch</a> match type. This match type reports a partial match as soon as it is found, and other match alternatives are not tried (even if they could lead to a complete match). For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"abc|ab"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"ab"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PartialPreferFirstMatch);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// false</span>
bool hasPartialMatch <span class="operator">=</span> match<span class="operator">.</span>hasPartialMatch(); <span class="comment">// true</span></pre></div>
<p>This happens because when matching the first branch of the alternation operator a partial match is found, and therefore matching stops, without trying the second branch. Another example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"abc(def)?"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"abc"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PartialPreferFirstMatch);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// false</span>
bool hasPartialMatch <span class="operator">=</span> match<span class="operator">.</span>hasPartialMatch(); <span class="comment">// true</span></pre></div>
<p>This shows what could seem a counterintuitive behavior of quantifiers: since <code translate="no">?</code> is greedy, then the engine tries first to continue the match after having matched <code translate="no">"abc"</code>; but then the matching reaches the end of the subject string, and therefore a partial match is reported. This is even more surprising in the following example:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="string">"(abc)*"</span>);
<span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> match <span class="operator">=</span> re<span class="operator">.</span>match(<span class="string">"abc"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>PartialPreferFirstMatch);
bool hasMatch <span class="operator">=</span> match<span class="operator">.</span>hasMatch(); <span class="comment">// false</span>
bool hasPartialMatch <span class="operator">=</span> match<span class="operator">.</span>hasPartialMatch(); <span class="comment">// true</span></pre></div>
<p>It's easy to understand this behavior if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</p>
<p>Since the <code translate="no">*</code> quantifier is greedy, then reporting a complete match could be an error, because after the current subject <code translate="no">"abc"</code> there may be other occurrences of <code translate="no">"abc"</code>. For instance, the complete text could have been "abcabcX", and therefore the <i>right</i> match to report (in the complete text) would have been <code translate="no">"abcabc"</code>; by matching only against the leading <code translate="no">"abc"</code> we instead get a partial match.</p>
<a name="error-handling"></a>
<h3 id="error-handling">Error Handling<a class="plink" href="#error-handling" title="Direct link to this headline"></a></h3>
<p>It is possible for a QRegularExpression object to be invalid because of syntax errors in the pattern string. The <a href="./qregularexpression.htm#isValid" translate="no">isValid</a>() function will return true if the regular expression is valid, or false otherwise:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> invalidRe(<span class="string">"(unmatched|parenthesis"</span>);
bool isValid <span class="operator">=</span> invalidRe<span class="operator">.</span>isValid(); <span class="comment">// false</span></pre></div>
<p>You can get more information about the specific error by calling the <a href="./qregularexpression.htm#errorString" translate="no">errorString</a>() function; moreover, the <a href="./qregularexpression.htm#patternErrorOffset" translate="no">patternErrorOffset</a>() function will return the offset inside the pattern string</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> invalidRe(<span class="string">"(unmatched|parenthesis"</span>);
<span class="keyword">if</span> (<span class="operator">!</span>invalidRe<span class="operator">.</span>isValid()) {
    <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> errorString <span class="operator">=</span> invalidRe<span class="operator">.</span>errorString(); <span class="comment">// errorString == "missing )"</span>
    <span class="type">int</span> errorOffset <span class="operator">=</span> invalidRe<span class="operator">.</span>patternErrorOffset(); <span class="comment">// errorOffset == 22</span>
    <span class="comment">// ...</span>
}</pre></div>
<p>If a match is attempted with an invalid QRegularExpression, then the returned <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object will be invalid as well (that is, its <a href="./qregularexpressionmatch.htm#isValid" translate="no">isValid()</a> function will return false). The same applies for attempting a global match.</p>
<a name="unsupported-perl-compatible-regular-expressions-features"></a>
<h3 id="unsupported-perl-compatible-regular-expressions-features">Unsupported Perl-compatible Regular Expressions Features<a class="plink" href="#unsupported-perl-compatible-regular-expressions-features" title="Direct link to this headline"></a></h3>
<p>QRegularExpression does not support all the features available in Perl-compatible regular expressions. The most notable one is the fact that duplicated names for capturing groups are not supported, and using them can lead to undefined behavior.</p>
<p>This may change in a future version of Qt.</p>
<a name="notes-for-qregexp-users"></a>
<h3 id="notes-for-qregexp-users">Notes for QRegExp Users<a class="plink" href="#notes-for-qregexp-users" title="Direct link to this headline"></a></h3>
<p>The QRegularExpression class introduced in Qt 5 is a big improvement upon <a href="./qregexp.htm" translate="no">QRegExp</a>, in terms of APIs offered, supported pattern syntax and speed of execution. The biggest difference is that QRegularExpression simply holds a regular expression, and it's <i>not</i> modified when a match is requested. Instead, a <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object is returned, in order to check the result of a match and extract the captured substring. The same applies with global matching and <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a>.</p>
<p>Other differences are outlined below.</p>
<a name="different-pattern-syntax"></a>
<h4 id="different-pattern-syntax">Different pattern syntax<a class="plink" href="#different-pattern-syntax" title="Direct link to this headline"></a></h4>
<p>Porting a regular expression from <a href="./qregexp.htm" translate="no">QRegExp</a> to QRegularExpression may require changes to the pattern itself.</p>
<p>In certain scenarios, <a href="./qregexp.htm" translate="no">QRegExp</a> was too lenient and accepted patterns that are simply invalid when using QRegularExpression. These are somehow easy to detect, because the QRegularExpression objects built with these patterns are not valid (cf. <a href="./qregularexpression.htm#isValid" translate="no">isValid</a>()).</p>
<p>In other cases, a pattern ported from <a href="./qregexp.htm" translate="no">QRegExp</a> to QRegularExpression may silently change semantics. Therefore, it is necessary to review the patterns used. The most notable cases of silent incompatibility are:</p>
<ul>
<li>Curly braces are needed in order to use a hexadecimal escape like <code translate="no">\xHHHH</code> with more than 2 digits. A pattern like <code translate="no">\x2022</code> neeeds to be ported to <code translate="no">\x{2022}</code>, or it will match a space (<code translate="no">0x20</code>) followed by the string <code translate="no">"22"</code>. In general, it is highly recommended to always use curly braces with the <code translate="no">\x</code> escape, no matter the amount of digits specified.</li>
<li>A 0-to-n quantification like <code translate="no">{,n}</code> needs to be ported to <code translate="no">{0,n}</code> to preserve semantics. Otherwise, a pattern such as <code translate="no">\d{,3}</code> would actually match a digit followed by the exact string <code translate="no">"{,3}"</code>.</li>
<li><a href="./qregexp.htm" translate="no">QRegExp</a> by default does Unicode-aware matching, while QRegularExpression requires a separate option; see below for more details.</li>
</ul>
<a name="porting-from-qregexp-exactmatch"></a>
<h4 id="porting-from-qregexp-exactmatch">Porting from QRegExp::exactMatch()<a class="plink" href="#porting-from-qregexp-exactmatch" title="Direct link to this headline"></a></h4>
<p><a href="./qregexp.htm#exactMatch" translate="no">QRegExp::exactMatch</a>() in Qt 4 served two purposes: it exactly matched a regular expression against a subject string, and it implemented partial matching.</p>
<a name="porting-from-qregexp-s-exact-matching"></a>
<h5 id="porting-from-qregexp-s-exact-matching">Porting from QRegExp's Exact Matching<a class="plink" href="#porting-from-qregexp-s-exact-matching" title="Direct link to this headline"></a></h5>
<p>Exact matching indicates whether the regular expression matches the entire subject string. For example, the classes yield on the subject string <code translate="no">"abc123"</code>:</p>
<div class="table"><table class="generic">
<thead><tr class="qt-style"><th></th><th><a href="./qregexp.htm#exactMatch" translate="no">QRegExp::exactMatch</a>()</th><th><a href="./qregularexpressionmatch.htm#hasMatch" translate="no">QRegularExpressionMatch::hasMatch</a>()</th></tr></thead>
<tbody><tr class="odd" valign="top"><td><code translate="no">"\\d+"</code></td><td><b>false</b></td><td><b>true</b></td></tr>
<tr class="even" valign="top"><td><code translate="no">"[a-z]+\\d+"</code></td><td><b>true</b></td><td><b>true</b></td></tr>
</tbody></table></div>
<p>Exact matching is not reflected in QRegularExpression. If you want to be sure that the subject string matches the regular expression exactly, you can wrap the pattern using the <a href="./qregularexpression.htm#anchoredPattern" translate="no">anchoredPattern</a>() function:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> p(<span class="string">"a .*|pattern"</span>);

<span class="comment">// re matches exactly the pattern string p</span>
<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>anchoredPattern(p));</pre></div>
<a name="porting-from-qregexp-s-partial-matching"></a>
<h5 id="porting-from-qregexp-s-partial-matching">Porting from QRegExp's Partial Matching<a class="plink" href="#porting-from-qregexp-s-partial-matching" title="Direct link to this headline"></a></h5>
<p>When using <a href="./qregexp.htm#exactMatch" translate="no">QRegExp::exactMatch</a>(), if an exact match was not found, one could still find out how much of the subject string was matched by the regular expression by calling <a href="./qregexp.htm#matchedLength" translate="no">QRegExp::matchedLength</a>(). If the returned length was equal to the subject string's length, then one could conclude that a partial match was found.</p>
<p>QRegularExpression supports partial matching explicitly by means of the appropriate <a href="./qregularexpression.htm#MatchType-enum" translate="no">MatchType</a>.</p>
<a name="global-matching"></a>
<h4 id="global-matching">Global matching<a class="plink" href="#global-matching" title="Direct link to this headline"></a></h4>
<p>Due to limitations of the <a href="./qregexp.htm" translate="no">QRegExp</a> API it was impossible to implement global matching correctly (that is, like Perl does). In particular, patterns that can match 0 characters (like <code translate="no">"a*"</code>) are problematic.</p>
<p><a href="./qregularexpression.htm#globalMatch" translate="no">QRegularExpression::globalMatch</a>() implements Perl global match correctly, and the returned iterator can be used to examine each result.</p>
<a name="unicode-properties-support"></a>
<h4 id="unicode-properties-support">Unicode properties support<a class="plink" href="#unicode-properties-support" title="Direct link to this headline"></a></h4>
<p>When using <a href="./qregexp.htm" translate="no">QRegExp</a>, character classes such as <code translate="no">\w</code>, <code translate="no">\d</code>, etc. match characters with the corresponding Unicode property: for instance, <code translate="no">\d</code> matches any character with the Unicode Nd (decimal digit) property.</p>
<p>Those character classes only match ASCII characters by default when using QRegularExpression: for instance, <code translate="no">\d</code> matches exactly a character in the <code translate="no">0-9</code> ASCII range. It is possible to change this behaviour by using the <a href="./qregularexpression.htm#PatternOption-enum" translate="no">UseUnicodePropertiesOption</a> pattern option.</p>
<a name="wildcard-matching"></a>
<h4 id="wildcard-matching">Wildcard matching<a class="plink" href="#wildcard-matching" title="Direct link to this headline"></a></h4>
<p>There is no direct way to do wildcard matching in QRegularExpression. However, the <a href="./qregularexpression.htm#wildcardToRegularExpression" translate="no">wildcardToRegularExpression</a> method is provided to translate glob patterns into a Perl-compatible regular expression that can be used for that purpose.</p>
<a name="other-pattern-syntaxes"></a>
<h4 id="other-pattern-syntaxes">Other pattern syntaxes<a class="plink" href="#other-pattern-syntaxes" title="Direct link to this headline"></a></h4>
<p>QRegularExpression supports only Perl-compatible regular expressions.</p>
<a name="minimal-matching"></a>
<h4 id="minimal-matching">Minimal matching<a class="plink" href="#minimal-matching" title="Direct link to this headline"></a></h4>
<p><a href="./qregexp.htm#setMinimal" translate="no">QRegExp::setMinimal</a>() implemented minimal matching by simply reversing the greediness of the quantifiers (<a href="./qregexp.htm" translate="no">QRegExp</a> did not support lazy quantifiers, like <code translate="no">*?</code>, <code translate="no">+?</code>, etc.). QRegularExpression instead does support greedy, lazy and possessive quantifiers. The <a href="./qregularexpression.htm#PatternOption-enum" translate="no">InvertedGreedinessOption</a> pattern option can be useful to emulate the effects of <a href="./qregexp.htm#setMinimal" translate="no">QRegExp::setMinimal</a>(): if enabled, it inverts the greediness of quantifiers (greedy ones become lazy and vice versa).</p>
<a name="caret-modes"></a>
<h4 id="caret-modes">Caret modes<a class="plink" href="#caret-modes" title="Direct link to this headline"></a></h4>
<p>The <a href="./qregularexpression.htm#MatchOption-enum" translate="no">AnchoredMatchOption</a> match option can be used to emulate the <a href="./qregexp.htm#CaretMode-enum" translate="no">QRegExp::CaretAtOffset</a> behaviour. There is no equivalent for the other <a href="./qregexp.htm#CaretMode-enum" translate="no">QRegExp::CaretMode</a> modes.</p>
<a name="debugging-code-that-uses-qregularexpression"></a>
<h3 id="debugging-code-that-uses-qregularexpression">Debugging Code that Uses QRegularExpression<a class="plink" href="#debugging-code-that-uses-qregularexpression" title="Direct link to this headline"></a></h3>
<p>QRegularExpression internally uses a just in time compiler (JIT) to optimize the execution of the matching algorithm. The JIT makes extensive usage of self-modifying code, which can lead debugging tools such as Valgrind to crash. You must enable all checks for self-modifying code if you want to debug programs using QRegularExpression (for instance, Valgrind's <code translate="no">--smc-check</code> command line option). The downside of enabling such checks is that your program will run considerably slower.</p>
<p>To avoid that, the JIT is disabled by default if you compile Qt in debug mode. It is possible to override the default and enable or disable the JIT usage (both in debug or release mode) by setting the <code translate="no">QT_ENABLE_REGEXP_JIT</code> environment variable to a non-zero or zero value respectively.</p>
</div>
<p><b>See also </b><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> and <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a>.</p>
<!-- @@@QRegularExpression -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$MatchOption$$$NoMatchOption$$$AnchoredMatchOption$$$DontCheckSubjectStringMatchOption -->
<h3 class="flags" id="MatchOption-enum"><a name="MatchOption-enum"></a>enum QRegularExpression::<span class="name">MatchOption</span><br>flags QRegularExpression::<span class="name">MatchOptions</span><a class="plink" href="#MatchOption-enum" title="Direct link to this headline"></a></h3>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::NoMatchOption</code></td><td class="topAlign tblval"><code translate="no">0x0000</code></td><td class="topAlign">No match options are set.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::AnchoredMatchOption</code></td><td class="topAlign tblval"><code translate="no">0x0001</code></td><td class="topAlign">The match is constrained to start exactly at the offset passed to <a href="./qregularexpression.htm#match" translate="no">match</a>() in order to be successful, even if the pattern string does not contain any metacharacter that anchors the match at that point.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::DontCheckSubjectStringMatchOption</code></td><td class="topAlign tblval"><code translate="no">0x0002</code></td><td class="topAlign">The subject string is not checked for UTF-16 validity before attempting a match. Use this option with extreme caution, as attempting to match an invalid string may crash the program and/or constitute a security issue. This enum value has been introduced in Qt 5.4.</td></tr>
</tbody></table></div>
<p>The MatchOptions type is a typedef for <a href="./qflags.htm">QFlags</a>&lt;MatchOption&gt;. It stores an OR combination of MatchOption values.</p>
<!-- @@@MatchOption -->
<!-- $$$MatchType$$$NormalMatch$$$PartialPreferCompleteMatch$$$PartialPreferFirstMatch$$$NoMatch -->
<h3 class="fn" id="MatchType-enum" translate="no"><a name="MatchType-enum"></a>enum QRegularExpression::<span class="name">MatchType</span><a class="plink" href="#MatchType-enum" title="Direct link to this headline"></a></h3>
<p>The MatchType enum defines the type of the match that should be attempted against the subject string.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::NormalMatch</code></td><td class="topAlign tblval"><code translate="no">0</code></td><td class="topAlign">A normal match is done.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::PartialPreferCompleteMatch</code></td><td class="topAlign tblval"><code translate="no">1</code></td><td class="topAlign">The pattern string is matched partially against the subject string. If a partial match is found, then it is recorded, and other matching alternatives are tried as usual. If a complete match is then found, then it's preferred to the partial match; in this case only the complete match is reported. If instead no complete match is found (but only the partial one), then the partial one is reported.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::PartialPreferFirstMatch</code></td><td class="topAlign tblval"><code translate="no">2</code></td><td class="topAlign">The pattern string is matched partially against the subject string. If a partial match is found, then matching stops and the partial match is reported. In this case, other matching alternatives (potentially leading to a complete match) are not tried. Moreover, this match type assumes that the subject string only a substring of a larger text, and that (in this text) there are other characters beyond the end of the subject string. This can lead to surprising results; see the discussion in the <a href="./qregularexpression.htm#partial-matching" translate="no">partial matching</a> section for more details.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::NoMatch</code></td><td class="topAlign tblval"><code translate="no">3</code></td><td class="topAlign">No matching is done. This value is returned as the match type by a default constructed <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> or <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a>. Using this match type is not very useful for the user, as no matching ever happens. This enum value has been introduced in Qt 5.1.</td></tr>
</tbody></table></div>
<!-- @@@MatchType -->
<!-- $$$PatternOption$$$NoPatternOption$$$CaseInsensitiveOption$$$DotMatchesEverythingOption$$$MultilineOption$$$ExtendedPatternSyntaxOption$$$InvertedGreedinessOption$$$DontCaptureOption$$$UseUnicodePropertiesOption$$$OptimizeOnFirstUsageOption$$$DontAutomaticallyOptimizeOption -->
<h3 class="flags" id="PatternOption-enum"><a name="PatternOption-enum"></a>enum QRegularExpression::<span class="name">PatternOption</span><br>flags QRegularExpression::<span class="name">PatternOptions</span><a class="plink" href="#PatternOption-enum" title="Direct link to this headline"></a></h3>
<p>The PatternOption enum defines modifiers to the way the pattern string should be interpreted, and therefore the way the pattern matches against a subject string.</p>
<div class="table"><table class="valuelist"><tbody><tr class="odd" valign="top"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::NoPatternOption</code></td><td class="topAlign tblval"><code translate="no">0x0000</code></td><td class="topAlign">No pattern options are set.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::CaseInsensitiveOption</code></td><td class="topAlign tblval"><code translate="no">0x0001</code></td><td class="topAlign">The pattern should match against the subject string in a case insensitive way. This option corresponds to the /i modifier in Perl regular expressions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::DotMatchesEverythingOption</code></td><td class="topAlign tblval"><code translate="no">0x0002</code></td><td class="topAlign">The dot metacharacter (<code translate="no">.</code>) in the pattern string is allowed to match any character in the subject string, including newlines (normally, the dot does not match newlines). This option corresponds to the <code translate="no">/s</code> modifier in Perl regular expressions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::MultilineOption</code></td><td class="topAlign tblval"><code translate="no">0x0004</code></td><td class="topAlign">The caret (<code translate="no">^</code>) and the dollar (<code translate="no">$</code>) metacharacters in the pattern string are allowed to match, respectively, immediately after and immediately before any newline in the subject string, as well as at the very beginning and at the very end of the subject string. This option corresponds to the <code translate="no">/m</code> modifier in Perl regular expressions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::ExtendedPatternSyntaxOption</code></td><td class="topAlign tblval"><code translate="no">0x0008</code></td><td class="topAlign">Any whitespace in the pattern string which is not escaped and outside a character class is ignored. Moreover, an unescaped sharp (<b>#</b>) outside a character class causes all the following characters, until the first newline (included), to be ignored. This can be used to increase the readability of a pattern string as well as put comments inside regular expressions; this is particularly useful if the pattern string is loaded from a file or written by the user, because in C++ code it is always possible to use the rules for string literals to put comments outside the pattern string. This option corresponds to the <code translate="no">/x</code> modifier in Perl regular expressions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::InvertedGreedinessOption</code></td><td class="topAlign tblval"><code translate="no">0x0010</code></td><td class="topAlign">The greediness of the quantifiers is inverted: <code translate="no">*</code>, <code translate="no">+</code>, <code translate="no">?</code>, <code translate="no">{m,n}</code>, etc. become lazy, while their lazy versions (<code translate="no">*?</code>, <code translate="no">+?</code>, <code translate="no">??</code>, <code translate="no">{m,n}?</code>, etc.) become greedy. There is no equivalent for this option in Perl regular expressions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::DontCaptureOption</code></td><td class="topAlign tblval"><code translate="no">0x0020</code></td><td class="topAlign">The non-named capturing groups do not capture substrings; named capturing groups still work as intended, as well as the implicit capturing group number 0 corresponding to the entire match. There is no equivalent for this option in Perl regular expressions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::UseUnicodePropertiesOption</code></td><td class="topAlign tblval"><code translate="no">0x0040</code></td><td class="topAlign">The meaning of the <code translate="no">\w</code>, <code translate="no">\d</code>, etc., character classes, as well as the meaning of their counterparts (<code translate="no">\W</code>, <code translate="no">\D</code>, etc.), is changed from matching ASCII characters only to matching any character with the corresponding Unicode property. For instance, <code translate="no">\d</code> is changed to match any character with the Unicode Nd (decimal digit) property; <code translate="no">\w</code> to match any character with either the Unicode L (letter) or N (digit) property, plus underscore, and so on. This option corresponds to the <code translate="no">/u</code> modifier in Perl regular expressions.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::OptimizeOnFirstUsageOption</code></td><td class="topAlign tblval"><code translate="no">0x0080</code></td><td class="topAlign">This option is ignored. A regular expression is automatically optimized (including JIT compiling) the first time it is used. This enum value was introduced in Qt 5.4.</td></tr>
<tr><td class="topAlign"><code translate="no">QRegularExpression::DontAutomaticallyOptimizeOption</code></td><td class="topAlign tblval"><code translate="no">0x0100</code></td><td class="topAlign">This option is ignored. A regular expression is automatically optimized (including JIT compiling) the first time it is used. This enum value was introduced in Qt 5.4.</td></tr>
</tbody></table></div>
<p>The PatternOptions type is a typedef for <a href="./qflags.htm">QFlags</a>&lt;PatternOption&gt;. It stores an OR combination of PatternOption values.</p>
<!-- @@@PatternOption -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QRegularExpression$$$QRegularExpressionconstQRegularExpression& -->
<h3 class="fn" id="QRegularExpression-2" translate="no"><a name="QRegularExpression-2"></a>QRegularExpression::<span class="name">QRegularExpression</span>(const <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>re</i>)<a class="plink" href="#QRegularExpression-2" title="Direct link to this headline"></a></h3>
<p>Constructs a QRegularExpression object as a copy of <i translate="no">re</i>.</p>
<p><b>See also </b><a href="./qregularexpression.htm#operator-eq" translate="no">operator=</a>().</p>
<!-- @@@QRegularExpression -->
<!-- $$$QRegularExpression$$$QRegularExpressionconstQString&QRegularExpression::PatternOptions -->
<h3 class="fn" id="QRegularExpression-1" translate="no"><a name="QRegularExpression-1"></a>QRegularExpression::<span class="name">QRegularExpression</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>pattern</i>, <span class="type"><a href="./qregularexpression.htm#PatternOption-enum" translate="no">QRegularExpression::PatternOptions</a></span> <i>options</i> = ...)<a class="plink" href="#QRegularExpression-1" title="Direct link to this headline"></a></h3>
<p>Constructs a QRegularExpression object using the given <i translate="no">pattern</i> as pattern and the <i translate="no">options</i> as the pattern options.</p>
<p><b>See also </b><a href="./qregularexpression.htm#setPattern" translate="no">setPattern</a>() and <a href="./qregularexpression.htm#setPatternOptions" translate="no">setPatternOptions</a>().</p>
<!-- @@@QRegularExpression -->
<!-- $$$QRegularExpression[overload1]$$$QRegularExpression -->
<h3 class="fn" id="QRegularExpression" translate="no"><a name="QRegularExpression"></a>QRegularExpression::<span class="name">QRegularExpression</span>()<a class="plink" href="#QRegularExpression" title="Direct link to this headline"></a></h3>
<p>Constructs a QRegularExpression object with an empty pattern and no pattern options.</p>
<p><b>See also </b><a href="./qregularexpression.htm#setPattern" translate="no">setPattern</a>() and <a href="./qregularexpression.htm#setPatternOptions" translate="no">setPatternOptions</a>().</p>
<!-- @@@QRegularExpression -->
<!-- $$$operator=$$$operator=QRegularExpression&& -->
<h3 class="fn" id="operator-eq-1" translate="no"><a name="operator-eq-1"></a><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;QRegularExpression::<span class="name">operator=</span>(<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;&amp;<i>re</i>)<a class="plink" href="#operator-eq-1" title="Direct link to this headline"></a></h3>
<p>Move-assigns the regular expression <i translate="no">re</i> to this object, and returns a reference to the copy. Both the pattern and the pattern options are copied.</p>
<!-- @@@operator= -->
<!-- $$$operator=[overload1]$$$operator=constQRegularExpression& -->
<h3 class="fn" id="operator-eq" translate="no"><a name="operator-eq"></a><span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;QRegularExpression::<span class="name">operator=</span>(const <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>re</i>)<a class="plink" href="#operator-eq" title="Direct link to this headline"></a></h3>
<p>Assigns the regular expression <i translate="no">re</i> to this object, and returns a reference to the copy. Both the pattern and the pattern options are copied.</p>
<!-- @@@operator= -->
<!-- $$$~QRegularExpression[overload1]$$$~QRegularExpression -->
<h3 class="fn" id="dtor.QRegularExpression" translate="no"><a name="dtor.QRegularExpression"></a>QRegularExpression::<span class="name">~QRegularExpression</span>()<a class="plink" href="#dtor.QRegularExpression" title="Direct link to this headline"></a></h3>
<p>Destroys the <a href="./qregularexpression.htm" translate="no">QRegularExpression</a> object.</p>
<!-- @@@~QRegularExpression -->
<!-- $$$anchoredPattern[overload1]$$$anchoredPatternQStringView -->
<h3 class="fn" id="anchoredPattern" translate="no"><a name="anchoredPattern"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">anchoredPattern</span>(<span class="type"><a href="./qstringview.htm" translate="no">QStringView</a></span> <i>expression</i>)<a class="plink" href="#anchoredPattern" title="Direct link to this headline"></a></h3>
<p>Returns the <i translate="no">expression</i> wrapped between the <code translate="no">\A</code> and <code translate="no">\z</code> anchors to be used for exact matching.</p>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qregularexpression.htm#porting-from-qregexp-s-exact-matching" translate="no">Porting from QRegExp's Exact Matching</a>.</p>
<!-- @@@anchoredPattern -->
<!-- $$$anchoredPattern$$$anchoredPatternconstQString& -->
<h3 class="fn" id="anchoredPattern-1" translate="no"><a name="anchoredPattern-1"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">anchoredPattern</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>expression</i>)<a class="plink" href="#anchoredPattern-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.12.</p>
<!-- @@@anchoredPattern -->
<!-- $$$captureCount[overload1]$$$captureCount -->
<h3 class="fn" id="captureCount" translate="no"><a name="captureCount"></a><span class="type">int</span> QRegularExpression::<span class="name">captureCount</span>() const<a class="plink" href="#captureCount" title="Direct link to this headline"></a></h3>
<p>Returns the number of capturing groups inside the pattern string, or -1 if the regular expression is not valid.</p>
<div class="admonition note">
<p><b>Note: </b>The implicit capturing group 0 is <i>not</i> included in the returned number.</p>
</div>
<p><b>See also </b><a href="./qregularexpression.htm#isValid" translate="no">isValid</a>().</p>
<!-- @@@captureCount -->
<!-- $$$errorString[overload1]$$$errorString -->
<h3 class="fn" id="errorString" translate="no"><a name="errorString"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">errorString</span>() const<a class="plink" href="#errorString" title="Direct link to this headline"></a></h3>
<p>Returns a textual description of the error found when checking the validity of the regular expression, or "no error" if no error was found.</p>
<p><b>See also </b><a href="./qregularexpression.htm#isValid" translate="no">isValid</a>() and <a href="./qregularexpression.htm#patternErrorOffset" translate="no">patternErrorOffset</a>().</p>
<!-- @@@errorString -->
<!-- $$$escape[overload1]$$$escapeQStringView -->
<h3 class="fn" id="escape" translate="no"><a name="escape"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">escape</span>(<span class="type"><a href="./qstringview.htm" translate="no">QStringView</a></span> <i>str</i>)<a class="plink" href="#escape" title="Direct link to this headline"></a></h3>
<p>Escapes all characters of <i translate="no">str</i> so that they no longer have any special meaning when used as a regular expression pattern string, and returns the escaped string. For instance:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> escaped <span class="operator">=</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>escape(<span class="string">"a(x) = f(x) + g(x)"</span>);
<span class="comment">// escaped == "a\\(x\\)\\ \\=\\ f\\(x\\)\\ \\+\\ g\\(x\\)"</span></pre></div>
<p>This is very convenient in order to build patterns from arbitrary strings:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> pattern <span class="operator">=</span> <span class="string">"("</span> <span class="operator">+</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>escape(name) <span class="operator">+</span>
                  <span class="string">"|"</span> <span class="operator">+</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>escape(nickname) <span class="operator">+</span> <span class="string">")"</span>;
<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> re(pattern);</pre></div>
<div class="admonition note">
<p><b>Note: </b>This function implements Perl's quotemeta algorithm and escapes with a backslash all characters in <i translate="no">str</i>, except for the characters in the <code translate="no">[A-Z]</code>, <code translate="no">[a-z]</code> and <code translate="no">[0-9]</code> ranges, as well as the underscore (<code translate="no">_</code>) character. The only difference with Perl is that a literal NUL inside <i translate="no">str</i> is escaped with the sequence <code translate="no">"\\0"</code> (backslash + <code translate="no">'0'</code>), instead of <code translate="no">"\\\0"</code> (backslash + <code translate="no">NUL</code>).</p>
</div>
<p>This function was introduced in Qt 5.15.</p>
<!-- @@@escape -->
<!-- $$$escape$$$escapeconstQString& -->
<h3 class="fn" id="escape-1" translate="no"><a name="escape-1"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">escape</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>str</i>)<a class="plink" href="#escape-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<!-- @@@escape -->
<!-- $$$globalMatch[overload1]$$$globalMatchconstQString&intQRegularExpression::MatchTypeQRegularExpression::MatchOptions -->
<h3 class="fn" id="globalMatch" translate="no"><a name="globalMatch"></a><span class="type"><a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a></span> QRegularExpression::<span class="name">globalMatch</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>subject</i>, <span class="type">int</span> <i>offset</i> = 0, <span class="type"><a href="./qregularexpression.htm#MatchType-enum" translate="no">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const<a class="plink" href="#globalMatch" title="Direct link to this headline"></a></h3>
<p>Attempts to perform a global match of the regular expression against the given <i translate="no">subject</i> string, starting at the position <i translate="no">offset</i> inside the subject, using a match of type <i translate="no">matchType</i> and honoring the given <i translate="no">matchOptions</i>.</p>
<p>The returned <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a> is positioned before the first match result (if any).</p>
<p><b>See also </b><a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a> and <a href="./qregularexpression.htm#global-matching" translate="no">global matching</a>.</p>
<!-- @@@globalMatch -->
<!-- $$$globalMatch$$$globalMatchconstQStringRef&intQRegularExpression::MatchTypeQRegularExpression::MatchOptions -->
<h3 class="fn" id="globalMatch-1" translate="no"><a name="globalMatch-1"></a><span class="type"><a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a></span> QRegularExpression::<span class="name">globalMatch</span>(const <span class="type"><a href="./qstringref.htm" translate="no">QStringRef</a></span> &amp;<i>subjectRef</i>, <span class="type">int</span> <i>offset</i> = 0, <span class="type"><a href="./qregularexpression.htm#MatchType-enum" translate="no">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const<a class="plink" href="#globalMatch-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Attempts to perform a global match of the regular expression against the given <i translate="no">subjectRef</i> string reference, starting at the position <i translate="no">offset</i> inside the subject, using a match of type <i translate="no">matchType</i> and honoring the given <i translate="no">matchOptions</i>.</p>
<p>The returned <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a> is positioned before the first match result (if any).</p>
<p>This function was introduced in Qt 5.5.</p>
<p><b>See also </b><a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a> and <a href="./qregularexpression.htm#global-matching" translate="no">global matching</a>.</p>
<!-- @@@globalMatch -->
<!-- $$$globalMatch$$$globalMatchQStringViewintQRegularExpression::MatchTypeQRegularExpression::MatchOptions -->
<h3 class="fn" id="globalMatch-2" translate="no"><a name="globalMatch-2"></a><span class="type"><a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a></span> QRegularExpression::<span class="name">globalMatch</span>(<span class="type"><a href="./qstringview.htm" translate="no">QStringView</a></span> <i>subject</i>, <span class="type">int</span> <i>offset</i> = 0, <span class="type"><a href="./qregularexpression.htm#MatchType-enum" translate="no">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const<a class="plink" href="#globalMatch-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Attempts to perform a global match of the regular expression against the given <i translate="no">subject</i> string, starting at the position <i translate="no">offset</i> inside the subject, using a match of type <i translate="no">matchType</i> and honoring the given <i translate="no">matchOptions</i>.</p>
<p>The returned <a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a> is positioned before the first match result (if any).</p>
<div class="admonition note">
<p><b>Note: </b>This overload has been added in 5.15.2 to simplify writing code that is portable between Qt 5.15 and Qt 6. The implementation is not tuned for performance in Qt 5.</p>
</div>
<p>This function was introduced in Qt 5.15.2.</p>
<p><b>See also </b><a href="./qregularexpressionmatchiterator.htm" translate="no">QRegularExpressionMatchIterator</a> and <a href="./qregularexpression.htm#global-matching" translate="no">global matching</a>.</p>
<!-- @@@globalMatch -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid" translate="no"><a name="isValid"></a><span class="type">bool</span> QRegularExpression::<span class="name">isValid</span>() const<a class="plink" href="#isValid" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the regular expression is a valid regular expression (that is, it contains no syntax errors, etc.), or false otherwise. Use <a href="./qregularexpression.htm#errorString" translate="no">errorString</a>() to obtain a textual description of the error.</p>
<p><b>See also </b><a href="./qregularexpression.htm#errorString" translate="no">errorString</a>() and <a href="./qregularexpression.htm#patternErrorOffset" translate="no">patternErrorOffset</a>().</p>
<!-- @@@isValid -->
<!-- $$$match[overload1]$$$matchconstQString&intQRegularExpression::MatchTypeQRegularExpression::MatchOptions -->
<h3 class="fn" id="match" translate="no"><a name="match"></a><span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> QRegularExpression::<span class="name">match</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>subject</i>, <span class="type">int</span> <i>offset</i> = 0, <span class="type"><a href="./qregularexpression.htm#MatchType-enum" translate="no">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = ...) const<a class="plink" href="#match" title="Direct link to this headline"></a></h3>
<p>Attempts to match the regular expression against the given <i translate="no">subject</i> string, starting at the position <i translate="no">offset</i> inside the subject, using a match of type <i translate="no">matchType</i> and honoring the given <i translate="no">matchOptions</i>.</p>
<p>The returned <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object contains the results of the match.</p>
<p><b>See also </b><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> and <a href="./qregularexpression.htm#normal-matching" translate="no">normal matching</a>.</p>
<!-- @@@match -->
<!-- $$$match$$$matchconstQStringRef&intQRegularExpression::MatchTypeQRegularExpression::MatchOptions -->
<h3 class="fn" id="match-1" translate="no"><a name="match-1"></a><span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> QRegularExpression::<span class="name">match</span>(const <span class="type"><a href="./qstringref.htm" translate="no">QStringRef</a></span> &amp;<i>subjectRef</i>, <span class="type">int</span> <i>offset</i> = 0, <span class="type"><a href="./qregularexpression.htm#MatchType-enum" translate="no">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const<a class="plink" href="#match-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Attempts to match the regular expression against the given <i translate="no">subjectRef</i> string reference, starting at the position <i translate="no">offset</i> inside the subject, using a match of type <i translate="no">matchType</i> and honoring the given <i translate="no">matchOptions</i>.</p>
<p>The returned <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object contains the results of the match.</p>
<p>This function was introduced in Qt 5.5.</p>
<p><b>See also </b><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> and <a href="./qregularexpression.htm#normal-matching" translate="no">normal matching</a>.</p>
<!-- @@@match -->
<!-- $$$match$$$matchQStringViewintQRegularExpression::MatchTypeQRegularExpression::MatchOptions -->
<h3 class="fn" id="match-2" translate="no"><a name="match-2"></a><span class="type"><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a></span> QRegularExpression::<span class="name">match</span>(<span class="type"><a href="./qstringview.htm" translate="no">QStringView</a></span> <i>subject</i>, <span class="type">int</span> <i>offset</i> = 0, <span class="type"><a href="./qregularexpression.htm#MatchType-enum" translate="no">QRegularExpression::MatchType</a></span> <i>matchType</i> = NormalMatch, <span class="type"><a href="./qregularexpression.htm#MatchOption-enum" translate="no">QRegularExpression::MatchOptions</a></span> <i>matchOptions</i> = NoMatchOption) const<a class="plink" href="#match-2" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>Attempts to match the regular expression against the given <i translate="no">subjectRef</i> string reference, starting at the position <i translate="no">offset</i> inside the subject, using a match of type <i translate="no">matchType</i> and honoring the given <i translate="no">matchOptions</i>.</p>
<p>The returned <a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> object contains the results of the match.</p>
<div class="admonition note">
<p><b>Note: </b>This overload has been added in 5.15.2 to simplify writing code that is portable between Qt 5.15 and Qt 6. The implementation is not tuned for performance in Qt 5.</p>
</div>
<p>This function was introduced in Qt 5.15.2.</p>
<p><b>See also </b><a href="./qregularexpressionmatch.htm" translate="no">QRegularExpressionMatch</a> and <a href="./qregularexpression.htm#normal-matching" translate="no">normal matching</a>.</p>
<!-- @@@match -->
<!-- $$$namedCaptureGroups[overload1]$$$namedCaptureGroups -->
<h3 class="fn" id="namedCaptureGroups" translate="no"><a name="namedCaptureGroups"></a><span class="type"><a href="./qstringlist.htm" translate="no">QStringList</a></span> QRegularExpression::<span class="name">namedCaptureGroups</span>() const<a class="plink" href="#namedCaptureGroups" title="Direct link to this headline"></a></h3>
<p>Returns a list of <a href="./qregularexpression.htm#captureCount" translate="no">captureCount</a>() + 1 elements, containing the names of the named capturing groups in the pattern string. The list is sorted such that the element of the list at position <code translate="no">i</code> is the name of the <code translate="no">i</code>-th capturing group, if it has a name, or an empty string if that capturing group is unnamed.</p>
<p>For instance, given the regular expression</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    (<span class="operator">?</span><span class="operator">&lt;</span>day<span class="operator">&gt;</span>\d\d)<span class="operator">-</span>(<span class="operator">?</span><span class="operator">&lt;</span>month<span class="operator">&gt;</span>\d\d)<span class="operator">-</span>(<span class="operator">?</span><span class="operator">&lt;</span>year<span class="operator">&gt;</span>\d\d\d\d) (\w<span class="operator">+</span>) (<span class="operator">?</span><span class="operator">&lt;</span>name<span class="operator">&gt;</span>\w<span class="operator">+</span>)</pre></div>
<p>namedCaptureGroups() will return the following list:</p>
<div class="pre"><pre class="cpp prettyprint" translate="no">    (<span class="string">""</span><span class="operator">,</span> <span class="string">"day"</span><span class="operator">,</span> <span class="string">"month"</span><span class="operator">,</span> <span class="string">"year"</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="string">"name"</span>)</pre></div>
<p>which corresponds to the fact that the capturing group #0 (corresponding to the whole match) has no name, the capturing group #1 has name "day", the capturing group #2 has name "month", etc.</p>
<p>If the regular expression is not valid, returns an empty list.</p>
<p>This function was introduced in Qt 5.1.</p>
<p><b>See also </b><a href="./qregularexpression.htm#isValid" translate="no">isValid</a>(), <a href="./qregularexpressionmatch.htm#captured" translate="no">QRegularExpressionMatch::captured</a>(), and <a href="./qstring.htm#isEmpty" translate="no">QString::isEmpty</a>().</p>
<!-- @@@namedCaptureGroups -->
<!-- $$$optimize[overload1]$$$optimize -->
<h3 class="fn" id="optimize" translate="no"><a name="optimize"></a><span class="type">void</span> QRegularExpression::<span class="name">optimize</span>() const<a class="plink" href="#optimize" title="Direct link to this headline"></a></h3>
<p>Compiles the pattern immediately, including JIT compiling it (if the JIT is enabled) for optimization.</p>
<p>This function was introduced in Qt 5.4.</p>
<p><b>See also </b><a href="./qregularexpression.htm#isValid" translate="no">isValid</a>() and <a href="./qregularexpression.htm#debugging-code-that-uses-qregularexpression" translate="no">Debugging Code that Uses QRegularExpression</a>.</p>
<!-- @@@optimize -->
<!-- $$$pattern[overload1]$$$pattern -->
<h3 class="fn" id="pattern" translate="no"><a name="pattern"></a><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">pattern</span>() const<a class="plink" href="#pattern" title="Direct link to this headline"></a></h3>
<p>Returns the pattern string of the regular expression.</p>
<p><b>See also </b><a href="./qregularexpression.htm#setPattern" translate="no">setPattern</a>() and <a href="./qregularexpression.htm#patternOptions" translate="no">patternOptions</a>().</p>
<!-- @@@pattern -->
<!-- $$$patternErrorOffset[overload1]$$$patternErrorOffset -->
<h3 class="fn" id="patternErrorOffset" translate="no"><a name="patternErrorOffset"></a><span class="type">int</span> QRegularExpression::<span class="name">patternErrorOffset</span>() const<a class="plink" href="#patternErrorOffset" title="Direct link to this headline"></a></h3>
<p>Returns the offset, inside the pattern string, at which an error was found when checking the validity of the regular expression. If no error was found, then -1 is returned.</p>
<p><b>See also </b><a href="./qregularexpression.htm#pattern" translate="no">pattern</a>(), <a href="./qregularexpression.htm#isValid" translate="no">isValid</a>(), and <a href="./qregularexpression.htm#errorString" translate="no">errorString</a>().</p>
<!-- @@@patternErrorOffset -->
<!-- $$$patternOptions[overload1]$$$patternOptions -->
<h3 class="fn" id="patternOptions" translate="no"><a name="patternOptions"></a><span class="type"><a href="./qregularexpression.htm#PatternOption-enum" translate="no">QRegularExpression::PatternOptions</a></span> QRegularExpression::<span class="name">patternOptions</span>() const<a class="plink" href="#patternOptions" title="Direct link to this headline"></a></h3>
<p>Returns the pattern options for the regular expression.</p>
<p><b>See also </b><a href="./qregularexpression.htm#setPatternOptions" translate="no">setPatternOptions</a>() and <a href="./qregularexpression.htm#pattern" translate="no">pattern</a>().</p>
<!-- @@@patternOptions -->
<!-- $$$setPattern[overload1]$$$setPatternconstQString& -->
<h3 class="fn" id="setPattern" translate="no"><a name="setPattern"></a><span class="type">void</span> QRegularExpression::<span class="name">setPattern</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>pattern</i>)<a class="plink" href="#setPattern" title="Direct link to this headline"></a></h3>
<p>Sets the pattern string of the regular expression to <i translate="no">pattern</i>. The pattern options are left unchanged.</p>
<p><b>See also </b><a href="./qregularexpression.htm#pattern" translate="no">pattern</a>() and <a href="./qregularexpression.htm#setPatternOptions" translate="no">setPatternOptions</a>().</p>
<!-- @@@setPattern -->
<!-- $$$setPatternOptions[overload1]$$$setPatternOptionsQRegularExpression::PatternOptions -->
<h3 class="fn" id="setPatternOptions" translate="no"><a name="setPatternOptions"></a><span class="type">void</span> QRegularExpression::<span class="name">setPatternOptions</span>(<span class="type"><a href="./qregularexpression.htm#PatternOption-enum" translate="no">QRegularExpression::PatternOptions</a></span> <i>options</i>)<a class="plink" href="#setPatternOptions" title="Direct link to this headline"></a></h3>
<p>Sets the given <i translate="no">options</i> as the pattern options of the regular expression. The pattern string is left unchanged.</p>
<p><b>See also </b><a href="./qregularexpression.htm#patternOptions" translate="no">patternOptions</a>() and <a href="./qregularexpression.htm#setPattern" translate="no">setPattern</a>().</p>
<!-- @@@setPatternOptions -->
<!-- $$$swap[overload1]$$$swapQRegularExpression& -->
<h3 class="fn" id="swap" translate="no"><a name="swap"></a><span class="type">void</span> QRegularExpression::<span class="name">swap</span>(<span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>other</i>)<a class="plink" href="#swap" title="Direct link to this headline"></a></h3>
<p>Swaps the regular expression <i translate="no">other</i> with this regular expression. This operation is very fast and never fails.</p>
<!-- @@@swap -->
<!-- $$$wildcardToRegularExpression[overload1]$$$wildcardToRegularExpressionQStringView -->
<h3 class="fn" id="wildcardToRegularExpression" translate="no"><a name="wildcardToRegularExpression"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">wildcardToRegularExpression</span>(<span class="type"><a href="./qstringview.htm" translate="no">QStringView</a></span> <i>pattern</i>)<a class="plink" href="#wildcardToRegularExpression" title="Direct link to this headline"></a></h3>
<p>Returns a regular expression representation of the given glob <i translate="no">pattern</i>. The transformation is targeting file path globbing, which means in particular that path separators receive special treatment. This implies that it is not just a basic translation from "*" to ".*".</p>
<div class="pre"><pre class="cpp prettyprint" translate="no"><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> wildcard <span class="operator">=</span> <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span><span class="operator">::</span>wildcardToRegularExpression(<span class="string">"*.jpeg"</span>);
<span class="comment">// Will match files with names like:</span>
<span class="comment">//    foo.jpeg</span>
<span class="comment">//    f_o_o.jpeg</span>
<span class="comment">//    fÃ¶Ã¶.jpeg</span></pre></div>
<p>The returned regular expression is already fully anchored. In other words, there is no need of calling <a href="./qregularexpression.htm#anchoredPattern" translate="no">anchoredPattern</a>() again on the result.</p>
<div class="admonition warning">
<p><b>Warning: </b>Unlike <a href="./qregexp.htm" translate="no">QRegExp</a>, this implementation follows closely the definition of wildcard for glob patterns:</p>
</div>
<div class="table"><table class="generic">
<tbody><tr class="odd" valign="top"><td><b>c</b></td><td>Any character represents itself apart from those mentioned below. Thus <b>c</b> matches the character <i>c</i>.</td></tr>
<tr class="even" valign="top"><td><b>?</b></td><td>Matches any single character. It is the same as <b>.</b> in full regexps.</td></tr>
<tr class="odd" valign="top"><td><b>*</b></td><td>Matches zero or more of any characters. It is the same as <b>.*</b> in full regexps.</td></tr>
<tr class="even" valign="top"><td><b>[abc]</b></td><td>Matches one character given in the bracket.</td></tr>
<tr class="odd" valign="top"><td><b>[a-c]</b></td><td>Matches one character from the range given in the bracket.</td></tr>
<tr class="even" valign="top"><td><b>[!abc]</b></td><td>Matches one character that is not given in the bracket. It is the same as <b>[^abc]</b> in full regexp.</td></tr>
<tr class="odd" valign="top"><td><b>[!a-c]</b></td><td>Matches one character that is not from the range given in the bracket. It is the same as <b>[^a-c]</b> in full regexp.</td></tr>
</tbody></table></div>
<div class="admonition note">
<p><b>Note: </b>The backslash (\) character is <i>not</i> an escape char in this context. In order to match one of the special characters, place it in square brackets (for example, <code translate="no">[?]</code>).</p>
</div>
<p>More information about the implementation can be found in:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Glob_(programming)" translate="no">The Wikipedia Glob article</a></li>
<li><code translate="no">man 7 glob</code></li>
</ul>
<p>This function was introduced in Qt 5.15.</p>
<p><b>See also </b><a href="./qregularexpression.htm#escape" translate="no">escape</a>().</p>
<!-- @@@wildcardToRegularExpression -->
<!-- $$$wildcardToRegularExpression$$$wildcardToRegularExpressionconstQString& -->
<h3 class="fn" id="wildcardToRegularExpression-1" translate="no"><a name="wildcardToRegularExpression-1"></a><code translate="no">[static] </code><span class="type"><a href="./qstring.htm" translate="no">QString</a></span> QRegularExpression::<span class="name">wildcardToRegularExpression</span>(const <span class="type"><a href="./qstring.htm" translate="no">QString</a></span> &amp;<i>pattern</i>)<a class="plink" href="#wildcardToRegularExpression-1" title="Direct link to this headline"></a></h3>
<p>This is an overloaded function.</p>
<p>This function was introduced in Qt 5.12.</p>
<!-- @@@wildcardToRegularExpression -->
<!-- $$$operator!=[overload1]$$$operator!=constQRegularExpression& -->
<h3 class="fn" id="operator-not-eq" translate="no"><a name="operator-not-eq"></a><span class="type">bool</span> QRegularExpression::<span class="name">operator!=</span>(const <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>re</i>) const<a class="plink" href="#operator-not-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the regular expression is different from <i translate="no">re</i>, or false otherwise.</p>
<p><b>See also </b><a href="./qregularexpression.htm#operator-eq-eq" translate="no">operator==</a>().</p>
<!-- @@@operator!= -->
<!-- $$$operator==[overload1]$$$operator==constQRegularExpression& -->
<h3 class="fn" id="operator-eq-eq" translate="no"><a name="operator-eq-eq"></a><span class="type">bool</span> QRegularExpression::<span class="name">operator==</span>(const <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>re</i>) const<a class="plink" href="#operator-eq-eq" title="Direct link to this headline"></a></h3>
<p>Returns <code translate="no">true</code> if the regular expression is equal to <i translate="no">re</i>, or false otherwise. Two <a href="./qregularexpression.htm" translate="no">QRegularExpression</a> objects are equal if they have the same pattern string and the same pattern options.</p>
<p><b>See also </b><a href="./qregularexpression.htm#operator-not-eq" translate="no">operator!=</a>().</p>
<!-- @@@operator== -->
</div>
<div class="relnonmem">
<h2>Related Non-Members</h2>
<!-- $$$qHash[overload1]$$$qHashconstQRegularExpression&uint -->
<h3 class="fn" id="qHash" translate="no"><a name="qHash"></a><span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <span class="name">qHash</span>(const <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>key</i>, <span class="type"><a href="./qtglobal.htm#uint-typedef" translate="no">uint</a></span> <i>seed</i> = 0)<a class="plink" href="#qHash" title="Direct link to this headline"></a></h3>
<p>Returns the hash value for <i translate="no">key</i>, using <i translate="no">seed</i> to seed the calculation.</p>
<p>This function was introduced in Qt 5.6.</p>
<!-- @@@qHash -->
<!-- $$$operator<<[overload1]$$$operator<<QDataStream&constQRegularExpression& -->
<h3 class="fn" id="operator-lt-lt" translate="no"><a name="operator-lt-lt"></a><span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<span class="name">operator&lt;&lt;</span>(<span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<i>out</i>, const <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>re</i>)<a class="plink" href="#operator-lt-lt" title="Direct link to this headline"></a></h3>
<p>Writes the regular expression <i translate="no">re</i> to stream <i translate="no">out</i>.</p>
<p><b>See also </b><a href="./datastreamformat.htm" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<QDebugconstQRegularExpression& -->
<h3 class="fn" id="operator-lt-lt-1" translate="no"><a name="operator-lt-lt-1"></a><span class="type"><a href="./qdebug.htm" translate="no">QDebug</a></span> <span class="name">operator&lt;&lt;</span>(<span class="type"><a href="./qdebug.htm" translate="no">QDebug</a></span> <i>debug</i>, const <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>re</i>)<a class="plink" href="#operator-lt-lt-1" title="Direct link to this headline"></a></h3>
<p>Writes the regular expression <i translate="no">re</i> into the debug object <i translate="no">debug</i> for debugging purposes.</p>
<p><b>See also </b><a href="./testing-and-debugging.htm#debugging-techniques" translate="no">Debugging Techniques</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator<<$$$operator<<QDebugQRegularExpression::PatternOptions -->
<h3 class="fn" id="operator-lt-lt-2" translate="no"><a name="operator-lt-lt-2"></a><span class="type"><a href="./qdebug.htm" translate="no">QDebug</a></span> <span class="name">operator&lt;&lt;</span>(<span class="type"><a href="./qdebug.htm" translate="no">QDebug</a></span> <i>debug</i>, <span class="type"><a href="./qregularexpression.htm#PatternOption-enum" translate="no">QRegularExpression::PatternOptions</a></span> <i>patternOptions</i>)<a class="plink" href="#operator-lt-lt-2" title="Direct link to this headline"></a></h3>
<p>Writes the pattern options <i translate="no">patternOptions</i> into the debug object <i translate="no">debug</i> for debugging purposes.</p>
<p><b>See also </b><a href="./testing-and-debugging.htm#debugging-techniques" translate="no">Debugging Techniques</a>.</p>
<!-- @@@operator<< -->
<!-- $$$operator>>[overload1]$$$operator>>QDataStream&QRegularExpression& -->
<h3 class="fn" id="operator-gt-gt" translate="no"><a name="operator-gt-gt"></a><span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<span class="name">operator&gt;&gt;</span>(<span class="type"><a href="./qdatastream.htm" translate="no">QDataStream</a></span> &amp;<i>in</i>, <span class="type"><a href="./qregularexpression.htm#QRegularExpression" translate="no">QRegularExpression</a></span> &amp;<i>re</i>)<a class="plink" href="#operator-gt-gt" title="Direct link to this headline"></a></h3>
<p>Reads a regular expression from stream <i translate="no">in</i> into <i translate="no">re</i>.</p>
<p><b>See also </b><a href="./datastreamformat.htm" translate="no">Serializing Qt Data Types</a>.</p>
<!-- @@@operator>> -->
</div>
</div>
<p class="copy-notice">
<acronym title="Copyright">Â©</acronym> 2025 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.     The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.     Qt and respective logos are <a href="https://doc.qt.io/qt/trademarks.html">    trademarks</a> of The Qt Company Ltd. in Finland and/or other countries
   worldwide. All other trademarks are property of their respective owners. </p>

                    </div>
                </article>
                
            </div>
        </div>
    </div>
</div>
</body></html>